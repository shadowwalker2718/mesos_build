// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mesos/master/master.proto

#ifndef PROTOBUF_mesos_2fmaster_2fmaster_2eproto__INCLUDED
#define PROTOBUF_mesos_2fmaster_2fmaster_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "mesos/mesos.pb.h"
#include "mesos/maintenance/maintenance.pb.h"
#include "mesos/quota/quota.pb.h"
// @@protoc_insertion_point(includes)

namespace protobuf_mesos_2fmaster_2fmaster_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[52];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsCall_GetMetricsImpl();
void InitDefaultsCall_GetMetrics();
void InitDefaultsCall_SetLoggingLevelImpl();
void InitDefaultsCall_SetLoggingLevel();
void InitDefaultsCall_ListFilesImpl();
void InitDefaultsCall_ListFiles();
void InitDefaultsCall_ReadFileImpl();
void InitDefaultsCall_ReadFile();
void InitDefaultsCall_UpdateWeightsImpl();
void InitDefaultsCall_UpdateWeights();
void InitDefaultsCall_ReserveResourcesImpl();
void InitDefaultsCall_ReserveResources();
void InitDefaultsCall_UnreserveResourcesImpl();
void InitDefaultsCall_UnreserveResources();
void InitDefaultsCall_CreateVolumesImpl();
void InitDefaultsCall_CreateVolumes();
void InitDefaultsCall_DestroyVolumesImpl();
void InitDefaultsCall_DestroyVolumes();
void InitDefaultsCall_GrowVolumeImpl();
void InitDefaultsCall_GrowVolume();
void InitDefaultsCall_ShrinkVolumeImpl();
void InitDefaultsCall_ShrinkVolume();
void InitDefaultsCall_UpdateMaintenanceScheduleImpl();
void InitDefaultsCall_UpdateMaintenanceSchedule();
void InitDefaultsCall_StartMaintenanceImpl();
void InitDefaultsCall_StartMaintenance();
void InitDefaultsCall_StopMaintenanceImpl();
void InitDefaultsCall_StopMaintenance();
void InitDefaultsCall_SetQuotaImpl();
void InitDefaultsCall_SetQuota();
void InitDefaultsCall_RemoveQuotaImpl();
void InitDefaultsCall_RemoveQuota();
void InitDefaultsCall_TeardownImpl();
void InitDefaultsCall_Teardown();
void InitDefaultsCall_MarkAgentGoneImpl();
void InitDefaultsCall_MarkAgentGone();
void InitDefaultsCallImpl();
void InitDefaultsCall();
void InitDefaultsResponse_GetHealthImpl();
void InitDefaultsResponse_GetHealth();
void InitDefaultsResponse_GetFlagsImpl();
void InitDefaultsResponse_GetFlags();
void InitDefaultsResponse_GetVersionImpl();
void InitDefaultsResponse_GetVersion();
void InitDefaultsResponse_GetMetricsImpl();
void InitDefaultsResponse_GetMetrics();
void InitDefaultsResponse_GetLoggingLevelImpl();
void InitDefaultsResponse_GetLoggingLevel();
void InitDefaultsResponse_ListFilesImpl();
void InitDefaultsResponse_ListFiles();
void InitDefaultsResponse_ReadFileImpl();
void InitDefaultsResponse_ReadFile();
void InitDefaultsResponse_GetStateImpl();
void InitDefaultsResponse_GetState();
void InitDefaultsResponse_GetAgents_Agent_ResourceProviderImpl();
void InitDefaultsResponse_GetAgents_Agent_ResourceProvider();
void InitDefaultsResponse_GetAgents_AgentImpl();
void InitDefaultsResponse_GetAgents_Agent();
void InitDefaultsResponse_GetAgentsImpl();
void InitDefaultsResponse_GetAgents();
void InitDefaultsResponse_GetFrameworks_FrameworkImpl();
void InitDefaultsResponse_GetFrameworks_Framework();
void InitDefaultsResponse_GetFrameworksImpl();
void InitDefaultsResponse_GetFrameworks();
void InitDefaultsResponse_GetExecutors_ExecutorImpl();
void InitDefaultsResponse_GetExecutors_Executor();
void InitDefaultsResponse_GetExecutorsImpl();
void InitDefaultsResponse_GetExecutors();
void InitDefaultsResponse_GetOperationsImpl();
void InitDefaultsResponse_GetOperations();
void InitDefaultsResponse_GetTasksImpl();
void InitDefaultsResponse_GetTasks();
void InitDefaultsResponse_GetRolesImpl();
void InitDefaultsResponse_GetRoles();
void InitDefaultsResponse_GetWeightsImpl();
void InitDefaultsResponse_GetWeights();
void InitDefaultsResponse_GetMasterImpl();
void InitDefaultsResponse_GetMaster();
void InitDefaultsResponse_GetMaintenanceStatusImpl();
void InitDefaultsResponse_GetMaintenanceStatus();
void InitDefaultsResponse_GetMaintenanceScheduleImpl();
void InitDefaultsResponse_GetMaintenanceSchedule();
void InitDefaultsResponse_GetQuotaImpl();
void InitDefaultsResponse_GetQuota();
void InitDefaultsResponseImpl();
void InitDefaultsResponse();
void InitDefaultsEvent_SubscribedImpl();
void InitDefaultsEvent_Subscribed();
void InitDefaultsEvent_TaskAddedImpl();
void InitDefaultsEvent_TaskAdded();
void InitDefaultsEvent_TaskUpdatedImpl();
void InitDefaultsEvent_TaskUpdated();
void InitDefaultsEvent_FrameworkAddedImpl();
void InitDefaultsEvent_FrameworkAdded();
void InitDefaultsEvent_FrameworkUpdatedImpl();
void InitDefaultsEvent_FrameworkUpdated();
void InitDefaultsEvent_FrameworkRemovedImpl();
void InitDefaultsEvent_FrameworkRemoved();
void InitDefaultsEvent_AgentAddedImpl();
void InitDefaultsEvent_AgentAdded();
void InitDefaultsEvent_AgentRemovedImpl();
void InitDefaultsEvent_AgentRemoved();
void InitDefaultsEventImpl();
void InitDefaultsEvent();
inline void InitDefaults() {
  InitDefaultsCall_GetMetrics();
  InitDefaultsCall_SetLoggingLevel();
  InitDefaultsCall_ListFiles();
  InitDefaultsCall_ReadFile();
  InitDefaultsCall_UpdateWeights();
  InitDefaultsCall_ReserveResources();
  InitDefaultsCall_UnreserveResources();
  InitDefaultsCall_CreateVolumes();
  InitDefaultsCall_DestroyVolumes();
  InitDefaultsCall_GrowVolume();
  InitDefaultsCall_ShrinkVolume();
  InitDefaultsCall_UpdateMaintenanceSchedule();
  InitDefaultsCall_StartMaintenance();
  InitDefaultsCall_StopMaintenance();
  InitDefaultsCall_SetQuota();
  InitDefaultsCall_RemoveQuota();
  InitDefaultsCall_Teardown();
  InitDefaultsCall_MarkAgentGone();
  InitDefaultsCall();
  InitDefaultsResponse_GetHealth();
  InitDefaultsResponse_GetFlags();
  InitDefaultsResponse_GetVersion();
  InitDefaultsResponse_GetMetrics();
  InitDefaultsResponse_GetLoggingLevel();
  InitDefaultsResponse_ListFiles();
  InitDefaultsResponse_ReadFile();
  InitDefaultsResponse_GetState();
  InitDefaultsResponse_GetAgents_Agent_ResourceProvider();
  InitDefaultsResponse_GetAgents_Agent();
  InitDefaultsResponse_GetAgents();
  InitDefaultsResponse_GetFrameworks_Framework();
  InitDefaultsResponse_GetFrameworks();
  InitDefaultsResponse_GetExecutors_Executor();
  InitDefaultsResponse_GetExecutors();
  InitDefaultsResponse_GetOperations();
  InitDefaultsResponse_GetTasks();
  InitDefaultsResponse_GetRoles();
  InitDefaultsResponse_GetWeights();
  InitDefaultsResponse_GetMaster();
  InitDefaultsResponse_GetMaintenanceStatus();
  InitDefaultsResponse_GetMaintenanceSchedule();
  InitDefaultsResponse_GetQuota();
  InitDefaultsResponse();
  InitDefaultsEvent_Subscribed();
  InitDefaultsEvent_TaskAdded();
  InitDefaultsEvent_TaskUpdated();
  InitDefaultsEvent_FrameworkAdded();
  InitDefaultsEvent_FrameworkUpdated();
  InitDefaultsEvent_FrameworkRemoved();
  InitDefaultsEvent_AgentAdded();
  InitDefaultsEvent_AgentRemoved();
  InitDefaultsEvent();
}
}  // namespace protobuf_mesos_2fmaster_2fmaster_2eproto
namespace mesos {
namespace master {
class Call;
class CallDefaultTypeInternal;
extern CallDefaultTypeInternal _Call_default_instance_;
class Call_CreateVolumes;
class Call_CreateVolumesDefaultTypeInternal;
extern Call_CreateVolumesDefaultTypeInternal _Call_CreateVolumes_default_instance_;
class Call_DestroyVolumes;
class Call_DestroyVolumesDefaultTypeInternal;
extern Call_DestroyVolumesDefaultTypeInternal _Call_DestroyVolumes_default_instance_;
class Call_GetMetrics;
class Call_GetMetricsDefaultTypeInternal;
extern Call_GetMetricsDefaultTypeInternal _Call_GetMetrics_default_instance_;
class Call_GrowVolume;
class Call_GrowVolumeDefaultTypeInternal;
extern Call_GrowVolumeDefaultTypeInternal _Call_GrowVolume_default_instance_;
class Call_ListFiles;
class Call_ListFilesDefaultTypeInternal;
extern Call_ListFilesDefaultTypeInternal _Call_ListFiles_default_instance_;
class Call_MarkAgentGone;
class Call_MarkAgentGoneDefaultTypeInternal;
extern Call_MarkAgentGoneDefaultTypeInternal _Call_MarkAgentGone_default_instance_;
class Call_ReadFile;
class Call_ReadFileDefaultTypeInternal;
extern Call_ReadFileDefaultTypeInternal _Call_ReadFile_default_instance_;
class Call_RemoveQuota;
class Call_RemoveQuotaDefaultTypeInternal;
extern Call_RemoveQuotaDefaultTypeInternal _Call_RemoveQuota_default_instance_;
class Call_ReserveResources;
class Call_ReserveResourcesDefaultTypeInternal;
extern Call_ReserveResourcesDefaultTypeInternal _Call_ReserveResources_default_instance_;
class Call_SetLoggingLevel;
class Call_SetLoggingLevelDefaultTypeInternal;
extern Call_SetLoggingLevelDefaultTypeInternal _Call_SetLoggingLevel_default_instance_;
class Call_SetQuota;
class Call_SetQuotaDefaultTypeInternal;
extern Call_SetQuotaDefaultTypeInternal _Call_SetQuota_default_instance_;
class Call_ShrinkVolume;
class Call_ShrinkVolumeDefaultTypeInternal;
extern Call_ShrinkVolumeDefaultTypeInternal _Call_ShrinkVolume_default_instance_;
class Call_StartMaintenance;
class Call_StartMaintenanceDefaultTypeInternal;
extern Call_StartMaintenanceDefaultTypeInternal _Call_StartMaintenance_default_instance_;
class Call_StopMaintenance;
class Call_StopMaintenanceDefaultTypeInternal;
extern Call_StopMaintenanceDefaultTypeInternal _Call_StopMaintenance_default_instance_;
class Call_Teardown;
class Call_TeardownDefaultTypeInternal;
extern Call_TeardownDefaultTypeInternal _Call_Teardown_default_instance_;
class Call_UnreserveResources;
class Call_UnreserveResourcesDefaultTypeInternal;
extern Call_UnreserveResourcesDefaultTypeInternal _Call_UnreserveResources_default_instance_;
class Call_UpdateMaintenanceSchedule;
class Call_UpdateMaintenanceScheduleDefaultTypeInternal;
extern Call_UpdateMaintenanceScheduleDefaultTypeInternal _Call_UpdateMaintenanceSchedule_default_instance_;
class Call_UpdateWeights;
class Call_UpdateWeightsDefaultTypeInternal;
extern Call_UpdateWeightsDefaultTypeInternal _Call_UpdateWeights_default_instance_;
class Event;
class EventDefaultTypeInternal;
extern EventDefaultTypeInternal _Event_default_instance_;
class Event_AgentAdded;
class Event_AgentAddedDefaultTypeInternal;
extern Event_AgentAddedDefaultTypeInternal _Event_AgentAdded_default_instance_;
class Event_AgentRemoved;
class Event_AgentRemovedDefaultTypeInternal;
extern Event_AgentRemovedDefaultTypeInternal _Event_AgentRemoved_default_instance_;
class Event_FrameworkAdded;
class Event_FrameworkAddedDefaultTypeInternal;
extern Event_FrameworkAddedDefaultTypeInternal _Event_FrameworkAdded_default_instance_;
class Event_FrameworkRemoved;
class Event_FrameworkRemovedDefaultTypeInternal;
extern Event_FrameworkRemovedDefaultTypeInternal _Event_FrameworkRemoved_default_instance_;
class Event_FrameworkUpdated;
class Event_FrameworkUpdatedDefaultTypeInternal;
extern Event_FrameworkUpdatedDefaultTypeInternal _Event_FrameworkUpdated_default_instance_;
class Event_Subscribed;
class Event_SubscribedDefaultTypeInternal;
extern Event_SubscribedDefaultTypeInternal _Event_Subscribed_default_instance_;
class Event_TaskAdded;
class Event_TaskAddedDefaultTypeInternal;
extern Event_TaskAddedDefaultTypeInternal _Event_TaskAdded_default_instance_;
class Event_TaskUpdated;
class Event_TaskUpdatedDefaultTypeInternal;
extern Event_TaskUpdatedDefaultTypeInternal _Event_TaskUpdated_default_instance_;
class Response;
class ResponseDefaultTypeInternal;
extern ResponseDefaultTypeInternal _Response_default_instance_;
class Response_GetAgents;
class Response_GetAgentsDefaultTypeInternal;
extern Response_GetAgentsDefaultTypeInternal _Response_GetAgents_default_instance_;
class Response_GetAgents_Agent;
class Response_GetAgents_AgentDefaultTypeInternal;
extern Response_GetAgents_AgentDefaultTypeInternal _Response_GetAgents_Agent_default_instance_;
class Response_GetAgents_Agent_ResourceProvider;
class Response_GetAgents_Agent_ResourceProviderDefaultTypeInternal;
extern Response_GetAgents_Agent_ResourceProviderDefaultTypeInternal _Response_GetAgents_Agent_ResourceProvider_default_instance_;
class Response_GetExecutors;
class Response_GetExecutorsDefaultTypeInternal;
extern Response_GetExecutorsDefaultTypeInternal _Response_GetExecutors_default_instance_;
class Response_GetExecutors_Executor;
class Response_GetExecutors_ExecutorDefaultTypeInternal;
extern Response_GetExecutors_ExecutorDefaultTypeInternal _Response_GetExecutors_Executor_default_instance_;
class Response_GetFlags;
class Response_GetFlagsDefaultTypeInternal;
extern Response_GetFlagsDefaultTypeInternal _Response_GetFlags_default_instance_;
class Response_GetFrameworks;
class Response_GetFrameworksDefaultTypeInternal;
extern Response_GetFrameworksDefaultTypeInternal _Response_GetFrameworks_default_instance_;
class Response_GetFrameworks_Framework;
class Response_GetFrameworks_FrameworkDefaultTypeInternal;
extern Response_GetFrameworks_FrameworkDefaultTypeInternal _Response_GetFrameworks_Framework_default_instance_;
class Response_GetHealth;
class Response_GetHealthDefaultTypeInternal;
extern Response_GetHealthDefaultTypeInternal _Response_GetHealth_default_instance_;
class Response_GetLoggingLevel;
class Response_GetLoggingLevelDefaultTypeInternal;
extern Response_GetLoggingLevelDefaultTypeInternal _Response_GetLoggingLevel_default_instance_;
class Response_GetMaintenanceSchedule;
class Response_GetMaintenanceScheduleDefaultTypeInternal;
extern Response_GetMaintenanceScheduleDefaultTypeInternal _Response_GetMaintenanceSchedule_default_instance_;
class Response_GetMaintenanceStatus;
class Response_GetMaintenanceStatusDefaultTypeInternal;
extern Response_GetMaintenanceStatusDefaultTypeInternal _Response_GetMaintenanceStatus_default_instance_;
class Response_GetMaster;
class Response_GetMasterDefaultTypeInternal;
extern Response_GetMasterDefaultTypeInternal _Response_GetMaster_default_instance_;
class Response_GetMetrics;
class Response_GetMetricsDefaultTypeInternal;
extern Response_GetMetricsDefaultTypeInternal _Response_GetMetrics_default_instance_;
class Response_GetOperations;
class Response_GetOperationsDefaultTypeInternal;
extern Response_GetOperationsDefaultTypeInternal _Response_GetOperations_default_instance_;
class Response_GetQuota;
class Response_GetQuotaDefaultTypeInternal;
extern Response_GetQuotaDefaultTypeInternal _Response_GetQuota_default_instance_;
class Response_GetRoles;
class Response_GetRolesDefaultTypeInternal;
extern Response_GetRolesDefaultTypeInternal _Response_GetRoles_default_instance_;
class Response_GetState;
class Response_GetStateDefaultTypeInternal;
extern Response_GetStateDefaultTypeInternal _Response_GetState_default_instance_;
class Response_GetTasks;
class Response_GetTasksDefaultTypeInternal;
extern Response_GetTasksDefaultTypeInternal _Response_GetTasks_default_instance_;
class Response_GetVersion;
class Response_GetVersionDefaultTypeInternal;
extern Response_GetVersionDefaultTypeInternal _Response_GetVersion_default_instance_;
class Response_GetWeights;
class Response_GetWeightsDefaultTypeInternal;
extern Response_GetWeightsDefaultTypeInternal _Response_GetWeights_default_instance_;
class Response_ListFiles;
class Response_ListFilesDefaultTypeInternal;
extern Response_ListFilesDefaultTypeInternal _Response_ListFiles_default_instance_;
class Response_ReadFile;
class Response_ReadFileDefaultTypeInternal;
extern Response_ReadFileDefaultTypeInternal _Response_ReadFile_default_instance_;
}  // namespace master
}  // namespace mesos
namespace mesos {
namespace master {

enum Call_Type {
  Call_Type_UNKNOWN = 0,
  Call_Type_GET_HEALTH = 1,
  Call_Type_GET_FLAGS = 2,
  Call_Type_GET_VERSION = 3,
  Call_Type_GET_METRICS = 4,
  Call_Type_GET_LOGGING_LEVEL = 5,
  Call_Type_SET_LOGGING_LEVEL = 6,
  Call_Type_LIST_FILES = 7,
  Call_Type_READ_FILE = 8,
  Call_Type_GET_STATE = 9,
  Call_Type_GET_AGENTS = 10,
  Call_Type_GET_FRAMEWORKS = 11,
  Call_Type_GET_EXECUTORS = 12,
  Call_Type_GET_OPERATIONS = 33,
  Call_Type_GET_TASKS = 13,
  Call_Type_GET_ROLES = 14,
  Call_Type_GET_WEIGHTS = 15,
  Call_Type_UPDATE_WEIGHTS = 16,
  Call_Type_GET_MASTER = 17,
  Call_Type_SUBSCRIBE = 18,
  Call_Type_RESERVE_RESOURCES = 19,
  Call_Type_UNRESERVE_RESOURCES = 20,
  Call_Type_CREATE_VOLUMES = 21,
  Call_Type_DESTROY_VOLUMES = 22,
  Call_Type_GROW_VOLUME = 34,
  Call_Type_SHRINK_VOLUME = 35,
  Call_Type_GET_MAINTENANCE_STATUS = 23,
  Call_Type_GET_MAINTENANCE_SCHEDULE = 24,
  Call_Type_UPDATE_MAINTENANCE_SCHEDULE = 25,
  Call_Type_START_MAINTENANCE = 26,
  Call_Type_STOP_MAINTENANCE = 27,
  Call_Type_GET_QUOTA = 28,
  Call_Type_SET_QUOTA = 29,
  Call_Type_REMOVE_QUOTA = 30,
  Call_Type_TEARDOWN = 31,
  Call_Type_MARK_AGENT_GONE = 32
};
bool Call_Type_IsValid(int value);
const Call_Type Call_Type_Type_MIN = Call_Type_UNKNOWN;
const Call_Type Call_Type_Type_MAX = Call_Type_SHRINK_VOLUME;
const int Call_Type_Type_ARRAYSIZE = Call_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Call_Type_descriptor();
inline const ::std::string& Call_Type_Name(Call_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Call_Type_descriptor(), value);
}
inline bool Call_Type_Parse(
    const ::std::string& name, Call_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Call_Type>(
    Call_Type_descriptor(), name, value);
}
enum Response_Type {
  Response_Type_UNKNOWN = 0,
  Response_Type_GET_HEALTH = 1,
  Response_Type_GET_FLAGS = 2,
  Response_Type_GET_VERSION = 3,
  Response_Type_GET_METRICS = 4,
  Response_Type_GET_LOGGING_LEVEL = 5,
  Response_Type_LIST_FILES = 6,
  Response_Type_READ_FILE = 7,
  Response_Type_GET_STATE = 8,
  Response_Type_GET_AGENTS = 9,
  Response_Type_GET_FRAMEWORKS = 10,
  Response_Type_GET_EXECUTORS = 11,
  Response_Type_GET_OPERATIONS = 19,
  Response_Type_GET_TASKS = 12,
  Response_Type_GET_ROLES = 13,
  Response_Type_GET_WEIGHTS = 14,
  Response_Type_GET_MASTER = 15,
  Response_Type_GET_MAINTENANCE_STATUS = 16,
  Response_Type_GET_MAINTENANCE_SCHEDULE = 17,
  Response_Type_GET_QUOTA = 18
};
bool Response_Type_IsValid(int value);
const Response_Type Response_Type_Type_MIN = Response_Type_UNKNOWN;
const Response_Type Response_Type_Type_MAX = Response_Type_GET_OPERATIONS;
const int Response_Type_Type_ARRAYSIZE = Response_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Response_Type_descriptor();
inline const ::std::string& Response_Type_Name(Response_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Response_Type_descriptor(), value);
}
inline bool Response_Type_Parse(
    const ::std::string& name, Response_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Response_Type>(
    Response_Type_descriptor(), name, value);
}
enum Event_Type {
  Event_Type_UNKNOWN = 0,
  Event_Type_SUBSCRIBED = 1,
  Event_Type_TASK_ADDED = 2,
  Event_Type_TASK_UPDATED = 3,
  Event_Type_AGENT_ADDED = 4,
  Event_Type_AGENT_REMOVED = 5,
  Event_Type_FRAMEWORK_ADDED = 6,
  Event_Type_FRAMEWORK_UPDATED = 7,
  Event_Type_FRAMEWORK_REMOVED = 8,
  Event_Type_HEARTBEAT = 9
};
bool Event_Type_IsValid(int value);
const Event_Type Event_Type_Type_MIN = Event_Type_UNKNOWN;
const Event_Type Event_Type_Type_MAX = Event_Type_HEARTBEAT;
const int Event_Type_Type_ARRAYSIZE = Event_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Event_Type_descriptor();
inline const ::std::string& Event_Type_Name(Event_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Event_Type_descriptor(), value);
}
inline bool Event_Type_Parse(
    const ::std::string& name, Event_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Event_Type>(
    Event_Type_descriptor(), name, value);
}
// ===================================================================

class Call_GetMetrics : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.master.Call.GetMetrics) */ {
 public:
  Call_GetMetrics();
  virtual ~Call_GetMetrics();

  Call_GetMetrics(const Call_GetMetrics& from);

  inline Call_GetMetrics& operator=(const Call_GetMetrics& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Call_GetMetrics(Call_GetMetrics&& from) noexcept
    : Call_GetMetrics() {
    *this = ::std::move(from);
  }

  inline Call_GetMetrics& operator=(Call_GetMetrics&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Call_GetMetrics& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Call_GetMetrics* internal_default_instance() {
    return reinterpret_cast<const Call_GetMetrics*>(
               &_Call_GetMetrics_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void UnsafeArenaSwap(Call_GetMetrics* other);
  void Swap(Call_GetMetrics* other);
  friend void swap(Call_GetMetrics& a, Call_GetMetrics& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Call_GetMetrics* New() const PROTOBUF_FINAL { return New(NULL); }

  Call_GetMetrics* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Call_GetMetrics& from);
  void MergeFrom(const Call_GetMetrics& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Call_GetMetrics* other);
  protected:
  explicit Call_GetMetrics(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mesos.DurationInfo timeout = 1;
  bool has_timeout() const;
  void clear_timeout();
  static const int kTimeoutFieldNumber = 1;
  private:
  void _slow_mutable_timeout();
  public:
  const ::mesos::DurationInfo& timeout() const;
  ::mesos::DurationInfo* release_timeout();
  ::mesos::DurationInfo* mutable_timeout();
  void set_allocated_timeout(::mesos::DurationInfo* timeout);
  void unsafe_arena_set_allocated_timeout(
      ::mesos::DurationInfo* timeout);
  ::mesos::DurationInfo* unsafe_arena_release_timeout();

  // @@protoc_insertion_point(class_scope:mesos.master.Call.GetMetrics)
 private:
  void set_has_timeout();
  void clear_has_timeout();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::DurationInfo* timeout_;
  friend struct ::protobuf_mesos_2fmaster_2fmaster_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmaster_2fmaster_2eproto::InitDefaultsCall_GetMetricsImpl();
};
// -------------------------------------------------------------------

class Call_SetLoggingLevel : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.master.Call.SetLoggingLevel) */ {
 public:
  Call_SetLoggingLevel();
  virtual ~Call_SetLoggingLevel();

  Call_SetLoggingLevel(const Call_SetLoggingLevel& from);

  inline Call_SetLoggingLevel& operator=(const Call_SetLoggingLevel& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Call_SetLoggingLevel(Call_SetLoggingLevel&& from) noexcept
    : Call_SetLoggingLevel() {
    *this = ::std::move(from);
  }

  inline Call_SetLoggingLevel& operator=(Call_SetLoggingLevel&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Call_SetLoggingLevel& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Call_SetLoggingLevel* internal_default_instance() {
    return reinterpret_cast<const Call_SetLoggingLevel*>(
               &_Call_SetLoggingLevel_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void UnsafeArenaSwap(Call_SetLoggingLevel* other);
  void Swap(Call_SetLoggingLevel* other);
  friend void swap(Call_SetLoggingLevel& a, Call_SetLoggingLevel& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Call_SetLoggingLevel* New() const PROTOBUF_FINAL { return New(NULL); }

  Call_SetLoggingLevel* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Call_SetLoggingLevel& from);
  void MergeFrom(const Call_SetLoggingLevel& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Call_SetLoggingLevel* other);
  protected:
  explicit Call_SetLoggingLevel(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.DurationInfo duration = 2;
  bool has_duration() const;
  void clear_duration();
  static const int kDurationFieldNumber = 2;
  private:
  void _slow_mutable_duration();
  public:
  const ::mesos::DurationInfo& duration() const;
  ::mesos::DurationInfo* release_duration();
  ::mesos::DurationInfo* mutable_duration();
  void set_allocated_duration(::mesos::DurationInfo* duration);
  void unsafe_arena_set_allocated_duration(
      ::mesos::DurationInfo* duration);
  ::mesos::DurationInfo* unsafe_arena_release_duration();

  // required uint32 level = 1;
  bool has_level() const;
  void clear_level();
  static const int kLevelFieldNumber = 1;
  ::google::protobuf::uint32 level() const;
  void set_level(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mesos.master.Call.SetLoggingLevel)
 private:
  void set_has_level();
  void clear_has_level();
  void set_has_duration();
  void clear_has_duration();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::DurationInfo* duration_;
  ::google::protobuf::uint32 level_;
  friend struct ::protobuf_mesos_2fmaster_2fmaster_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmaster_2fmaster_2eproto::InitDefaultsCall_SetLoggingLevelImpl();
};
// -------------------------------------------------------------------

class Call_ListFiles : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.master.Call.ListFiles) */ {
 public:
  Call_ListFiles();
  virtual ~Call_ListFiles();

  Call_ListFiles(const Call_ListFiles& from);

  inline Call_ListFiles& operator=(const Call_ListFiles& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Call_ListFiles(Call_ListFiles&& from) noexcept
    : Call_ListFiles() {
    *this = ::std::move(from);
  }

  inline Call_ListFiles& operator=(Call_ListFiles&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Call_ListFiles& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Call_ListFiles* internal_default_instance() {
    return reinterpret_cast<const Call_ListFiles*>(
               &_Call_ListFiles_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void UnsafeArenaSwap(Call_ListFiles* other);
  void Swap(Call_ListFiles* other);
  friend void swap(Call_ListFiles& a, Call_ListFiles& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Call_ListFiles* New() const PROTOBUF_FINAL { return New(NULL); }

  Call_ListFiles* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Call_ListFiles& from);
  void MergeFrom(const Call_ListFiles& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Call_ListFiles* other);
  protected:
  explicit Call_ListFiles(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string path = 1;
  bool has_path() const;
  void clear_path();
  static const int kPathFieldNumber = 1;
  const ::std::string& path() const;
  void set_path(const ::std::string& value);
  #if LANG_CXX11
  void set_path(::std::string&& value);
  #endif
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  ::std::string* mutable_path();
  ::std::string* release_path();
  void set_allocated_path(::std::string* path);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_path();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_path(
      ::std::string* path);

  // @@protoc_insertion_point(class_scope:mesos.master.Call.ListFiles)
 private:
  void set_has_path();
  void clear_has_path();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr path_;
  friend struct ::protobuf_mesos_2fmaster_2fmaster_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmaster_2fmaster_2eproto::InitDefaultsCall_ListFilesImpl();
};
// -------------------------------------------------------------------

class Call_ReadFile : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.master.Call.ReadFile) */ {
 public:
  Call_ReadFile();
  virtual ~Call_ReadFile();

  Call_ReadFile(const Call_ReadFile& from);

  inline Call_ReadFile& operator=(const Call_ReadFile& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Call_ReadFile(Call_ReadFile&& from) noexcept
    : Call_ReadFile() {
    *this = ::std::move(from);
  }

  inline Call_ReadFile& operator=(Call_ReadFile&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Call_ReadFile& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Call_ReadFile* internal_default_instance() {
    return reinterpret_cast<const Call_ReadFile*>(
               &_Call_ReadFile_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void UnsafeArenaSwap(Call_ReadFile* other);
  void Swap(Call_ReadFile* other);
  friend void swap(Call_ReadFile& a, Call_ReadFile& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Call_ReadFile* New() const PROTOBUF_FINAL { return New(NULL); }

  Call_ReadFile* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Call_ReadFile& from);
  void MergeFrom(const Call_ReadFile& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Call_ReadFile* other);
  protected:
  explicit Call_ReadFile(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string path = 1;
  bool has_path() const;
  void clear_path();
  static const int kPathFieldNumber = 1;
  const ::std::string& path() const;
  void set_path(const ::std::string& value);
  #if LANG_CXX11
  void set_path(::std::string&& value);
  #endif
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  ::std::string* mutable_path();
  ::std::string* release_path();
  void set_allocated_path(::std::string* path);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_path();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_path(
      ::std::string* path);

  // required uint64 offset = 2;
  bool has_offset() const;
  void clear_offset();
  static const int kOffsetFieldNumber = 2;
  ::google::protobuf::uint64 offset() const;
  void set_offset(::google::protobuf::uint64 value);

  // optional uint64 length = 3;
  bool has_length() const;
  void clear_length();
  static const int kLengthFieldNumber = 3;
  ::google::protobuf::uint64 length() const;
  void set_length(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:mesos.master.Call.ReadFile)
 private:
  void set_has_path();
  void clear_has_path();
  void set_has_offset();
  void clear_has_offset();
  void set_has_length();
  void clear_has_length();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr path_;
  ::google::protobuf::uint64 offset_;
  ::google::protobuf::uint64 length_;
  friend struct ::protobuf_mesos_2fmaster_2fmaster_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmaster_2fmaster_2eproto::InitDefaultsCall_ReadFileImpl();
};
// -------------------------------------------------------------------

class Call_UpdateWeights : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.master.Call.UpdateWeights) */ {
 public:
  Call_UpdateWeights();
  virtual ~Call_UpdateWeights();

  Call_UpdateWeights(const Call_UpdateWeights& from);

  inline Call_UpdateWeights& operator=(const Call_UpdateWeights& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Call_UpdateWeights(Call_UpdateWeights&& from) noexcept
    : Call_UpdateWeights() {
    *this = ::std::move(from);
  }

  inline Call_UpdateWeights& operator=(Call_UpdateWeights&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Call_UpdateWeights& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Call_UpdateWeights* internal_default_instance() {
    return reinterpret_cast<const Call_UpdateWeights*>(
               &_Call_UpdateWeights_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void UnsafeArenaSwap(Call_UpdateWeights* other);
  void Swap(Call_UpdateWeights* other);
  friend void swap(Call_UpdateWeights& a, Call_UpdateWeights& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Call_UpdateWeights* New() const PROTOBUF_FINAL { return New(NULL); }

  Call_UpdateWeights* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Call_UpdateWeights& from);
  void MergeFrom(const Call_UpdateWeights& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Call_UpdateWeights* other);
  protected:
  explicit Call_UpdateWeights(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.WeightInfo weight_infos = 1;
  int weight_infos_size() const;
  void clear_weight_infos();
  static const int kWeightInfosFieldNumber = 1;
  const ::mesos::WeightInfo& weight_infos(int index) const;
  ::mesos::WeightInfo* mutable_weight_infos(int index);
  ::mesos::WeightInfo* add_weight_infos();
  ::google::protobuf::RepeatedPtrField< ::mesos::WeightInfo >*
      mutable_weight_infos();
  const ::google::protobuf::RepeatedPtrField< ::mesos::WeightInfo >&
      weight_infos() const;

  // @@protoc_insertion_point(class_scope:mesos.master.Call.UpdateWeights)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::WeightInfo > weight_infos_;
  friend struct ::protobuf_mesos_2fmaster_2fmaster_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmaster_2fmaster_2eproto::InitDefaultsCall_UpdateWeightsImpl();
};
// -------------------------------------------------------------------

class Call_ReserveResources : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.master.Call.ReserveResources) */ {
 public:
  Call_ReserveResources();
  virtual ~Call_ReserveResources();

  Call_ReserveResources(const Call_ReserveResources& from);

  inline Call_ReserveResources& operator=(const Call_ReserveResources& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Call_ReserveResources(Call_ReserveResources&& from) noexcept
    : Call_ReserveResources() {
    *this = ::std::move(from);
  }

  inline Call_ReserveResources& operator=(Call_ReserveResources&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Call_ReserveResources& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Call_ReserveResources* internal_default_instance() {
    return reinterpret_cast<const Call_ReserveResources*>(
               &_Call_ReserveResources_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void UnsafeArenaSwap(Call_ReserveResources* other);
  void Swap(Call_ReserveResources* other);
  friend void swap(Call_ReserveResources& a, Call_ReserveResources& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Call_ReserveResources* New() const PROTOBUF_FINAL { return New(NULL); }

  Call_ReserveResources* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Call_ReserveResources& from);
  void MergeFrom(const Call_ReserveResources& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Call_ReserveResources* other);
  protected:
  explicit Call_ReserveResources(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.Resource resources = 2;
  int resources_size() const;
  void clear_resources();
  static const int kResourcesFieldNumber = 2;
  const ::mesos::Resource& resources(int index) const;
  ::mesos::Resource* mutable_resources(int index);
  ::mesos::Resource* add_resources();
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
      mutable_resources();
  const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
      resources() const;

  // required .mesos.SlaveID slave_id = 1;
  bool has_slave_id() const;
  void clear_slave_id();
  static const int kSlaveIdFieldNumber = 1;
  private:
  void _slow_mutable_slave_id();
  public:
  const ::mesos::SlaveID& slave_id() const;
  ::mesos::SlaveID* release_slave_id();
  ::mesos::SlaveID* mutable_slave_id();
  void set_allocated_slave_id(::mesos::SlaveID* slave_id);
  void unsafe_arena_set_allocated_slave_id(
      ::mesos::SlaveID* slave_id);
  ::mesos::SlaveID* unsafe_arena_release_slave_id();

  // @@protoc_insertion_point(class_scope:mesos.master.Call.ReserveResources)
 private:
  void set_has_slave_id();
  void clear_has_slave_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource > resources_;
  ::mesos::SlaveID* slave_id_;
  friend struct ::protobuf_mesos_2fmaster_2fmaster_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmaster_2fmaster_2eproto::InitDefaultsCall_ReserveResourcesImpl();
};
// -------------------------------------------------------------------

class Call_UnreserveResources : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.master.Call.UnreserveResources) */ {
 public:
  Call_UnreserveResources();
  virtual ~Call_UnreserveResources();

  Call_UnreserveResources(const Call_UnreserveResources& from);

  inline Call_UnreserveResources& operator=(const Call_UnreserveResources& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Call_UnreserveResources(Call_UnreserveResources&& from) noexcept
    : Call_UnreserveResources() {
    *this = ::std::move(from);
  }

  inline Call_UnreserveResources& operator=(Call_UnreserveResources&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Call_UnreserveResources& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Call_UnreserveResources* internal_default_instance() {
    return reinterpret_cast<const Call_UnreserveResources*>(
               &_Call_UnreserveResources_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void UnsafeArenaSwap(Call_UnreserveResources* other);
  void Swap(Call_UnreserveResources* other);
  friend void swap(Call_UnreserveResources& a, Call_UnreserveResources& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Call_UnreserveResources* New() const PROTOBUF_FINAL { return New(NULL); }

  Call_UnreserveResources* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Call_UnreserveResources& from);
  void MergeFrom(const Call_UnreserveResources& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Call_UnreserveResources* other);
  protected:
  explicit Call_UnreserveResources(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.Resource resources = 2;
  int resources_size() const;
  void clear_resources();
  static const int kResourcesFieldNumber = 2;
  const ::mesos::Resource& resources(int index) const;
  ::mesos::Resource* mutable_resources(int index);
  ::mesos::Resource* add_resources();
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
      mutable_resources();
  const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
      resources() const;

  // required .mesos.SlaveID slave_id = 1;
  bool has_slave_id() const;
  void clear_slave_id();
  static const int kSlaveIdFieldNumber = 1;
  private:
  void _slow_mutable_slave_id();
  public:
  const ::mesos::SlaveID& slave_id() const;
  ::mesos::SlaveID* release_slave_id();
  ::mesos::SlaveID* mutable_slave_id();
  void set_allocated_slave_id(::mesos::SlaveID* slave_id);
  void unsafe_arena_set_allocated_slave_id(
      ::mesos::SlaveID* slave_id);
  ::mesos::SlaveID* unsafe_arena_release_slave_id();

  // @@protoc_insertion_point(class_scope:mesos.master.Call.UnreserveResources)
 private:
  void set_has_slave_id();
  void clear_has_slave_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource > resources_;
  ::mesos::SlaveID* slave_id_;
  friend struct ::protobuf_mesos_2fmaster_2fmaster_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmaster_2fmaster_2eproto::InitDefaultsCall_UnreserveResourcesImpl();
};
// -------------------------------------------------------------------

class Call_CreateVolumes : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.master.Call.CreateVolumes) */ {
 public:
  Call_CreateVolumes();
  virtual ~Call_CreateVolumes();

  Call_CreateVolumes(const Call_CreateVolumes& from);

  inline Call_CreateVolumes& operator=(const Call_CreateVolumes& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Call_CreateVolumes(Call_CreateVolumes&& from) noexcept
    : Call_CreateVolumes() {
    *this = ::std::move(from);
  }

  inline Call_CreateVolumes& operator=(Call_CreateVolumes&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Call_CreateVolumes& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Call_CreateVolumes* internal_default_instance() {
    return reinterpret_cast<const Call_CreateVolumes*>(
               &_Call_CreateVolumes_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void UnsafeArenaSwap(Call_CreateVolumes* other);
  void Swap(Call_CreateVolumes* other);
  friend void swap(Call_CreateVolumes& a, Call_CreateVolumes& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Call_CreateVolumes* New() const PROTOBUF_FINAL { return New(NULL); }

  Call_CreateVolumes* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Call_CreateVolumes& from);
  void MergeFrom(const Call_CreateVolumes& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Call_CreateVolumes* other);
  protected:
  explicit Call_CreateVolumes(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.Resource volumes = 2;
  int volumes_size() const;
  void clear_volumes();
  static const int kVolumesFieldNumber = 2;
  const ::mesos::Resource& volumes(int index) const;
  ::mesos::Resource* mutable_volumes(int index);
  ::mesos::Resource* add_volumes();
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
      mutable_volumes();
  const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
      volumes() const;

  // required .mesos.SlaveID slave_id = 1;
  bool has_slave_id() const;
  void clear_slave_id();
  static const int kSlaveIdFieldNumber = 1;
  private:
  void _slow_mutable_slave_id();
  public:
  const ::mesos::SlaveID& slave_id() const;
  ::mesos::SlaveID* release_slave_id();
  ::mesos::SlaveID* mutable_slave_id();
  void set_allocated_slave_id(::mesos::SlaveID* slave_id);
  void unsafe_arena_set_allocated_slave_id(
      ::mesos::SlaveID* slave_id);
  ::mesos::SlaveID* unsafe_arena_release_slave_id();

  // @@protoc_insertion_point(class_scope:mesos.master.Call.CreateVolumes)
 private:
  void set_has_slave_id();
  void clear_has_slave_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource > volumes_;
  ::mesos::SlaveID* slave_id_;
  friend struct ::protobuf_mesos_2fmaster_2fmaster_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmaster_2fmaster_2eproto::InitDefaultsCall_CreateVolumesImpl();
};
// -------------------------------------------------------------------

class Call_DestroyVolumes : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.master.Call.DestroyVolumes) */ {
 public:
  Call_DestroyVolumes();
  virtual ~Call_DestroyVolumes();

  Call_DestroyVolumes(const Call_DestroyVolumes& from);

  inline Call_DestroyVolumes& operator=(const Call_DestroyVolumes& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Call_DestroyVolumes(Call_DestroyVolumes&& from) noexcept
    : Call_DestroyVolumes() {
    *this = ::std::move(from);
  }

  inline Call_DestroyVolumes& operator=(Call_DestroyVolumes&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Call_DestroyVolumes& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Call_DestroyVolumes* internal_default_instance() {
    return reinterpret_cast<const Call_DestroyVolumes*>(
               &_Call_DestroyVolumes_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void UnsafeArenaSwap(Call_DestroyVolumes* other);
  void Swap(Call_DestroyVolumes* other);
  friend void swap(Call_DestroyVolumes& a, Call_DestroyVolumes& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Call_DestroyVolumes* New() const PROTOBUF_FINAL { return New(NULL); }

  Call_DestroyVolumes* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Call_DestroyVolumes& from);
  void MergeFrom(const Call_DestroyVolumes& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Call_DestroyVolumes* other);
  protected:
  explicit Call_DestroyVolumes(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.Resource volumes = 2;
  int volumes_size() const;
  void clear_volumes();
  static const int kVolumesFieldNumber = 2;
  const ::mesos::Resource& volumes(int index) const;
  ::mesos::Resource* mutable_volumes(int index);
  ::mesos::Resource* add_volumes();
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
      mutable_volumes();
  const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
      volumes() const;

  // required .mesos.SlaveID slave_id = 1;
  bool has_slave_id() const;
  void clear_slave_id();
  static const int kSlaveIdFieldNumber = 1;
  private:
  void _slow_mutable_slave_id();
  public:
  const ::mesos::SlaveID& slave_id() const;
  ::mesos::SlaveID* release_slave_id();
  ::mesos::SlaveID* mutable_slave_id();
  void set_allocated_slave_id(::mesos::SlaveID* slave_id);
  void unsafe_arena_set_allocated_slave_id(
      ::mesos::SlaveID* slave_id);
  ::mesos::SlaveID* unsafe_arena_release_slave_id();

  // @@protoc_insertion_point(class_scope:mesos.master.Call.DestroyVolumes)
 private:
  void set_has_slave_id();
  void clear_has_slave_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource > volumes_;
  ::mesos::SlaveID* slave_id_;
  friend struct ::protobuf_mesos_2fmaster_2fmaster_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmaster_2fmaster_2eproto::InitDefaultsCall_DestroyVolumesImpl();
};
// -------------------------------------------------------------------

class Call_GrowVolume : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.master.Call.GrowVolume) */ {
 public:
  Call_GrowVolume();
  virtual ~Call_GrowVolume();

  Call_GrowVolume(const Call_GrowVolume& from);

  inline Call_GrowVolume& operator=(const Call_GrowVolume& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Call_GrowVolume(Call_GrowVolume&& from) noexcept
    : Call_GrowVolume() {
    *this = ::std::move(from);
  }

  inline Call_GrowVolume& operator=(Call_GrowVolume&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Call_GrowVolume& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Call_GrowVolume* internal_default_instance() {
    return reinterpret_cast<const Call_GrowVolume*>(
               &_Call_GrowVolume_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void UnsafeArenaSwap(Call_GrowVolume* other);
  void Swap(Call_GrowVolume* other);
  friend void swap(Call_GrowVolume& a, Call_GrowVolume& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Call_GrowVolume* New() const PROTOBUF_FINAL { return New(NULL); }

  Call_GrowVolume* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Call_GrowVolume& from);
  void MergeFrom(const Call_GrowVolume& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Call_GrowVolume* other);
  protected:
  explicit Call_GrowVolume(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mesos.SlaveID slave_id = 1;
  bool has_slave_id() const;
  void clear_slave_id();
  static const int kSlaveIdFieldNumber = 1;
  private:
  void _slow_mutable_slave_id();
  public:
  const ::mesos::SlaveID& slave_id() const;
  ::mesos::SlaveID* release_slave_id();
  ::mesos::SlaveID* mutable_slave_id();
  void set_allocated_slave_id(::mesos::SlaveID* slave_id);
  void unsafe_arena_set_allocated_slave_id(
      ::mesos::SlaveID* slave_id);
  ::mesos::SlaveID* unsafe_arena_release_slave_id();

  // required .mesos.Resource volume = 2;
  bool has_volume() const;
  void clear_volume();
  static const int kVolumeFieldNumber = 2;
  private:
  void _slow_mutable_volume();
  public:
  const ::mesos::Resource& volume() const;
  ::mesos::Resource* release_volume();
  ::mesos::Resource* mutable_volume();
  void set_allocated_volume(::mesos::Resource* volume);
  void unsafe_arena_set_allocated_volume(
      ::mesos::Resource* volume);
  ::mesos::Resource* unsafe_arena_release_volume();

  // required .mesos.Resource addition = 3;
  bool has_addition() const;
  void clear_addition();
  static const int kAdditionFieldNumber = 3;
  private:
  void _slow_mutable_addition();
  public:
  const ::mesos::Resource& addition() const;
  ::mesos::Resource* release_addition();
  ::mesos::Resource* mutable_addition();
  void set_allocated_addition(::mesos::Resource* addition);
  void unsafe_arena_set_allocated_addition(
      ::mesos::Resource* addition);
  ::mesos::Resource* unsafe_arena_release_addition();

  // @@protoc_insertion_point(class_scope:mesos.master.Call.GrowVolume)
 private:
  void set_has_slave_id();
  void clear_has_slave_id();
  void set_has_volume();
  void clear_has_volume();
  void set_has_addition();
  void clear_has_addition();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::SlaveID* slave_id_;
  ::mesos::Resource* volume_;
  ::mesos::Resource* addition_;
  friend struct ::protobuf_mesos_2fmaster_2fmaster_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmaster_2fmaster_2eproto::InitDefaultsCall_GrowVolumeImpl();
};
// -------------------------------------------------------------------

class Call_ShrinkVolume : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.master.Call.ShrinkVolume) */ {
 public:
  Call_ShrinkVolume();
  virtual ~Call_ShrinkVolume();

  Call_ShrinkVolume(const Call_ShrinkVolume& from);

  inline Call_ShrinkVolume& operator=(const Call_ShrinkVolume& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Call_ShrinkVolume(Call_ShrinkVolume&& from) noexcept
    : Call_ShrinkVolume() {
    *this = ::std::move(from);
  }

  inline Call_ShrinkVolume& operator=(Call_ShrinkVolume&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Call_ShrinkVolume& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Call_ShrinkVolume* internal_default_instance() {
    return reinterpret_cast<const Call_ShrinkVolume*>(
               &_Call_ShrinkVolume_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void UnsafeArenaSwap(Call_ShrinkVolume* other);
  void Swap(Call_ShrinkVolume* other);
  friend void swap(Call_ShrinkVolume& a, Call_ShrinkVolume& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Call_ShrinkVolume* New() const PROTOBUF_FINAL { return New(NULL); }

  Call_ShrinkVolume* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Call_ShrinkVolume& from);
  void MergeFrom(const Call_ShrinkVolume& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Call_ShrinkVolume* other);
  protected:
  explicit Call_ShrinkVolume(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mesos.SlaveID slave_id = 1;
  bool has_slave_id() const;
  void clear_slave_id();
  static const int kSlaveIdFieldNumber = 1;
  private:
  void _slow_mutable_slave_id();
  public:
  const ::mesos::SlaveID& slave_id() const;
  ::mesos::SlaveID* release_slave_id();
  ::mesos::SlaveID* mutable_slave_id();
  void set_allocated_slave_id(::mesos::SlaveID* slave_id);
  void unsafe_arena_set_allocated_slave_id(
      ::mesos::SlaveID* slave_id);
  ::mesos::SlaveID* unsafe_arena_release_slave_id();

  // required .mesos.Resource volume = 2;
  bool has_volume() const;
  void clear_volume();
  static const int kVolumeFieldNumber = 2;
  private:
  void _slow_mutable_volume();
  public:
  const ::mesos::Resource& volume() const;
  ::mesos::Resource* release_volume();
  ::mesos::Resource* mutable_volume();
  void set_allocated_volume(::mesos::Resource* volume);
  void unsafe_arena_set_allocated_volume(
      ::mesos::Resource* volume);
  ::mesos::Resource* unsafe_arena_release_volume();

  // required .mesos.Value.Scalar subtract = 3;
  bool has_subtract() const;
  void clear_subtract();
  static const int kSubtractFieldNumber = 3;
  private:
  void _slow_mutable_subtract();
  public:
  const ::mesos::Value_Scalar& subtract() const;
  ::mesos::Value_Scalar* release_subtract();
  ::mesos::Value_Scalar* mutable_subtract();
  void set_allocated_subtract(::mesos::Value_Scalar* subtract);
  void unsafe_arena_set_allocated_subtract(
      ::mesos::Value_Scalar* subtract);
  ::mesos::Value_Scalar* unsafe_arena_release_subtract();

  // @@protoc_insertion_point(class_scope:mesos.master.Call.ShrinkVolume)
 private:
  void set_has_slave_id();
  void clear_has_slave_id();
  void set_has_volume();
  void clear_has_volume();
  void set_has_subtract();
  void clear_has_subtract();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::SlaveID* slave_id_;
  ::mesos::Resource* volume_;
  ::mesos::Value_Scalar* subtract_;
  friend struct ::protobuf_mesos_2fmaster_2fmaster_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmaster_2fmaster_2eproto::InitDefaultsCall_ShrinkVolumeImpl();
};
// -------------------------------------------------------------------

class Call_UpdateMaintenanceSchedule : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.master.Call.UpdateMaintenanceSchedule) */ {
 public:
  Call_UpdateMaintenanceSchedule();
  virtual ~Call_UpdateMaintenanceSchedule();

  Call_UpdateMaintenanceSchedule(const Call_UpdateMaintenanceSchedule& from);

  inline Call_UpdateMaintenanceSchedule& operator=(const Call_UpdateMaintenanceSchedule& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Call_UpdateMaintenanceSchedule(Call_UpdateMaintenanceSchedule&& from) noexcept
    : Call_UpdateMaintenanceSchedule() {
    *this = ::std::move(from);
  }

  inline Call_UpdateMaintenanceSchedule& operator=(Call_UpdateMaintenanceSchedule&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Call_UpdateMaintenanceSchedule& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Call_UpdateMaintenanceSchedule* internal_default_instance() {
    return reinterpret_cast<const Call_UpdateMaintenanceSchedule*>(
               &_Call_UpdateMaintenanceSchedule_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void UnsafeArenaSwap(Call_UpdateMaintenanceSchedule* other);
  void Swap(Call_UpdateMaintenanceSchedule* other);
  friend void swap(Call_UpdateMaintenanceSchedule& a, Call_UpdateMaintenanceSchedule& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Call_UpdateMaintenanceSchedule* New() const PROTOBUF_FINAL { return New(NULL); }

  Call_UpdateMaintenanceSchedule* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Call_UpdateMaintenanceSchedule& from);
  void MergeFrom(const Call_UpdateMaintenanceSchedule& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Call_UpdateMaintenanceSchedule* other);
  protected:
  explicit Call_UpdateMaintenanceSchedule(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.maintenance.Schedule schedule = 1;
  bool has_schedule() const;
  void clear_schedule();
  static const int kScheduleFieldNumber = 1;
  private:
  void _slow_mutable_schedule();
  public:
  const ::mesos::maintenance::Schedule& schedule() const;
  ::mesos::maintenance::Schedule* release_schedule();
  ::mesos::maintenance::Schedule* mutable_schedule();
  void set_allocated_schedule(::mesos::maintenance::Schedule* schedule);
  void unsafe_arena_set_allocated_schedule(
      ::mesos::maintenance::Schedule* schedule);
  ::mesos::maintenance::Schedule* unsafe_arena_release_schedule();

  // @@protoc_insertion_point(class_scope:mesos.master.Call.UpdateMaintenanceSchedule)
 private:
  void set_has_schedule();
  void clear_has_schedule();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::maintenance::Schedule* schedule_;
  friend struct ::protobuf_mesos_2fmaster_2fmaster_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmaster_2fmaster_2eproto::InitDefaultsCall_UpdateMaintenanceScheduleImpl();
};
// -------------------------------------------------------------------

class Call_StartMaintenance : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.master.Call.StartMaintenance) */ {
 public:
  Call_StartMaintenance();
  virtual ~Call_StartMaintenance();

  Call_StartMaintenance(const Call_StartMaintenance& from);

  inline Call_StartMaintenance& operator=(const Call_StartMaintenance& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Call_StartMaintenance(Call_StartMaintenance&& from) noexcept
    : Call_StartMaintenance() {
    *this = ::std::move(from);
  }

  inline Call_StartMaintenance& operator=(Call_StartMaintenance&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Call_StartMaintenance& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Call_StartMaintenance* internal_default_instance() {
    return reinterpret_cast<const Call_StartMaintenance*>(
               &_Call_StartMaintenance_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void UnsafeArenaSwap(Call_StartMaintenance* other);
  void Swap(Call_StartMaintenance* other);
  friend void swap(Call_StartMaintenance& a, Call_StartMaintenance& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Call_StartMaintenance* New() const PROTOBUF_FINAL { return New(NULL); }

  Call_StartMaintenance* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Call_StartMaintenance& from);
  void MergeFrom(const Call_StartMaintenance& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Call_StartMaintenance* other);
  protected:
  explicit Call_StartMaintenance(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.MachineID machines = 1;
  int machines_size() const;
  void clear_machines();
  static const int kMachinesFieldNumber = 1;
  const ::mesos::MachineID& machines(int index) const;
  ::mesos::MachineID* mutable_machines(int index);
  ::mesos::MachineID* add_machines();
  ::google::protobuf::RepeatedPtrField< ::mesos::MachineID >*
      mutable_machines();
  const ::google::protobuf::RepeatedPtrField< ::mesos::MachineID >&
      machines() const;

  // @@protoc_insertion_point(class_scope:mesos.master.Call.StartMaintenance)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::MachineID > machines_;
  friend struct ::protobuf_mesos_2fmaster_2fmaster_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmaster_2fmaster_2eproto::InitDefaultsCall_StartMaintenanceImpl();
};
// -------------------------------------------------------------------

class Call_StopMaintenance : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.master.Call.StopMaintenance) */ {
 public:
  Call_StopMaintenance();
  virtual ~Call_StopMaintenance();

  Call_StopMaintenance(const Call_StopMaintenance& from);

  inline Call_StopMaintenance& operator=(const Call_StopMaintenance& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Call_StopMaintenance(Call_StopMaintenance&& from) noexcept
    : Call_StopMaintenance() {
    *this = ::std::move(from);
  }

  inline Call_StopMaintenance& operator=(Call_StopMaintenance&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Call_StopMaintenance& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Call_StopMaintenance* internal_default_instance() {
    return reinterpret_cast<const Call_StopMaintenance*>(
               &_Call_StopMaintenance_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void UnsafeArenaSwap(Call_StopMaintenance* other);
  void Swap(Call_StopMaintenance* other);
  friend void swap(Call_StopMaintenance& a, Call_StopMaintenance& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Call_StopMaintenance* New() const PROTOBUF_FINAL { return New(NULL); }

  Call_StopMaintenance* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Call_StopMaintenance& from);
  void MergeFrom(const Call_StopMaintenance& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Call_StopMaintenance* other);
  protected:
  explicit Call_StopMaintenance(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.MachineID machines = 1;
  int machines_size() const;
  void clear_machines();
  static const int kMachinesFieldNumber = 1;
  const ::mesos::MachineID& machines(int index) const;
  ::mesos::MachineID* mutable_machines(int index);
  ::mesos::MachineID* add_machines();
  ::google::protobuf::RepeatedPtrField< ::mesos::MachineID >*
      mutable_machines();
  const ::google::protobuf::RepeatedPtrField< ::mesos::MachineID >&
      machines() const;

  // @@protoc_insertion_point(class_scope:mesos.master.Call.StopMaintenance)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::MachineID > machines_;
  friend struct ::protobuf_mesos_2fmaster_2fmaster_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmaster_2fmaster_2eproto::InitDefaultsCall_StopMaintenanceImpl();
};
// -------------------------------------------------------------------

class Call_SetQuota : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.master.Call.SetQuota) */ {
 public:
  Call_SetQuota();
  virtual ~Call_SetQuota();

  Call_SetQuota(const Call_SetQuota& from);

  inline Call_SetQuota& operator=(const Call_SetQuota& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Call_SetQuota(Call_SetQuota&& from) noexcept
    : Call_SetQuota() {
    *this = ::std::move(from);
  }

  inline Call_SetQuota& operator=(Call_SetQuota&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Call_SetQuota& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Call_SetQuota* internal_default_instance() {
    return reinterpret_cast<const Call_SetQuota*>(
               &_Call_SetQuota_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    14;

  void UnsafeArenaSwap(Call_SetQuota* other);
  void Swap(Call_SetQuota* other);
  friend void swap(Call_SetQuota& a, Call_SetQuota& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Call_SetQuota* New() const PROTOBUF_FINAL { return New(NULL); }

  Call_SetQuota* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Call_SetQuota& from);
  void MergeFrom(const Call_SetQuota& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Call_SetQuota* other);
  protected:
  explicit Call_SetQuota(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.quota.QuotaRequest quota_request = 1;
  bool has_quota_request() const;
  void clear_quota_request();
  static const int kQuotaRequestFieldNumber = 1;
  private:
  void _slow_mutable_quota_request();
  public:
  const ::mesos::quota::QuotaRequest& quota_request() const;
  ::mesos::quota::QuotaRequest* release_quota_request();
  ::mesos::quota::QuotaRequest* mutable_quota_request();
  void set_allocated_quota_request(::mesos::quota::QuotaRequest* quota_request);
  void unsafe_arena_set_allocated_quota_request(
      ::mesos::quota::QuotaRequest* quota_request);
  ::mesos::quota::QuotaRequest* unsafe_arena_release_quota_request();

  // @@protoc_insertion_point(class_scope:mesos.master.Call.SetQuota)
 private:
  void set_has_quota_request();
  void clear_has_quota_request();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::quota::QuotaRequest* quota_request_;
  friend struct ::protobuf_mesos_2fmaster_2fmaster_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmaster_2fmaster_2eproto::InitDefaultsCall_SetQuotaImpl();
};
// -------------------------------------------------------------------

class Call_RemoveQuota : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.master.Call.RemoveQuota) */ {
 public:
  Call_RemoveQuota();
  virtual ~Call_RemoveQuota();

  Call_RemoveQuota(const Call_RemoveQuota& from);

  inline Call_RemoveQuota& operator=(const Call_RemoveQuota& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Call_RemoveQuota(Call_RemoveQuota&& from) noexcept
    : Call_RemoveQuota() {
    *this = ::std::move(from);
  }

  inline Call_RemoveQuota& operator=(Call_RemoveQuota&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Call_RemoveQuota& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Call_RemoveQuota* internal_default_instance() {
    return reinterpret_cast<const Call_RemoveQuota*>(
               &_Call_RemoveQuota_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    15;

  void UnsafeArenaSwap(Call_RemoveQuota* other);
  void Swap(Call_RemoveQuota* other);
  friend void swap(Call_RemoveQuota& a, Call_RemoveQuota& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Call_RemoveQuota* New() const PROTOBUF_FINAL { return New(NULL); }

  Call_RemoveQuota* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Call_RemoveQuota& from);
  void MergeFrom(const Call_RemoveQuota& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Call_RemoveQuota* other);
  protected:
  explicit Call_RemoveQuota(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string role = 1;
  bool has_role() const;
  void clear_role();
  static const int kRoleFieldNumber = 1;
  const ::std::string& role() const;
  void set_role(const ::std::string& value);
  #if LANG_CXX11
  void set_role(::std::string&& value);
  #endif
  void set_role(const char* value);
  void set_role(const char* value, size_t size);
  ::std::string* mutable_role();
  ::std::string* release_role();
  void set_allocated_role(::std::string* role);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_role();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_role(
      ::std::string* role);

  // @@protoc_insertion_point(class_scope:mesos.master.Call.RemoveQuota)
 private:
  void set_has_role();
  void clear_has_role();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr role_;
  friend struct ::protobuf_mesos_2fmaster_2fmaster_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmaster_2fmaster_2eproto::InitDefaultsCall_RemoveQuotaImpl();
};
// -------------------------------------------------------------------

class Call_Teardown : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.master.Call.Teardown) */ {
 public:
  Call_Teardown();
  virtual ~Call_Teardown();

  Call_Teardown(const Call_Teardown& from);

  inline Call_Teardown& operator=(const Call_Teardown& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Call_Teardown(Call_Teardown&& from) noexcept
    : Call_Teardown() {
    *this = ::std::move(from);
  }

  inline Call_Teardown& operator=(Call_Teardown&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Call_Teardown& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Call_Teardown* internal_default_instance() {
    return reinterpret_cast<const Call_Teardown*>(
               &_Call_Teardown_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    16;

  void UnsafeArenaSwap(Call_Teardown* other);
  void Swap(Call_Teardown* other);
  friend void swap(Call_Teardown& a, Call_Teardown& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Call_Teardown* New() const PROTOBUF_FINAL { return New(NULL); }

  Call_Teardown* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Call_Teardown& from);
  void MergeFrom(const Call_Teardown& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Call_Teardown* other);
  protected:
  explicit Call_Teardown(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.FrameworkID framework_id = 1;
  bool has_framework_id() const;
  void clear_framework_id();
  static const int kFrameworkIdFieldNumber = 1;
  private:
  void _slow_mutable_framework_id();
  public:
  const ::mesos::FrameworkID& framework_id() const;
  ::mesos::FrameworkID* release_framework_id();
  ::mesos::FrameworkID* mutable_framework_id();
  void set_allocated_framework_id(::mesos::FrameworkID* framework_id);
  void unsafe_arena_set_allocated_framework_id(
      ::mesos::FrameworkID* framework_id);
  ::mesos::FrameworkID* unsafe_arena_release_framework_id();

  // @@protoc_insertion_point(class_scope:mesos.master.Call.Teardown)
 private:
  void set_has_framework_id();
  void clear_has_framework_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::FrameworkID* framework_id_;
  friend struct ::protobuf_mesos_2fmaster_2fmaster_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmaster_2fmaster_2eproto::InitDefaultsCall_TeardownImpl();
};
// -------------------------------------------------------------------

class Call_MarkAgentGone : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.master.Call.MarkAgentGone) */ {
 public:
  Call_MarkAgentGone();
  virtual ~Call_MarkAgentGone();

  Call_MarkAgentGone(const Call_MarkAgentGone& from);

  inline Call_MarkAgentGone& operator=(const Call_MarkAgentGone& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Call_MarkAgentGone(Call_MarkAgentGone&& from) noexcept
    : Call_MarkAgentGone() {
    *this = ::std::move(from);
  }

  inline Call_MarkAgentGone& operator=(Call_MarkAgentGone&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Call_MarkAgentGone& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Call_MarkAgentGone* internal_default_instance() {
    return reinterpret_cast<const Call_MarkAgentGone*>(
               &_Call_MarkAgentGone_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    17;

  void UnsafeArenaSwap(Call_MarkAgentGone* other);
  void Swap(Call_MarkAgentGone* other);
  friend void swap(Call_MarkAgentGone& a, Call_MarkAgentGone& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Call_MarkAgentGone* New() const PROTOBUF_FINAL { return New(NULL); }

  Call_MarkAgentGone* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Call_MarkAgentGone& from);
  void MergeFrom(const Call_MarkAgentGone& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Call_MarkAgentGone* other);
  protected:
  explicit Call_MarkAgentGone(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.SlaveID slave_id = 1;
  bool has_slave_id() const;
  void clear_slave_id();
  static const int kSlaveIdFieldNumber = 1;
  private:
  void _slow_mutable_slave_id();
  public:
  const ::mesos::SlaveID& slave_id() const;
  ::mesos::SlaveID* release_slave_id();
  ::mesos::SlaveID* mutable_slave_id();
  void set_allocated_slave_id(::mesos::SlaveID* slave_id);
  void unsafe_arena_set_allocated_slave_id(
      ::mesos::SlaveID* slave_id);
  ::mesos::SlaveID* unsafe_arena_release_slave_id();

  // @@protoc_insertion_point(class_scope:mesos.master.Call.MarkAgentGone)
 private:
  void set_has_slave_id();
  void clear_has_slave_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::SlaveID* slave_id_;
  friend struct ::protobuf_mesos_2fmaster_2fmaster_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmaster_2fmaster_2eproto::InitDefaultsCall_MarkAgentGoneImpl();
};
// -------------------------------------------------------------------

class Call : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.master.Call) */ {
 public:
  Call();
  virtual ~Call();

  Call(const Call& from);

  inline Call& operator=(const Call& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Call(Call&& from) noexcept
    : Call() {
    *this = ::std::move(from);
  }

  inline Call& operator=(Call&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Call& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Call* internal_default_instance() {
    return reinterpret_cast<const Call*>(
               &_Call_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    18;

  void UnsafeArenaSwap(Call* other);
  void Swap(Call* other);
  friend void swap(Call& a, Call& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Call* New() const PROTOBUF_FINAL { return New(NULL); }

  Call* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Call& from);
  void MergeFrom(const Call& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Call* other);
  protected:
  explicit Call(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Call_GetMetrics GetMetrics;
  typedef Call_SetLoggingLevel SetLoggingLevel;
  typedef Call_ListFiles ListFiles;
  typedef Call_ReadFile ReadFile;
  typedef Call_UpdateWeights UpdateWeights;
  typedef Call_ReserveResources ReserveResources;
  typedef Call_UnreserveResources UnreserveResources;
  typedef Call_CreateVolumes CreateVolumes;
  typedef Call_DestroyVolumes DestroyVolumes;
  typedef Call_GrowVolume GrowVolume;
  typedef Call_ShrinkVolume ShrinkVolume;
  typedef Call_UpdateMaintenanceSchedule UpdateMaintenanceSchedule;
  typedef Call_StartMaintenance StartMaintenance;
  typedef Call_StopMaintenance StopMaintenance;
  typedef Call_SetQuota SetQuota;
  typedef Call_RemoveQuota RemoveQuota;
  typedef Call_Teardown Teardown;
  typedef Call_MarkAgentGone MarkAgentGone;

  typedef Call_Type Type;
  static const Type UNKNOWN =
    Call_Type_UNKNOWN;
  static const Type GET_HEALTH =
    Call_Type_GET_HEALTH;
  static const Type GET_FLAGS =
    Call_Type_GET_FLAGS;
  static const Type GET_VERSION =
    Call_Type_GET_VERSION;
  static const Type GET_METRICS =
    Call_Type_GET_METRICS;
  static const Type GET_LOGGING_LEVEL =
    Call_Type_GET_LOGGING_LEVEL;
  static const Type SET_LOGGING_LEVEL =
    Call_Type_SET_LOGGING_LEVEL;
  static const Type LIST_FILES =
    Call_Type_LIST_FILES;
  static const Type READ_FILE =
    Call_Type_READ_FILE;
  static const Type GET_STATE =
    Call_Type_GET_STATE;
  static const Type GET_AGENTS =
    Call_Type_GET_AGENTS;
  static const Type GET_FRAMEWORKS =
    Call_Type_GET_FRAMEWORKS;
  static const Type GET_EXECUTORS =
    Call_Type_GET_EXECUTORS;
  static const Type GET_OPERATIONS =
    Call_Type_GET_OPERATIONS;
  static const Type GET_TASKS =
    Call_Type_GET_TASKS;
  static const Type GET_ROLES =
    Call_Type_GET_ROLES;
  static const Type GET_WEIGHTS =
    Call_Type_GET_WEIGHTS;
  static const Type UPDATE_WEIGHTS =
    Call_Type_UPDATE_WEIGHTS;
  static const Type GET_MASTER =
    Call_Type_GET_MASTER;
  static const Type SUBSCRIBE =
    Call_Type_SUBSCRIBE;
  static const Type RESERVE_RESOURCES =
    Call_Type_RESERVE_RESOURCES;
  static const Type UNRESERVE_RESOURCES =
    Call_Type_UNRESERVE_RESOURCES;
  static const Type CREATE_VOLUMES =
    Call_Type_CREATE_VOLUMES;
  static const Type DESTROY_VOLUMES =
    Call_Type_DESTROY_VOLUMES;
  static const Type GROW_VOLUME =
    Call_Type_GROW_VOLUME;
  static const Type SHRINK_VOLUME =
    Call_Type_SHRINK_VOLUME;
  static const Type GET_MAINTENANCE_STATUS =
    Call_Type_GET_MAINTENANCE_STATUS;
  static const Type GET_MAINTENANCE_SCHEDULE =
    Call_Type_GET_MAINTENANCE_SCHEDULE;
  static const Type UPDATE_MAINTENANCE_SCHEDULE =
    Call_Type_UPDATE_MAINTENANCE_SCHEDULE;
  static const Type START_MAINTENANCE =
    Call_Type_START_MAINTENANCE;
  static const Type STOP_MAINTENANCE =
    Call_Type_STOP_MAINTENANCE;
  static const Type GET_QUOTA =
    Call_Type_GET_QUOTA;
  static const Type SET_QUOTA =
    Call_Type_SET_QUOTA;
  static const Type REMOVE_QUOTA =
    Call_Type_REMOVE_QUOTA;
  static const Type TEARDOWN =
    Call_Type_TEARDOWN;
  static const Type MARK_AGENT_GONE =
    Call_Type_MARK_AGENT_GONE;
  static inline bool Type_IsValid(int value) {
    return Call_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Call_Type_Type_MIN;
  static const Type Type_MAX =
    Call_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Call_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Call_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Call_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Call_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .mesos.master.Call.GetMetrics get_metrics = 2;
  bool has_get_metrics() const;
  void clear_get_metrics();
  static const int kGetMetricsFieldNumber = 2;
  private:
  void _slow_mutable_get_metrics();
  public:
  const ::mesos::master::Call_GetMetrics& get_metrics() const;
  ::mesos::master::Call_GetMetrics* release_get_metrics();
  ::mesos::master::Call_GetMetrics* mutable_get_metrics();
  void set_allocated_get_metrics(::mesos::master::Call_GetMetrics* get_metrics);
  void unsafe_arena_set_allocated_get_metrics(
      ::mesos::master::Call_GetMetrics* get_metrics);
  ::mesos::master::Call_GetMetrics* unsafe_arena_release_get_metrics();

  // optional .mesos.master.Call.SetLoggingLevel set_logging_level = 3;
  bool has_set_logging_level() const;
  void clear_set_logging_level();
  static const int kSetLoggingLevelFieldNumber = 3;
  private:
  void _slow_mutable_set_logging_level();
  public:
  const ::mesos::master::Call_SetLoggingLevel& set_logging_level() const;
  ::mesos::master::Call_SetLoggingLevel* release_set_logging_level();
  ::mesos::master::Call_SetLoggingLevel* mutable_set_logging_level();
  void set_allocated_set_logging_level(::mesos::master::Call_SetLoggingLevel* set_logging_level);
  void unsafe_arena_set_allocated_set_logging_level(
      ::mesos::master::Call_SetLoggingLevel* set_logging_level);
  ::mesos::master::Call_SetLoggingLevel* unsafe_arena_release_set_logging_level();

  // optional .mesos.master.Call.ListFiles list_files = 4;
  bool has_list_files() const;
  void clear_list_files();
  static const int kListFilesFieldNumber = 4;
  private:
  void _slow_mutable_list_files();
  public:
  const ::mesos::master::Call_ListFiles& list_files() const;
  ::mesos::master::Call_ListFiles* release_list_files();
  ::mesos::master::Call_ListFiles* mutable_list_files();
  void set_allocated_list_files(::mesos::master::Call_ListFiles* list_files);
  void unsafe_arena_set_allocated_list_files(
      ::mesos::master::Call_ListFiles* list_files);
  ::mesos::master::Call_ListFiles* unsafe_arena_release_list_files();

  // optional .mesos.master.Call.ReadFile read_file = 5;
  bool has_read_file() const;
  void clear_read_file();
  static const int kReadFileFieldNumber = 5;
  private:
  void _slow_mutable_read_file();
  public:
  const ::mesos::master::Call_ReadFile& read_file() const;
  ::mesos::master::Call_ReadFile* release_read_file();
  ::mesos::master::Call_ReadFile* mutable_read_file();
  void set_allocated_read_file(::mesos::master::Call_ReadFile* read_file);
  void unsafe_arena_set_allocated_read_file(
      ::mesos::master::Call_ReadFile* read_file);
  ::mesos::master::Call_ReadFile* unsafe_arena_release_read_file();

  // optional .mesos.master.Call.UpdateWeights update_weights = 6;
  bool has_update_weights() const;
  void clear_update_weights();
  static const int kUpdateWeightsFieldNumber = 6;
  private:
  void _slow_mutable_update_weights();
  public:
  const ::mesos::master::Call_UpdateWeights& update_weights() const;
  ::mesos::master::Call_UpdateWeights* release_update_weights();
  ::mesos::master::Call_UpdateWeights* mutable_update_weights();
  void set_allocated_update_weights(::mesos::master::Call_UpdateWeights* update_weights);
  void unsafe_arena_set_allocated_update_weights(
      ::mesos::master::Call_UpdateWeights* update_weights);
  ::mesos::master::Call_UpdateWeights* unsafe_arena_release_update_weights();

  // optional .mesos.master.Call.ReserveResources reserve_resources = 7;
  bool has_reserve_resources() const;
  void clear_reserve_resources();
  static const int kReserveResourcesFieldNumber = 7;
  private:
  void _slow_mutable_reserve_resources();
  public:
  const ::mesos::master::Call_ReserveResources& reserve_resources() const;
  ::mesos::master::Call_ReserveResources* release_reserve_resources();
  ::mesos::master::Call_ReserveResources* mutable_reserve_resources();
  void set_allocated_reserve_resources(::mesos::master::Call_ReserveResources* reserve_resources);
  void unsafe_arena_set_allocated_reserve_resources(
      ::mesos::master::Call_ReserveResources* reserve_resources);
  ::mesos::master::Call_ReserveResources* unsafe_arena_release_reserve_resources();

  // optional .mesos.master.Call.UnreserveResources unreserve_resources = 8;
  bool has_unreserve_resources() const;
  void clear_unreserve_resources();
  static const int kUnreserveResourcesFieldNumber = 8;
  private:
  void _slow_mutable_unreserve_resources();
  public:
  const ::mesos::master::Call_UnreserveResources& unreserve_resources() const;
  ::mesos::master::Call_UnreserveResources* release_unreserve_resources();
  ::mesos::master::Call_UnreserveResources* mutable_unreserve_resources();
  void set_allocated_unreserve_resources(::mesos::master::Call_UnreserveResources* unreserve_resources);
  void unsafe_arena_set_allocated_unreserve_resources(
      ::mesos::master::Call_UnreserveResources* unreserve_resources);
  ::mesos::master::Call_UnreserveResources* unsafe_arena_release_unreserve_resources();

  // optional .mesos.master.Call.CreateVolumes create_volumes = 9;
  bool has_create_volumes() const;
  void clear_create_volumes();
  static const int kCreateVolumesFieldNumber = 9;
  private:
  void _slow_mutable_create_volumes();
  public:
  const ::mesos::master::Call_CreateVolumes& create_volumes() const;
  ::mesos::master::Call_CreateVolumes* release_create_volumes();
  ::mesos::master::Call_CreateVolumes* mutable_create_volumes();
  void set_allocated_create_volumes(::mesos::master::Call_CreateVolumes* create_volumes);
  void unsafe_arena_set_allocated_create_volumes(
      ::mesos::master::Call_CreateVolumes* create_volumes);
  ::mesos::master::Call_CreateVolumes* unsafe_arena_release_create_volumes();

  // optional .mesos.master.Call.DestroyVolumes destroy_volumes = 10;
  bool has_destroy_volumes() const;
  void clear_destroy_volumes();
  static const int kDestroyVolumesFieldNumber = 10;
  private:
  void _slow_mutable_destroy_volumes();
  public:
  const ::mesos::master::Call_DestroyVolumes& destroy_volumes() const;
  ::mesos::master::Call_DestroyVolumes* release_destroy_volumes();
  ::mesos::master::Call_DestroyVolumes* mutable_destroy_volumes();
  void set_allocated_destroy_volumes(::mesos::master::Call_DestroyVolumes* destroy_volumes);
  void unsafe_arena_set_allocated_destroy_volumes(
      ::mesos::master::Call_DestroyVolumes* destroy_volumes);
  ::mesos::master::Call_DestroyVolumes* unsafe_arena_release_destroy_volumes();

  // optional .mesos.master.Call.UpdateMaintenanceSchedule update_maintenance_schedule = 11;
  bool has_update_maintenance_schedule() const;
  void clear_update_maintenance_schedule();
  static const int kUpdateMaintenanceScheduleFieldNumber = 11;
  private:
  void _slow_mutable_update_maintenance_schedule();
  public:
  const ::mesos::master::Call_UpdateMaintenanceSchedule& update_maintenance_schedule() const;
  ::mesos::master::Call_UpdateMaintenanceSchedule* release_update_maintenance_schedule();
  ::mesos::master::Call_UpdateMaintenanceSchedule* mutable_update_maintenance_schedule();
  void set_allocated_update_maintenance_schedule(::mesos::master::Call_UpdateMaintenanceSchedule* update_maintenance_schedule);
  void unsafe_arena_set_allocated_update_maintenance_schedule(
      ::mesos::master::Call_UpdateMaintenanceSchedule* update_maintenance_schedule);
  ::mesos::master::Call_UpdateMaintenanceSchedule* unsafe_arena_release_update_maintenance_schedule();

  // optional .mesos.master.Call.StartMaintenance start_maintenance = 12;
  bool has_start_maintenance() const;
  void clear_start_maintenance();
  static const int kStartMaintenanceFieldNumber = 12;
  private:
  void _slow_mutable_start_maintenance();
  public:
  const ::mesos::master::Call_StartMaintenance& start_maintenance() const;
  ::mesos::master::Call_StartMaintenance* release_start_maintenance();
  ::mesos::master::Call_StartMaintenance* mutable_start_maintenance();
  void set_allocated_start_maintenance(::mesos::master::Call_StartMaintenance* start_maintenance);
  void unsafe_arena_set_allocated_start_maintenance(
      ::mesos::master::Call_StartMaintenance* start_maintenance);
  ::mesos::master::Call_StartMaintenance* unsafe_arena_release_start_maintenance();

  // optional .mesos.master.Call.StopMaintenance stop_maintenance = 13;
  bool has_stop_maintenance() const;
  void clear_stop_maintenance();
  static const int kStopMaintenanceFieldNumber = 13;
  private:
  void _slow_mutable_stop_maintenance();
  public:
  const ::mesos::master::Call_StopMaintenance& stop_maintenance() const;
  ::mesos::master::Call_StopMaintenance* release_stop_maintenance();
  ::mesos::master::Call_StopMaintenance* mutable_stop_maintenance();
  void set_allocated_stop_maintenance(::mesos::master::Call_StopMaintenance* stop_maintenance);
  void unsafe_arena_set_allocated_stop_maintenance(
      ::mesos::master::Call_StopMaintenance* stop_maintenance);
  ::mesos::master::Call_StopMaintenance* unsafe_arena_release_stop_maintenance();

  // optional .mesos.master.Call.SetQuota set_quota = 14;
  bool has_set_quota() const;
  void clear_set_quota();
  static const int kSetQuotaFieldNumber = 14;
  private:
  void _slow_mutable_set_quota();
  public:
  const ::mesos::master::Call_SetQuota& set_quota() const;
  ::mesos::master::Call_SetQuota* release_set_quota();
  ::mesos::master::Call_SetQuota* mutable_set_quota();
  void set_allocated_set_quota(::mesos::master::Call_SetQuota* set_quota);
  void unsafe_arena_set_allocated_set_quota(
      ::mesos::master::Call_SetQuota* set_quota);
  ::mesos::master::Call_SetQuota* unsafe_arena_release_set_quota();

  // optional .mesos.master.Call.RemoveQuota remove_quota = 15;
  bool has_remove_quota() const;
  void clear_remove_quota();
  static const int kRemoveQuotaFieldNumber = 15;
  private:
  void _slow_mutable_remove_quota();
  public:
  const ::mesos::master::Call_RemoveQuota& remove_quota() const;
  ::mesos::master::Call_RemoveQuota* release_remove_quota();
  ::mesos::master::Call_RemoveQuota* mutable_remove_quota();
  void set_allocated_remove_quota(::mesos::master::Call_RemoveQuota* remove_quota);
  void unsafe_arena_set_allocated_remove_quota(
      ::mesos::master::Call_RemoveQuota* remove_quota);
  ::mesos::master::Call_RemoveQuota* unsafe_arena_release_remove_quota();

  // optional .mesos.master.Call.Teardown teardown = 16;
  bool has_teardown() const;
  void clear_teardown();
  static const int kTeardownFieldNumber = 16;
  private:
  void _slow_mutable_teardown();
  public:
  const ::mesos::master::Call_Teardown& teardown() const;
  ::mesos::master::Call_Teardown* release_teardown();
  ::mesos::master::Call_Teardown* mutable_teardown();
  void set_allocated_teardown(::mesos::master::Call_Teardown* teardown);
  void unsafe_arena_set_allocated_teardown(
      ::mesos::master::Call_Teardown* teardown);
  ::mesos::master::Call_Teardown* unsafe_arena_release_teardown();

  // optional .mesos.master.Call.MarkAgentGone mark_agent_gone = 17;
  bool has_mark_agent_gone() const;
  void clear_mark_agent_gone();
  static const int kMarkAgentGoneFieldNumber = 17;
  private:
  void _slow_mutable_mark_agent_gone();
  public:
  const ::mesos::master::Call_MarkAgentGone& mark_agent_gone() const;
  ::mesos::master::Call_MarkAgentGone* release_mark_agent_gone();
  ::mesos::master::Call_MarkAgentGone* mutable_mark_agent_gone();
  void set_allocated_mark_agent_gone(::mesos::master::Call_MarkAgentGone* mark_agent_gone);
  void unsafe_arena_set_allocated_mark_agent_gone(
      ::mesos::master::Call_MarkAgentGone* mark_agent_gone);
  ::mesos::master::Call_MarkAgentGone* unsafe_arena_release_mark_agent_gone();

  // optional .mesos.master.Call.GrowVolume grow_volume = 18;
  bool has_grow_volume() const;
  void clear_grow_volume();
  static const int kGrowVolumeFieldNumber = 18;
  private:
  void _slow_mutable_grow_volume();
  public:
  const ::mesos::master::Call_GrowVolume& grow_volume() const;
  ::mesos::master::Call_GrowVolume* release_grow_volume();
  ::mesos::master::Call_GrowVolume* mutable_grow_volume();
  void set_allocated_grow_volume(::mesos::master::Call_GrowVolume* grow_volume);
  void unsafe_arena_set_allocated_grow_volume(
      ::mesos::master::Call_GrowVolume* grow_volume);
  ::mesos::master::Call_GrowVolume* unsafe_arena_release_grow_volume();

  // optional .mesos.master.Call.ShrinkVolume shrink_volume = 19;
  bool has_shrink_volume() const;
  void clear_shrink_volume();
  static const int kShrinkVolumeFieldNumber = 19;
  private:
  void _slow_mutable_shrink_volume();
  public:
  const ::mesos::master::Call_ShrinkVolume& shrink_volume() const;
  ::mesos::master::Call_ShrinkVolume* release_shrink_volume();
  ::mesos::master::Call_ShrinkVolume* mutable_shrink_volume();
  void set_allocated_shrink_volume(::mesos::master::Call_ShrinkVolume* shrink_volume);
  void unsafe_arena_set_allocated_shrink_volume(
      ::mesos::master::Call_ShrinkVolume* shrink_volume);
  ::mesos::master::Call_ShrinkVolume* unsafe_arena_release_shrink_volume();

  // optional .mesos.master.Call.Type type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::mesos::master::Call_Type type() const;
  void set_type(::mesos::master::Call_Type value);

  // @@protoc_insertion_point(class_scope:mesos.master.Call)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_get_metrics();
  void clear_has_get_metrics();
  void set_has_set_logging_level();
  void clear_has_set_logging_level();
  void set_has_list_files();
  void clear_has_list_files();
  void set_has_read_file();
  void clear_has_read_file();
  void set_has_update_weights();
  void clear_has_update_weights();
  void set_has_reserve_resources();
  void clear_has_reserve_resources();
  void set_has_unreserve_resources();
  void clear_has_unreserve_resources();
  void set_has_create_volumes();
  void clear_has_create_volumes();
  void set_has_destroy_volumes();
  void clear_has_destroy_volumes();
  void set_has_grow_volume();
  void clear_has_grow_volume();
  void set_has_shrink_volume();
  void clear_has_shrink_volume();
  void set_has_update_maintenance_schedule();
  void clear_has_update_maintenance_schedule();
  void set_has_start_maintenance();
  void clear_has_start_maintenance();
  void set_has_stop_maintenance();
  void clear_has_stop_maintenance();
  void set_has_set_quota();
  void clear_has_set_quota();
  void set_has_remove_quota();
  void clear_has_remove_quota();
  void set_has_teardown();
  void clear_has_teardown();
  void set_has_mark_agent_gone();
  void clear_has_mark_agent_gone();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::master::Call_GetMetrics* get_metrics_;
  ::mesos::master::Call_SetLoggingLevel* set_logging_level_;
  ::mesos::master::Call_ListFiles* list_files_;
  ::mesos::master::Call_ReadFile* read_file_;
  ::mesos::master::Call_UpdateWeights* update_weights_;
  ::mesos::master::Call_ReserveResources* reserve_resources_;
  ::mesos::master::Call_UnreserveResources* unreserve_resources_;
  ::mesos::master::Call_CreateVolumes* create_volumes_;
  ::mesos::master::Call_DestroyVolumes* destroy_volumes_;
  ::mesos::master::Call_UpdateMaintenanceSchedule* update_maintenance_schedule_;
  ::mesos::master::Call_StartMaintenance* start_maintenance_;
  ::mesos::master::Call_StopMaintenance* stop_maintenance_;
  ::mesos::master::Call_SetQuota* set_quota_;
  ::mesos::master::Call_RemoveQuota* remove_quota_;
  ::mesos::master::Call_Teardown* teardown_;
  ::mesos::master::Call_MarkAgentGone* mark_agent_gone_;
  ::mesos::master::Call_GrowVolume* grow_volume_;
  ::mesos::master::Call_ShrinkVolume* shrink_volume_;
  int type_;
  friend struct ::protobuf_mesos_2fmaster_2fmaster_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmaster_2fmaster_2eproto::InitDefaultsCallImpl();
};
// -------------------------------------------------------------------

class Response_GetHealth : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.master.Response.GetHealth) */ {
 public:
  Response_GetHealth();
  virtual ~Response_GetHealth();

  Response_GetHealth(const Response_GetHealth& from);

  inline Response_GetHealth& operator=(const Response_GetHealth& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Response_GetHealth(Response_GetHealth&& from) noexcept
    : Response_GetHealth() {
    *this = ::std::move(from);
  }

  inline Response_GetHealth& operator=(Response_GetHealth&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Response_GetHealth& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Response_GetHealth* internal_default_instance() {
    return reinterpret_cast<const Response_GetHealth*>(
               &_Response_GetHealth_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    19;

  void UnsafeArenaSwap(Response_GetHealth* other);
  void Swap(Response_GetHealth* other);
  friend void swap(Response_GetHealth& a, Response_GetHealth& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Response_GetHealth* New() const PROTOBUF_FINAL { return New(NULL); }

  Response_GetHealth* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Response_GetHealth& from);
  void MergeFrom(const Response_GetHealth& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Response_GetHealth* other);
  protected:
  explicit Response_GetHealth(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool healthy = 1;
  bool has_healthy() const;
  void clear_healthy();
  static const int kHealthyFieldNumber = 1;
  bool healthy() const;
  void set_healthy(bool value);

  // @@protoc_insertion_point(class_scope:mesos.master.Response.GetHealth)
 private:
  void set_has_healthy();
  void clear_has_healthy();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  bool healthy_;
  friend struct ::protobuf_mesos_2fmaster_2fmaster_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmaster_2fmaster_2eproto::InitDefaultsResponse_GetHealthImpl();
};
// -------------------------------------------------------------------

class Response_GetFlags : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.master.Response.GetFlags) */ {
 public:
  Response_GetFlags();
  virtual ~Response_GetFlags();

  Response_GetFlags(const Response_GetFlags& from);

  inline Response_GetFlags& operator=(const Response_GetFlags& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Response_GetFlags(Response_GetFlags&& from) noexcept
    : Response_GetFlags() {
    *this = ::std::move(from);
  }

  inline Response_GetFlags& operator=(Response_GetFlags&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Response_GetFlags& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Response_GetFlags* internal_default_instance() {
    return reinterpret_cast<const Response_GetFlags*>(
               &_Response_GetFlags_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    20;

  void UnsafeArenaSwap(Response_GetFlags* other);
  void Swap(Response_GetFlags* other);
  friend void swap(Response_GetFlags& a, Response_GetFlags& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Response_GetFlags* New() const PROTOBUF_FINAL { return New(NULL); }

  Response_GetFlags* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Response_GetFlags& from);
  void MergeFrom(const Response_GetFlags& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Response_GetFlags* other);
  protected:
  explicit Response_GetFlags(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.Flag flags = 1;
  int flags_size() const;
  void clear_flags();
  static const int kFlagsFieldNumber = 1;
  const ::mesos::Flag& flags(int index) const;
  ::mesos::Flag* mutable_flags(int index);
  ::mesos::Flag* add_flags();
  ::google::protobuf::RepeatedPtrField< ::mesos::Flag >*
      mutable_flags();
  const ::google::protobuf::RepeatedPtrField< ::mesos::Flag >&
      flags() const;

  // @@protoc_insertion_point(class_scope:mesos.master.Response.GetFlags)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Flag > flags_;
  friend struct ::protobuf_mesos_2fmaster_2fmaster_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmaster_2fmaster_2eproto::InitDefaultsResponse_GetFlagsImpl();
};
// -------------------------------------------------------------------

class Response_GetVersion : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.master.Response.GetVersion) */ {
 public:
  Response_GetVersion();
  virtual ~Response_GetVersion();

  Response_GetVersion(const Response_GetVersion& from);

  inline Response_GetVersion& operator=(const Response_GetVersion& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Response_GetVersion(Response_GetVersion&& from) noexcept
    : Response_GetVersion() {
    *this = ::std::move(from);
  }

  inline Response_GetVersion& operator=(Response_GetVersion&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Response_GetVersion& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Response_GetVersion* internal_default_instance() {
    return reinterpret_cast<const Response_GetVersion*>(
               &_Response_GetVersion_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    21;

  void UnsafeArenaSwap(Response_GetVersion* other);
  void Swap(Response_GetVersion* other);
  friend void swap(Response_GetVersion& a, Response_GetVersion& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Response_GetVersion* New() const PROTOBUF_FINAL { return New(NULL); }

  Response_GetVersion* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Response_GetVersion& from);
  void MergeFrom(const Response_GetVersion& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Response_GetVersion* other);
  protected:
  explicit Response_GetVersion(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.VersionInfo version_info = 1;
  bool has_version_info() const;
  void clear_version_info();
  static const int kVersionInfoFieldNumber = 1;
  private:
  void _slow_mutable_version_info();
  public:
  const ::mesos::VersionInfo& version_info() const;
  ::mesos::VersionInfo* release_version_info();
  ::mesos::VersionInfo* mutable_version_info();
  void set_allocated_version_info(::mesos::VersionInfo* version_info);
  void unsafe_arena_set_allocated_version_info(
      ::mesos::VersionInfo* version_info);
  ::mesos::VersionInfo* unsafe_arena_release_version_info();

  // @@protoc_insertion_point(class_scope:mesos.master.Response.GetVersion)
 private:
  void set_has_version_info();
  void clear_has_version_info();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::VersionInfo* version_info_;
  friend struct ::protobuf_mesos_2fmaster_2fmaster_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmaster_2fmaster_2eproto::InitDefaultsResponse_GetVersionImpl();
};
// -------------------------------------------------------------------

class Response_GetMetrics : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.master.Response.GetMetrics) */ {
 public:
  Response_GetMetrics();
  virtual ~Response_GetMetrics();

  Response_GetMetrics(const Response_GetMetrics& from);

  inline Response_GetMetrics& operator=(const Response_GetMetrics& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Response_GetMetrics(Response_GetMetrics&& from) noexcept
    : Response_GetMetrics() {
    *this = ::std::move(from);
  }

  inline Response_GetMetrics& operator=(Response_GetMetrics&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Response_GetMetrics& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Response_GetMetrics* internal_default_instance() {
    return reinterpret_cast<const Response_GetMetrics*>(
               &_Response_GetMetrics_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    22;

  void UnsafeArenaSwap(Response_GetMetrics* other);
  void Swap(Response_GetMetrics* other);
  friend void swap(Response_GetMetrics& a, Response_GetMetrics& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Response_GetMetrics* New() const PROTOBUF_FINAL { return New(NULL); }

  Response_GetMetrics* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Response_GetMetrics& from);
  void MergeFrom(const Response_GetMetrics& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Response_GetMetrics* other);
  protected:
  explicit Response_GetMetrics(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.Metric metrics = 1;
  int metrics_size() const;
  void clear_metrics();
  static const int kMetricsFieldNumber = 1;
  const ::mesos::Metric& metrics(int index) const;
  ::mesos::Metric* mutable_metrics(int index);
  ::mesos::Metric* add_metrics();
  ::google::protobuf::RepeatedPtrField< ::mesos::Metric >*
      mutable_metrics();
  const ::google::protobuf::RepeatedPtrField< ::mesos::Metric >&
      metrics() const;

  // @@protoc_insertion_point(class_scope:mesos.master.Response.GetMetrics)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Metric > metrics_;
  friend struct ::protobuf_mesos_2fmaster_2fmaster_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmaster_2fmaster_2eproto::InitDefaultsResponse_GetMetricsImpl();
};
// -------------------------------------------------------------------

class Response_GetLoggingLevel : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.master.Response.GetLoggingLevel) */ {
 public:
  Response_GetLoggingLevel();
  virtual ~Response_GetLoggingLevel();

  Response_GetLoggingLevel(const Response_GetLoggingLevel& from);

  inline Response_GetLoggingLevel& operator=(const Response_GetLoggingLevel& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Response_GetLoggingLevel(Response_GetLoggingLevel&& from) noexcept
    : Response_GetLoggingLevel() {
    *this = ::std::move(from);
  }

  inline Response_GetLoggingLevel& operator=(Response_GetLoggingLevel&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Response_GetLoggingLevel& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Response_GetLoggingLevel* internal_default_instance() {
    return reinterpret_cast<const Response_GetLoggingLevel*>(
               &_Response_GetLoggingLevel_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    23;

  void UnsafeArenaSwap(Response_GetLoggingLevel* other);
  void Swap(Response_GetLoggingLevel* other);
  friend void swap(Response_GetLoggingLevel& a, Response_GetLoggingLevel& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Response_GetLoggingLevel* New() const PROTOBUF_FINAL { return New(NULL); }

  Response_GetLoggingLevel* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Response_GetLoggingLevel& from);
  void MergeFrom(const Response_GetLoggingLevel& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Response_GetLoggingLevel* other);
  protected:
  explicit Response_GetLoggingLevel(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 level = 1;
  bool has_level() const;
  void clear_level();
  static const int kLevelFieldNumber = 1;
  ::google::protobuf::uint32 level() const;
  void set_level(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mesos.master.Response.GetLoggingLevel)
 private:
  void set_has_level();
  void clear_has_level();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 level_;
  friend struct ::protobuf_mesos_2fmaster_2fmaster_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmaster_2fmaster_2eproto::InitDefaultsResponse_GetLoggingLevelImpl();
};
// -------------------------------------------------------------------

class Response_ListFiles : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.master.Response.ListFiles) */ {
 public:
  Response_ListFiles();
  virtual ~Response_ListFiles();

  Response_ListFiles(const Response_ListFiles& from);

  inline Response_ListFiles& operator=(const Response_ListFiles& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Response_ListFiles(Response_ListFiles&& from) noexcept
    : Response_ListFiles() {
    *this = ::std::move(from);
  }

  inline Response_ListFiles& operator=(Response_ListFiles&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Response_ListFiles& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Response_ListFiles* internal_default_instance() {
    return reinterpret_cast<const Response_ListFiles*>(
               &_Response_ListFiles_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    24;

  void UnsafeArenaSwap(Response_ListFiles* other);
  void Swap(Response_ListFiles* other);
  friend void swap(Response_ListFiles& a, Response_ListFiles& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Response_ListFiles* New() const PROTOBUF_FINAL { return New(NULL); }

  Response_ListFiles* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Response_ListFiles& from);
  void MergeFrom(const Response_ListFiles& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Response_ListFiles* other);
  protected:
  explicit Response_ListFiles(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.FileInfo file_infos = 1;
  int file_infos_size() const;
  void clear_file_infos();
  static const int kFileInfosFieldNumber = 1;
  const ::mesos::FileInfo& file_infos(int index) const;
  ::mesos::FileInfo* mutable_file_infos(int index);
  ::mesos::FileInfo* add_file_infos();
  ::google::protobuf::RepeatedPtrField< ::mesos::FileInfo >*
      mutable_file_infos();
  const ::google::protobuf::RepeatedPtrField< ::mesos::FileInfo >&
      file_infos() const;

  // @@protoc_insertion_point(class_scope:mesos.master.Response.ListFiles)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::FileInfo > file_infos_;
  friend struct ::protobuf_mesos_2fmaster_2fmaster_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmaster_2fmaster_2eproto::InitDefaultsResponse_ListFilesImpl();
};
// -------------------------------------------------------------------

class Response_ReadFile : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.master.Response.ReadFile) */ {
 public:
  Response_ReadFile();
  virtual ~Response_ReadFile();

  Response_ReadFile(const Response_ReadFile& from);

  inline Response_ReadFile& operator=(const Response_ReadFile& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Response_ReadFile(Response_ReadFile&& from) noexcept
    : Response_ReadFile() {
    *this = ::std::move(from);
  }

  inline Response_ReadFile& operator=(Response_ReadFile&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Response_ReadFile& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Response_ReadFile* internal_default_instance() {
    return reinterpret_cast<const Response_ReadFile*>(
               &_Response_ReadFile_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    25;

  void UnsafeArenaSwap(Response_ReadFile* other);
  void Swap(Response_ReadFile* other);
  friend void swap(Response_ReadFile& a, Response_ReadFile& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Response_ReadFile* New() const PROTOBUF_FINAL { return New(NULL); }

  Response_ReadFile* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Response_ReadFile& from);
  void MergeFrom(const Response_ReadFile& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Response_ReadFile* other);
  protected:
  explicit Response_ReadFile(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes data = 2;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 2;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_data();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_data(
      ::std::string* data);

  // required uint64 size = 1;
  bool has_size() const;
  void clear_size();
  static const int kSizeFieldNumber = 1;
  ::google::protobuf::uint64 size() const;
  void set_size(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:mesos.master.Response.ReadFile)
 private:
  void set_has_size();
  void clear_has_size();
  void set_has_data();
  void clear_has_data();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  ::google::protobuf::uint64 size_;
  friend struct ::protobuf_mesos_2fmaster_2fmaster_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmaster_2fmaster_2eproto::InitDefaultsResponse_ReadFileImpl();
};
// -------------------------------------------------------------------

class Response_GetState : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.master.Response.GetState) */ {
 public:
  Response_GetState();
  virtual ~Response_GetState();

  Response_GetState(const Response_GetState& from);

  inline Response_GetState& operator=(const Response_GetState& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Response_GetState(Response_GetState&& from) noexcept
    : Response_GetState() {
    *this = ::std::move(from);
  }

  inline Response_GetState& operator=(Response_GetState&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Response_GetState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Response_GetState* internal_default_instance() {
    return reinterpret_cast<const Response_GetState*>(
               &_Response_GetState_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    26;

  void UnsafeArenaSwap(Response_GetState* other);
  void Swap(Response_GetState* other);
  friend void swap(Response_GetState& a, Response_GetState& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Response_GetState* New() const PROTOBUF_FINAL { return New(NULL); }

  Response_GetState* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Response_GetState& from);
  void MergeFrom(const Response_GetState& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Response_GetState* other);
  protected:
  explicit Response_GetState(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mesos.master.Response.GetTasks get_tasks = 1;
  bool has_get_tasks() const;
  void clear_get_tasks();
  static const int kGetTasksFieldNumber = 1;
  private:
  void _slow_mutable_get_tasks();
  public:
  const ::mesos::master::Response_GetTasks& get_tasks() const;
  ::mesos::master::Response_GetTasks* release_get_tasks();
  ::mesos::master::Response_GetTasks* mutable_get_tasks();
  void set_allocated_get_tasks(::mesos::master::Response_GetTasks* get_tasks);
  void unsafe_arena_set_allocated_get_tasks(
      ::mesos::master::Response_GetTasks* get_tasks);
  ::mesos::master::Response_GetTasks* unsafe_arena_release_get_tasks();

  // optional .mesos.master.Response.GetExecutors get_executors = 2;
  bool has_get_executors() const;
  void clear_get_executors();
  static const int kGetExecutorsFieldNumber = 2;
  private:
  void _slow_mutable_get_executors();
  public:
  const ::mesos::master::Response_GetExecutors& get_executors() const;
  ::mesos::master::Response_GetExecutors* release_get_executors();
  ::mesos::master::Response_GetExecutors* mutable_get_executors();
  void set_allocated_get_executors(::mesos::master::Response_GetExecutors* get_executors);
  void unsafe_arena_set_allocated_get_executors(
      ::mesos::master::Response_GetExecutors* get_executors);
  ::mesos::master::Response_GetExecutors* unsafe_arena_release_get_executors();

  // optional .mesos.master.Response.GetFrameworks get_frameworks = 3;
  bool has_get_frameworks() const;
  void clear_get_frameworks();
  static const int kGetFrameworksFieldNumber = 3;
  private:
  void _slow_mutable_get_frameworks();
  public:
  const ::mesos::master::Response_GetFrameworks& get_frameworks() const;
  ::mesos::master::Response_GetFrameworks* release_get_frameworks();
  ::mesos::master::Response_GetFrameworks* mutable_get_frameworks();
  void set_allocated_get_frameworks(::mesos::master::Response_GetFrameworks* get_frameworks);
  void unsafe_arena_set_allocated_get_frameworks(
      ::mesos::master::Response_GetFrameworks* get_frameworks);
  ::mesos::master::Response_GetFrameworks* unsafe_arena_release_get_frameworks();

  // optional .mesos.master.Response.GetAgents get_agents = 4;
  bool has_get_agents() const;
  void clear_get_agents();
  static const int kGetAgentsFieldNumber = 4;
  private:
  void _slow_mutable_get_agents();
  public:
  const ::mesos::master::Response_GetAgents& get_agents() const;
  ::mesos::master::Response_GetAgents* release_get_agents();
  ::mesos::master::Response_GetAgents* mutable_get_agents();
  void set_allocated_get_agents(::mesos::master::Response_GetAgents* get_agents);
  void unsafe_arena_set_allocated_get_agents(
      ::mesos::master::Response_GetAgents* get_agents);
  ::mesos::master::Response_GetAgents* unsafe_arena_release_get_agents();

  // @@protoc_insertion_point(class_scope:mesos.master.Response.GetState)
 private:
  void set_has_get_tasks();
  void clear_has_get_tasks();
  void set_has_get_executors();
  void clear_has_get_executors();
  void set_has_get_frameworks();
  void clear_has_get_frameworks();
  void set_has_get_agents();
  void clear_has_get_agents();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::master::Response_GetTasks* get_tasks_;
  ::mesos::master::Response_GetExecutors* get_executors_;
  ::mesos::master::Response_GetFrameworks* get_frameworks_;
  ::mesos::master::Response_GetAgents* get_agents_;
  friend struct ::protobuf_mesos_2fmaster_2fmaster_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmaster_2fmaster_2eproto::InitDefaultsResponse_GetStateImpl();
};
// -------------------------------------------------------------------

class Response_GetAgents_Agent_ResourceProvider : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.master.Response.GetAgents.Agent.ResourceProvider) */ {
 public:
  Response_GetAgents_Agent_ResourceProvider();
  virtual ~Response_GetAgents_Agent_ResourceProvider();

  Response_GetAgents_Agent_ResourceProvider(const Response_GetAgents_Agent_ResourceProvider& from);

  inline Response_GetAgents_Agent_ResourceProvider& operator=(const Response_GetAgents_Agent_ResourceProvider& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Response_GetAgents_Agent_ResourceProvider(Response_GetAgents_Agent_ResourceProvider&& from) noexcept
    : Response_GetAgents_Agent_ResourceProvider() {
    *this = ::std::move(from);
  }

  inline Response_GetAgents_Agent_ResourceProvider& operator=(Response_GetAgents_Agent_ResourceProvider&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Response_GetAgents_Agent_ResourceProvider& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Response_GetAgents_Agent_ResourceProvider* internal_default_instance() {
    return reinterpret_cast<const Response_GetAgents_Agent_ResourceProvider*>(
               &_Response_GetAgents_Agent_ResourceProvider_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    27;

  void UnsafeArenaSwap(Response_GetAgents_Agent_ResourceProvider* other);
  void Swap(Response_GetAgents_Agent_ResourceProvider* other);
  friend void swap(Response_GetAgents_Agent_ResourceProvider& a, Response_GetAgents_Agent_ResourceProvider& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Response_GetAgents_Agent_ResourceProvider* New() const PROTOBUF_FINAL { return New(NULL); }

  Response_GetAgents_Agent_ResourceProvider* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Response_GetAgents_Agent_ResourceProvider& from);
  void MergeFrom(const Response_GetAgents_Agent_ResourceProvider& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Response_GetAgents_Agent_ResourceProvider* other);
  protected:
  explicit Response_GetAgents_Agent_ResourceProvider(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.Resource total_resources = 2;
  int total_resources_size() const;
  void clear_total_resources();
  static const int kTotalResourcesFieldNumber = 2;
  const ::mesos::Resource& total_resources(int index) const;
  ::mesos::Resource* mutable_total_resources(int index);
  ::mesos::Resource* add_total_resources();
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
      mutable_total_resources();
  const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
      total_resources() const;

  // required .mesos.ResourceProviderInfo resource_provider_info = 1;
  bool has_resource_provider_info() const;
  void clear_resource_provider_info();
  static const int kResourceProviderInfoFieldNumber = 1;
  private:
  void _slow_mutable_resource_provider_info();
  public:
  const ::mesos::ResourceProviderInfo& resource_provider_info() const;
  ::mesos::ResourceProviderInfo* release_resource_provider_info();
  ::mesos::ResourceProviderInfo* mutable_resource_provider_info();
  void set_allocated_resource_provider_info(::mesos::ResourceProviderInfo* resource_provider_info);
  void unsafe_arena_set_allocated_resource_provider_info(
      ::mesos::ResourceProviderInfo* resource_provider_info);
  ::mesos::ResourceProviderInfo* unsafe_arena_release_resource_provider_info();

  // @@protoc_insertion_point(class_scope:mesos.master.Response.GetAgents.Agent.ResourceProvider)
 private:
  void set_has_resource_provider_info();
  void clear_has_resource_provider_info();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource > total_resources_;
  ::mesos::ResourceProviderInfo* resource_provider_info_;
  friend struct ::protobuf_mesos_2fmaster_2fmaster_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmaster_2fmaster_2eproto::InitDefaultsResponse_GetAgents_Agent_ResourceProviderImpl();
};
// -------------------------------------------------------------------

class Response_GetAgents_Agent : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.master.Response.GetAgents.Agent) */ {
 public:
  Response_GetAgents_Agent();
  virtual ~Response_GetAgents_Agent();

  Response_GetAgents_Agent(const Response_GetAgents_Agent& from);

  inline Response_GetAgents_Agent& operator=(const Response_GetAgents_Agent& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Response_GetAgents_Agent(Response_GetAgents_Agent&& from) noexcept
    : Response_GetAgents_Agent() {
    *this = ::std::move(from);
  }

  inline Response_GetAgents_Agent& operator=(Response_GetAgents_Agent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Response_GetAgents_Agent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Response_GetAgents_Agent* internal_default_instance() {
    return reinterpret_cast<const Response_GetAgents_Agent*>(
               &_Response_GetAgents_Agent_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    28;

  void UnsafeArenaSwap(Response_GetAgents_Agent* other);
  void Swap(Response_GetAgents_Agent* other);
  friend void swap(Response_GetAgents_Agent& a, Response_GetAgents_Agent& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Response_GetAgents_Agent* New() const PROTOBUF_FINAL { return New(NULL); }

  Response_GetAgents_Agent* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Response_GetAgents_Agent& from);
  void MergeFrom(const Response_GetAgents_Agent& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Response_GetAgents_Agent* other);
  protected:
  explicit Response_GetAgents_Agent(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Response_GetAgents_Agent_ResourceProvider ResourceProvider;

  // accessors -------------------------------------------------------

  // repeated .mesos.Resource total_resources = 7;
  int total_resources_size() const;
  void clear_total_resources();
  static const int kTotalResourcesFieldNumber = 7;
  const ::mesos::Resource& total_resources(int index) const;
  ::mesos::Resource* mutable_total_resources(int index);
  ::mesos::Resource* add_total_resources();
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
      mutable_total_resources();
  const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
      total_resources() const;

  // repeated .mesos.Resource allocated_resources = 8;
  int allocated_resources_size() const;
  void clear_allocated_resources();
  static const int kAllocatedResourcesFieldNumber = 8;
  const ::mesos::Resource& allocated_resources(int index) const;
  ::mesos::Resource* mutable_allocated_resources(int index);
  ::mesos::Resource* add_allocated_resources();
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
      mutable_allocated_resources();
  const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
      allocated_resources() const;

  // repeated .mesos.Resource offered_resources = 9;
  int offered_resources_size() const;
  void clear_offered_resources();
  static const int kOfferedResourcesFieldNumber = 9;
  const ::mesos::Resource& offered_resources(int index) const;
  ::mesos::Resource* mutable_offered_resources(int index);
  ::mesos::Resource* add_offered_resources();
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
      mutable_offered_resources();
  const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
      offered_resources() const;

  // repeated .mesos.SlaveInfo.Capability capabilities = 10;
  int capabilities_size() const;
  void clear_capabilities();
  static const int kCapabilitiesFieldNumber = 10;
  const ::mesos::SlaveInfo_Capability& capabilities(int index) const;
  ::mesos::SlaveInfo_Capability* mutable_capabilities(int index);
  ::mesos::SlaveInfo_Capability* add_capabilities();
  ::google::protobuf::RepeatedPtrField< ::mesos::SlaveInfo_Capability >*
      mutable_capabilities();
  const ::google::protobuf::RepeatedPtrField< ::mesos::SlaveInfo_Capability >&
      capabilities() const;

  // repeated .mesos.master.Response.GetAgents.Agent.ResourceProvider resource_providers = 11;
  int resource_providers_size() const;
  void clear_resource_providers();
  static const int kResourceProvidersFieldNumber = 11;
  const ::mesos::master::Response_GetAgents_Agent_ResourceProvider& resource_providers(int index) const;
  ::mesos::master::Response_GetAgents_Agent_ResourceProvider* mutable_resource_providers(int index);
  ::mesos::master::Response_GetAgents_Agent_ResourceProvider* add_resource_providers();
  ::google::protobuf::RepeatedPtrField< ::mesos::master::Response_GetAgents_Agent_ResourceProvider >*
      mutable_resource_providers();
  const ::google::protobuf::RepeatedPtrField< ::mesos::master::Response_GetAgents_Agent_ResourceProvider >&
      resource_providers() const;

  // required string version = 3;
  bool has_version() const;
  void clear_version();
  static const int kVersionFieldNumber = 3;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_version();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_version(
      ::std::string* version);

  // optional string pid = 4;
  bool has_pid() const;
  void clear_pid();
  static const int kPidFieldNumber = 4;
  const ::std::string& pid() const;
  void set_pid(const ::std::string& value);
  #if LANG_CXX11
  void set_pid(::std::string&& value);
  #endif
  void set_pid(const char* value);
  void set_pid(const char* value, size_t size);
  ::std::string* mutable_pid();
  ::std::string* release_pid();
  void set_allocated_pid(::std::string* pid);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_pid();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_pid(
      ::std::string* pid);

  // required .mesos.SlaveInfo agent_info = 1;
  bool has_agent_info() const;
  void clear_agent_info();
  static const int kAgentInfoFieldNumber = 1;
  private:
  void _slow_mutable_agent_info();
  public:
  const ::mesos::SlaveInfo& agent_info() const;
  ::mesos::SlaveInfo* release_agent_info();
  ::mesos::SlaveInfo* mutable_agent_info();
  void set_allocated_agent_info(::mesos::SlaveInfo* agent_info);
  void unsafe_arena_set_allocated_agent_info(
      ::mesos::SlaveInfo* agent_info);
  ::mesos::SlaveInfo* unsafe_arena_release_agent_info();

  // optional .mesos.TimeInfo registered_time = 5;
  bool has_registered_time() const;
  void clear_registered_time();
  static const int kRegisteredTimeFieldNumber = 5;
  private:
  void _slow_mutable_registered_time();
  public:
  const ::mesos::TimeInfo& registered_time() const;
  ::mesos::TimeInfo* release_registered_time();
  ::mesos::TimeInfo* mutable_registered_time();
  void set_allocated_registered_time(::mesos::TimeInfo* registered_time);
  void unsafe_arena_set_allocated_registered_time(
      ::mesos::TimeInfo* registered_time);
  ::mesos::TimeInfo* unsafe_arena_release_registered_time();

  // optional .mesos.TimeInfo reregistered_time = 6;
  bool has_reregistered_time() const;
  void clear_reregistered_time();
  static const int kReregisteredTimeFieldNumber = 6;
  private:
  void _slow_mutable_reregistered_time();
  public:
  const ::mesos::TimeInfo& reregistered_time() const;
  ::mesos::TimeInfo* release_reregistered_time();
  ::mesos::TimeInfo* mutable_reregistered_time();
  void set_allocated_reregistered_time(::mesos::TimeInfo* reregistered_time);
  void unsafe_arena_set_allocated_reregistered_time(
      ::mesos::TimeInfo* reregistered_time);
  ::mesos::TimeInfo* unsafe_arena_release_reregistered_time();

  // required bool active = 2;
  bool has_active() const;
  void clear_active();
  static const int kActiveFieldNumber = 2;
  bool active() const;
  void set_active(bool value);

  // @@protoc_insertion_point(class_scope:mesos.master.Response.GetAgents.Agent)
 private:
  void set_has_agent_info();
  void clear_has_agent_info();
  void set_has_active();
  void clear_has_active();
  void set_has_version();
  void clear_has_version();
  void set_has_pid();
  void clear_has_pid();
  void set_has_registered_time();
  void clear_has_registered_time();
  void set_has_reregistered_time();
  void clear_has_reregistered_time();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource > total_resources_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource > allocated_resources_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource > offered_resources_;
  ::google::protobuf::RepeatedPtrField< ::mesos::SlaveInfo_Capability > capabilities_;
  ::google::protobuf::RepeatedPtrField< ::mesos::master::Response_GetAgents_Agent_ResourceProvider > resource_providers_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  ::google::protobuf::internal::ArenaStringPtr pid_;
  ::mesos::SlaveInfo* agent_info_;
  ::mesos::TimeInfo* registered_time_;
  ::mesos::TimeInfo* reregistered_time_;
  bool active_;
  friend struct ::protobuf_mesos_2fmaster_2fmaster_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmaster_2fmaster_2eproto::InitDefaultsResponse_GetAgents_AgentImpl();
};
// -------------------------------------------------------------------

class Response_GetAgents : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.master.Response.GetAgents) */ {
 public:
  Response_GetAgents();
  virtual ~Response_GetAgents();

  Response_GetAgents(const Response_GetAgents& from);

  inline Response_GetAgents& operator=(const Response_GetAgents& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Response_GetAgents(Response_GetAgents&& from) noexcept
    : Response_GetAgents() {
    *this = ::std::move(from);
  }

  inline Response_GetAgents& operator=(Response_GetAgents&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Response_GetAgents& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Response_GetAgents* internal_default_instance() {
    return reinterpret_cast<const Response_GetAgents*>(
               &_Response_GetAgents_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    29;

  void UnsafeArenaSwap(Response_GetAgents* other);
  void Swap(Response_GetAgents* other);
  friend void swap(Response_GetAgents& a, Response_GetAgents& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Response_GetAgents* New() const PROTOBUF_FINAL { return New(NULL); }

  Response_GetAgents* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Response_GetAgents& from);
  void MergeFrom(const Response_GetAgents& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Response_GetAgents* other);
  protected:
  explicit Response_GetAgents(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Response_GetAgents_Agent Agent;

  // accessors -------------------------------------------------------

  // repeated .mesos.master.Response.GetAgents.Agent agents = 1;
  int agents_size() const;
  void clear_agents();
  static const int kAgentsFieldNumber = 1;
  const ::mesos::master::Response_GetAgents_Agent& agents(int index) const;
  ::mesos::master::Response_GetAgents_Agent* mutable_agents(int index);
  ::mesos::master::Response_GetAgents_Agent* add_agents();
  ::google::protobuf::RepeatedPtrField< ::mesos::master::Response_GetAgents_Agent >*
      mutable_agents();
  const ::google::protobuf::RepeatedPtrField< ::mesos::master::Response_GetAgents_Agent >&
      agents() const;

  // repeated .mesos.SlaveInfo recovered_agents = 2;
  int recovered_agents_size() const;
  void clear_recovered_agents();
  static const int kRecoveredAgentsFieldNumber = 2;
  const ::mesos::SlaveInfo& recovered_agents(int index) const;
  ::mesos::SlaveInfo* mutable_recovered_agents(int index);
  ::mesos::SlaveInfo* add_recovered_agents();
  ::google::protobuf::RepeatedPtrField< ::mesos::SlaveInfo >*
      mutable_recovered_agents();
  const ::google::protobuf::RepeatedPtrField< ::mesos::SlaveInfo >&
      recovered_agents() const;

  // @@protoc_insertion_point(class_scope:mesos.master.Response.GetAgents)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::master::Response_GetAgents_Agent > agents_;
  ::google::protobuf::RepeatedPtrField< ::mesos::SlaveInfo > recovered_agents_;
  friend struct ::protobuf_mesos_2fmaster_2fmaster_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmaster_2fmaster_2eproto::InitDefaultsResponse_GetAgentsImpl();
};
// -------------------------------------------------------------------

class Response_GetFrameworks_Framework : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.master.Response.GetFrameworks.Framework) */ {
 public:
  Response_GetFrameworks_Framework();
  virtual ~Response_GetFrameworks_Framework();

  Response_GetFrameworks_Framework(const Response_GetFrameworks_Framework& from);

  inline Response_GetFrameworks_Framework& operator=(const Response_GetFrameworks_Framework& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Response_GetFrameworks_Framework(Response_GetFrameworks_Framework&& from) noexcept
    : Response_GetFrameworks_Framework() {
    *this = ::std::move(from);
  }

  inline Response_GetFrameworks_Framework& operator=(Response_GetFrameworks_Framework&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Response_GetFrameworks_Framework& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Response_GetFrameworks_Framework* internal_default_instance() {
    return reinterpret_cast<const Response_GetFrameworks_Framework*>(
               &_Response_GetFrameworks_Framework_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    30;

  void UnsafeArenaSwap(Response_GetFrameworks_Framework* other);
  void Swap(Response_GetFrameworks_Framework* other);
  friend void swap(Response_GetFrameworks_Framework& a, Response_GetFrameworks_Framework& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Response_GetFrameworks_Framework* New() const PROTOBUF_FINAL { return New(NULL); }

  Response_GetFrameworks_Framework* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Response_GetFrameworks_Framework& from);
  void MergeFrom(const Response_GetFrameworks_Framework& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Response_GetFrameworks_Framework* other);
  protected:
  explicit Response_GetFrameworks_Framework(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.Offer offers = 7;
  int offers_size() const;
  void clear_offers();
  static const int kOffersFieldNumber = 7;
  const ::mesos::Offer& offers(int index) const;
  ::mesos::Offer* mutable_offers(int index);
  ::mesos::Offer* add_offers();
  ::google::protobuf::RepeatedPtrField< ::mesos::Offer >*
      mutable_offers();
  const ::google::protobuf::RepeatedPtrField< ::mesos::Offer >&
      offers() const;

  // repeated .mesos.InverseOffer inverse_offers = 8;
  int inverse_offers_size() const;
  void clear_inverse_offers();
  static const int kInverseOffersFieldNumber = 8;
  const ::mesos::InverseOffer& inverse_offers(int index) const;
  ::mesos::InverseOffer* mutable_inverse_offers(int index);
  ::mesos::InverseOffer* add_inverse_offers();
  ::google::protobuf::RepeatedPtrField< ::mesos::InverseOffer >*
      mutable_inverse_offers();
  const ::google::protobuf::RepeatedPtrField< ::mesos::InverseOffer >&
      inverse_offers() const;

  // repeated .mesos.Resource allocated_resources = 9;
  int allocated_resources_size() const;
  void clear_allocated_resources();
  static const int kAllocatedResourcesFieldNumber = 9;
  const ::mesos::Resource& allocated_resources(int index) const;
  ::mesos::Resource* mutable_allocated_resources(int index);
  ::mesos::Resource* add_allocated_resources();
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
      mutable_allocated_resources();
  const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
      allocated_resources() const;

  // repeated .mesos.Resource offered_resources = 10;
  int offered_resources_size() const;
  void clear_offered_resources();
  static const int kOfferedResourcesFieldNumber = 10;
  const ::mesos::Resource& offered_resources(int index) const;
  ::mesos::Resource* mutable_offered_resources(int index);
  ::mesos::Resource* add_offered_resources();
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
      mutable_offered_resources();
  const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
      offered_resources() const;

  // required .mesos.FrameworkInfo framework_info = 1;
  bool has_framework_info() const;
  void clear_framework_info();
  static const int kFrameworkInfoFieldNumber = 1;
  private:
  void _slow_mutable_framework_info();
  public:
  const ::mesos::FrameworkInfo& framework_info() const;
  ::mesos::FrameworkInfo* release_framework_info();
  ::mesos::FrameworkInfo* mutable_framework_info();
  void set_allocated_framework_info(::mesos::FrameworkInfo* framework_info);
  void unsafe_arena_set_allocated_framework_info(
      ::mesos::FrameworkInfo* framework_info);
  ::mesos::FrameworkInfo* unsafe_arena_release_framework_info();

  // optional .mesos.TimeInfo registered_time = 4;
  bool has_registered_time() const;
  void clear_registered_time();
  static const int kRegisteredTimeFieldNumber = 4;
  private:
  void _slow_mutable_registered_time();
  public:
  const ::mesos::TimeInfo& registered_time() const;
  ::mesos::TimeInfo* release_registered_time();
  ::mesos::TimeInfo* mutable_registered_time();
  void set_allocated_registered_time(::mesos::TimeInfo* registered_time);
  void unsafe_arena_set_allocated_registered_time(
      ::mesos::TimeInfo* registered_time);
  ::mesos::TimeInfo* unsafe_arena_release_registered_time();

  // optional .mesos.TimeInfo reregistered_time = 5;
  bool has_reregistered_time() const;
  void clear_reregistered_time();
  static const int kReregisteredTimeFieldNumber = 5;
  private:
  void _slow_mutable_reregistered_time();
  public:
  const ::mesos::TimeInfo& reregistered_time() const;
  ::mesos::TimeInfo* release_reregistered_time();
  ::mesos::TimeInfo* mutable_reregistered_time();
  void set_allocated_reregistered_time(::mesos::TimeInfo* reregistered_time);
  void unsafe_arena_set_allocated_reregistered_time(
      ::mesos::TimeInfo* reregistered_time);
  ::mesos::TimeInfo* unsafe_arena_release_reregistered_time();

  // optional .mesos.TimeInfo unregistered_time = 6;
  bool has_unregistered_time() const;
  void clear_unregistered_time();
  static const int kUnregisteredTimeFieldNumber = 6;
  private:
  void _slow_mutable_unregistered_time();
  public:
  const ::mesos::TimeInfo& unregistered_time() const;
  ::mesos::TimeInfo* release_unregistered_time();
  ::mesos::TimeInfo* mutable_unregistered_time();
  void set_allocated_unregistered_time(::mesos::TimeInfo* unregistered_time);
  void unsafe_arena_set_allocated_unregistered_time(
      ::mesos::TimeInfo* unregistered_time);
  ::mesos::TimeInfo* unsafe_arena_release_unregistered_time();

  // required bool active = 2;
  bool has_active() const;
  void clear_active();
  static const int kActiveFieldNumber = 2;
  bool active() const;
  void set_active(bool value);

  // required bool connected = 3;
  bool has_connected() const;
  void clear_connected();
  static const int kConnectedFieldNumber = 3;
  bool connected() const;
  void set_connected(bool value);

  // required bool recovered = 11;
  bool has_recovered() const;
  void clear_recovered();
  static const int kRecoveredFieldNumber = 11;
  bool recovered() const;
  void set_recovered(bool value);

  // @@protoc_insertion_point(class_scope:mesos.master.Response.GetFrameworks.Framework)
 private:
  void set_has_framework_info();
  void clear_has_framework_info();
  void set_has_active();
  void clear_has_active();
  void set_has_connected();
  void clear_has_connected();
  void set_has_recovered();
  void clear_has_recovered();
  void set_has_registered_time();
  void clear_has_registered_time();
  void set_has_reregistered_time();
  void clear_has_reregistered_time();
  void set_has_unregistered_time();
  void clear_has_unregistered_time();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Offer > offers_;
  ::google::protobuf::RepeatedPtrField< ::mesos::InverseOffer > inverse_offers_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource > allocated_resources_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource > offered_resources_;
  ::mesos::FrameworkInfo* framework_info_;
  ::mesos::TimeInfo* registered_time_;
  ::mesos::TimeInfo* reregistered_time_;
  ::mesos::TimeInfo* unregistered_time_;
  bool active_;
  bool connected_;
  bool recovered_;
  friend struct ::protobuf_mesos_2fmaster_2fmaster_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmaster_2fmaster_2eproto::InitDefaultsResponse_GetFrameworks_FrameworkImpl();
};
// -------------------------------------------------------------------

class Response_GetFrameworks : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.master.Response.GetFrameworks) */ {
 public:
  Response_GetFrameworks();
  virtual ~Response_GetFrameworks();

  Response_GetFrameworks(const Response_GetFrameworks& from);

  inline Response_GetFrameworks& operator=(const Response_GetFrameworks& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Response_GetFrameworks(Response_GetFrameworks&& from) noexcept
    : Response_GetFrameworks() {
    *this = ::std::move(from);
  }

  inline Response_GetFrameworks& operator=(Response_GetFrameworks&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Response_GetFrameworks& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Response_GetFrameworks* internal_default_instance() {
    return reinterpret_cast<const Response_GetFrameworks*>(
               &_Response_GetFrameworks_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    31;

  void UnsafeArenaSwap(Response_GetFrameworks* other);
  void Swap(Response_GetFrameworks* other);
  friend void swap(Response_GetFrameworks& a, Response_GetFrameworks& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Response_GetFrameworks* New() const PROTOBUF_FINAL { return New(NULL); }

  Response_GetFrameworks* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Response_GetFrameworks& from);
  void MergeFrom(const Response_GetFrameworks& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Response_GetFrameworks* other);
  protected:
  explicit Response_GetFrameworks(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Response_GetFrameworks_Framework Framework;

  // accessors -------------------------------------------------------

  // repeated .mesos.master.Response.GetFrameworks.Framework frameworks = 1;
  int frameworks_size() const;
  void clear_frameworks();
  static const int kFrameworksFieldNumber = 1;
  const ::mesos::master::Response_GetFrameworks_Framework& frameworks(int index) const;
  ::mesos::master::Response_GetFrameworks_Framework* mutable_frameworks(int index);
  ::mesos::master::Response_GetFrameworks_Framework* add_frameworks();
  ::google::protobuf::RepeatedPtrField< ::mesos::master::Response_GetFrameworks_Framework >*
      mutable_frameworks();
  const ::google::protobuf::RepeatedPtrField< ::mesos::master::Response_GetFrameworks_Framework >&
      frameworks() const;

  // repeated .mesos.master.Response.GetFrameworks.Framework completed_frameworks = 2;
  int completed_frameworks_size() const;
  void clear_completed_frameworks();
  static const int kCompletedFrameworksFieldNumber = 2;
  const ::mesos::master::Response_GetFrameworks_Framework& completed_frameworks(int index) const;
  ::mesos::master::Response_GetFrameworks_Framework* mutable_completed_frameworks(int index);
  ::mesos::master::Response_GetFrameworks_Framework* add_completed_frameworks();
  ::google::protobuf::RepeatedPtrField< ::mesos::master::Response_GetFrameworks_Framework >*
      mutable_completed_frameworks();
  const ::google::protobuf::RepeatedPtrField< ::mesos::master::Response_GetFrameworks_Framework >&
      completed_frameworks() const;

  // repeated .mesos.FrameworkInfo recovered_frameworks = 3 [deprecated = true];
  GOOGLE_PROTOBUF_DEPRECATED_ATTR int recovered_frameworks_size() const;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void clear_recovered_frameworks();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR static const int kRecoveredFrameworksFieldNumber = 3;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR const ::mesos::FrameworkInfo& recovered_frameworks(int index) const;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR ::mesos::FrameworkInfo* mutable_recovered_frameworks(int index);
  GOOGLE_PROTOBUF_DEPRECATED_ATTR ::mesos::FrameworkInfo* add_recovered_frameworks();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR ::google::protobuf::RepeatedPtrField< ::mesos::FrameworkInfo >*
      mutable_recovered_frameworks();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR const ::google::protobuf::RepeatedPtrField< ::mesos::FrameworkInfo >&
      recovered_frameworks() const;

  // @@protoc_insertion_point(class_scope:mesos.master.Response.GetFrameworks)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::master::Response_GetFrameworks_Framework > frameworks_;
  ::google::protobuf::RepeatedPtrField< ::mesos::master::Response_GetFrameworks_Framework > completed_frameworks_;
  ::google::protobuf::RepeatedPtrField< ::mesos::FrameworkInfo > recovered_frameworks_;
  friend struct ::protobuf_mesos_2fmaster_2fmaster_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmaster_2fmaster_2eproto::InitDefaultsResponse_GetFrameworksImpl();
};
// -------------------------------------------------------------------

class Response_GetExecutors_Executor : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.master.Response.GetExecutors.Executor) */ {
 public:
  Response_GetExecutors_Executor();
  virtual ~Response_GetExecutors_Executor();

  Response_GetExecutors_Executor(const Response_GetExecutors_Executor& from);

  inline Response_GetExecutors_Executor& operator=(const Response_GetExecutors_Executor& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Response_GetExecutors_Executor(Response_GetExecutors_Executor&& from) noexcept
    : Response_GetExecutors_Executor() {
    *this = ::std::move(from);
  }

  inline Response_GetExecutors_Executor& operator=(Response_GetExecutors_Executor&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Response_GetExecutors_Executor& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Response_GetExecutors_Executor* internal_default_instance() {
    return reinterpret_cast<const Response_GetExecutors_Executor*>(
               &_Response_GetExecutors_Executor_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    32;

  void UnsafeArenaSwap(Response_GetExecutors_Executor* other);
  void Swap(Response_GetExecutors_Executor* other);
  friend void swap(Response_GetExecutors_Executor& a, Response_GetExecutors_Executor& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Response_GetExecutors_Executor* New() const PROTOBUF_FINAL { return New(NULL); }

  Response_GetExecutors_Executor* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Response_GetExecutors_Executor& from);
  void MergeFrom(const Response_GetExecutors_Executor& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Response_GetExecutors_Executor* other);
  protected:
  explicit Response_GetExecutors_Executor(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.ExecutorInfo executor_info = 1;
  bool has_executor_info() const;
  void clear_executor_info();
  static const int kExecutorInfoFieldNumber = 1;
  private:
  void _slow_mutable_executor_info();
  public:
  const ::mesos::ExecutorInfo& executor_info() const;
  ::mesos::ExecutorInfo* release_executor_info();
  ::mesos::ExecutorInfo* mutable_executor_info();
  void set_allocated_executor_info(::mesos::ExecutorInfo* executor_info);
  void unsafe_arena_set_allocated_executor_info(
      ::mesos::ExecutorInfo* executor_info);
  ::mesos::ExecutorInfo* unsafe_arena_release_executor_info();

  // required .mesos.SlaveID slave_id = 2;
  bool has_slave_id() const;
  void clear_slave_id();
  static const int kSlaveIdFieldNumber = 2;
  private:
  void _slow_mutable_slave_id();
  public:
  const ::mesos::SlaveID& slave_id() const;
  ::mesos::SlaveID* release_slave_id();
  ::mesos::SlaveID* mutable_slave_id();
  void set_allocated_slave_id(::mesos::SlaveID* slave_id);
  void unsafe_arena_set_allocated_slave_id(
      ::mesos::SlaveID* slave_id);
  ::mesos::SlaveID* unsafe_arena_release_slave_id();

  // @@protoc_insertion_point(class_scope:mesos.master.Response.GetExecutors.Executor)
 private:
  void set_has_executor_info();
  void clear_has_executor_info();
  void set_has_slave_id();
  void clear_has_slave_id();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::ExecutorInfo* executor_info_;
  ::mesos::SlaveID* slave_id_;
  friend struct ::protobuf_mesos_2fmaster_2fmaster_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmaster_2fmaster_2eproto::InitDefaultsResponse_GetExecutors_ExecutorImpl();
};
// -------------------------------------------------------------------

class Response_GetExecutors : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.master.Response.GetExecutors) */ {
 public:
  Response_GetExecutors();
  virtual ~Response_GetExecutors();

  Response_GetExecutors(const Response_GetExecutors& from);

  inline Response_GetExecutors& operator=(const Response_GetExecutors& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Response_GetExecutors(Response_GetExecutors&& from) noexcept
    : Response_GetExecutors() {
    *this = ::std::move(from);
  }

  inline Response_GetExecutors& operator=(Response_GetExecutors&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Response_GetExecutors& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Response_GetExecutors* internal_default_instance() {
    return reinterpret_cast<const Response_GetExecutors*>(
               &_Response_GetExecutors_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    33;

  void UnsafeArenaSwap(Response_GetExecutors* other);
  void Swap(Response_GetExecutors* other);
  friend void swap(Response_GetExecutors& a, Response_GetExecutors& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Response_GetExecutors* New() const PROTOBUF_FINAL { return New(NULL); }

  Response_GetExecutors* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Response_GetExecutors& from);
  void MergeFrom(const Response_GetExecutors& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Response_GetExecutors* other);
  protected:
  explicit Response_GetExecutors(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Response_GetExecutors_Executor Executor;

  // accessors -------------------------------------------------------

  // repeated .mesos.master.Response.GetExecutors.Executor executors = 1;
  int executors_size() const;
  void clear_executors();
  static const int kExecutorsFieldNumber = 1;
  const ::mesos::master::Response_GetExecutors_Executor& executors(int index) const;
  ::mesos::master::Response_GetExecutors_Executor* mutable_executors(int index);
  ::mesos::master::Response_GetExecutors_Executor* add_executors();
  ::google::protobuf::RepeatedPtrField< ::mesos::master::Response_GetExecutors_Executor >*
      mutable_executors();
  const ::google::protobuf::RepeatedPtrField< ::mesos::master::Response_GetExecutors_Executor >&
      executors() const;

  // repeated .mesos.master.Response.GetExecutors.Executor orphan_executors = 2 [deprecated = true];
  GOOGLE_PROTOBUF_DEPRECATED_ATTR int orphan_executors_size() const;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void clear_orphan_executors();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR static const int kOrphanExecutorsFieldNumber = 2;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR const ::mesos::master::Response_GetExecutors_Executor& orphan_executors(int index) const;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR ::mesos::master::Response_GetExecutors_Executor* mutable_orphan_executors(int index);
  GOOGLE_PROTOBUF_DEPRECATED_ATTR ::mesos::master::Response_GetExecutors_Executor* add_orphan_executors();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR ::google::protobuf::RepeatedPtrField< ::mesos::master::Response_GetExecutors_Executor >*
      mutable_orphan_executors();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR const ::google::protobuf::RepeatedPtrField< ::mesos::master::Response_GetExecutors_Executor >&
      orphan_executors() const;

  // @@protoc_insertion_point(class_scope:mesos.master.Response.GetExecutors)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::master::Response_GetExecutors_Executor > executors_;
  ::google::protobuf::RepeatedPtrField< ::mesos::master::Response_GetExecutors_Executor > orphan_executors_;
  friend struct ::protobuf_mesos_2fmaster_2fmaster_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmaster_2fmaster_2eproto::InitDefaultsResponse_GetExecutorsImpl();
};
// -------------------------------------------------------------------

class Response_GetOperations : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.master.Response.GetOperations) */ {
 public:
  Response_GetOperations();
  virtual ~Response_GetOperations();

  Response_GetOperations(const Response_GetOperations& from);

  inline Response_GetOperations& operator=(const Response_GetOperations& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Response_GetOperations(Response_GetOperations&& from) noexcept
    : Response_GetOperations() {
    *this = ::std::move(from);
  }

  inline Response_GetOperations& operator=(Response_GetOperations&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Response_GetOperations& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Response_GetOperations* internal_default_instance() {
    return reinterpret_cast<const Response_GetOperations*>(
               &_Response_GetOperations_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    34;

  void UnsafeArenaSwap(Response_GetOperations* other);
  void Swap(Response_GetOperations* other);
  friend void swap(Response_GetOperations& a, Response_GetOperations& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Response_GetOperations* New() const PROTOBUF_FINAL { return New(NULL); }

  Response_GetOperations* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Response_GetOperations& from);
  void MergeFrom(const Response_GetOperations& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Response_GetOperations* other);
  protected:
  explicit Response_GetOperations(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.Operation operations = 1;
  int operations_size() const;
  void clear_operations();
  static const int kOperationsFieldNumber = 1;
  const ::mesos::Operation& operations(int index) const;
  ::mesos::Operation* mutable_operations(int index);
  ::mesos::Operation* add_operations();
  ::google::protobuf::RepeatedPtrField< ::mesos::Operation >*
      mutable_operations();
  const ::google::protobuf::RepeatedPtrField< ::mesos::Operation >&
      operations() const;

  // @@protoc_insertion_point(class_scope:mesos.master.Response.GetOperations)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Operation > operations_;
  friend struct ::protobuf_mesos_2fmaster_2fmaster_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmaster_2fmaster_2eproto::InitDefaultsResponse_GetOperationsImpl();
};
// -------------------------------------------------------------------

class Response_GetTasks : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.master.Response.GetTasks) */ {
 public:
  Response_GetTasks();
  virtual ~Response_GetTasks();

  Response_GetTasks(const Response_GetTasks& from);

  inline Response_GetTasks& operator=(const Response_GetTasks& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Response_GetTasks(Response_GetTasks&& from) noexcept
    : Response_GetTasks() {
    *this = ::std::move(from);
  }

  inline Response_GetTasks& operator=(Response_GetTasks&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Response_GetTasks& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Response_GetTasks* internal_default_instance() {
    return reinterpret_cast<const Response_GetTasks*>(
               &_Response_GetTasks_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    35;

  void UnsafeArenaSwap(Response_GetTasks* other);
  void Swap(Response_GetTasks* other);
  friend void swap(Response_GetTasks& a, Response_GetTasks& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Response_GetTasks* New() const PROTOBUF_FINAL { return New(NULL); }

  Response_GetTasks* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Response_GetTasks& from);
  void MergeFrom(const Response_GetTasks& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Response_GetTasks* other);
  protected:
  explicit Response_GetTasks(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.Task pending_tasks = 1;
  int pending_tasks_size() const;
  void clear_pending_tasks();
  static const int kPendingTasksFieldNumber = 1;
  const ::mesos::Task& pending_tasks(int index) const;
  ::mesos::Task* mutable_pending_tasks(int index);
  ::mesos::Task* add_pending_tasks();
  ::google::protobuf::RepeatedPtrField< ::mesos::Task >*
      mutable_pending_tasks();
  const ::google::protobuf::RepeatedPtrField< ::mesos::Task >&
      pending_tasks() const;

  // repeated .mesos.Task tasks = 2;
  int tasks_size() const;
  void clear_tasks();
  static const int kTasksFieldNumber = 2;
  const ::mesos::Task& tasks(int index) const;
  ::mesos::Task* mutable_tasks(int index);
  ::mesos::Task* add_tasks();
  ::google::protobuf::RepeatedPtrField< ::mesos::Task >*
      mutable_tasks();
  const ::google::protobuf::RepeatedPtrField< ::mesos::Task >&
      tasks() const;

  // repeated .mesos.Task completed_tasks = 3;
  int completed_tasks_size() const;
  void clear_completed_tasks();
  static const int kCompletedTasksFieldNumber = 3;
  const ::mesos::Task& completed_tasks(int index) const;
  ::mesos::Task* mutable_completed_tasks(int index);
  ::mesos::Task* add_completed_tasks();
  ::google::protobuf::RepeatedPtrField< ::mesos::Task >*
      mutable_completed_tasks();
  const ::google::protobuf::RepeatedPtrField< ::mesos::Task >&
      completed_tasks() const;

  // repeated .mesos.Task orphan_tasks = 4 [deprecated = true];
  GOOGLE_PROTOBUF_DEPRECATED_ATTR int orphan_tasks_size() const;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void clear_orphan_tasks();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR static const int kOrphanTasksFieldNumber = 4;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR const ::mesos::Task& orphan_tasks(int index) const;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR ::mesos::Task* mutable_orphan_tasks(int index);
  GOOGLE_PROTOBUF_DEPRECATED_ATTR ::mesos::Task* add_orphan_tasks();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR ::google::protobuf::RepeatedPtrField< ::mesos::Task >*
      mutable_orphan_tasks();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR const ::google::protobuf::RepeatedPtrField< ::mesos::Task >&
      orphan_tasks() const;

  // repeated .mesos.Task unreachable_tasks = 5;
  int unreachable_tasks_size() const;
  void clear_unreachable_tasks();
  static const int kUnreachableTasksFieldNumber = 5;
  const ::mesos::Task& unreachable_tasks(int index) const;
  ::mesos::Task* mutable_unreachable_tasks(int index);
  ::mesos::Task* add_unreachable_tasks();
  ::google::protobuf::RepeatedPtrField< ::mesos::Task >*
      mutable_unreachable_tasks();
  const ::google::protobuf::RepeatedPtrField< ::mesos::Task >&
      unreachable_tasks() const;

  // @@protoc_insertion_point(class_scope:mesos.master.Response.GetTasks)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Task > pending_tasks_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Task > tasks_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Task > completed_tasks_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Task > orphan_tasks_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Task > unreachable_tasks_;
  friend struct ::protobuf_mesos_2fmaster_2fmaster_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmaster_2fmaster_2eproto::InitDefaultsResponse_GetTasksImpl();
};
// -------------------------------------------------------------------

class Response_GetRoles : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.master.Response.GetRoles) */ {
 public:
  Response_GetRoles();
  virtual ~Response_GetRoles();

  Response_GetRoles(const Response_GetRoles& from);

  inline Response_GetRoles& operator=(const Response_GetRoles& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Response_GetRoles(Response_GetRoles&& from) noexcept
    : Response_GetRoles() {
    *this = ::std::move(from);
  }

  inline Response_GetRoles& operator=(Response_GetRoles&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Response_GetRoles& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Response_GetRoles* internal_default_instance() {
    return reinterpret_cast<const Response_GetRoles*>(
               &_Response_GetRoles_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    36;

  void UnsafeArenaSwap(Response_GetRoles* other);
  void Swap(Response_GetRoles* other);
  friend void swap(Response_GetRoles& a, Response_GetRoles& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Response_GetRoles* New() const PROTOBUF_FINAL { return New(NULL); }

  Response_GetRoles* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Response_GetRoles& from);
  void MergeFrom(const Response_GetRoles& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Response_GetRoles* other);
  protected:
  explicit Response_GetRoles(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.Role roles = 1;
  int roles_size() const;
  void clear_roles();
  static const int kRolesFieldNumber = 1;
  const ::mesos::Role& roles(int index) const;
  ::mesos::Role* mutable_roles(int index);
  ::mesos::Role* add_roles();
  ::google::protobuf::RepeatedPtrField< ::mesos::Role >*
      mutable_roles();
  const ::google::protobuf::RepeatedPtrField< ::mesos::Role >&
      roles() const;

  // @@protoc_insertion_point(class_scope:mesos.master.Response.GetRoles)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Role > roles_;
  friend struct ::protobuf_mesos_2fmaster_2fmaster_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmaster_2fmaster_2eproto::InitDefaultsResponse_GetRolesImpl();
};
// -------------------------------------------------------------------

class Response_GetWeights : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.master.Response.GetWeights) */ {
 public:
  Response_GetWeights();
  virtual ~Response_GetWeights();

  Response_GetWeights(const Response_GetWeights& from);

  inline Response_GetWeights& operator=(const Response_GetWeights& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Response_GetWeights(Response_GetWeights&& from) noexcept
    : Response_GetWeights() {
    *this = ::std::move(from);
  }

  inline Response_GetWeights& operator=(Response_GetWeights&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Response_GetWeights& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Response_GetWeights* internal_default_instance() {
    return reinterpret_cast<const Response_GetWeights*>(
               &_Response_GetWeights_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    37;

  void UnsafeArenaSwap(Response_GetWeights* other);
  void Swap(Response_GetWeights* other);
  friend void swap(Response_GetWeights& a, Response_GetWeights& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Response_GetWeights* New() const PROTOBUF_FINAL { return New(NULL); }

  Response_GetWeights* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Response_GetWeights& from);
  void MergeFrom(const Response_GetWeights& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Response_GetWeights* other);
  protected:
  explicit Response_GetWeights(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.WeightInfo weight_infos = 1;
  int weight_infos_size() const;
  void clear_weight_infos();
  static const int kWeightInfosFieldNumber = 1;
  const ::mesos::WeightInfo& weight_infos(int index) const;
  ::mesos::WeightInfo* mutable_weight_infos(int index);
  ::mesos::WeightInfo* add_weight_infos();
  ::google::protobuf::RepeatedPtrField< ::mesos::WeightInfo >*
      mutable_weight_infos();
  const ::google::protobuf::RepeatedPtrField< ::mesos::WeightInfo >&
      weight_infos() const;

  // @@protoc_insertion_point(class_scope:mesos.master.Response.GetWeights)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::WeightInfo > weight_infos_;
  friend struct ::protobuf_mesos_2fmaster_2fmaster_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmaster_2fmaster_2eproto::InitDefaultsResponse_GetWeightsImpl();
};
// -------------------------------------------------------------------

class Response_GetMaster : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.master.Response.GetMaster) */ {
 public:
  Response_GetMaster();
  virtual ~Response_GetMaster();

  Response_GetMaster(const Response_GetMaster& from);

  inline Response_GetMaster& operator=(const Response_GetMaster& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Response_GetMaster(Response_GetMaster&& from) noexcept
    : Response_GetMaster() {
    *this = ::std::move(from);
  }

  inline Response_GetMaster& operator=(Response_GetMaster&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Response_GetMaster& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Response_GetMaster* internal_default_instance() {
    return reinterpret_cast<const Response_GetMaster*>(
               &_Response_GetMaster_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    38;

  void UnsafeArenaSwap(Response_GetMaster* other);
  void Swap(Response_GetMaster* other);
  friend void swap(Response_GetMaster& a, Response_GetMaster& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Response_GetMaster* New() const PROTOBUF_FINAL { return New(NULL); }

  Response_GetMaster* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Response_GetMaster& from);
  void MergeFrom(const Response_GetMaster& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Response_GetMaster* other);
  protected:
  explicit Response_GetMaster(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mesos.MasterInfo master_info = 1;
  bool has_master_info() const;
  void clear_master_info();
  static const int kMasterInfoFieldNumber = 1;
  private:
  void _slow_mutable_master_info();
  public:
  const ::mesos::MasterInfo& master_info() const;
  ::mesos::MasterInfo* release_master_info();
  ::mesos::MasterInfo* mutable_master_info();
  void set_allocated_master_info(::mesos::MasterInfo* master_info);
  void unsafe_arena_set_allocated_master_info(
      ::mesos::MasterInfo* master_info);
  ::mesos::MasterInfo* unsafe_arena_release_master_info();

  // optional double start_time = 2;
  bool has_start_time() const;
  void clear_start_time();
  static const int kStartTimeFieldNumber = 2;
  double start_time() const;
  void set_start_time(double value);

  // optional double elected_time = 3;
  bool has_elected_time() const;
  void clear_elected_time();
  static const int kElectedTimeFieldNumber = 3;
  double elected_time() const;
  void set_elected_time(double value);

  // @@protoc_insertion_point(class_scope:mesos.master.Response.GetMaster)
 private:
  void set_has_master_info();
  void clear_has_master_info();
  void set_has_start_time();
  void clear_has_start_time();
  void set_has_elected_time();
  void clear_has_elected_time();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::MasterInfo* master_info_;
  double start_time_;
  double elected_time_;
  friend struct ::protobuf_mesos_2fmaster_2fmaster_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmaster_2fmaster_2eproto::InitDefaultsResponse_GetMasterImpl();
};
// -------------------------------------------------------------------

class Response_GetMaintenanceStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.master.Response.GetMaintenanceStatus) */ {
 public:
  Response_GetMaintenanceStatus();
  virtual ~Response_GetMaintenanceStatus();

  Response_GetMaintenanceStatus(const Response_GetMaintenanceStatus& from);

  inline Response_GetMaintenanceStatus& operator=(const Response_GetMaintenanceStatus& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Response_GetMaintenanceStatus(Response_GetMaintenanceStatus&& from) noexcept
    : Response_GetMaintenanceStatus() {
    *this = ::std::move(from);
  }

  inline Response_GetMaintenanceStatus& operator=(Response_GetMaintenanceStatus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Response_GetMaintenanceStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Response_GetMaintenanceStatus* internal_default_instance() {
    return reinterpret_cast<const Response_GetMaintenanceStatus*>(
               &_Response_GetMaintenanceStatus_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    39;

  void UnsafeArenaSwap(Response_GetMaintenanceStatus* other);
  void Swap(Response_GetMaintenanceStatus* other);
  friend void swap(Response_GetMaintenanceStatus& a, Response_GetMaintenanceStatus& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Response_GetMaintenanceStatus* New() const PROTOBUF_FINAL { return New(NULL); }

  Response_GetMaintenanceStatus* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Response_GetMaintenanceStatus& from);
  void MergeFrom(const Response_GetMaintenanceStatus& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Response_GetMaintenanceStatus* other);
  protected:
  explicit Response_GetMaintenanceStatus(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.maintenance.ClusterStatus status = 1;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  private:
  void _slow_mutable_status();
  public:
  const ::mesos::maintenance::ClusterStatus& status() const;
  ::mesos::maintenance::ClusterStatus* release_status();
  ::mesos::maintenance::ClusterStatus* mutable_status();
  void set_allocated_status(::mesos::maintenance::ClusterStatus* status);
  void unsafe_arena_set_allocated_status(
      ::mesos::maintenance::ClusterStatus* status);
  ::mesos::maintenance::ClusterStatus* unsafe_arena_release_status();

  // @@protoc_insertion_point(class_scope:mesos.master.Response.GetMaintenanceStatus)
 private:
  void set_has_status();
  void clear_has_status();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::maintenance::ClusterStatus* status_;
  friend struct ::protobuf_mesos_2fmaster_2fmaster_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmaster_2fmaster_2eproto::InitDefaultsResponse_GetMaintenanceStatusImpl();
};
// -------------------------------------------------------------------

class Response_GetMaintenanceSchedule : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.master.Response.GetMaintenanceSchedule) */ {
 public:
  Response_GetMaintenanceSchedule();
  virtual ~Response_GetMaintenanceSchedule();

  Response_GetMaintenanceSchedule(const Response_GetMaintenanceSchedule& from);

  inline Response_GetMaintenanceSchedule& operator=(const Response_GetMaintenanceSchedule& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Response_GetMaintenanceSchedule(Response_GetMaintenanceSchedule&& from) noexcept
    : Response_GetMaintenanceSchedule() {
    *this = ::std::move(from);
  }

  inline Response_GetMaintenanceSchedule& operator=(Response_GetMaintenanceSchedule&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Response_GetMaintenanceSchedule& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Response_GetMaintenanceSchedule* internal_default_instance() {
    return reinterpret_cast<const Response_GetMaintenanceSchedule*>(
               &_Response_GetMaintenanceSchedule_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    40;

  void UnsafeArenaSwap(Response_GetMaintenanceSchedule* other);
  void Swap(Response_GetMaintenanceSchedule* other);
  friend void swap(Response_GetMaintenanceSchedule& a, Response_GetMaintenanceSchedule& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Response_GetMaintenanceSchedule* New() const PROTOBUF_FINAL { return New(NULL); }

  Response_GetMaintenanceSchedule* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Response_GetMaintenanceSchedule& from);
  void MergeFrom(const Response_GetMaintenanceSchedule& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Response_GetMaintenanceSchedule* other);
  protected:
  explicit Response_GetMaintenanceSchedule(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.maintenance.Schedule schedule = 1;
  bool has_schedule() const;
  void clear_schedule();
  static const int kScheduleFieldNumber = 1;
  private:
  void _slow_mutable_schedule();
  public:
  const ::mesos::maintenance::Schedule& schedule() const;
  ::mesos::maintenance::Schedule* release_schedule();
  ::mesos::maintenance::Schedule* mutable_schedule();
  void set_allocated_schedule(::mesos::maintenance::Schedule* schedule);
  void unsafe_arena_set_allocated_schedule(
      ::mesos::maintenance::Schedule* schedule);
  ::mesos::maintenance::Schedule* unsafe_arena_release_schedule();

  // @@protoc_insertion_point(class_scope:mesos.master.Response.GetMaintenanceSchedule)
 private:
  void set_has_schedule();
  void clear_has_schedule();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::maintenance::Schedule* schedule_;
  friend struct ::protobuf_mesos_2fmaster_2fmaster_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmaster_2fmaster_2eproto::InitDefaultsResponse_GetMaintenanceScheduleImpl();
};
// -------------------------------------------------------------------

class Response_GetQuota : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.master.Response.GetQuota) */ {
 public:
  Response_GetQuota();
  virtual ~Response_GetQuota();

  Response_GetQuota(const Response_GetQuota& from);

  inline Response_GetQuota& operator=(const Response_GetQuota& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Response_GetQuota(Response_GetQuota&& from) noexcept
    : Response_GetQuota() {
    *this = ::std::move(from);
  }

  inline Response_GetQuota& operator=(Response_GetQuota&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Response_GetQuota& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Response_GetQuota* internal_default_instance() {
    return reinterpret_cast<const Response_GetQuota*>(
               &_Response_GetQuota_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    41;

  void UnsafeArenaSwap(Response_GetQuota* other);
  void Swap(Response_GetQuota* other);
  friend void swap(Response_GetQuota& a, Response_GetQuota& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Response_GetQuota* New() const PROTOBUF_FINAL { return New(NULL); }

  Response_GetQuota* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Response_GetQuota& from);
  void MergeFrom(const Response_GetQuota& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Response_GetQuota* other);
  protected:
  explicit Response_GetQuota(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.quota.QuotaStatus status = 1;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  private:
  void _slow_mutable_status();
  public:
  const ::mesos::quota::QuotaStatus& status() const;
  ::mesos::quota::QuotaStatus* release_status();
  ::mesos::quota::QuotaStatus* mutable_status();
  void set_allocated_status(::mesos::quota::QuotaStatus* status);
  void unsafe_arena_set_allocated_status(
      ::mesos::quota::QuotaStatus* status);
  ::mesos::quota::QuotaStatus* unsafe_arena_release_status();

  // @@protoc_insertion_point(class_scope:mesos.master.Response.GetQuota)
 private:
  void set_has_status();
  void clear_has_status();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::quota::QuotaStatus* status_;
  friend struct ::protobuf_mesos_2fmaster_2fmaster_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmaster_2fmaster_2eproto::InitDefaultsResponse_GetQuotaImpl();
};
// -------------------------------------------------------------------

class Response : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.master.Response) */ {
 public:
  Response();
  virtual ~Response();

  Response(const Response& from);

  inline Response& operator=(const Response& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Response(Response&& from) noexcept
    : Response() {
    *this = ::std::move(from);
  }

  inline Response& operator=(Response&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Response& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Response* internal_default_instance() {
    return reinterpret_cast<const Response*>(
               &_Response_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    42;

  void UnsafeArenaSwap(Response* other);
  void Swap(Response* other);
  friend void swap(Response& a, Response& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Response* New() const PROTOBUF_FINAL { return New(NULL); }

  Response* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Response& from);
  void MergeFrom(const Response& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Response* other);
  protected:
  explicit Response(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Response_GetHealth GetHealth;
  typedef Response_GetFlags GetFlags;
  typedef Response_GetVersion GetVersion;
  typedef Response_GetMetrics GetMetrics;
  typedef Response_GetLoggingLevel GetLoggingLevel;
  typedef Response_ListFiles ListFiles;
  typedef Response_ReadFile ReadFile;
  typedef Response_GetState GetState;
  typedef Response_GetAgents GetAgents;
  typedef Response_GetFrameworks GetFrameworks;
  typedef Response_GetExecutors GetExecutors;
  typedef Response_GetOperations GetOperations;
  typedef Response_GetTasks GetTasks;
  typedef Response_GetRoles GetRoles;
  typedef Response_GetWeights GetWeights;
  typedef Response_GetMaster GetMaster;
  typedef Response_GetMaintenanceStatus GetMaintenanceStatus;
  typedef Response_GetMaintenanceSchedule GetMaintenanceSchedule;
  typedef Response_GetQuota GetQuota;

  typedef Response_Type Type;
  static const Type UNKNOWN =
    Response_Type_UNKNOWN;
  static const Type GET_HEALTH =
    Response_Type_GET_HEALTH;
  static const Type GET_FLAGS =
    Response_Type_GET_FLAGS;
  static const Type GET_VERSION =
    Response_Type_GET_VERSION;
  static const Type GET_METRICS =
    Response_Type_GET_METRICS;
  static const Type GET_LOGGING_LEVEL =
    Response_Type_GET_LOGGING_LEVEL;
  static const Type LIST_FILES =
    Response_Type_LIST_FILES;
  static const Type READ_FILE =
    Response_Type_READ_FILE;
  static const Type GET_STATE =
    Response_Type_GET_STATE;
  static const Type GET_AGENTS =
    Response_Type_GET_AGENTS;
  static const Type GET_FRAMEWORKS =
    Response_Type_GET_FRAMEWORKS;
  static const Type GET_EXECUTORS =
    Response_Type_GET_EXECUTORS;
  static const Type GET_OPERATIONS =
    Response_Type_GET_OPERATIONS;
  static const Type GET_TASKS =
    Response_Type_GET_TASKS;
  static const Type GET_ROLES =
    Response_Type_GET_ROLES;
  static const Type GET_WEIGHTS =
    Response_Type_GET_WEIGHTS;
  static const Type GET_MASTER =
    Response_Type_GET_MASTER;
  static const Type GET_MAINTENANCE_STATUS =
    Response_Type_GET_MAINTENANCE_STATUS;
  static const Type GET_MAINTENANCE_SCHEDULE =
    Response_Type_GET_MAINTENANCE_SCHEDULE;
  static const Type GET_QUOTA =
    Response_Type_GET_QUOTA;
  static inline bool Type_IsValid(int value) {
    return Response_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Response_Type_Type_MIN;
  static const Type Type_MAX =
    Response_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Response_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Response_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Response_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Response_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .mesos.master.Response.GetHealth get_health = 2;
  bool has_get_health() const;
  void clear_get_health();
  static const int kGetHealthFieldNumber = 2;
  private:
  void _slow_mutable_get_health();
  public:
  const ::mesos::master::Response_GetHealth& get_health() const;
  ::mesos::master::Response_GetHealth* release_get_health();
  ::mesos::master::Response_GetHealth* mutable_get_health();
  void set_allocated_get_health(::mesos::master::Response_GetHealth* get_health);
  void unsafe_arena_set_allocated_get_health(
      ::mesos::master::Response_GetHealth* get_health);
  ::mesos::master::Response_GetHealth* unsafe_arena_release_get_health();

  // optional .mesos.master.Response.GetFlags get_flags = 3;
  bool has_get_flags() const;
  void clear_get_flags();
  static const int kGetFlagsFieldNumber = 3;
  private:
  void _slow_mutable_get_flags();
  public:
  const ::mesos::master::Response_GetFlags& get_flags() const;
  ::mesos::master::Response_GetFlags* release_get_flags();
  ::mesos::master::Response_GetFlags* mutable_get_flags();
  void set_allocated_get_flags(::mesos::master::Response_GetFlags* get_flags);
  void unsafe_arena_set_allocated_get_flags(
      ::mesos::master::Response_GetFlags* get_flags);
  ::mesos::master::Response_GetFlags* unsafe_arena_release_get_flags();

  // optional .mesos.master.Response.GetVersion get_version = 4;
  bool has_get_version() const;
  void clear_get_version();
  static const int kGetVersionFieldNumber = 4;
  private:
  void _slow_mutable_get_version();
  public:
  const ::mesos::master::Response_GetVersion& get_version() const;
  ::mesos::master::Response_GetVersion* release_get_version();
  ::mesos::master::Response_GetVersion* mutable_get_version();
  void set_allocated_get_version(::mesos::master::Response_GetVersion* get_version);
  void unsafe_arena_set_allocated_get_version(
      ::mesos::master::Response_GetVersion* get_version);
  ::mesos::master::Response_GetVersion* unsafe_arena_release_get_version();

  // optional .mesos.master.Response.GetMetrics get_metrics = 5;
  bool has_get_metrics() const;
  void clear_get_metrics();
  static const int kGetMetricsFieldNumber = 5;
  private:
  void _slow_mutable_get_metrics();
  public:
  const ::mesos::master::Response_GetMetrics& get_metrics() const;
  ::mesos::master::Response_GetMetrics* release_get_metrics();
  ::mesos::master::Response_GetMetrics* mutable_get_metrics();
  void set_allocated_get_metrics(::mesos::master::Response_GetMetrics* get_metrics);
  void unsafe_arena_set_allocated_get_metrics(
      ::mesos::master::Response_GetMetrics* get_metrics);
  ::mesos::master::Response_GetMetrics* unsafe_arena_release_get_metrics();

  // optional .mesos.master.Response.GetLoggingLevel get_logging_level = 6;
  bool has_get_logging_level() const;
  void clear_get_logging_level();
  static const int kGetLoggingLevelFieldNumber = 6;
  private:
  void _slow_mutable_get_logging_level();
  public:
  const ::mesos::master::Response_GetLoggingLevel& get_logging_level() const;
  ::mesos::master::Response_GetLoggingLevel* release_get_logging_level();
  ::mesos::master::Response_GetLoggingLevel* mutable_get_logging_level();
  void set_allocated_get_logging_level(::mesos::master::Response_GetLoggingLevel* get_logging_level);
  void unsafe_arena_set_allocated_get_logging_level(
      ::mesos::master::Response_GetLoggingLevel* get_logging_level);
  ::mesos::master::Response_GetLoggingLevel* unsafe_arena_release_get_logging_level();

  // optional .mesos.master.Response.ListFiles list_files = 7;
  bool has_list_files() const;
  void clear_list_files();
  static const int kListFilesFieldNumber = 7;
  private:
  void _slow_mutable_list_files();
  public:
  const ::mesos::master::Response_ListFiles& list_files() const;
  ::mesos::master::Response_ListFiles* release_list_files();
  ::mesos::master::Response_ListFiles* mutable_list_files();
  void set_allocated_list_files(::mesos::master::Response_ListFiles* list_files);
  void unsafe_arena_set_allocated_list_files(
      ::mesos::master::Response_ListFiles* list_files);
  ::mesos::master::Response_ListFiles* unsafe_arena_release_list_files();

  // optional .mesos.master.Response.ReadFile read_file = 8;
  bool has_read_file() const;
  void clear_read_file();
  static const int kReadFileFieldNumber = 8;
  private:
  void _slow_mutable_read_file();
  public:
  const ::mesos::master::Response_ReadFile& read_file() const;
  ::mesos::master::Response_ReadFile* release_read_file();
  ::mesos::master::Response_ReadFile* mutable_read_file();
  void set_allocated_read_file(::mesos::master::Response_ReadFile* read_file);
  void unsafe_arena_set_allocated_read_file(
      ::mesos::master::Response_ReadFile* read_file);
  ::mesos::master::Response_ReadFile* unsafe_arena_release_read_file();

  // optional .mesos.master.Response.GetState get_state = 9;
  bool has_get_state() const;
  void clear_get_state();
  static const int kGetStateFieldNumber = 9;
  private:
  void _slow_mutable_get_state();
  public:
  const ::mesos::master::Response_GetState& get_state() const;
  ::mesos::master::Response_GetState* release_get_state();
  ::mesos::master::Response_GetState* mutable_get_state();
  void set_allocated_get_state(::mesos::master::Response_GetState* get_state);
  void unsafe_arena_set_allocated_get_state(
      ::mesos::master::Response_GetState* get_state);
  ::mesos::master::Response_GetState* unsafe_arena_release_get_state();

  // optional .mesos.master.Response.GetAgents get_agents = 10;
  bool has_get_agents() const;
  void clear_get_agents();
  static const int kGetAgentsFieldNumber = 10;
  private:
  void _slow_mutable_get_agents();
  public:
  const ::mesos::master::Response_GetAgents& get_agents() const;
  ::mesos::master::Response_GetAgents* release_get_agents();
  ::mesos::master::Response_GetAgents* mutable_get_agents();
  void set_allocated_get_agents(::mesos::master::Response_GetAgents* get_agents);
  void unsafe_arena_set_allocated_get_agents(
      ::mesos::master::Response_GetAgents* get_agents);
  ::mesos::master::Response_GetAgents* unsafe_arena_release_get_agents();

  // optional .mesos.master.Response.GetFrameworks get_frameworks = 11;
  bool has_get_frameworks() const;
  void clear_get_frameworks();
  static const int kGetFrameworksFieldNumber = 11;
  private:
  void _slow_mutable_get_frameworks();
  public:
  const ::mesos::master::Response_GetFrameworks& get_frameworks() const;
  ::mesos::master::Response_GetFrameworks* release_get_frameworks();
  ::mesos::master::Response_GetFrameworks* mutable_get_frameworks();
  void set_allocated_get_frameworks(::mesos::master::Response_GetFrameworks* get_frameworks);
  void unsafe_arena_set_allocated_get_frameworks(
      ::mesos::master::Response_GetFrameworks* get_frameworks);
  ::mesos::master::Response_GetFrameworks* unsafe_arena_release_get_frameworks();

  // optional .mesos.master.Response.GetExecutors get_executors = 12;
  bool has_get_executors() const;
  void clear_get_executors();
  static const int kGetExecutorsFieldNumber = 12;
  private:
  void _slow_mutable_get_executors();
  public:
  const ::mesos::master::Response_GetExecutors& get_executors() const;
  ::mesos::master::Response_GetExecutors* release_get_executors();
  ::mesos::master::Response_GetExecutors* mutable_get_executors();
  void set_allocated_get_executors(::mesos::master::Response_GetExecutors* get_executors);
  void unsafe_arena_set_allocated_get_executors(
      ::mesos::master::Response_GetExecutors* get_executors);
  ::mesos::master::Response_GetExecutors* unsafe_arena_release_get_executors();

  // optional .mesos.master.Response.GetTasks get_tasks = 13;
  bool has_get_tasks() const;
  void clear_get_tasks();
  static const int kGetTasksFieldNumber = 13;
  private:
  void _slow_mutable_get_tasks();
  public:
  const ::mesos::master::Response_GetTasks& get_tasks() const;
  ::mesos::master::Response_GetTasks* release_get_tasks();
  ::mesos::master::Response_GetTasks* mutable_get_tasks();
  void set_allocated_get_tasks(::mesos::master::Response_GetTasks* get_tasks);
  void unsafe_arena_set_allocated_get_tasks(
      ::mesos::master::Response_GetTasks* get_tasks);
  ::mesos::master::Response_GetTasks* unsafe_arena_release_get_tasks();

  // optional .mesos.master.Response.GetRoles get_roles = 14;
  bool has_get_roles() const;
  void clear_get_roles();
  static const int kGetRolesFieldNumber = 14;
  private:
  void _slow_mutable_get_roles();
  public:
  const ::mesos::master::Response_GetRoles& get_roles() const;
  ::mesos::master::Response_GetRoles* release_get_roles();
  ::mesos::master::Response_GetRoles* mutable_get_roles();
  void set_allocated_get_roles(::mesos::master::Response_GetRoles* get_roles);
  void unsafe_arena_set_allocated_get_roles(
      ::mesos::master::Response_GetRoles* get_roles);
  ::mesos::master::Response_GetRoles* unsafe_arena_release_get_roles();

  // optional .mesos.master.Response.GetWeights get_weights = 15;
  bool has_get_weights() const;
  void clear_get_weights();
  static const int kGetWeightsFieldNumber = 15;
  private:
  void _slow_mutable_get_weights();
  public:
  const ::mesos::master::Response_GetWeights& get_weights() const;
  ::mesos::master::Response_GetWeights* release_get_weights();
  ::mesos::master::Response_GetWeights* mutable_get_weights();
  void set_allocated_get_weights(::mesos::master::Response_GetWeights* get_weights);
  void unsafe_arena_set_allocated_get_weights(
      ::mesos::master::Response_GetWeights* get_weights);
  ::mesos::master::Response_GetWeights* unsafe_arena_release_get_weights();

  // optional .mesos.master.Response.GetMaster get_master = 16;
  bool has_get_master() const;
  void clear_get_master();
  static const int kGetMasterFieldNumber = 16;
  private:
  void _slow_mutable_get_master();
  public:
  const ::mesos::master::Response_GetMaster& get_master() const;
  ::mesos::master::Response_GetMaster* release_get_master();
  ::mesos::master::Response_GetMaster* mutable_get_master();
  void set_allocated_get_master(::mesos::master::Response_GetMaster* get_master);
  void unsafe_arena_set_allocated_get_master(
      ::mesos::master::Response_GetMaster* get_master);
  ::mesos::master::Response_GetMaster* unsafe_arena_release_get_master();

  // optional .mesos.master.Response.GetMaintenanceStatus get_maintenance_status = 17;
  bool has_get_maintenance_status() const;
  void clear_get_maintenance_status();
  static const int kGetMaintenanceStatusFieldNumber = 17;
  private:
  void _slow_mutable_get_maintenance_status();
  public:
  const ::mesos::master::Response_GetMaintenanceStatus& get_maintenance_status() const;
  ::mesos::master::Response_GetMaintenanceStatus* release_get_maintenance_status();
  ::mesos::master::Response_GetMaintenanceStatus* mutable_get_maintenance_status();
  void set_allocated_get_maintenance_status(::mesos::master::Response_GetMaintenanceStatus* get_maintenance_status);
  void unsafe_arena_set_allocated_get_maintenance_status(
      ::mesos::master::Response_GetMaintenanceStatus* get_maintenance_status);
  ::mesos::master::Response_GetMaintenanceStatus* unsafe_arena_release_get_maintenance_status();

  // optional .mesos.master.Response.GetMaintenanceSchedule get_maintenance_schedule = 18;
  bool has_get_maintenance_schedule() const;
  void clear_get_maintenance_schedule();
  static const int kGetMaintenanceScheduleFieldNumber = 18;
  private:
  void _slow_mutable_get_maintenance_schedule();
  public:
  const ::mesos::master::Response_GetMaintenanceSchedule& get_maintenance_schedule() const;
  ::mesos::master::Response_GetMaintenanceSchedule* release_get_maintenance_schedule();
  ::mesos::master::Response_GetMaintenanceSchedule* mutable_get_maintenance_schedule();
  void set_allocated_get_maintenance_schedule(::mesos::master::Response_GetMaintenanceSchedule* get_maintenance_schedule);
  void unsafe_arena_set_allocated_get_maintenance_schedule(
      ::mesos::master::Response_GetMaintenanceSchedule* get_maintenance_schedule);
  ::mesos::master::Response_GetMaintenanceSchedule* unsafe_arena_release_get_maintenance_schedule();

  // optional .mesos.master.Response.GetQuota get_quota = 19;
  bool has_get_quota() const;
  void clear_get_quota();
  static const int kGetQuotaFieldNumber = 19;
  private:
  void _slow_mutable_get_quota();
  public:
  const ::mesos::master::Response_GetQuota& get_quota() const;
  ::mesos::master::Response_GetQuota* release_get_quota();
  ::mesos::master::Response_GetQuota* mutable_get_quota();
  void set_allocated_get_quota(::mesos::master::Response_GetQuota* get_quota);
  void unsafe_arena_set_allocated_get_quota(
      ::mesos::master::Response_GetQuota* get_quota);
  ::mesos::master::Response_GetQuota* unsafe_arena_release_get_quota();

  // optional .mesos.master.Response.GetOperations get_operations = 20;
  bool has_get_operations() const;
  void clear_get_operations();
  static const int kGetOperationsFieldNumber = 20;
  private:
  void _slow_mutable_get_operations();
  public:
  const ::mesos::master::Response_GetOperations& get_operations() const;
  ::mesos::master::Response_GetOperations* release_get_operations();
  ::mesos::master::Response_GetOperations* mutable_get_operations();
  void set_allocated_get_operations(::mesos::master::Response_GetOperations* get_operations);
  void unsafe_arena_set_allocated_get_operations(
      ::mesos::master::Response_GetOperations* get_operations);
  ::mesos::master::Response_GetOperations* unsafe_arena_release_get_operations();

  // optional .mesos.master.Response.Type type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::mesos::master::Response_Type type() const;
  void set_type(::mesos::master::Response_Type value);

  // @@protoc_insertion_point(class_scope:mesos.master.Response)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_get_health();
  void clear_has_get_health();
  void set_has_get_flags();
  void clear_has_get_flags();
  void set_has_get_version();
  void clear_has_get_version();
  void set_has_get_metrics();
  void clear_has_get_metrics();
  void set_has_get_logging_level();
  void clear_has_get_logging_level();
  void set_has_list_files();
  void clear_has_list_files();
  void set_has_read_file();
  void clear_has_read_file();
  void set_has_get_state();
  void clear_has_get_state();
  void set_has_get_agents();
  void clear_has_get_agents();
  void set_has_get_frameworks();
  void clear_has_get_frameworks();
  void set_has_get_executors();
  void clear_has_get_executors();
  void set_has_get_operations();
  void clear_has_get_operations();
  void set_has_get_tasks();
  void clear_has_get_tasks();
  void set_has_get_roles();
  void clear_has_get_roles();
  void set_has_get_weights();
  void clear_has_get_weights();
  void set_has_get_master();
  void clear_has_get_master();
  void set_has_get_maintenance_status();
  void clear_has_get_maintenance_status();
  void set_has_get_maintenance_schedule();
  void clear_has_get_maintenance_schedule();
  void set_has_get_quota();
  void clear_has_get_quota();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::master::Response_GetHealth* get_health_;
  ::mesos::master::Response_GetFlags* get_flags_;
  ::mesos::master::Response_GetVersion* get_version_;
  ::mesos::master::Response_GetMetrics* get_metrics_;
  ::mesos::master::Response_GetLoggingLevel* get_logging_level_;
  ::mesos::master::Response_ListFiles* list_files_;
  ::mesos::master::Response_ReadFile* read_file_;
  ::mesos::master::Response_GetState* get_state_;
  ::mesos::master::Response_GetAgents* get_agents_;
  ::mesos::master::Response_GetFrameworks* get_frameworks_;
  ::mesos::master::Response_GetExecutors* get_executors_;
  ::mesos::master::Response_GetTasks* get_tasks_;
  ::mesos::master::Response_GetRoles* get_roles_;
  ::mesos::master::Response_GetWeights* get_weights_;
  ::mesos::master::Response_GetMaster* get_master_;
  ::mesos::master::Response_GetMaintenanceStatus* get_maintenance_status_;
  ::mesos::master::Response_GetMaintenanceSchedule* get_maintenance_schedule_;
  ::mesos::master::Response_GetQuota* get_quota_;
  ::mesos::master::Response_GetOperations* get_operations_;
  int type_;
  friend struct ::protobuf_mesos_2fmaster_2fmaster_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmaster_2fmaster_2eproto::InitDefaultsResponseImpl();
};
// -------------------------------------------------------------------

class Event_Subscribed : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.master.Event.Subscribed) */ {
 public:
  Event_Subscribed();
  virtual ~Event_Subscribed();

  Event_Subscribed(const Event_Subscribed& from);

  inline Event_Subscribed& operator=(const Event_Subscribed& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Event_Subscribed(Event_Subscribed&& from) noexcept
    : Event_Subscribed() {
    *this = ::std::move(from);
  }

  inline Event_Subscribed& operator=(Event_Subscribed&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Event_Subscribed& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Event_Subscribed* internal_default_instance() {
    return reinterpret_cast<const Event_Subscribed*>(
               &_Event_Subscribed_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    43;

  void UnsafeArenaSwap(Event_Subscribed* other);
  void Swap(Event_Subscribed* other);
  friend void swap(Event_Subscribed& a, Event_Subscribed& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Event_Subscribed* New() const PROTOBUF_FINAL { return New(NULL); }

  Event_Subscribed* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Event_Subscribed& from);
  void MergeFrom(const Event_Subscribed& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Event_Subscribed* other);
  protected:
  explicit Event_Subscribed(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mesos.master.Response.GetState get_state = 1;
  bool has_get_state() const;
  void clear_get_state();
  static const int kGetStateFieldNumber = 1;
  private:
  void _slow_mutable_get_state();
  public:
  const ::mesos::master::Response_GetState& get_state() const;
  ::mesos::master::Response_GetState* release_get_state();
  ::mesos::master::Response_GetState* mutable_get_state();
  void set_allocated_get_state(::mesos::master::Response_GetState* get_state);
  void unsafe_arena_set_allocated_get_state(
      ::mesos::master::Response_GetState* get_state);
  ::mesos::master::Response_GetState* unsafe_arena_release_get_state();

  // optional double heartbeat_interval_seconds = 2;
  bool has_heartbeat_interval_seconds() const;
  void clear_heartbeat_interval_seconds();
  static const int kHeartbeatIntervalSecondsFieldNumber = 2;
  double heartbeat_interval_seconds() const;
  void set_heartbeat_interval_seconds(double value);

  // @@protoc_insertion_point(class_scope:mesos.master.Event.Subscribed)
 private:
  void set_has_get_state();
  void clear_has_get_state();
  void set_has_heartbeat_interval_seconds();
  void clear_has_heartbeat_interval_seconds();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::master::Response_GetState* get_state_;
  double heartbeat_interval_seconds_;
  friend struct ::protobuf_mesos_2fmaster_2fmaster_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmaster_2fmaster_2eproto::InitDefaultsEvent_SubscribedImpl();
};
// -------------------------------------------------------------------

class Event_TaskAdded : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.master.Event.TaskAdded) */ {
 public:
  Event_TaskAdded();
  virtual ~Event_TaskAdded();

  Event_TaskAdded(const Event_TaskAdded& from);

  inline Event_TaskAdded& operator=(const Event_TaskAdded& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Event_TaskAdded(Event_TaskAdded&& from) noexcept
    : Event_TaskAdded() {
    *this = ::std::move(from);
  }

  inline Event_TaskAdded& operator=(Event_TaskAdded&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Event_TaskAdded& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Event_TaskAdded* internal_default_instance() {
    return reinterpret_cast<const Event_TaskAdded*>(
               &_Event_TaskAdded_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    44;

  void UnsafeArenaSwap(Event_TaskAdded* other);
  void Swap(Event_TaskAdded* other);
  friend void swap(Event_TaskAdded& a, Event_TaskAdded& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Event_TaskAdded* New() const PROTOBUF_FINAL { return New(NULL); }

  Event_TaskAdded* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Event_TaskAdded& from);
  void MergeFrom(const Event_TaskAdded& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Event_TaskAdded* other);
  protected:
  explicit Event_TaskAdded(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.Task task = 1;
  bool has_task() const;
  void clear_task();
  static const int kTaskFieldNumber = 1;
  private:
  void _slow_mutable_task();
  public:
  const ::mesos::Task& task() const;
  ::mesos::Task* release_task();
  ::mesos::Task* mutable_task();
  void set_allocated_task(::mesos::Task* task);
  void unsafe_arena_set_allocated_task(
      ::mesos::Task* task);
  ::mesos::Task* unsafe_arena_release_task();

  // @@protoc_insertion_point(class_scope:mesos.master.Event.TaskAdded)
 private:
  void set_has_task();
  void clear_has_task();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::Task* task_;
  friend struct ::protobuf_mesos_2fmaster_2fmaster_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmaster_2fmaster_2eproto::InitDefaultsEvent_TaskAddedImpl();
};
// -------------------------------------------------------------------

class Event_TaskUpdated : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.master.Event.TaskUpdated) */ {
 public:
  Event_TaskUpdated();
  virtual ~Event_TaskUpdated();

  Event_TaskUpdated(const Event_TaskUpdated& from);

  inline Event_TaskUpdated& operator=(const Event_TaskUpdated& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Event_TaskUpdated(Event_TaskUpdated&& from) noexcept
    : Event_TaskUpdated() {
    *this = ::std::move(from);
  }

  inline Event_TaskUpdated& operator=(Event_TaskUpdated&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Event_TaskUpdated& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Event_TaskUpdated* internal_default_instance() {
    return reinterpret_cast<const Event_TaskUpdated*>(
               &_Event_TaskUpdated_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    45;

  void UnsafeArenaSwap(Event_TaskUpdated* other);
  void Swap(Event_TaskUpdated* other);
  friend void swap(Event_TaskUpdated& a, Event_TaskUpdated& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Event_TaskUpdated* New() const PROTOBUF_FINAL { return New(NULL); }

  Event_TaskUpdated* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Event_TaskUpdated& from);
  void MergeFrom(const Event_TaskUpdated& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Event_TaskUpdated* other);
  protected:
  explicit Event_TaskUpdated(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.FrameworkID framework_id = 1;
  bool has_framework_id() const;
  void clear_framework_id();
  static const int kFrameworkIdFieldNumber = 1;
  private:
  void _slow_mutable_framework_id();
  public:
  const ::mesos::FrameworkID& framework_id() const;
  ::mesos::FrameworkID* release_framework_id();
  ::mesos::FrameworkID* mutable_framework_id();
  void set_allocated_framework_id(::mesos::FrameworkID* framework_id);
  void unsafe_arena_set_allocated_framework_id(
      ::mesos::FrameworkID* framework_id);
  ::mesos::FrameworkID* unsafe_arena_release_framework_id();

  // required .mesos.TaskStatus status = 2;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 2;
  private:
  void _slow_mutable_status();
  public:
  const ::mesos::TaskStatus& status() const;
  ::mesos::TaskStatus* release_status();
  ::mesos::TaskStatus* mutable_status();
  void set_allocated_status(::mesos::TaskStatus* status);
  void unsafe_arena_set_allocated_status(
      ::mesos::TaskStatus* status);
  ::mesos::TaskStatus* unsafe_arena_release_status();

  // required .mesos.TaskState state = 3;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 3;
  ::mesos::TaskState state() const;
  void set_state(::mesos::TaskState value);

  // @@protoc_insertion_point(class_scope:mesos.master.Event.TaskUpdated)
 private:
  void set_has_framework_id();
  void clear_has_framework_id();
  void set_has_status();
  void clear_has_status();
  void set_has_state();
  void clear_has_state();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::FrameworkID* framework_id_;
  ::mesos::TaskStatus* status_;
  int state_;
  friend struct ::protobuf_mesos_2fmaster_2fmaster_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmaster_2fmaster_2eproto::InitDefaultsEvent_TaskUpdatedImpl();
};
// -------------------------------------------------------------------

class Event_FrameworkAdded : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.master.Event.FrameworkAdded) */ {
 public:
  Event_FrameworkAdded();
  virtual ~Event_FrameworkAdded();

  Event_FrameworkAdded(const Event_FrameworkAdded& from);

  inline Event_FrameworkAdded& operator=(const Event_FrameworkAdded& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Event_FrameworkAdded(Event_FrameworkAdded&& from) noexcept
    : Event_FrameworkAdded() {
    *this = ::std::move(from);
  }

  inline Event_FrameworkAdded& operator=(Event_FrameworkAdded&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Event_FrameworkAdded& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Event_FrameworkAdded* internal_default_instance() {
    return reinterpret_cast<const Event_FrameworkAdded*>(
               &_Event_FrameworkAdded_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    46;

  void UnsafeArenaSwap(Event_FrameworkAdded* other);
  void Swap(Event_FrameworkAdded* other);
  friend void swap(Event_FrameworkAdded& a, Event_FrameworkAdded& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Event_FrameworkAdded* New() const PROTOBUF_FINAL { return New(NULL); }

  Event_FrameworkAdded* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Event_FrameworkAdded& from);
  void MergeFrom(const Event_FrameworkAdded& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Event_FrameworkAdded* other);
  protected:
  explicit Event_FrameworkAdded(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.master.Response.GetFrameworks.Framework framework = 1;
  bool has_framework() const;
  void clear_framework();
  static const int kFrameworkFieldNumber = 1;
  private:
  void _slow_mutable_framework();
  public:
  const ::mesos::master::Response_GetFrameworks_Framework& framework() const;
  ::mesos::master::Response_GetFrameworks_Framework* release_framework();
  ::mesos::master::Response_GetFrameworks_Framework* mutable_framework();
  void set_allocated_framework(::mesos::master::Response_GetFrameworks_Framework* framework);
  void unsafe_arena_set_allocated_framework(
      ::mesos::master::Response_GetFrameworks_Framework* framework);
  ::mesos::master::Response_GetFrameworks_Framework* unsafe_arena_release_framework();

  // @@protoc_insertion_point(class_scope:mesos.master.Event.FrameworkAdded)
 private:
  void set_has_framework();
  void clear_has_framework();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::master::Response_GetFrameworks_Framework* framework_;
  friend struct ::protobuf_mesos_2fmaster_2fmaster_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmaster_2fmaster_2eproto::InitDefaultsEvent_FrameworkAddedImpl();
};
// -------------------------------------------------------------------

class Event_FrameworkUpdated : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.master.Event.FrameworkUpdated) */ {
 public:
  Event_FrameworkUpdated();
  virtual ~Event_FrameworkUpdated();

  Event_FrameworkUpdated(const Event_FrameworkUpdated& from);

  inline Event_FrameworkUpdated& operator=(const Event_FrameworkUpdated& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Event_FrameworkUpdated(Event_FrameworkUpdated&& from) noexcept
    : Event_FrameworkUpdated() {
    *this = ::std::move(from);
  }

  inline Event_FrameworkUpdated& operator=(Event_FrameworkUpdated&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Event_FrameworkUpdated& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Event_FrameworkUpdated* internal_default_instance() {
    return reinterpret_cast<const Event_FrameworkUpdated*>(
               &_Event_FrameworkUpdated_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    47;

  void UnsafeArenaSwap(Event_FrameworkUpdated* other);
  void Swap(Event_FrameworkUpdated* other);
  friend void swap(Event_FrameworkUpdated& a, Event_FrameworkUpdated& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Event_FrameworkUpdated* New() const PROTOBUF_FINAL { return New(NULL); }

  Event_FrameworkUpdated* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Event_FrameworkUpdated& from);
  void MergeFrom(const Event_FrameworkUpdated& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Event_FrameworkUpdated* other);
  protected:
  explicit Event_FrameworkUpdated(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.master.Response.GetFrameworks.Framework framework = 1;
  bool has_framework() const;
  void clear_framework();
  static const int kFrameworkFieldNumber = 1;
  private:
  void _slow_mutable_framework();
  public:
  const ::mesos::master::Response_GetFrameworks_Framework& framework() const;
  ::mesos::master::Response_GetFrameworks_Framework* release_framework();
  ::mesos::master::Response_GetFrameworks_Framework* mutable_framework();
  void set_allocated_framework(::mesos::master::Response_GetFrameworks_Framework* framework);
  void unsafe_arena_set_allocated_framework(
      ::mesos::master::Response_GetFrameworks_Framework* framework);
  ::mesos::master::Response_GetFrameworks_Framework* unsafe_arena_release_framework();

  // @@protoc_insertion_point(class_scope:mesos.master.Event.FrameworkUpdated)
 private:
  void set_has_framework();
  void clear_has_framework();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::master::Response_GetFrameworks_Framework* framework_;
  friend struct ::protobuf_mesos_2fmaster_2fmaster_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmaster_2fmaster_2eproto::InitDefaultsEvent_FrameworkUpdatedImpl();
};
// -------------------------------------------------------------------

class Event_FrameworkRemoved : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.master.Event.FrameworkRemoved) */ {
 public:
  Event_FrameworkRemoved();
  virtual ~Event_FrameworkRemoved();

  Event_FrameworkRemoved(const Event_FrameworkRemoved& from);

  inline Event_FrameworkRemoved& operator=(const Event_FrameworkRemoved& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Event_FrameworkRemoved(Event_FrameworkRemoved&& from) noexcept
    : Event_FrameworkRemoved() {
    *this = ::std::move(from);
  }

  inline Event_FrameworkRemoved& operator=(Event_FrameworkRemoved&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Event_FrameworkRemoved& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Event_FrameworkRemoved* internal_default_instance() {
    return reinterpret_cast<const Event_FrameworkRemoved*>(
               &_Event_FrameworkRemoved_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    48;

  void UnsafeArenaSwap(Event_FrameworkRemoved* other);
  void Swap(Event_FrameworkRemoved* other);
  friend void swap(Event_FrameworkRemoved& a, Event_FrameworkRemoved& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Event_FrameworkRemoved* New() const PROTOBUF_FINAL { return New(NULL); }

  Event_FrameworkRemoved* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Event_FrameworkRemoved& from);
  void MergeFrom(const Event_FrameworkRemoved& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Event_FrameworkRemoved* other);
  protected:
  explicit Event_FrameworkRemoved(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.FrameworkInfo framework_info = 1;
  bool has_framework_info() const;
  void clear_framework_info();
  static const int kFrameworkInfoFieldNumber = 1;
  private:
  void _slow_mutable_framework_info();
  public:
  const ::mesos::FrameworkInfo& framework_info() const;
  ::mesos::FrameworkInfo* release_framework_info();
  ::mesos::FrameworkInfo* mutable_framework_info();
  void set_allocated_framework_info(::mesos::FrameworkInfo* framework_info);
  void unsafe_arena_set_allocated_framework_info(
      ::mesos::FrameworkInfo* framework_info);
  ::mesos::FrameworkInfo* unsafe_arena_release_framework_info();

  // @@protoc_insertion_point(class_scope:mesos.master.Event.FrameworkRemoved)
 private:
  void set_has_framework_info();
  void clear_has_framework_info();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::FrameworkInfo* framework_info_;
  friend struct ::protobuf_mesos_2fmaster_2fmaster_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmaster_2fmaster_2eproto::InitDefaultsEvent_FrameworkRemovedImpl();
};
// -------------------------------------------------------------------

class Event_AgentAdded : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.master.Event.AgentAdded) */ {
 public:
  Event_AgentAdded();
  virtual ~Event_AgentAdded();

  Event_AgentAdded(const Event_AgentAdded& from);

  inline Event_AgentAdded& operator=(const Event_AgentAdded& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Event_AgentAdded(Event_AgentAdded&& from) noexcept
    : Event_AgentAdded() {
    *this = ::std::move(from);
  }

  inline Event_AgentAdded& operator=(Event_AgentAdded&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Event_AgentAdded& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Event_AgentAdded* internal_default_instance() {
    return reinterpret_cast<const Event_AgentAdded*>(
               &_Event_AgentAdded_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    49;

  void UnsafeArenaSwap(Event_AgentAdded* other);
  void Swap(Event_AgentAdded* other);
  friend void swap(Event_AgentAdded& a, Event_AgentAdded& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Event_AgentAdded* New() const PROTOBUF_FINAL { return New(NULL); }

  Event_AgentAdded* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Event_AgentAdded& from);
  void MergeFrom(const Event_AgentAdded& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Event_AgentAdded* other);
  protected:
  explicit Event_AgentAdded(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.master.Response.GetAgents.Agent agent = 1;
  bool has_agent() const;
  void clear_agent();
  static const int kAgentFieldNumber = 1;
  private:
  void _slow_mutable_agent();
  public:
  const ::mesos::master::Response_GetAgents_Agent& agent() const;
  ::mesos::master::Response_GetAgents_Agent* release_agent();
  ::mesos::master::Response_GetAgents_Agent* mutable_agent();
  void set_allocated_agent(::mesos::master::Response_GetAgents_Agent* agent);
  void unsafe_arena_set_allocated_agent(
      ::mesos::master::Response_GetAgents_Agent* agent);
  ::mesos::master::Response_GetAgents_Agent* unsafe_arena_release_agent();

  // @@protoc_insertion_point(class_scope:mesos.master.Event.AgentAdded)
 private:
  void set_has_agent();
  void clear_has_agent();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::master::Response_GetAgents_Agent* agent_;
  friend struct ::protobuf_mesos_2fmaster_2fmaster_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmaster_2fmaster_2eproto::InitDefaultsEvent_AgentAddedImpl();
};
// -------------------------------------------------------------------

class Event_AgentRemoved : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.master.Event.AgentRemoved) */ {
 public:
  Event_AgentRemoved();
  virtual ~Event_AgentRemoved();

  Event_AgentRemoved(const Event_AgentRemoved& from);

  inline Event_AgentRemoved& operator=(const Event_AgentRemoved& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Event_AgentRemoved(Event_AgentRemoved&& from) noexcept
    : Event_AgentRemoved() {
    *this = ::std::move(from);
  }

  inline Event_AgentRemoved& operator=(Event_AgentRemoved&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Event_AgentRemoved& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Event_AgentRemoved* internal_default_instance() {
    return reinterpret_cast<const Event_AgentRemoved*>(
               &_Event_AgentRemoved_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    50;

  void UnsafeArenaSwap(Event_AgentRemoved* other);
  void Swap(Event_AgentRemoved* other);
  friend void swap(Event_AgentRemoved& a, Event_AgentRemoved& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Event_AgentRemoved* New() const PROTOBUF_FINAL { return New(NULL); }

  Event_AgentRemoved* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Event_AgentRemoved& from);
  void MergeFrom(const Event_AgentRemoved& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Event_AgentRemoved* other);
  protected:
  explicit Event_AgentRemoved(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.SlaveID agent_id = 1;
  bool has_agent_id() const;
  void clear_agent_id();
  static const int kAgentIdFieldNumber = 1;
  private:
  void _slow_mutable_agent_id();
  public:
  const ::mesos::SlaveID& agent_id() const;
  ::mesos::SlaveID* release_agent_id();
  ::mesos::SlaveID* mutable_agent_id();
  void set_allocated_agent_id(::mesos::SlaveID* agent_id);
  void unsafe_arena_set_allocated_agent_id(
      ::mesos::SlaveID* agent_id);
  ::mesos::SlaveID* unsafe_arena_release_agent_id();

  // @@protoc_insertion_point(class_scope:mesos.master.Event.AgentRemoved)
 private:
  void set_has_agent_id();
  void clear_has_agent_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::SlaveID* agent_id_;
  friend struct ::protobuf_mesos_2fmaster_2fmaster_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmaster_2fmaster_2eproto::InitDefaultsEvent_AgentRemovedImpl();
};
// -------------------------------------------------------------------

class Event : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.master.Event) */ {
 public:
  Event();
  virtual ~Event();

  Event(const Event& from);

  inline Event& operator=(const Event& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Event(Event&& from) noexcept
    : Event() {
    *this = ::std::move(from);
  }

  inline Event& operator=(Event&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Event& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Event* internal_default_instance() {
    return reinterpret_cast<const Event*>(
               &_Event_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    51;

  void UnsafeArenaSwap(Event* other);
  void Swap(Event* other);
  friend void swap(Event& a, Event& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Event* New() const PROTOBUF_FINAL { return New(NULL); }

  Event* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Event& from);
  void MergeFrom(const Event& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Event* other);
  protected:
  explicit Event(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Event_Subscribed Subscribed;
  typedef Event_TaskAdded TaskAdded;
  typedef Event_TaskUpdated TaskUpdated;
  typedef Event_FrameworkAdded FrameworkAdded;
  typedef Event_FrameworkUpdated FrameworkUpdated;
  typedef Event_FrameworkRemoved FrameworkRemoved;
  typedef Event_AgentAdded AgentAdded;
  typedef Event_AgentRemoved AgentRemoved;

  typedef Event_Type Type;
  static const Type UNKNOWN =
    Event_Type_UNKNOWN;
  static const Type SUBSCRIBED =
    Event_Type_SUBSCRIBED;
  static const Type TASK_ADDED =
    Event_Type_TASK_ADDED;
  static const Type TASK_UPDATED =
    Event_Type_TASK_UPDATED;
  static const Type AGENT_ADDED =
    Event_Type_AGENT_ADDED;
  static const Type AGENT_REMOVED =
    Event_Type_AGENT_REMOVED;
  static const Type FRAMEWORK_ADDED =
    Event_Type_FRAMEWORK_ADDED;
  static const Type FRAMEWORK_UPDATED =
    Event_Type_FRAMEWORK_UPDATED;
  static const Type FRAMEWORK_REMOVED =
    Event_Type_FRAMEWORK_REMOVED;
  static const Type HEARTBEAT =
    Event_Type_HEARTBEAT;
  static inline bool Type_IsValid(int value) {
    return Event_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Event_Type_Type_MIN;
  static const Type Type_MAX =
    Event_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Event_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Event_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Event_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Event_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .mesos.master.Event.Subscribed subscribed = 2;
  bool has_subscribed() const;
  void clear_subscribed();
  static const int kSubscribedFieldNumber = 2;
  private:
  void _slow_mutable_subscribed();
  public:
  const ::mesos::master::Event_Subscribed& subscribed() const;
  ::mesos::master::Event_Subscribed* release_subscribed();
  ::mesos::master::Event_Subscribed* mutable_subscribed();
  void set_allocated_subscribed(::mesos::master::Event_Subscribed* subscribed);
  void unsafe_arena_set_allocated_subscribed(
      ::mesos::master::Event_Subscribed* subscribed);
  ::mesos::master::Event_Subscribed* unsafe_arena_release_subscribed();

  // optional .mesos.master.Event.TaskAdded task_added = 3;
  bool has_task_added() const;
  void clear_task_added();
  static const int kTaskAddedFieldNumber = 3;
  private:
  void _slow_mutable_task_added();
  public:
  const ::mesos::master::Event_TaskAdded& task_added() const;
  ::mesos::master::Event_TaskAdded* release_task_added();
  ::mesos::master::Event_TaskAdded* mutable_task_added();
  void set_allocated_task_added(::mesos::master::Event_TaskAdded* task_added);
  void unsafe_arena_set_allocated_task_added(
      ::mesos::master::Event_TaskAdded* task_added);
  ::mesos::master::Event_TaskAdded* unsafe_arena_release_task_added();

  // optional .mesos.master.Event.TaskUpdated task_updated = 4;
  bool has_task_updated() const;
  void clear_task_updated();
  static const int kTaskUpdatedFieldNumber = 4;
  private:
  void _slow_mutable_task_updated();
  public:
  const ::mesos::master::Event_TaskUpdated& task_updated() const;
  ::mesos::master::Event_TaskUpdated* release_task_updated();
  ::mesos::master::Event_TaskUpdated* mutable_task_updated();
  void set_allocated_task_updated(::mesos::master::Event_TaskUpdated* task_updated);
  void unsafe_arena_set_allocated_task_updated(
      ::mesos::master::Event_TaskUpdated* task_updated);
  ::mesos::master::Event_TaskUpdated* unsafe_arena_release_task_updated();

  // optional .mesos.master.Event.AgentAdded agent_added = 5;
  bool has_agent_added() const;
  void clear_agent_added();
  static const int kAgentAddedFieldNumber = 5;
  private:
  void _slow_mutable_agent_added();
  public:
  const ::mesos::master::Event_AgentAdded& agent_added() const;
  ::mesos::master::Event_AgentAdded* release_agent_added();
  ::mesos::master::Event_AgentAdded* mutable_agent_added();
  void set_allocated_agent_added(::mesos::master::Event_AgentAdded* agent_added);
  void unsafe_arena_set_allocated_agent_added(
      ::mesos::master::Event_AgentAdded* agent_added);
  ::mesos::master::Event_AgentAdded* unsafe_arena_release_agent_added();

  // optional .mesos.master.Event.AgentRemoved agent_removed = 6;
  bool has_agent_removed() const;
  void clear_agent_removed();
  static const int kAgentRemovedFieldNumber = 6;
  private:
  void _slow_mutable_agent_removed();
  public:
  const ::mesos::master::Event_AgentRemoved& agent_removed() const;
  ::mesos::master::Event_AgentRemoved* release_agent_removed();
  ::mesos::master::Event_AgentRemoved* mutable_agent_removed();
  void set_allocated_agent_removed(::mesos::master::Event_AgentRemoved* agent_removed);
  void unsafe_arena_set_allocated_agent_removed(
      ::mesos::master::Event_AgentRemoved* agent_removed);
  ::mesos::master::Event_AgentRemoved* unsafe_arena_release_agent_removed();

  // optional .mesos.master.Event.FrameworkAdded framework_added = 7;
  bool has_framework_added() const;
  void clear_framework_added();
  static const int kFrameworkAddedFieldNumber = 7;
  private:
  void _slow_mutable_framework_added();
  public:
  const ::mesos::master::Event_FrameworkAdded& framework_added() const;
  ::mesos::master::Event_FrameworkAdded* release_framework_added();
  ::mesos::master::Event_FrameworkAdded* mutable_framework_added();
  void set_allocated_framework_added(::mesos::master::Event_FrameworkAdded* framework_added);
  void unsafe_arena_set_allocated_framework_added(
      ::mesos::master::Event_FrameworkAdded* framework_added);
  ::mesos::master::Event_FrameworkAdded* unsafe_arena_release_framework_added();

  // optional .mesos.master.Event.FrameworkUpdated framework_updated = 8;
  bool has_framework_updated() const;
  void clear_framework_updated();
  static const int kFrameworkUpdatedFieldNumber = 8;
  private:
  void _slow_mutable_framework_updated();
  public:
  const ::mesos::master::Event_FrameworkUpdated& framework_updated() const;
  ::mesos::master::Event_FrameworkUpdated* release_framework_updated();
  ::mesos::master::Event_FrameworkUpdated* mutable_framework_updated();
  void set_allocated_framework_updated(::mesos::master::Event_FrameworkUpdated* framework_updated);
  void unsafe_arena_set_allocated_framework_updated(
      ::mesos::master::Event_FrameworkUpdated* framework_updated);
  ::mesos::master::Event_FrameworkUpdated* unsafe_arena_release_framework_updated();

  // optional .mesos.master.Event.FrameworkRemoved framework_removed = 9;
  bool has_framework_removed() const;
  void clear_framework_removed();
  static const int kFrameworkRemovedFieldNumber = 9;
  private:
  void _slow_mutable_framework_removed();
  public:
  const ::mesos::master::Event_FrameworkRemoved& framework_removed() const;
  ::mesos::master::Event_FrameworkRemoved* release_framework_removed();
  ::mesos::master::Event_FrameworkRemoved* mutable_framework_removed();
  void set_allocated_framework_removed(::mesos::master::Event_FrameworkRemoved* framework_removed);
  void unsafe_arena_set_allocated_framework_removed(
      ::mesos::master::Event_FrameworkRemoved* framework_removed);
  ::mesos::master::Event_FrameworkRemoved* unsafe_arena_release_framework_removed();

  // optional .mesos.master.Event.Type type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::mesos::master::Event_Type type() const;
  void set_type(::mesos::master::Event_Type value);

  // @@protoc_insertion_point(class_scope:mesos.master.Event)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_subscribed();
  void clear_has_subscribed();
  void set_has_task_added();
  void clear_has_task_added();
  void set_has_task_updated();
  void clear_has_task_updated();
  void set_has_agent_added();
  void clear_has_agent_added();
  void set_has_agent_removed();
  void clear_has_agent_removed();
  void set_has_framework_added();
  void clear_has_framework_added();
  void set_has_framework_updated();
  void clear_has_framework_updated();
  void set_has_framework_removed();
  void clear_has_framework_removed();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::master::Event_Subscribed* subscribed_;
  ::mesos::master::Event_TaskAdded* task_added_;
  ::mesos::master::Event_TaskUpdated* task_updated_;
  ::mesos::master::Event_AgentAdded* agent_added_;
  ::mesos::master::Event_AgentRemoved* agent_removed_;
  ::mesos::master::Event_FrameworkAdded* framework_added_;
  ::mesos::master::Event_FrameworkUpdated* framework_updated_;
  ::mesos::master::Event_FrameworkRemoved* framework_removed_;
  int type_;
  friend struct ::protobuf_mesos_2fmaster_2fmaster_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmaster_2fmaster_2eproto::InitDefaultsEventImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Call_GetMetrics

// optional .mesos.DurationInfo timeout = 1;
inline bool Call_GetMetrics::has_timeout() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Call_GetMetrics::set_has_timeout() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Call_GetMetrics::clear_has_timeout() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::mesos::DurationInfo& Call_GetMetrics::timeout() const {
  const ::mesos::DurationInfo* p = timeout_;
  // @@protoc_insertion_point(field_get:mesos.master.Call.GetMetrics.timeout)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::DurationInfo*>(
      &::mesos::_DurationInfo_default_instance_);
}
inline ::mesos::DurationInfo* Call_GetMetrics::release_timeout() {
  // @@protoc_insertion_point(field_release:mesos.master.Call.GetMetrics.timeout)
  clear_has_timeout();
  ::mesos::DurationInfo* temp = timeout_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  timeout_ = NULL;
  return temp;
}
inline ::mesos::DurationInfo* Call_GetMetrics::unsafe_arena_release_timeout() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.master.Call.GetMetrics.timeout)
  clear_has_timeout();
  ::mesos::DurationInfo* temp = timeout_;
  timeout_ = NULL;
  return temp;
}
inline ::mesos::DurationInfo* Call_GetMetrics::mutable_timeout() {
  set_has_timeout();
  if (timeout_ == NULL) {
    _slow_mutable_timeout();
  }
  // @@protoc_insertion_point(field_mutable:mesos.master.Call.GetMetrics.timeout)
  return timeout_;
}
inline void Call_GetMetrics::set_allocated_timeout(::mesos::DurationInfo* timeout) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(timeout_);
  }
  if (timeout) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(timeout)->GetArena();
    if (message_arena != submessage_arena) {
      timeout = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, timeout, submessage_arena);
    }
    set_has_timeout();
  } else {
    clear_has_timeout();
  }
  timeout_ = timeout;
  // @@protoc_insertion_point(field_set_allocated:mesos.master.Call.GetMetrics.timeout)
}

// -------------------------------------------------------------------

// Call_SetLoggingLevel

// required uint32 level = 1;
inline bool Call_SetLoggingLevel::has_level() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Call_SetLoggingLevel::set_has_level() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Call_SetLoggingLevel::clear_has_level() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Call_SetLoggingLevel::clear_level() {
  level_ = 0u;
  clear_has_level();
}
inline ::google::protobuf::uint32 Call_SetLoggingLevel::level() const {
  // @@protoc_insertion_point(field_get:mesos.master.Call.SetLoggingLevel.level)
  return level_;
}
inline void Call_SetLoggingLevel::set_level(::google::protobuf::uint32 value) {
  set_has_level();
  level_ = value;
  // @@protoc_insertion_point(field_set:mesos.master.Call.SetLoggingLevel.level)
}

// required .mesos.DurationInfo duration = 2;
inline bool Call_SetLoggingLevel::has_duration() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Call_SetLoggingLevel::set_has_duration() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Call_SetLoggingLevel::clear_has_duration() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::mesos::DurationInfo& Call_SetLoggingLevel::duration() const {
  const ::mesos::DurationInfo* p = duration_;
  // @@protoc_insertion_point(field_get:mesos.master.Call.SetLoggingLevel.duration)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::DurationInfo*>(
      &::mesos::_DurationInfo_default_instance_);
}
inline ::mesos::DurationInfo* Call_SetLoggingLevel::release_duration() {
  // @@protoc_insertion_point(field_release:mesos.master.Call.SetLoggingLevel.duration)
  clear_has_duration();
  ::mesos::DurationInfo* temp = duration_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  duration_ = NULL;
  return temp;
}
inline ::mesos::DurationInfo* Call_SetLoggingLevel::unsafe_arena_release_duration() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.master.Call.SetLoggingLevel.duration)
  clear_has_duration();
  ::mesos::DurationInfo* temp = duration_;
  duration_ = NULL;
  return temp;
}
inline ::mesos::DurationInfo* Call_SetLoggingLevel::mutable_duration() {
  set_has_duration();
  if (duration_ == NULL) {
    _slow_mutable_duration();
  }
  // @@protoc_insertion_point(field_mutable:mesos.master.Call.SetLoggingLevel.duration)
  return duration_;
}
inline void Call_SetLoggingLevel::set_allocated_duration(::mesos::DurationInfo* duration) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(duration_);
  }
  if (duration) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(duration)->GetArena();
    if (message_arena != submessage_arena) {
      duration = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, duration, submessage_arena);
    }
    set_has_duration();
  } else {
    clear_has_duration();
  }
  duration_ = duration;
  // @@protoc_insertion_point(field_set_allocated:mesos.master.Call.SetLoggingLevel.duration)
}

// -------------------------------------------------------------------

// Call_ListFiles

// required string path = 1;
inline bool Call_ListFiles::has_path() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Call_ListFiles::set_has_path() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Call_ListFiles::clear_has_path() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Call_ListFiles::clear_path() {
  path_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_path();
}
inline const ::std::string& Call_ListFiles::path() const {
  // @@protoc_insertion_point(field_get:mesos.master.Call.ListFiles.path)
  return path_.Get();
}
inline void Call_ListFiles::set_path(const ::std::string& value) {
  set_has_path();
  path_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.master.Call.ListFiles.path)
}
#if LANG_CXX11
inline void Call_ListFiles::set_path(::std::string&& value) {
  set_has_path();
  path_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.master.Call.ListFiles.path)
}
#endif
inline void Call_ListFiles::set_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_path();
  path_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.master.Call.ListFiles.path)
}
inline void Call_ListFiles::set_path(const char* value,
    size_t size) {
  set_has_path();
  path_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.master.Call.ListFiles.path)
}
inline ::std::string* Call_ListFiles::mutable_path() {
  set_has_path();
  // @@protoc_insertion_point(field_mutable:mesos.master.Call.ListFiles.path)
  return path_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* Call_ListFiles::release_path() {
  // @@protoc_insertion_point(field_release:mesos.master.Call.ListFiles.path)
  clear_has_path();
  return path_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void Call_ListFiles::set_allocated_path(::std::string* path) {
  if (path != NULL) {
    set_has_path();
  } else {
    clear_has_path();
  }
  path_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), path,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.master.Call.ListFiles.path)
}
inline ::std::string* Call_ListFiles::unsafe_arena_release_path() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.master.Call.ListFiles.path)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_path();
  return path_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void Call_ListFiles::unsafe_arena_set_allocated_path(
    ::std::string* path) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (path != NULL) {
    set_has_path();
  } else {
    clear_has_path();
  }
  path_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      path, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.master.Call.ListFiles.path)
}

// -------------------------------------------------------------------

// Call_ReadFile

// required string path = 1;
inline bool Call_ReadFile::has_path() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Call_ReadFile::set_has_path() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Call_ReadFile::clear_has_path() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Call_ReadFile::clear_path() {
  path_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_path();
}
inline const ::std::string& Call_ReadFile::path() const {
  // @@protoc_insertion_point(field_get:mesos.master.Call.ReadFile.path)
  return path_.Get();
}
inline void Call_ReadFile::set_path(const ::std::string& value) {
  set_has_path();
  path_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.master.Call.ReadFile.path)
}
#if LANG_CXX11
inline void Call_ReadFile::set_path(::std::string&& value) {
  set_has_path();
  path_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.master.Call.ReadFile.path)
}
#endif
inline void Call_ReadFile::set_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_path();
  path_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.master.Call.ReadFile.path)
}
inline void Call_ReadFile::set_path(const char* value,
    size_t size) {
  set_has_path();
  path_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.master.Call.ReadFile.path)
}
inline ::std::string* Call_ReadFile::mutable_path() {
  set_has_path();
  // @@protoc_insertion_point(field_mutable:mesos.master.Call.ReadFile.path)
  return path_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* Call_ReadFile::release_path() {
  // @@protoc_insertion_point(field_release:mesos.master.Call.ReadFile.path)
  clear_has_path();
  return path_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void Call_ReadFile::set_allocated_path(::std::string* path) {
  if (path != NULL) {
    set_has_path();
  } else {
    clear_has_path();
  }
  path_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), path,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.master.Call.ReadFile.path)
}
inline ::std::string* Call_ReadFile::unsafe_arena_release_path() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.master.Call.ReadFile.path)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_path();
  return path_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void Call_ReadFile::unsafe_arena_set_allocated_path(
    ::std::string* path) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (path != NULL) {
    set_has_path();
  } else {
    clear_has_path();
  }
  path_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      path, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.master.Call.ReadFile.path)
}

// required uint64 offset = 2;
inline bool Call_ReadFile::has_offset() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Call_ReadFile::set_has_offset() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Call_ReadFile::clear_has_offset() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Call_ReadFile::clear_offset() {
  offset_ = GOOGLE_ULONGLONG(0);
  clear_has_offset();
}
inline ::google::protobuf::uint64 Call_ReadFile::offset() const {
  // @@protoc_insertion_point(field_get:mesos.master.Call.ReadFile.offset)
  return offset_;
}
inline void Call_ReadFile::set_offset(::google::protobuf::uint64 value) {
  set_has_offset();
  offset_ = value;
  // @@protoc_insertion_point(field_set:mesos.master.Call.ReadFile.offset)
}

// optional uint64 length = 3;
inline bool Call_ReadFile::has_length() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Call_ReadFile::set_has_length() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Call_ReadFile::clear_has_length() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Call_ReadFile::clear_length() {
  length_ = GOOGLE_ULONGLONG(0);
  clear_has_length();
}
inline ::google::protobuf::uint64 Call_ReadFile::length() const {
  // @@protoc_insertion_point(field_get:mesos.master.Call.ReadFile.length)
  return length_;
}
inline void Call_ReadFile::set_length(::google::protobuf::uint64 value) {
  set_has_length();
  length_ = value;
  // @@protoc_insertion_point(field_set:mesos.master.Call.ReadFile.length)
}

// -------------------------------------------------------------------

// Call_UpdateWeights

// repeated .mesos.WeightInfo weight_infos = 1;
inline int Call_UpdateWeights::weight_infos_size() const {
  return weight_infos_.size();
}
inline const ::mesos::WeightInfo& Call_UpdateWeights::weight_infos(int index) const {
  // @@protoc_insertion_point(field_get:mesos.master.Call.UpdateWeights.weight_infos)
  return weight_infos_.Get(index);
}
inline ::mesos::WeightInfo* Call_UpdateWeights::mutable_weight_infos(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.master.Call.UpdateWeights.weight_infos)
  return weight_infos_.Mutable(index);
}
inline ::mesos::WeightInfo* Call_UpdateWeights::add_weight_infos() {
  // @@protoc_insertion_point(field_add:mesos.master.Call.UpdateWeights.weight_infos)
  return weight_infos_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::WeightInfo >*
Call_UpdateWeights::mutable_weight_infos() {
  // @@protoc_insertion_point(field_mutable_list:mesos.master.Call.UpdateWeights.weight_infos)
  return &weight_infos_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::WeightInfo >&
Call_UpdateWeights::weight_infos() const {
  // @@protoc_insertion_point(field_list:mesos.master.Call.UpdateWeights.weight_infos)
  return weight_infos_;
}

// -------------------------------------------------------------------

// Call_ReserveResources

// required .mesos.SlaveID slave_id = 1;
inline bool Call_ReserveResources::has_slave_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Call_ReserveResources::set_has_slave_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Call_ReserveResources::clear_has_slave_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::mesos::SlaveID& Call_ReserveResources::slave_id() const {
  const ::mesos::SlaveID* p = slave_id_;
  // @@protoc_insertion_point(field_get:mesos.master.Call.ReserveResources.slave_id)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::SlaveID*>(
      &::mesos::_SlaveID_default_instance_);
}
inline ::mesos::SlaveID* Call_ReserveResources::release_slave_id() {
  // @@protoc_insertion_point(field_release:mesos.master.Call.ReserveResources.slave_id)
  clear_has_slave_id();
  ::mesos::SlaveID* temp = slave_id_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  slave_id_ = NULL;
  return temp;
}
inline ::mesos::SlaveID* Call_ReserveResources::unsafe_arena_release_slave_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.master.Call.ReserveResources.slave_id)
  clear_has_slave_id();
  ::mesos::SlaveID* temp = slave_id_;
  slave_id_ = NULL;
  return temp;
}
inline ::mesos::SlaveID* Call_ReserveResources::mutable_slave_id() {
  set_has_slave_id();
  if (slave_id_ == NULL) {
    _slow_mutable_slave_id();
  }
  // @@protoc_insertion_point(field_mutable:mesos.master.Call.ReserveResources.slave_id)
  return slave_id_;
}
inline void Call_ReserveResources::set_allocated_slave_id(::mesos::SlaveID* slave_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(slave_id_);
  }
  if (slave_id) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(slave_id)->GetArena();
    if (message_arena != submessage_arena) {
      slave_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, slave_id, submessage_arena);
    }
    set_has_slave_id();
  } else {
    clear_has_slave_id();
  }
  slave_id_ = slave_id;
  // @@protoc_insertion_point(field_set_allocated:mesos.master.Call.ReserveResources.slave_id)
}

// repeated .mesos.Resource resources = 2;
inline int Call_ReserveResources::resources_size() const {
  return resources_.size();
}
inline const ::mesos::Resource& Call_ReserveResources::resources(int index) const {
  // @@protoc_insertion_point(field_get:mesos.master.Call.ReserveResources.resources)
  return resources_.Get(index);
}
inline ::mesos::Resource* Call_ReserveResources::mutable_resources(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.master.Call.ReserveResources.resources)
  return resources_.Mutable(index);
}
inline ::mesos::Resource* Call_ReserveResources::add_resources() {
  // @@protoc_insertion_point(field_add:mesos.master.Call.ReserveResources.resources)
  return resources_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
Call_ReserveResources::mutable_resources() {
  // @@protoc_insertion_point(field_mutable_list:mesos.master.Call.ReserveResources.resources)
  return &resources_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
Call_ReserveResources::resources() const {
  // @@protoc_insertion_point(field_list:mesos.master.Call.ReserveResources.resources)
  return resources_;
}

// -------------------------------------------------------------------

// Call_UnreserveResources

// required .mesos.SlaveID slave_id = 1;
inline bool Call_UnreserveResources::has_slave_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Call_UnreserveResources::set_has_slave_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Call_UnreserveResources::clear_has_slave_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::mesos::SlaveID& Call_UnreserveResources::slave_id() const {
  const ::mesos::SlaveID* p = slave_id_;
  // @@protoc_insertion_point(field_get:mesos.master.Call.UnreserveResources.slave_id)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::SlaveID*>(
      &::mesos::_SlaveID_default_instance_);
}
inline ::mesos::SlaveID* Call_UnreserveResources::release_slave_id() {
  // @@protoc_insertion_point(field_release:mesos.master.Call.UnreserveResources.slave_id)
  clear_has_slave_id();
  ::mesos::SlaveID* temp = slave_id_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  slave_id_ = NULL;
  return temp;
}
inline ::mesos::SlaveID* Call_UnreserveResources::unsafe_arena_release_slave_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.master.Call.UnreserveResources.slave_id)
  clear_has_slave_id();
  ::mesos::SlaveID* temp = slave_id_;
  slave_id_ = NULL;
  return temp;
}
inline ::mesos::SlaveID* Call_UnreserveResources::mutable_slave_id() {
  set_has_slave_id();
  if (slave_id_ == NULL) {
    _slow_mutable_slave_id();
  }
  // @@protoc_insertion_point(field_mutable:mesos.master.Call.UnreserveResources.slave_id)
  return slave_id_;
}
inline void Call_UnreserveResources::set_allocated_slave_id(::mesos::SlaveID* slave_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(slave_id_);
  }
  if (slave_id) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(slave_id)->GetArena();
    if (message_arena != submessage_arena) {
      slave_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, slave_id, submessage_arena);
    }
    set_has_slave_id();
  } else {
    clear_has_slave_id();
  }
  slave_id_ = slave_id;
  // @@protoc_insertion_point(field_set_allocated:mesos.master.Call.UnreserveResources.slave_id)
}

// repeated .mesos.Resource resources = 2;
inline int Call_UnreserveResources::resources_size() const {
  return resources_.size();
}
inline const ::mesos::Resource& Call_UnreserveResources::resources(int index) const {
  // @@protoc_insertion_point(field_get:mesos.master.Call.UnreserveResources.resources)
  return resources_.Get(index);
}
inline ::mesos::Resource* Call_UnreserveResources::mutable_resources(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.master.Call.UnreserveResources.resources)
  return resources_.Mutable(index);
}
inline ::mesos::Resource* Call_UnreserveResources::add_resources() {
  // @@protoc_insertion_point(field_add:mesos.master.Call.UnreserveResources.resources)
  return resources_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
Call_UnreserveResources::mutable_resources() {
  // @@protoc_insertion_point(field_mutable_list:mesos.master.Call.UnreserveResources.resources)
  return &resources_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
Call_UnreserveResources::resources() const {
  // @@protoc_insertion_point(field_list:mesos.master.Call.UnreserveResources.resources)
  return resources_;
}

// -------------------------------------------------------------------

// Call_CreateVolumes

// required .mesos.SlaveID slave_id = 1;
inline bool Call_CreateVolumes::has_slave_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Call_CreateVolumes::set_has_slave_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Call_CreateVolumes::clear_has_slave_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::mesos::SlaveID& Call_CreateVolumes::slave_id() const {
  const ::mesos::SlaveID* p = slave_id_;
  // @@protoc_insertion_point(field_get:mesos.master.Call.CreateVolumes.slave_id)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::SlaveID*>(
      &::mesos::_SlaveID_default_instance_);
}
inline ::mesos::SlaveID* Call_CreateVolumes::release_slave_id() {
  // @@protoc_insertion_point(field_release:mesos.master.Call.CreateVolumes.slave_id)
  clear_has_slave_id();
  ::mesos::SlaveID* temp = slave_id_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  slave_id_ = NULL;
  return temp;
}
inline ::mesos::SlaveID* Call_CreateVolumes::unsafe_arena_release_slave_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.master.Call.CreateVolumes.slave_id)
  clear_has_slave_id();
  ::mesos::SlaveID* temp = slave_id_;
  slave_id_ = NULL;
  return temp;
}
inline ::mesos::SlaveID* Call_CreateVolumes::mutable_slave_id() {
  set_has_slave_id();
  if (slave_id_ == NULL) {
    _slow_mutable_slave_id();
  }
  // @@protoc_insertion_point(field_mutable:mesos.master.Call.CreateVolumes.slave_id)
  return slave_id_;
}
inline void Call_CreateVolumes::set_allocated_slave_id(::mesos::SlaveID* slave_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(slave_id_);
  }
  if (slave_id) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(slave_id)->GetArena();
    if (message_arena != submessage_arena) {
      slave_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, slave_id, submessage_arena);
    }
    set_has_slave_id();
  } else {
    clear_has_slave_id();
  }
  slave_id_ = slave_id;
  // @@protoc_insertion_point(field_set_allocated:mesos.master.Call.CreateVolumes.slave_id)
}

// repeated .mesos.Resource volumes = 2;
inline int Call_CreateVolumes::volumes_size() const {
  return volumes_.size();
}
inline const ::mesos::Resource& Call_CreateVolumes::volumes(int index) const {
  // @@protoc_insertion_point(field_get:mesos.master.Call.CreateVolumes.volumes)
  return volumes_.Get(index);
}
inline ::mesos::Resource* Call_CreateVolumes::mutable_volumes(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.master.Call.CreateVolumes.volumes)
  return volumes_.Mutable(index);
}
inline ::mesos::Resource* Call_CreateVolumes::add_volumes() {
  // @@protoc_insertion_point(field_add:mesos.master.Call.CreateVolumes.volumes)
  return volumes_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
Call_CreateVolumes::mutable_volumes() {
  // @@protoc_insertion_point(field_mutable_list:mesos.master.Call.CreateVolumes.volumes)
  return &volumes_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
Call_CreateVolumes::volumes() const {
  // @@protoc_insertion_point(field_list:mesos.master.Call.CreateVolumes.volumes)
  return volumes_;
}

// -------------------------------------------------------------------

// Call_DestroyVolumes

// required .mesos.SlaveID slave_id = 1;
inline bool Call_DestroyVolumes::has_slave_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Call_DestroyVolumes::set_has_slave_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Call_DestroyVolumes::clear_has_slave_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::mesos::SlaveID& Call_DestroyVolumes::slave_id() const {
  const ::mesos::SlaveID* p = slave_id_;
  // @@protoc_insertion_point(field_get:mesos.master.Call.DestroyVolumes.slave_id)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::SlaveID*>(
      &::mesos::_SlaveID_default_instance_);
}
inline ::mesos::SlaveID* Call_DestroyVolumes::release_slave_id() {
  // @@protoc_insertion_point(field_release:mesos.master.Call.DestroyVolumes.slave_id)
  clear_has_slave_id();
  ::mesos::SlaveID* temp = slave_id_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  slave_id_ = NULL;
  return temp;
}
inline ::mesos::SlaveID* Call_DestroyVolumes::unsafe_arena_release_slave_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.master.Call.DestroyVolumes.slave_id)
  clear_has_slave_id();
  ::mesos::SlaveID* temp = slave_id_;
  slave_id_ = NULL;
  return temp;
}
inline ::mesos::SlaveID* Call_DestroyVolumes::mutable_slave_id() {
  set_has_slave_id();
  if (slave_id_ == NULL) {
    _slow_mutable_slave_id();
  }
  // @@protoc_insertion_point(field_mutable:mesos.master.Call.DestroyVolumes.slave_id)
  return slave_id_;
}
inline void Call_DestroyVolumes::set_allocated_slave_id(::mesos::SlaveID* slave_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(slave_id_);
  }
  if (slave_id) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(slave_id)->GetArena();
    if (message_arena != submessage_arena) {
      slave_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, slave_id, submessage_arena);
    }
    set_has_slave_id();
  } else {
    clear_has_slave_id();
  }
  slave_id_ = slave_id;
  // @@protoc_insertion_point(field_set_allocated:mesos.master.Call.DestroyVolumes.slave_id)
}

// repeated .mesos.Resource volumes = 2;
inline int Call_DestroyVolumes::volumes_size() const {
  return volumes_.size();
}
inline const ::mesos::Resource& Call_DestroyVolumes::volumes(int index) const {
  // @@protoc_insertion_point(field_get:mesos.master.Call.DestroyVolumes.volumes)
  return volumes_.Get(index);
}
inline ::mesos::Resource* Call_DestroyVolumes::mutable_volumes(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.master.Call.DestroyVolumes.volumes)
  return volumes_.Mutable(index);
}
inline ::mesos::Resource* Call_DestroyVolumes::add_volumes() {
  // @@protoc_insertion_point(field_add:mesos.master.Call.DestroyVolumes.volumes)
  return volumes_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
Call_DestroyVolumes::mutable_volumes() {
  // @@protoc_insertion_point(field_mutable_list:mesos.master.Call.DestroyVolumes.volumes)
  return &volumes_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
Call_DestroyVolumes::volumes() const {
  // @@protoc_insertion_point(field_list:mesos.master.Call.DestroyVolumes.volumes)
  return volumes_;
}

// -------------------------------------------------------------------

// Call_GrowVolume

// optional .mesos.SlaveID slave_id = 1;
inline bool Call_GrowVolume::has_slave_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Call_GrowVolume::set_has_slave_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Call_GrowVolume::clear_has_slave_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::mesos::SlaveID& Call_GrowVolume::slave_id() const {
  const ::mesos::SlaveID* p = slave_id_;
  // @@protoc_insertion_point(field_get:mesos.master.Call.GrowVolume.slave_id)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::SlaveID*>(
      &::mesos::_SlaveID_default_instance_);
}
inline ::mesos::SlaveID* Call_GrowVolume::release_slave_id() {
  // @@protoc_insertion_point(field_release:mesos.master.Call.GrowVolume.slave_id)
  clear_has_slave_id();
  ::mesos::SlaveID* temp = slave_id_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  slave_id_ = NULL;
  return temp;
}
inline ::mesos::SlaveID* Call_GrowVolume::unsafe_arena_release_slave_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.master.Call.GrowVolume.slave_id)
  clear_has_slave_id();
  ::mesos::SlaveID* temp = slave_id_;
  slave_id_ = NULL;
  return temp;
}
inline ::mesos::SlaveID* Call_GrowVolume::mutable_slave_id() {
  set_has_slave_id();
  if (slave_id_ == NULL) {
    _slow_mutable_slave_id();
  }
  // @@protoc_insertion_point(field_mutable:mesos.master.Call.GrowVolume.slave_id)
  return slave_id_;
}
inline void Call_GrowVolume::set_allocated_slave_id(::mesos::SlaveID* slave_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(slave_id_);
  }
  if (slave_id) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(slave_id)->GetArena();
    if (message_arena != submessage_arena) {
      slave_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, slave_id, submessage_arena);
    }
    set_has_slave_id();
  } else {
    clear_has_slave_id();
  }
  slave_id_ = slave_id;
  // @@protoc_insertion_point(field_set_allocated:mesos.master.Call.GrowVolume.slave_id)
}

// required .mesos.Resource volume = 2;
inline bool Call_GrowVolume::has_volume() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Call_GrowVolume::set_has_volume() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Call_GrowVolume::clear_has_volume() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::mesos::Resource& Call_GrowVolume::volume() const {
  const ::mesos::Resource* p = volume_;
  // @@protoc_insertion_point(field_get:mesos.master.Call.GrowVolume.volume)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::Resource*>(
      &::mesos::_Resource_default_instance_);
}
inline ::mesos::Resource* Call_GrowVolume::release_volume() {
  // @@protoc_insertion_point(field_release:mesos.master.Call.GrowVolume.volume)
  clear_has_volume();
  ::mesos::Resource* temp = volume_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  volume_ = NULL;
  return temp;
}
inline ::mesos::Resource* Call_GrowVolume::unsafe_arena_release_volume() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.master.Call.GrowVolume.volume)
  clear_has_volume();
  ::mesos::Resource* temp = volume_;
  volume_ = NULL;
  return temp;
}
inline ::mesos::Resource* Call_GrowVolume::mutable_volume() {
  set_has_volume();
  if (volume_ == NULL) {
    _slow_mutable_volume();
  }
  // @@protoc_insertion_point(field_mutable:mesos.master.Call.GrowVolume.volume)
  return volume_;
}
inline void Call_GrowVolume::set_allocated_volume(::mesos::Resource* volume) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(volume_);
  }
  if (volume) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(volume)->GetArena();
    if (message_arena != submessage_arena) {
      volume = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, volume, submessage_arena);
    }
    set_has_volume();
  } else {
    clear_has_volume();
  }
  volume_ = volume;
  // @@protoc_insertion_point(field_set_allocated:mesos.master.Call.GrowVolume.volume)
}

// required .mesos.Resource addition = 3;
inline bool Call_GrowVolume::has_addition() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Call_GrowVolume::set_has_addition() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Call_GrowVolume::clear_has_addition() {
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::mesos::Resource& Call_GrowVolume::addition() const {
  const ::mesos::Resource* p = addition_;
  // @@protoc_insertion_point(field_get:mesos.master.Call.GrowVolume.addition)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::Resource*>(
      &::mesos::_Resource_default_instance_);
}
inline ::mesos::Resource* Call_GrowVolume::release_addition() {
  // @@protoc_insertion_point(field_release:mesos.master.Call.GrowVolume.addition)
  clear_has_addition();
  ::mesos::Resource* temp = addition_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  addition_ = NULL;
  return temp;
}
inline ::mesos::Resource* Call_GrowVolume::unsafe_arena_release_addition() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.master.Call.GrowVolume.addition)
  clear_has_addition();
  ::mesos::Resource* temp = addition_;
  addition_ = NULL;
  return temp;
}
inline ::mesos::Resource* Call_GrowVolume::mutable_addition() {
  set_has_addition();
  if (addition_ == NULL) {
    _slow_mutable_addition();
  }
  // @@protoc_insertion_point(field_mutable:mesos.master.Call.GrowVolume.addition)
  return addition_;
}
inline void Call_GrowVolume::set_allocated_addition(::mesos::Resource* addition) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(addition_);
  }
  if (addition) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(addition)->GetArena();
    if (message_arena != submessage_arena) {
      addition = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, addition, submessage_arena);
    }
    set_has_addition();
  } else {
    clear_has_addition();
  }
  addition_ = addition;
  // @@protoc_insertion_point(field_set_allocated:mesos.master.Call.GrowVolume.addition)
}

// -------------------------------------------------------------------

// Call_ShrinkVolume

// optional .mesos.SlaveID slave_id = 1;
inline bool Call_ShrinkVolume::has_slave_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Call_ShrinkVolume::set_has_slave_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Call_ShrinkVolume::clear_has_slave_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::mesos::SlaveID& Call_ShrinkVolume::slave_id() const {
  const ::mesos::SlaveID* p = slave_id_;
  // @@protoc_insertion_point(field_get:mesos.master.Call.ShrinkVolume.slave_id)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::SlaveID*>(
      &::mesos::_SlaveID_default_instance_);
}
inline ::mesos::SlaveID* Call_ShrinkVolume::release_slave_id() {
  // @@protoc_insertion_point(field_release:mesos.master.Call.ShrinkVolume.slave_id)
  clear_has_slave_id();
  ::mesos::SlaveID* temp = slave_id_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  slave_id_ = NULL;
  return temp;
}
inline ::mesos::SlaveID* Call_ShrinkVolume::unsafe_arena_release_slave_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.master.Call.ShrinkVolume.slave_id)
  clear_has_slave_id();
  ::mesos::SlaveID* temp = slave_id_;
  slave_id_ = NULL;
  return temp;
}
inline ::mesos::SlaveID* Call_ShrinkVolume::mutable_slave_id() {
  set_has_slave_id();
  if (slave_id_ == NULL) {
    _slow_mutable_slave_id();
  }
  // @@protoc_insertion_point(field_mutable:mesos.master.Call.ShrinkVolume.slave_id)
  return slave_id_;
}
inline void Call_ShrinkVolume::set_allocated_slave_id(::mesos::SlaveID* slave_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(slave_id_);
  }
  if (slave_id) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(slave_id)->GetArena();
    if (message_arena != submessage_arena) {
      slave_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, slave_id, submessage_arena);
    }
    set_has_slave_id();
  } else {
    clear_has_slave_id();
  }
  slave_id_ = slave_id;
  // @@protoc_insertion_point(field_set_allocated:mesos.master.Call.ShrinkVolume.slave_id)
}

// required .mesos.Resource volume = 2;
inline bool Call_ShrinkVolume::has_volume() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Call_ShrinkVolume::set_has_volume() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Call_ShrinkVolume::clear_has_volume() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::mesos::Resource& Call_ShrinkVolume::volume() const {
  const ::mesos::Resource* p = volume_;
  // @@protoc_insertion_point(field_get:mesos.master.Call.ShrinkVolume.volume)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::Resource*>(
      &::mesos::_Resource_default_instance_);
}
inline ::mesos::Resource* Call_ShrinkVolume::release_volume() {
  // @@protoc_insertion_point(field_release:mesos.master.Call.ShrinkVolume.volume)
  clear_has_volume();
  ::mesos::Resource* temp = volume_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  volume_ = NULL;
  return temp;
}
inline ::mesos::Resource* Call_ShrinkVolume::unsafe_arena_release_volume() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.master.Call.ShrinkVolume.volume)
  clear_has_volume();
  ::mesos::Resource* temp = volume_;
  volume_ = NULL;
  return temp;
}
inline ::mesos::Resource* Call_ShrinkVolume::mutable_volume() {
  set_has_volume();
  if (volume_ == NULL) {
    _slow_mutable_volume();
  }
  // @@protoc_insertion_point(field_mutable:mesos.master.Call.ShrinkVolume.volume)
  return volume_;
}
inline void Call_ShrinkVolume::set_allocated_volume(::mesos::Resource* volume) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(volume_);
  }
  if (volume) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(volume)->GetArena();
    if (message_arena != submessage_arena) {
      volume = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, volume, submessage_arena);
    }
    set_has_volume();
  } else {
    clear_has_volume();
  }
  volume_ = volume;
  // @@protoc_insertion_point(field_set_allocated:mesos.master.Call.ShrinkVolume.volume)
}

// required .mesos.Value.Scalar subtract = 3;
inline bool Call_ShrinkVolume::has_subtract() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Call_ShrinkVolume::set_has_subtract() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Call_ShrinkVolume::clear_has_subtract() {
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::mesos::Value_Scalar& Call_ShrinkVolume::subtract() const {
  const ::mesos::Value_Scalar* p = subtract_;
  // @@protoc_insertion_point(field_get:mesos.master.Call.ShrinkVolume.subtract)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::Value_Scalar*>(
      &::mesos::_Value_Scalar_default_instance_);
}
inline ::mesos::Value_Scalar* Call_ShrinkVolume::release_subtract() {
  // @@protoc_insertion_point(field_release:mesos.master.Call.ShrinkVolume.subtract)
  clear_has_subtract();
  ::mesos::Value_Scalar* temp = subtract_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  subtract_ = NULL;
  return temp;
}
inline ::mesos::Value_Scalar* Call_ShrinkVolume::unsafe_arena_release_subtract() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.master.Call.ShrinkVolume.subtract)
  clear_has_subtract();
  ::mesos::Value_Scalar* temp = subtract_;
  subtract_ = NULL;
  return temp;
}
inline ::mesos::Value_Scalar* Call_ShrinkVolume::mutable_subtract() {
  set_has_subtract();
  if (subtract_ == NULL) {
    _slow_mutable_subtract();
  }
  // @@protoc_insertion_point(field_mutable:mesos.master.Call.ShrinkVolume.subtract)
  return subtract_;
}
inline void Call_ShrinkVolume::set_allocated_subtract(::mesos::Value_Scalar* subtract) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(subtract_);
  }
  if (subtract) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(subtract)->GetArena();
    if (message_arena != submessage_arena) {
      subtract = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, subtract, submessage_arena);
    }
    set_has_subtract();
  } else {
    clear_has_subtract();
  }
  subtract_ = subtract;
  // @@protoc_insertion_point(field_set_allocated:mesos.master.Call.ShrinkVolume.subtract)
}

// -------------------------------------------------------------------

// Call_UpdateMaintenanceSchedule

// required .mesos.maintenance.Schedule schedule = 1;
inline bool Call_UpdateMaintenanceSchedule::has_schedule() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Call_UpdateMaintenanceSchedule::set_has_schedule() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Call_UpdateMaintenanceSchedule::clear_has_schedule() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::mesos::maintenance::Schedule& Call_UpdateMaintenanceSchedule::schedule() const {
  const ::mesos::maintenance::Schedule* p = schedule_;
  // @@protoc_insertion_point(field_get:mesos.master.Call.UpdateMaintenanceSchedule.schedule)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::maintenance::Schedule*>(
      &::mesos::maintenance::_Schedule_default_instance_);
}
inline ::mesos::maintenance::Schedule* Call_UpdateMaintenanceSchedule::release_schedule() {
  // @@protoc_insertion_point(field_release:mesos.master.Call.UpdateMaintenanceSchedule.schedule)
  clear_has_schedule();
  ::mesos::maintenance::Schedule* temp = schedule_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  schedule_ = NULL;
  return temp;
}
inline ::mesos::maintenance::Schedule* Call_UpdateMaintenanceSchedule::unsafe_arena_release_schedule() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.master.Call.UpdateMaintenanceSchedule.schedule)
  clear_has_schedule();
  ::mesos::maintenance::Schedule* temp = schedule_;
  schedule_ = NULL;
  return temp;
}
inline ::mesos::maintenance::Schedule* Call_UpdateMaintenanceSchedule::mutable_schedule() {
  set_has_schedule();
  if (schedule_ == NULL) {
    _slow_mutable_schedule();
  }
  // @@protoc_insertion_point(field_mutable:mesos.master.Call.UpdateMaintenanceSchedule.schedule)
  return schedule_;
}
inline void Call_UpdateMaintenanceSchedule::set_allocated_schedule(::mesos::maintenance::Schedule* schedule) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(schedule_);
  }
  if (schedule) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      schedule = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, schedule, submessage_arena);
    }
    set_has_schedule();
  } else {
    clear_has_schedule();
  }
  schedule_ = schedule;
  // @@protoc_insertion_point(field_set_allocated:mesos.master.Call.UpdateMaintenanceSchedule.schedule)
}

// -------------------------------------------------------------------

// Call_StartMaintenance

// repeated .mesos.MachineID machines = 1;
inline int Call_StartMaintenance::machines_size() const {
  return machines_.size();
}
inline const ::mesos::MachineID& Call_StartMaintenance::machines(int index) const {
  // @@protoc_insertion_point(field_get:mesos.master.Call.StartMaintenance.machines)
  return machines_.Get(index);
}
inline ::mesos::MachineID* Call_StartMaintenance::mutable_machines(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.master.Call.StartMaintenance.machines)
  return machines_.Mutable(index);
}
inline ::mesos::MachineID* Call_StartMaintenance::add_machines() {
  // @@protoc_insertion_point(field_add:mesos.master.Call.StartMaintenance.machines)
  return machines_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::MachineID >*
Call_StartMaintenance::mutable_machines() {
  // @@protoc_insertion_point(field_mutable_list:mesos.master.Call.StartMaintenance.machines)
  return &machines_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::MachineID >&
Call_StartMaintenance::machines() const {
  // @@protoc_insertion_point(field_list:mesos.master.Call.StartMaintenance.machines)
  return machines_;
}

// -------------------------------------------------------------------

// Call_StopMaintenance

// repeated .mesos.MachineID machines = 1;
inline int Call_StopMaintenance::machines_size() const {
  return machines_.size();
}
inline const ::mesos::MachineID& Call_StopMaintenance::machines(int index) const {
  // @@protoc_insertion_point(field_get:mesos.master.Call.StopMaintenance.machines)
  return machines_.Get(index);
}
inline ::mesos::MachineID* Call_StopMaintenance::mutable_machines(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.master.Call.StopMaintenance.machines)
  return machines_.Mutable(index);
}
inline ::mesos::MachineID* Call_StopMaintenance::add_machines() {
  // @@protoc_insertion_point(field_add:mesos.master.Call.StopMaintenance.machines)
  return machines_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::MachineID >*
Call_StopMaintenance::mutable_machines() {
  // @@protoc_insertion_point(field_mutable_list:mesos.master.Call.StopMaintenance.machines)
  return &machines_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::MachineID >&
Call_StopMaintenance::machines() const {
  // @@protoc_insertion_point(field_list:mesos.master.Call.StopMaintenance.machines)
  return machines_;
}

// -------------------------------------------------------------------

// Call_SetQuota

// required .mesos.quota.QuotaRequest quota_request = 1;
inline bool Call_SetQuota::has_quota_request() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Call_SetQuota::set_has_quota_request() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Call_SetQuota::clear_has_quota_request() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::mesos::quota::QuotaRequest& Call_SetQuota::quota_request() const {
  const ::mesos::quota::QuotaRequest* p = quota_request_;
  // @@protoc_insertion_point(field_get:mesos.master.Call.SetQuota.quota_request)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::quota::QuotaRequest*>(
      &::mesos::quota::_QuotaRequest_default_instance_);
}
inline ::mesos::quota::QuotaRequest* Call_SetQuota::release_quota_request() {
  // @@protoc_insertion_point(field_release:mesos.master.Call.SetQuota.quota_request)
  clear_has_quota_request();
  ::mesos::quota::QuotaRequest* temp = quota_request_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  quota_request_ = NULL;
  return temp;
}
inline ::mesos::quota::QuotaRequest* Call_SetQuota::unsafe_arena_release_quota_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.master.Call.SetQuota.quota_request)
  clear_has_quota_request();
  ::mesos::quota::QuotaRequest* temp = quota_request_;
  quota_request_ = NULL;
  return temp;
}
inline ::mesos::quota::QuotaRequest* Call_SetQuota::mutable_quota_request() {
  set_has_quota_request();
  if (quota_request_ == NULL) {
    _slow_mutable_quota_request();
  }
  // @@protoc_insertion_point(field_mutable:mesos.master.Call.SetQuota.quota_request)
  return quota_request_;
}
inline void Call_SetQuota::set_allocated_quota_request(::mesos::quota::QuotaRequest* quota_request) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(quota_request_);
  }
  if (quota_request) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      quota_request = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, quota_request, submessage_arena);
    }
    set_has_quota_request();
  } else {
    clear_has_quota_request();
  }
  quota_request_ = quota_request;
  // @@protoc_insertion_point(field_set_allocated:mesos.master.Call.SetQuota.quota_request)
}

// -------------------------------------------------------------------

// Call_RemoveQuota

// required string role = 1;
inline bool Call_RemoveQuota::has_role() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Call_RemoveQuota::set_has_role() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Call_RemoveQuota::clear_has_role() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Call_RemoveQuota::clear_role() {
  role_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_role();
}
inline const ::std::string& Call_RemoveQuota::role() const {
  // @@protoc_insertion_point(field_get:mesos.master.Call.RemoveQuota.role)
  return role_.Get();
}
inline void Call_RemoveQuota::set_role(const ::std::string& value) {
  set_has_role();
  role_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.master.Call.RemoveQuota.role)
}
#if LANG_CXX11
inline void Call_RemoveQuota::set_role(::std::string&& value) {
  set_has_role();
  role_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.master.Call.RemoveQuota.role)
}
#endif
inline void Call_RemoveQuota::set_role(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_role();
  role_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.master.Call.RemoveQuota.role)
}
inline void Call_RemoveQuota::set_role(const char* value,
    size_t size) {
  set_has_role();
  role_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.master.Call.RemoveQuota.role)
}
inline ::std::string* Call_RemoveQuota::mutable_role() {
  set_has_role();
  // @@protoc_insertion_point(field_mutable:mesos.master.Call.RemoveQuota.role)
  return role_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* Call_RemoveQuota::release_role() {
  // @@protoc_insertion_point(field_release:mesos.master.Call.RemoveQuota.role)
  clear_has_role();
  return role_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void Call_RemoveQuota::set_allocated_role(::std::string* role) {
  if (role != NULL) {
    set_has_role();
  } else {
    clear_has_role();
  }
  role_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), role,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.master.Call.RemoveQuota.role)
}
inline ::std::string* Call_RemoveQuota::unsafe_arena_release_role() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.master.Call.RemoveQuota.role)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_role();
  return role_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void Call_RemoveQuota::unsafe_arena_set_allocated_role(
    ::std::string* role) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (role != NULL) {
    set_has_role();
  } else {
    clear_has_role();
  }
  role_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      role, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.master.Call.RemoveQuota.role)
}

// -------------------------------------------------------------------

// Call_Teardown

// required .mesos.FrameworkID framework_id = 1;
inline bool Call_Teardown::has_framework_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Call_Teardown::set_has_framework_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Call_Teardown::clear_has_framework_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::mesos::FrameworkID& Call_Teardown::framework_id() const {
  const ::mesos::FrameworkID* p = framework_id_;
  // @@protoc_insertion_point(field_get:mesos.master.Call.Teardown.framework_id)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::FrameworkID*>(
      &::mesos::_FrameworkID_default_instance_);
}
inline ::mesos::FrameworkID* Call_Teardown::release_framework_id() {
  // @@protoc_insertion_point(field_release:mesos.master.Call.Teardown.framework_id)
  clear_has_framework_id();
  ::mesos::FrameworkID* temp = framework_id_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  framework_id_ = NULL;
  return temp;
}
inline ::mesos::FrameworkID* Call_Teardown::unsafe_arena_release_framework_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.master.Call.Teardown.framework_id)
  clear_has_framework_id();
  ::mesos::FrameworkID* temp = framework_id_;
  framework_id_ = NULL;
  return temp;
}
inline ::mesos::FrameworkID* Call_Teardown::mutable_framework_id() {
  set_has_framework_id();
  if (framework_id_ == NULL) {
    _slow_mutable_framework_id();
  }
  // @@protoc_insertion_point(field_mutable:mesos.master.Call.Teardown.framework_id)
  return framework_id_;
}
inline void Call_Teardown::set_allocated_framework_id(::mesos::FrameworkID* framework_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(framework_id_);
  }
  if (framework_id) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(framework_id)->GetArena();
    if (message_arena != submessage_arena) {
      framework_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, framework_id, submessage_arena);
    }
    set_has_framework_id();
  } else {
    clear_has_framework_id();
  }
  framework_id_ = framework_id;
  // @@protoc_insertion_point(field_set_allocated:mesos.master.Call.Teardown.framework_id)
}

// -------------------------------------------------------------------

// Call_MarkAgentGone

// required .mesos.SlaveID slave_id = 1;
inline bool Call_MarkAgentGone::has_slave_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Call_MarkAgentGone::set_has_slave_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Call_MarkAgentGone::clear_has_slave_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::mesos::SlaveID& Call_MarkAgentGone::slave_id() const {
  const ::mesos::SlaveID* p = slave_id_;
  // @@protoc_insertion_point(field_get:mesos.master.Call.MarkAgentGone.slave_id)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::SlaveID*>(
      &::mesos::_SlaveID_default_instance_);
}
inline ::mesos::SlaveID* Call_MarkAgentGone::release_slave_id() {
  // @@protoc_insertion_point(field_release:mesos.master.Call.MarkAgentGone.slave_id)
  clear_has_slave_id();
  ::mesos::SlaveID* temp = slave_id_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  slave_id_ = NULL;
  return temp;
}
inline ::mesos::SlaveID* Call_MarkAgentGone::unsafe_arena_release_slave_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.master.Call.MarkAgentGone.slave_id)
  clear_has_slave_id();
  ::mesos::SlaveID* temp = slave_id_;
  slave_id_ = NULL;
  return temp;
}
inline ::mesos::SlaveID* Call_MarkAgentGone::mutable_slave_id() {
  set_has_slave_id();
  if (slave_id_ == NULL) {
    _slow_mutable_slave_id();
  }
  // @@protoc_insertion_point(field_mutable:mesos.master.Call.MarkAgentGone.slave_id)
  return slave_id_;
}
inline void Call_MarkAgentGone::set_allocated_slave_id(::mesos::SlaveID* slave_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(slave_id_);
  }
  if (slave_id) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(slave_id)->GetArena();
    if (message_arena != submessage_arena) {
      slave_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, slave_id, submessage_arena);
    }
    set_has_slave_id();
  } else {
    clear_has_slave_id();
  }
  slave_id_ = slave_id;
  // @@protoc_insertion_point(field_set_allocated:mesos.master.Call.MarkAgentGone.slave_id)
}

// -------------------------------------------------------------------

// Call

// optional .mesos.master.Call.Type type = 1;
inline bool Call::has_type() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void Call::set_has_type() {
  _has_bits_[0] |= 0x00040000u;
}
inline void Call::clear_has_type() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void Call::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::mesos::master::Call_Type Call::type() const {
  // @@protoc_insertion_point(field_get:mesos.master.Call.type)
  return static_cast< ::mesos::master::Call_Type >(type_);
}
inline void Call::set_type(::mesos::master::Call_Type value) {
  assert(::mesos::master::Call_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:mesos.master.Call.type)
}

// optional .mesos.master.Call.GetMetrics get_metrics = 2;
inline bool Call::has_get_metrics() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Call::set_has_get_metrics() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Call::clear_has_get_metrics() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Call::clear_get_metrics() {
  if (get_metrics_ != NULL) get_metrics_->Clear();
  clear_has_get_metrics();
}
inline const ::mesos::master::Call_GetMetrics& Call::get_metrics() const {
  const ::mesos::master::Call_GetMetrics* p = get_metrics_;
  // @@protoc_insertion_point(field_get:mesos.master.Call.get_metrics)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::master::Call_GetMetrics*>(
      &::mesos::master::_Call_GetMetrics_default_instance_);
}
inline ::mesos::master::Call_GetMetrics* Call::release_get_metrics() {
  // @@protoc_insertion_point(field_release:mesos.master.Call.get_metrics)
  clear_has_get_metrics();
  ::mesos::master::Call_GetMetrics* temp = get_metrics_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  get_metrics_ = NULL;
  return temp;
}
inline ::mesos::master::Call_GetMetrics* Call::unsafe_arena_release_get_metrics() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.master.Call.get_metrics)
  clear_has_get_metrics();
  ::mesos::master::Call_GetMetrics* temp = get_metrics_;
  get_metrics_ = NULL;
  return temp;
}
inline ::mesos::master::Call_GetMetrics* Call::mutable_get_metrics() {
  set_has_get_metrics();
  if (get_metrics_ == NULL) {
    _slow_mutable_get_metrics();
  }
  // @@protoc_insertion_point(field_mutable:mesos.master.Call.get_metrics)
  return get_metrics_;
}
inline void Call::set_allocated_get_metrics(::mesos::master::Call_GetMetrics* get_metrics) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete get_metrics_;
  }
  if (get_metrics) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(get_metrics);
    if (message_arena != submessage_arena) {
      get_metrics = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, get_metrics, submessage_arena);
    }
    set_has_get_metrics();
  } else {
    clear_has_get_metrics();
  }
  get_metrics_ = get_metrics;
  // @@protoc_insertion_point(field_set_allocated:mesos.master.Call.get_metrics)
}

// optional .mesos.master.Call.SetLoggingLevel set_logging_level = 3;
inline bool Call::has_set_logging_level() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Call::set_has_set_logging_level() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Call::clear_has_set_logging_level() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Call::clear_set_logging_level() {
  if (set_logging_level_ != NULL) set_logging_level_->Clear();
  clear_has_set_logging_level();
}
inline const ::mesos::master::Call_SetLoggingLevel& Call::set_logging_level() const {
  const ::mesos::master::Call_SetLoggingLevel* p = set_logging_level_;
  // @@protoc_insertion_point(field_get:mesos.master.Call.set_logging_level)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::master::Call_SetLoggingLevel*>(
      &::mesos::master::_Call_SetLoggingLevel_default_instance_);
}
inline ::mesos::master::Call_SetLoggingLevel* Call::release_set_logging_level() {
  // @@protoc_insertion_point(field_release:mesos.master.Call.set_logging_level)
  clear_has_set_logging_level();
  ::mesos::master::Call_SetLoggingLevel* temp = set_logging_level_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  set_logging_level_ = NULL;
  return temp;
}
inline ::mesos::master::Call_SetLoggingLevel* Call::unsafe_arena_release_set_logging_level() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.master.Call.set_logging_level)
  clear_has_set_logging_level();
  ::mesos::master::Call_SetLoggingLevel* temp = set_logging_level_;
  set_logging_level_ = NULL;
  return temp;
}
inline ::mesos::master::Call_SetLoggingLevel* Call::mutable_set_logging_level() {
  set_has_set_logging_level();
  if (set_logging_level_ == NULL) {
    _slow_mutable_set_logging_level();
  }
  // @@protoc_insertion_point(field_mutable:mesos.master.Call.set_logging_level)
  return set_logging_level_;
}
inline void Call::set_allocated_set_logging_level(::mesos::master::Call_SetLoggingLevel* set_logging_level) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete set_logging_level_;
  }
  if (set_logging_level) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(set_logging_level);
    if (message_arena != submessage_arena) {
      set_logging_level = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, set_logging_level, submessage_arena);
    }
    set_has_set_logging_level();
  } else {
    clear_has_set_logging_level();
  }
  set_logging_level_ = set_logging_level;
  // @@protoc_insertion_point(field_set_allocated:mesos.master.Call.set_logging_level)
}

// optional .mesos.master.Call.ListFiles list_files = 4;
inline bool Call::has_list_files() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Call::set_has_list_files() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Call::clear_has_list_files() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Call::clear_list_files() {
  if (list_files_ != NULL) list_files_->Clear();
  clear_has_list_files();
}
inline const ::mesos::master::Call_ListFiles& Call::list_files() const {
  const ::mesos::master::Call_ListFiles* p = list_files_;
  // @@protoc_insertion_point(field_get:mesos.master.Call.list_files)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::master::Call_ListFiles*>(
      &::mesos::master::_Call_ListFiles_default_instance_);
}
inline ::mesos::master::Call_ListFiles* Call::release_list_files() {
  // @@protoc_insertion_point(field_release:mesos.master.Call.list_files)
  clear_has_list_files();
  ::mesos::master::Call_ListFiles* temp = list_files_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  list_files_ = NULL;
  return temp;
}
inline ::mesos::master::Call_ListFiles* Call::unsafe_arena_release_list_files() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.master.Call.list_files)
  clear_has_list_files();
  ::mesos::master::Call_ListFiles* temp = list_files_;
  list_files_ = NULL;
  return temp;
}
inline ::mesos::master::Call_ListFiles* Call::mutable_list_files() {
  set_has_list_files();
  if (list_files_ == NULL) {
    _slow_mutable_list_files();
  }
  // @@protoc_insertion_point(field_mutable:mesos.master.Call.list_files)
  return list_files_;
}
inline void Call::set_allocated_list_files(::mesos::master::Call_ListFiles* list_files) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete list_files_;
  }
  if (list_files) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(list_files);
    if (message_arena != submessage_arena) {
      list_files = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, list_files, submessage_arena);
    }
    set_has_list_files();
  } else {
    clear_has_list_files();
  }
  list_files_ = list_files;
  // @@protoc_insertion_point(field_set_allocated:mesos.master.Call.list_files)
}

// optional .mesos.master.Call.ReadFile read_file = 5;
inline bool Call::has_read_file() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Call::set_has_read_file() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Call::clear_has_read_file() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Call::clear_read_file() {
  if (read_file_ != NULL) read_file_->Clear();
  clear_has_read_file();
}
inline const ::mesos::master::Call_ReadFile& Call::read_file() const {
  const ::mesos::master::Call_ReadFile* p = read_file_;
  // @@protoc_insertion_point(field_get:mesos.master.Call.read_file)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::master::Call_ReadFile*>(
      &::mesos::master::_Call_ReadFile_default_instance_);
}
inline ::mesos::master::Call_ReadFile* Call::release_read_file() {
  // @@protoc_insertion_point(field_release:mesos.master.Call.read_file)
  clear_has_read_file();
  ::mesos::master::Call_ReadFile* temp = read_file_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  read_file_ = NULL;
  return temp;
}
inline ::mesos::master::Call_ReadFile* Call::unsafe_arena_release_read_file() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.master.Call.read_file)
  clear_has_read_file();
  ::mesos::master::Call_ReadFile* temp = read_file_;
  read_file_ = NULL;
  return temp;
}
inline ::mesos::master::Call_ReadFile* Call::mutable_read_file() {
  set_has_read_file();
  if (read_file_ == NULL) {
    _slow_mutable_read_file();
  }
  // @@protoc_insertion_point(field_mutable:mesos.master.Call.read_file)
  return read_file_;
}
inline void Call::set_allocated_read_file(::mesos::master::Call_ReadFile* read_file) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete read_file_;
  }
  if (read_file) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(read_file);
    if (message_arena != submessage_arena) {
      read_file = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, read_file, submessage_arena);
    }
    set_has_read_file();
  } else {
    clear_has_read_file();
  }
  read_file_ = read_file;
  // @@protoc_insertion_point(field_set_allocated:mesos.master.Call.read_file)
}

// optional .mesos.master.Call.UpdateWeights update_weights = 6;
inline bool Call::has_update_weights() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Call::set_has_update_weights() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Call::clear_has_update_weights() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Call::clear_update_weights() {
  if (update_weights_ != NULL) update_weights_->Clear();
  clear_has_update_weights();
}
inline const ::mesos::master::Call_UpdateWeights& Call::update_weights() const {
  const ::mesos::master::Call_UpdateWeights* p = update_weights_;
  // @@protoc_insertion_point(field_get:mesos.master.Call.update_weights)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::master::Call_UpdateWeights*>(
      &::mesos::master::_Call_UpdateWeights_default_instance_);
}
inline ::mesos::master::Call_UpdateWeights* Call::release_update_weights() {
  // @@protoc_insertion_point(field_release:mesos.master.Call.update_weights)
  clear_has_update_weights();
  ::mesos::master::Call_UpdateWeights* temp = update_weights_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  update_weights_ = NULL;
  return temp;
}
inline ::mesos::master::Call_UpdateWeights* Call::unsafe_arena_release_update_weights() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.master.Call.update_weights)
  clear_has_update_weights();
  ::mesos::master::Call_UpdateWeights* temp = update_weights_;
  update_weights_ = NULL;
  return temp;
}
inline ::mesos::master::Call_UpdateWeights* Call::mutable_update_weights() {
  set_has_update_weights();
  if (update_weights_ == NULL) {
    _slow_mutable_update_weights();
  }
  // @@protoc_insertion_point(field_mutable:mesos.master.Call.update_weights)
  return update_weights_;
}
inline void Call::set_allocated_update_weights(::mesos::master::Call_UpdateWeights* update_weights) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete update_weights_;
  }
  if (update_weights) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(update_weights);
    if (message_arena != submessage_arena) {
      update_weights = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, update_weights, submessage_arena);
    }
    set_has_update_weights();
  } else {
    clear_has_update_weights();
  }
  update_weights_ = update_weights;
  // @@protoc_insertion_point(field_set_allocated:mesos.master.Call.update_weights)
}

// optional .mesos.master.Call.ReserveResources reserve_resources = 7;
inline bool Call::has_reserve_resources() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Call::set_has_reserve_resources() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Call::clear_has_reserve_resources() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Call::clear_reserve_resources() {
  if (reserve_resources_ != NULL) reserve_resources_->Clear();
  clear_has_reserve_resources();
}
inline const ::mesos::master::Call_ReserveResources& Call::reserve_resources() const {
  const ::mesos::master::Call_ReserveResources* p = reserve_resources_;
  // @@protoc_insertion_point(field_get:mesos.master.Call.reserve_resources)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::master::Call_ReserveResources*>(
      &::mesos::master::_Call_ReserveResources_default_instance_);
}
inline ::mesos::master::Call_ReserveResources* Call::release_reserve_resources() {
  // @@protoc_insertion_point(field_release:mesos.master.Call.reserve_resources)
  clear_has_reserve_resources();
  ::mesos::master::Call_ReserveResources* temp = reserve_resources_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  reserve_resources_ = NULL;
  return temp;
}
inline ::mesos::master::Call_ReserveResources* Call::unsafe_arena_release_reserve_resources() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.master.Call.reserve_resources)
  clear_has_reserve_resources();
  ::mesos::master::Call_ReserveResources* temp = reserve_resources_;
  reserve_resources_ = NULL;
  return temp;
}
inline ::mesos::master::Call_ReserveResources* Call::mutable_reserve_resources() {
  set_has_reserve_resources();
  if (reserve_resources_ == NULL) {
    _slow_mutable_reserve_resources();
  }
  // @@protoc_insertion_point(field_mutable:mesos.master.Call.reserve_resources)
  return reserve_resources_;
}
inline void Call::set_allocated_reserve_resources(::mesos::master::Call_ReserveResources* reserve_resources) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reserve_resources_;
  }
  if (reserve_resources) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(reserve_resources);
    if (message_arena != submessage_arena) {
      reserve_resources = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, reserve_resources, submessage_arena);
    }
    set_has_reserve_resources();
  } else {
    clear_has_reserve_resources();
  }
  reserve_resources_ = reserve_resources;
  // @@protoc_insertion_point(field_set_allocated:mesos.master.Call.reserve_resources)
}

// optional .mesos.master.Call.UnreserveResources unreserve_resources = 8;
inline bool Call::has_unreserve_resources() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Call::set_has_unreserve_resources() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Call::clear_has_unreserve_resources() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Call::clear_unreserve_resources() {
  if (unreserve_resources_ != NULL) unreserve_resources_->Clear();
  clear_has_unreserve_resources();
}
inline const ::mesos::master::Call_UnreserveResources& Call::unreserve_resources() const {
  const ::mesos::master::Call_UnreserveResources* p = unreserve_resources_;
  // @@protoc_insertion_point(field_get:mesos.master.Call.unreserve_resources)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::master::Call_UnreserveResources*>(
      &::mesos::master::_Call_UnreserveResources_default_instance_);
}
inline ::mesos::master::Call_UnreserveResources* Call::release_unreserve_resources() {
  // @@protoc_insertion_point(field_release:mesos.master.Call.unreserve_resources)
  clear_has_unreserve_resources();
  ::mesos::master::Call_UnreserveResources* temp = unreserve_resources_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  unreserve_resources_ = NULL;
  return temp;
}
inline ::mesos::master::Call_UnreserveResources* Call::unsafe_arena_release_unreserve_resources() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.master.Call.unreserve_resources)
  clear_has_unreserve_resources();
  ::mesos::master::Call_UnreserveResources* temp = unreserve_resources_;
  unreserve_resources_ = NULL;
  return temp;
}
inline ::mesos::master::Call_UnreserveResources* Call::mutable_unreserve_resources() {
  set_has_unreserve_resources();
  if (unreserve_resources_ == NULL) {
    _slow_mutable_unreserve_resources();
  }
  // @@protoc_insertion_point(field_mutable:mesos.master.Call.unreserve_resources)
  return unreserve_resources_;
}
inline void Call::set_allocated_unreserve_resources(::mesos::master::Call_UnreserveResources* unreserve_resources) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete unreserve_resources_;
  }
  if (unreserve_resources) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(unreserve_resources);
    if (message_arena != submessage_arena) {
      unreserve_resources = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, unreserve_resources, submessage_arena);
    }
    set_has_unreserve_resources();
  } else {
    clear_has_unreserve_resources();
  }
  unreserve_resources_ = unreserve_resources;
  // @@protoc_insertion_point(field_set_allocated:mesos.master.Call.unreserve_resources)
}

// optional .mesos.master.Call.CreateVolumes create_volumes = 9;
inline bool Call::has_create_volumes() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Call::set_has_create_volumes() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Call::clear_has_create_volumes() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Call::clear_create_volumes() {
  if (create_volumes_ != NULL) create_volumes_->Clear();
  clear_has_create_volumes();
}
inline const ::mesos::master::Call_CreateVolumes& Call::create_volumes() const {
  const ::mesos::master::Call_CreateVolumes* p = create_volumes_;
  // @@protoc_insertion_point(field_get:mesos.master.Call.create_volumes)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::master::Call_CreateVolumes*>(
      &::mesos::master::_Call_CreateVolumes_default_instance_);
}
inline ::mesos::master::Call_CreateVolumes* Call::release_create_volumes() {
  // @@protoc_insertion_point(field_release:mesos.master.Call.create_volumes)
  clear_has_create_volumes();
  ::mesos::master::Call_CreateVolumes* temp = create_volumes_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  create_volumes_ = NULL;
  return temp;
}
inline ::mesos::master::Call_CreateVolumes* Call::unsafe_arena_release_create_volumes() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.master.Call.create_volumes)
  clear_has_create_volumes();
  ::mesos::master::Call_CreateVolumes* temp = create_volumes_;
  create_volumes_ = NULL;
  return temp;
}
inline ::mesos::master::Call_CreateVolumes* Call::mutable_create_volumes() {
  set_has_create_volumes();
  if (create_volumes_ == NULL) {
    _slow_mutable_create_volumes();
  }
  // @@protoc_insertion_point(field_mutable:mesos.master.Call.create_volumes)
  return create_volumes_;
}
inline void Call::set_allocated_create_volumes(::mesos::master::Call_CreateVolumes* create_volumes) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete create_volumes_;
  }
  if (create_volumes) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(create_volumes);
    if (message_arena != submessage_arena) {
      create_volumes = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, create_volumes, submessage_arena);
    }
    set_has_create_volumes();
  } else {
    clear_has_create_volumes();
  }
  create_volumes_ = create_volumes;
  // @@protoc_insertion_point(field_set_allocated:mesos.master.Call.create_volumes)
}

// optional .mesos.master.Call.DestroyVolumes destroy_volumes = 10;
inline bool Call::has_destroy_volumes() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Call::set_has_destroy_volumes() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Call::clear_has_destroy_volumes() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Call::clear_destroy_volumes() {
  if (destroy_volumes_ != NULL) destroy_volumes_->Clear();
  clear_has_destroy_volumes();
}
inline const ::mesos::master::Call_DestroyVolumes& Call::destroy_volumes() const {
  const ::mesos::master::Call_DestroyVolumes* p = destroy_volumes_;
  // @@protoc_insertion_point(field_get:mesos.master.Call.destroy_volumes)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::master::Call_DestroyVolumes*>(
      &::mesos::master::_Call_DestroyVolumes_default_instance_);
}
inline ::mesos::master::Call_DestroyVolumes* Call::release_destroy_volumes() {
  // @@protoc_insertion_point(field_release:mesos.master.Call.destroy_volumes)
  clear_has_destroy_volumes();
  ::mesos::master::Call_DestroyVolumes* temp = destroy_volumes_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  destroy_volumes_ = NULL;
  return temp;
}
inline ::mesos::master::Call_DestroyVolumes* Call::unsafe_arena_release_destroy_volumes() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.master.Call.destroy_volumes)
  clear_has_destroy_volumes();
  ::mesos::master::Call_DestroyVolumes* temp = destroy_volumes_;
  destroy_volumes_ = NULL;
  return temp;
}
inline ::mesos::master::Call_DestroyVolumes* Call::mutable_destroy_volumes() {
  set_has_destroy_volumes();
  if (destroy_volumes_ == NULL) {
    _slow_mutable_destroy_volumes();
  }
  // @@protoc_insertion_point(field_mutable:mesos.master.Call.destroy_volumes)
  return destroy_volumes_;
}
inline void Call::set_allocated_destroy_volumes(::mesos::master::Call_DestroyVolumes* destroy_volumes) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete destroy_volumes_;
  }
  if (destroy_volumes) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(destroy_volumes);
    if (message_arena != submessage_arena) {
      destroy_volumes = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, destroy_volumes, submessage_arena);
    }
    set_has_destroy_volumes();
  } else {
    clear_has_destroy_volumes();
  }
  destroy_volumes_ = destroy_volumes;
  // @@protoc_insertion_point(field_set_allocated:mesos.master.Call.destroy_volumes)
}

// optional .mesos.master.Call.GrowVolume grow_volume = 18;
inline bool Call::has_grow_volume() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Call::set_has_grow_volume() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Call::clear_has_grow_volume() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Call::clear_grow_volume() {
  if (grow_volume_ != NULL) grow_volume_->Clear();
  clear_has_grow_volume();
}
inline const ::mesos::master::Call_GrowVolume& Call::grow_volume() const {
  const ::mesos::master::Call_GrowVolume* p = grow_volume_;
  // @@protoc_insertion_point(field_get:mesos.master.Call.grow_volume)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::master::Call_GrowVolume*>(
      &::mesos::master::_Call_GrowVolume_default_instance_);
}
inline ::mesos::master::Call_GrowVolume* Call::release_grow_volume() {
  // @@protoc_insertion_point(field_release:mesos.master.Call.grow_volume)
  clear_has_grow_volume();
  ::mesos::master::Call_GrowVolume* temp = grow_volume_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  grow_volume_ = NULL;
  return temp;
}
inline ::mesos::master::Call_GrowVolume* Call::unsafe_arena_release_grow_volume() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.master.Call.grow_volume)
  clear_has_grow_volume();
  ::mesos::master::Call_GrowVolume* temp = grow_volume_;
  grow_volume_ = NULL;
  return temp;
}
inline ::mesos::master::Call_GrowVolume* Call::mutable_grow_volume() {
  set_has_grow_volume();
  if (grow_volume_ == NULL) {
    _slow_mutable_grow_volume();
  }
  // @@protoc_insertion_point(field_mutable:mesos.master.Call.grow_volume)
  return grow_volume_;
}
inline void Call::set_allocated_grow_volume(::mesos::master::Call_GrowVolume* grow_volume) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete grow_volume_;
  }
  if (grow_volume) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(grow_volume);
    if (message_arena != submessage_arena) {
      grow_volume = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, grow_volume, submessage_arena);
    }
    set_has_grow_volume();
  } else {
    clear_has_grow_volume();
  }
  grow_volume_ = grow_volume;
  // @@protoc_insertion_point(field_set_allocated:mesos.master.Call.grow_volume)
}

// optional .mesos.master.Call.ShrinkVolume shrink_volume = 19;
inline bool Call::has_shrink_volume() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void Call::set_has_shrink_volume() {
  _has_bits_[0] |= 0x00020000u;
}
inline void Call::clear_has_shrink_volume() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void Call::clear_shrink_volume() {
  if (shrink_volume_ != NULL) shrink_volume_->Clear();
  clear_has_shrink_volume();
}
inline const ::mesos::master::Call_ShrinkVolume& Call::shrink_volume() const {
  const ::mesos::master::Call_ShrinkVolume* p = shrink_volume_;
  // @@protoc_insertion_point(field_get:mesos.master.Call.shrink_volume)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::master::Call_ShrinkVolume*>(
      &::mesos::master::_Call_ShrinkVolume_default_instance_);
}
inline ::mesos::master::Call_ShrinkVolume* Call::release_shrink_volume() {
  // @@protoc_insertion_point(field_release:mesos.master.Call.shrink_volume)
  clear_has_shrink_volume();
  ::mesos::master::Call_ShrinkVolume* temp = shrink_volume_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  shrink_volume_ = NULL;
  return temp;
}
inline ::mesos::master::Call_ShrinkVolume* Call::unsafe_arena_release_shrink_volume() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.master.Call.shrink_volume)
  clear_has_shrink_volume();
  ::mesos::master::Call_ShrinkVolume* temp = shrink_volume_;
  shrink_volume_ = NULL;
  return temp;
}
inline ::mesos::master::Call_ShrinkVolume* Call::mutable_shrink_volume() {
  set_has_shrink_volume();
  if (shrink_volume_ == NULL) {
    _slow_mutable_shrink_volume();
  }
  // @@protoc_insertion_point(field_mutable:mesos.master.Call.shrink_volume)
  return shrink_volume_;
}
inline void Call::set_allocated_shrink_volume(::mesos::master::Call_ShrinkVolume* shrink_volume) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete shrink_volume_;
  }
  if (shrink_volume) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(shrink_volume);
    if (message_arena != submessage_arena) {
      shrink_volume = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, shrink_volume, submessage_arena);
    }
    set_has_shrink_volume();
  } else {
    clear_has_shrink_volume();
  }
  shrink_volume_ = shrink_volume;
  // @@protoc_insertion_point(field_set_allocated:mesos.master.Call.shrink_volume)
}

// optional .mesos.master.Call.UpdateMaintenanceSchedule update_maintenance_schedule = 11;
inline bool Call::has_update_maintenance_schedule() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Call::set_has_update_maintenance_schedule() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Call::clear_has_update_maintenance_schedule() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Call::clear_update_maintenance_schedule() {
  if (update_maintenance_schedule_ != NULL) update_maintenance_schedule_->Clear();
  clear_has_update_maintenance_schedule();
}
inline const ::mesos::master::Call_UpdateMaintenanceSchedule& Call::update_maintenance_schedule() const {
  const ::mesos::master::Call_UpdateMaintenanceSchedule* p = update_maintenance_schedule_;
  // @@protoc_insertion_point(field_get:mesos.master.Call.update_maintenance_schedule)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::master::Call_UpdateMaintenanceSchedule*>(
      &::mesos::master::_Call_UpdateMaintenanceSchedule_default_instance_);
}
inline ::mesos::master::Call_UpdateMaintenanceSchedule* Call::release_update_maintenance_schedule() {
  // @@protoc_insertion_point(field_release:mesos.master.Call.update_maintenance_schedule)
  clear_has_update_maintenance_schedule();
  ::mesos::master::Call_UpdateMaintenanceSchedule* temp = update_maintenance_schedule_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  update_maintenance_schedule_ = NULL;
  return temp;
}
inline ::mesos::master::Call_UpdateMaintenanceSchedule* Call::unsafe_arena_release_update_maintenance_schedule() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.master.Call.update_maintenance_schedule)
  clear_has_update_maintenance_schedule();
  ::mesos::master::Call_UpdateMaintenanceSchedule* temp = update_maintenance_schedule_;
  update_maintenance_schedule_ = NULL;
  return temp;
}
inline ::mesos::master::Call_UpdateMaintenanceSchedule* Call::mutable_update_maintenance_schedule() {
  set_has_update_maintenance_schedule();
  if (update_maintenance_schedule_ == NULL) {
    _slow_mutable_update_maintenance_schedule();
  }
  // @@protoc_insertion_point(field_mutable:mesos.master.Call.update_maintenance_schedule)
  return update_maintenance_schedule_;
}
inline void Call::set_allocated_update_maintenance_schedule(::mesos::master::Call_UpdateMaintenanceSchedule* update_maintenance_schedule) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete update_maintenance_schedule_;
  }
  if (update_maintenance_schedule) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(update_maintenance_schedule);
    if (message_arena != submessage_arena) {
      update_maintenance_schedule = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, update_maintenance_schedule, submessage_arena);
    }
    set_has_update_maintenance_schedule();
  } else {
    clear_has_update_maintenance_schedule();
  }
  update_maintenance_schedule_ = update_maintenance_schedule;
  // @@protoc_insertion_point(field_set_allocated:mesos.master.Call.update_maintenance_schedule)
}

// optional .mesos.master.Call.StartMaintenance start_maintenance = 12;
inline bool Call::has_start_maintenance() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Call::set_has_start_maintenance() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Call::clear_has_start_maintenance() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Call::clear_start_maintenance() {
  if (start_maintenance_ != NULL) start_maintenance_->Clear();
  clear_has_start_maintenance();
}
inline const ::mesos::master::Call_StartMaintenance& Call::start_maintenance() const {
  const ::mesos::master::Call_StartMaintenance* p = start_maintenance_;
  // @@protoc_insertion_point(field_get:mesos.master.Call.start_maintenance)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::master::Call_StartMaintenance*>(
      &::mesos::master::_Call_StartMaintenance_default_instance_);
}
inline ::mesos::master::Call_StartMaintenance* Call::release_start_maintenance() {
  // @@protoc_insertion_point(field_release:mesos.master.Call.start_maintenance)
  clear_has_start_maintenance();
  ::mesos::master::Call_StartMaintenance* temp = start_maintenance_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  start_maintenance_ = NULL;
  return temp;
}
inline ::mesos::master::Call_StartMaintenance* Call::unsafe_arena_release_start_maintenance() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.master.Call.start_maintenance)
  clear_has_start_maintenance();
  ::mesos::master::Call_StartMaintenance* temp = start_maintenance_;
  start_maintenance_ = NULL;
  return temp;
}
inline ::mesos::master::Call_StartMaintenance* Call::mutable_start_maintenance() {
  set_has_start_maintenance();
  if (start_maintenance_ == NULL) {
    _slow_mutable_start_maintenance();
  }
  // @@protoc_insertion_point(field_mutable:mesos.master.Call.start_maintenance)
  return start_maintenance_;
}
inline void Call::set_allocated_start_maintenance(::mesos::master::Call_StartMaintenance* start_maintenance) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete start_maintenance_;
  }
  if (start_maintenance) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(start_maintenance);
    if (message_arena != submessage_arena) {
      start_maintenance = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, start_maintenance, submessage_arena);
    }
    set_has_start_maintenance();
  } else {
    clear_has_start_maintenance();
  }
  start_maintenance_ = start_maintenance;
  // @@protoc_insertion_point(field_set_allocated:mesos.master.Call.start_maintenance)
}

// optional .mesos.master.Call.StopMaintenance stop_maintenance = 13;
inline bool Call::has_stop_maintenance() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Call::set_has_stop_maintenance() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Call::clear_has_stop_maintenance() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Call::clear_stop_maintenance() {
  if (stop_maintenance_ != NULL) stop_maintenance_->Clear();
  clear_has_stop_maintenance();
}
inline const ::mesos::master::Call_StopMaintenance& Call::stop_maintenance() const {
  const ::mesos::master::Call_StopMaintenance* p = stop_maintenance_;
  // @@protoc_insertion_point(field_get:mesos.master.Call.stop_maintenance)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::master::Call_StopMaintenance*>(
      &::mesos::master::_Call_StopMaintenance_default_instance_);
}
inline ::mesos::master::Call_StopMaintenance* Call::release_stop_maintenance() {
  // @@protoc_insertion_point(field_release:mesos.master.Call.stop_maintenance)
  clear_has_stop_maintenance();
  ::mesos::master::Call_StopMaintenance* temp = stop_maintenance_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  stop_maintenance_ = NULL;
  return temp;
}
inline ::mesos::master::Call_StopMaintenance* Call::unsafe_arena_release_stop_maintenance() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.master.Call.stop_maintenance)
  clear_has_stop_maintenance();
  ::mesos::master::Call_StopMaintenance* temp = stop_maintenance_;
  stop_maintenance_ = NULL;
  return temp;
}
inline ::mesos::master::Call_StopMaintenance* Call::mutable_stop_maintenance() {
  set_has_stop_maintenance();
  if (stop_maintenance_ == NULL) {
    _slow_mutable_stop_maintenance();
  }
  // @@protoc_insertion_point(field_mutable:mesos.master.Call.stop_maintenance)
  return stop_maintenance_;
}
inline void Call::set_allocated_stop_maintenance(::mesos::master::Call_StopMaintenance* stop_maintenance) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete stop_maintenance_;
  }
  if (stop_maintenance) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(stop_maintenance);
    if (message_arena != submessage_arena) {
      stop_maintenance = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, stop_maintenance, submessage_arena);
    }
    set_has_stop_maintenance();
  } else {
    clear_has_stop_maintenance();
  }
  stop_maintenance_ = stop_maintenance;
  // @@protoc_insertion_point(field_set_allocated:mesos.master.Call.stop_maintenance)
}

// optional .mesos.master.Call.SetQuota set_quota = 14;
inline bool Call::has_set_quota() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Call::set_has_set_quota() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Call::clear_has_set_quota() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Call::clear_set_quota() {
  if (set_quota_ != NULL) set_quota_->Clear();
  clear_has_set_quota();
}
inline const ::mesos::master::Call_SetQuota& Call::set_quota() const {
  const ::mesos::master::Call_SetQuota* p = set_quota_;
  // @@protoc_insertion_point(field_get:mesos.master.Call.set_quota)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::master::Call_SetQuota*>(
      &::mesos::master::_Call_SetQuota_default_instance_);
}
inline ::mesos::master::Call_SetQuota* Call::release_set_quota() {
  // @@protoc_insertion_point(field_release:mesos.master.Call.set_quota)
  clear_has_set_quota();
  ::mesos::master::Call_SetQuota* temp = set_quota_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  set_quota_ = NULL;
  return temp;
}
inline ::mesos::master::Call_SetQuota* Call::unsafe_arena_release_set_quota() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.master.Call.set_quota)
  clear_has_set_quota();
  ::mesos::master::Call_SetQuota* temp = set_quota_;
  set_quota_ = NULL;
  return temp;
}
inline ::mesos::master::Call_SetQuota* Call::mutable_set_quota() {
  set_has_set_quota();
  if (set_quota_ == NULL) {
    _slow_mutable_set_quota();
  }
  // @@protoc_insertion_point(field_mutable:mesos.master.Call.set_quota)
  return set_quota_;
}
inline void Call::set_allocated_set_quota(::mesos::master::Call_SetQuota* set_quota) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete set_quota_;
  }
  if (set_quota) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(set_quota);
    if (message_arena != submessage_arena) {
      set_quota = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, set_quota, submessage_arena);
    }
    set_has_set_quota();
  } else {
    clear_has_set_quota();
  }
  set_quota_ = set_quota;
  // @@protoc_insertion_point(field_set_allocated:mesos.master.Call.set_quota)
}

// optional .mesos.master.Call.RemoveQuota remove_quota = 15;
inline bool Call::has_remove_quota() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Call::set_has_remove_quota() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Call::clear_has_remove_quota() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Call::clear_remove_quota() {
  if (remove_quota_ != NULL) remove_quota_->Clear();
  clear_has_remove_quota();
}
inline const ::mesos::master::Call_RemoveQuota& Call::remove_quota() const {
  const ::mesos::master::Call_RemoveQuota* p = remove_quota_;
  // @@protoc_insertion_point(field_get:mesos.master.Call.remove_quota)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::master::Call_RemoveQuota*>(
      &::mesos::master::_Call_RemoveQuota_default_instance_);
}
inline ::mesos::master::Call_RemoveQuota* Call::release_remove_quota() {
  // @@protoc_insertion_point(field_release:mesos.master.Call.remove_quota)
  clear_has_remove_quota();
  ::mesos::master::Call_RemoveQuota* temp = remove_quota_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  remove_quota_ = NULL;
  return temp;
}
inline ::mesos::master::Call_RemoveQuota* Call::unsafe_arena_release_remove_quota() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.master.Call.remove_quota)
  clear_has_remove_quota();
  ::mesos::master::Call_RemoveQuota* temp = remove_quota_;
  remove_quota_ = NULL;
  return temp;
}
inline ::mesos::master::Call_RemoveQuota* Call::mutable_remove_quota() {
  set_has_remove_quota();
  if (remove_quota_ == NULL) {
    _slow_mutable_remove_quota();
  }
  // @@protoc_insertion_point(field_mutable:mesos.master.Call.remove_quota)
  return remove_quota_;
}
inline void Call::set_allocated_remove_quota(::mesos::master::Call_RemoveQuota* remove_quota) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete remove_quota_;
  }
  if (remove_quota) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(remove_quota);
    if (message_arena != submessage_arena) {
      remove_quota = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, remove_quota, submessage_arena);
    }
    set_has_remove_quota();
  } else {
    clear_has_remove_quota();
  }
  remove_quota_ = remove_quota;
  // @@protoc_insertion_point(field_set_allocated:mesos.master.Call.remove_quota)
}

// optional .mesos.master.Call.Teardown teardown = 16;
inline bool Call::has_teardown() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Call::set_has_teardown() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Call::clear_has_teardown() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Call::clear_teardown() {
  if (teardown_ != NULL) teardown_->Clear();
  clear_has_teardown();
}
inline const ::mesos::master::Call_Teardown& Call::teardown() const {
  const ::mesos::master::Call_Teardown* p = teardown_;
  // @@protoc_insertion_point(field_get:mesos.master.Call.teardown)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::master::Call_Teardown*>(
      &::mesos::master::_Call_Teardown_default_instance_);
}
inline ::mesos::master::Call_Teardown* Call::release_teardown() {
  // @@protoc_insertion_point(field_release:mesos.master.Call.teardown)
  clear_has_teardown();
  ::mesos::master::Call_Teardown* temp = teardown_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  teardown_ = NULL;
  return temp;
}
inline ::mesos::master::Call_Teardown* Call::unsafe_arena_release_teardown() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.master.Call.teardown)
  clear_has_teardown();
  ::mesos::master::Call_Teardown* temp = teardown_;
  teardown_ = NULL;
  return temp;
}
inline ::mesos::master::Call_Teardown* Call::mutable_teardown() {
  set_has_teardown();
  if (teardown_ == NULL) {
    _slow_mutable_teardown();
  }
  // @@protoc_insertion_point(field_mutable:mesos.master.Call.teardown)
  return teardown_;
}
inline void Call::set_allocated_teardown(::mesos::master::Call_Teardown* teardown) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete teardown_;
  }
  if (teardown) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(teardown);
    if (message_arena != submessage_arena) {
      teardown = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, teardown, submessage_arena);
    }
    set_has_teardown();
  } else {
    clear_has_teardown();
  }
  teardown_ = teardown;
  // @@protoc_insertion_point(field_set_allocated:mesos.master.Call.teardown)
}

// optional .mesos.master.Call.MarkAgentGone mark_agent_gone = 17;
inline bool Call::has_mark_agent_gone() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Call::set_has_mark_agent_gone() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Call::clear_has_mark_agent_gone() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Call::clear_mark_agent_gone() {
  if (mark_agent_gone_ != NULL) mark_agent_gone_->Clear();
  clear_has_mark_agent_gone();
}
inline const ::mesos::master::Call_MarkAgentGone& Call::mark_agent_gone() const {
  const ::mesos::master::Call_MarkAgentGone* p = mark_agent_gone_;
  // @@protoc_insertion_point(field_get:mesos.master.Call.mark_agent_gone)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::master::Call_MarkAgentGone*>(
      &::mesos::master::_Call_MarkAgentGone_default_instance_);
}
inline ::mesos::master::Call_MarkAgentGone* Call::release_mark_agent_gone() {
  // @@protoc_insertion_point(field_release:mesos.master.Call.mark_agent_gone)
  clear_has_mark_agent_gone();
  ::mesos::master::Call_MarkAgentGone* temp = mark_agent_gone_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  mark_agent_gone_ = NULL;
  return temp;
}
inline ::mesos::master::Call_MarkAgentGone* Call::unsafe_arena_release_mark_agent_gone() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.master.Call.mark_agent_gone)
  clear_has_mark_agent_gone();
  ::mesos::master::Call_MarkAgentGone* temp = mark_agent_gone_;
  mark_agent_gone_ = NULL;
  return temp;
}
inline ::mesos::master::Call_MarkAgentGone* Call::mutable_mark_agent_gone() {
  set_has_mark_agent_gone();
  if (mark_agent_gone_ == NULL) {
    _slow_mutable_mark_agent_gone();
  }
  // @@protoc_insertion_point(field_mutable:mesos.master.Call.mark_agent_gone)
  return mark_agent_gone_;
}
inline void Call::set_allocated_mark_agent_gone(::mesos::master::Call_MarkAgentGone* mark_agent_gone) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete mark_agent_gone_;
  }
  if (mark_agent_gone) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(mark_agent_gone);
    if (message_arena != submessage_arena) {
      mark_agent_gone = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, mark_agent_gone, submessage_arena);
    }
    set_has_mark_agent_gone();
  } else {
    clear_has_mark_agent_gone();
  }
  mark_agent_gone_ = mark_agent_gone;
  // @@protoc_insertion_point(field_set_allocated:mesos.master.Call.mark_agent_gone)
}

// -------------------------------------------------------------------

// Response_GetHealth

// required bool healthy = 1;
inline bool Response_GetHealth::has_healthy() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Response_GetHealth::set_has_healthy() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Response_GetHealth::clear_has_healthy() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Response_GetHealth::clear_healthy() {
  healthy_ = false;
  clear_has_healthy();
}
inline bool Response_GetHealth::healthy() const {
  // @@protoc_insertion_point(field_get:mesos.master.Response.GetHealth.healthy)
  return healthy_;
}
inline void Response_GetHealth::set_healthy(bool value) {
  set_has_healthy();
  healthy_ = value;
  // @@protoc_insertion_point(field_set:mesos.master.Response.GetHealth.healthy)
}

// -------------------------------------------------------------------

// Response_GetFlags

// repeated .mesos.Flag flags = 1;
inline int Response_GetFlags::flags_size() const {
  return flags_.size();
}
inline const ::mesos::Flag& Response_GetFlags::flags(int index) const {
  // @@protoc_insertion_point(field_get:mesos.master.Response.GetFlags.flags)
  return flags_.Get(index);
}
inline ::mesos::Flag* Response_GetFlags::mutable_flags(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.master.Response.GetFlags.flags)
  return flags_.Mutable(index);
}
inline ::mesos::Flag* Response_GetFlags::add_flags() {
  // @@protoc_insertion_point(field_add:mesos.master.Response.GetFlags.flags)
  return flags_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Flag >*
Response_GetFlags::mutable_flags() {
  // @@protoc_insertion_point(field_mutable_list:mesos.master.Response.GetFlags.flags)
  return &flags_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Flag >&
Response_GetFlags::flags() const {
  // @@protoc_insertion_point(field_list:mesos.master.Response.GetFlags.flags)
  return flags_;
}

// -------------------------------------------------------------------

// Response_GetVersion

// required .mesos.VersionInfo version_info = 1;
inline bool Response_GetVersion::has_version_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Response_GetVersion::set_has_version_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Response_GetVersion::clear_has_version_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::mesos::VersionInfo& Response_GetVersion::version_info() const {
  const ::mesos::VersionInfo* p = version_info_;
  // @@protoc_insertion_point(field_get:mesos.master.Response.GetVersion.version_info)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::VersionInfo*>(
      &::mesos::_VersionInfo_default_instance_);
}
inline ::mesos::VersionInfo* Response_GetVersion::release_version_info() {
  // @@protoc_insertion_point(field_release:mesos.master.Response.GetVersion.version_info)
  clear_has_version_info();
  ::mesos::VersionInfo* temp = version_info_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  version_info_ = NULL;
  return temp;
}
inline ::mesos::VersionInfo* Response_GetVersion::unsafe_arena_release_version_info() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.master.Response.GetVersion.version_info)
  clear_has_version_info();
  ::mesos::VersionInfo* temp = version_info_;
  version_info_ = NULL;
  return temp;
}
inline ::mesos::VersionInfo* Response_GetVersion::mutable_version_info() {
  set_has_version_info();
  if (version_info_ == NULL) {
    _slow_mutable_version_info();
  }
  // @@protoc_insertion_point(field_mutable:mesos.master.Response.GetVersion.version_info)
  return version_info_;
}
inline void Response_GetVersion::set_allocated_version_info(::mesos::VersionInfo* version_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(version_info_);
  }
  if (version_info) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(version_info)->GetArena();
    if (message_arena != submessage_arena) {
      version_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, version_info, submessage_arena);
    }
    set_has_version_info();
  } else {
    clear_has_version_info();
  }
  version_info_ = version_info;
  // @@protoc_insertion_point(field_set_allocated:mesos.master.Response.GetVersion.version_info)
}

// -------------------------------------------------------------------

// Response_GetMetrics

// repeated .mesos.Metric metrics = 1;
inline int Response_GetMetrics::metrics_size() const {
  return metrics_.size();
}
inline const ::mesos::Metric& Response_GetMetrics::metrics(int index) const {
  // @@protoc_insertion_point(field_get:mesos.master.Response.GetMetrics.metrics)
  return metrics_.Get(index);
}
inline ::mesos::Metric* Response_GetMetrics::mutable_metrics(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.master.Response.GetMetrics.metrics)
  return metrics_.Mutable(index);
}
inline ::mesos::Metric* Response_GetMetrics::add_metrics() {
  // @@protoc_insertion_point(field_add:mesos.master.Response.GetMetrics.metrics)
  return metrics_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Metric >*
Response_GetMetrics::mutable_metrics() {
  // @@protoc_insertion_point(field_mutable_list:mesos.master.Response.GetMetrics.metrics)
  return &metrics_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Metric >&
Response_GetMetrics::metrics() const {
  // @@protoc_insertion_point(field_list:mesos.master.Response.GetMetrics.metrics)
  return metrics_;
}

// -------------------------------------------------------------------

// Response_GetLoggingLevel

// required uint32 level = 1;
inline bool Response_GetLoggingLevel::has_level() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Response_GetLoggingLevel::set_has_level() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Response_GetLoggingLevel::clear_has_level() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Response_GetLoggingLevel::clear_level() {
  level_ = 0u;
  clear_has_level();
}
inline ::google::protobuf::uint32 Response_GetLoggingLevel::level() const {
  // @@protoc_insertion_point(field_get:mesos.master.Response.GetLoggingLevel.level)
  return level_;
}
inline void Response_GetLoggingLevel::set_level(::google::protobuf::uint32 value) {
  set_has_level();
  level_ = value;
  // @@protoc_insertion_point(field_set:mesos.master.Response.GetLoggingLevel.level)
}

// -------------------------------------------------------------------

// Response_ListFiles

// repeated .mesos.FileInfo file_infos = 1;
inline int Response_ListFiles::file_infos_size() const {
  return file_infos_.size();
}
inline const ::mesos::FileInfo& Response_ListFiles::file_infos(int index) const {
  // @@protoc_insertion_point(field_get:mesos.master.Response.ListFiles.file_infos)
  return file_infos_.Get(index);
}
inline ::mesos::FileInfo* Response_ListFiles::mutable_file_infos(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.master.Response.ListFiles.file_infos)
  return file_infos_.Mutable(index);
}
inline ::mesos::FileInfo* Response_ListFiles::add_file_infos() {
  // @@protoc_insertion_point(field_add:mesos.master.Response.ListFiles.file_infos)
  return file_infos_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::FileInfo >*
Response_ListFiles::mutable_file_infos() {
  // @@protoc_insertion_point(field_mutable_list:mesos.master.Response.ListFiles.file_infos)
  return &file_infos_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::FileInfo >&
Response_ListFiles::file_infos() const {
  // @@protoc_insertion_point(field_list:mesos.master.Response.ListFiles.file_infos)
  return file_infos_;
}

// -------------------------------------------------------------------

// Response_ReadFile

// required uint64 size = 1;
inline bool Response_ReadFile::has_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Response_ReadFile::set_has_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Response_ReadFile::clear_has_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Response_ReadFile::clear_size() {
  size_ = GOOGLE_ULONGLONG(0);
  clear_has_size();
}
inline ::google::protobuf::uint64 Response_ReadFile::size() const {
  // @@protoc_insertion_point(field_get:mesos.master.Response.ReadFile.size)
  return size_;
}
inline void Response_ReadFile::set_size(::google::protobuf::uint64 value) {
  set_has_size();
  size_ = value;
  // @@protoc_insertion_point(field_set:mesos.master.Response.ReadFile.size)
}

// required bytes data = 2;
inline bool Response_ReadFile::has_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Response_ReadFile::set_has_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Response_ReadFile::clear_has_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Response_ReadFile::clear_data() {
  data_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_data();
}
inline const ::std::string& Response_ReadFile::data() const {
  // @@protoc_insertion_point(field_get:mesos.master.Response.ReadFile.data)
  return data_.Get();
}
inline void Response_ReadFile::set_data(const ::std::string& value) {
  set_has_data();
  data_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.master.Response.ReadFile.data)
}
#if LANG_CXX11
inline void Response_ReadFile::set_data(::std::string&& value) {
  set_has_data();
  data_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.master.Response.ReadFile.data)
}
#endif
inline void Response_ReadFile::set_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_data();
  data_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.master.Response.ReadFile.data)
}
inline void Response_ReadFile::set_data(const void* value,
    size_t size) {
  set_has_data();
  data_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.master.Response.ReadFile.data)
}
inline ::std::string* Response_ReadFile::mutable_data() {
  set_has_data();
  // @@protoc_insertion_point(field_mutable:mesos.master.Response.ReadFile.data)
  return data_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* Response_ReadFile::release_data() {
  // @@protoc_insertion_point(field_release:mesos.master.Response.ReadFile.data)
  clear_has_data();
  return data_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void Response_ReadFile::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    set_has_data();
  } else {
    clear_has_data();
  }
  data_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.master.Response.ReadFile.data)
}
inline ::std::string* Response_ReadFile::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.master.Response.ReadFile.data)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_data();
  return data_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void Response_ReadFile::unsafe_arena_set_allocated_data(
    ::std::string* data) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (data != NULL) {
    set_has_data();
  } else {
    clear_has_data();
  }
  data_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      data, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.master.Response.ReadFile.data)
}

// -------------------------------------------------------------------

// Response_GetState

// optional .mesos.master.Response.GetTasks get_tasks = 1;
inline bool Response_GetState::has_get_tasks() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Response_GetState::set_has_get_tasks() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Response_GetState::clear_has_get_tasks() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Response_GetState::clear_get_tasks() {
  if (get_tasks_ != NULL) get_tasks_->Clear();
  clear_has_get_tasks();
}
inline const ::mesos::master::Response_GetTasks& Response_GetState::get_tasks() const {
  const ::mesos::master::Response_GetTasks* p = get_tasks_;
  // @@protoc_insertion_point(field_get:mesos.master.Response.GetState.get_tasks)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::master::Response_GetTasks*>(
      &::mesos::master::_Response_GetTasks_default_instance_);
}
inline ::mesos::master::Response_GetTasks* Response_GetState::release_get_tasks() {
  // @@protoc_insertion_point(field_release:mesos.master.Response.GetState.get_tasks)
  clear_has_get_tasks();
  ::mesos::master::Response_GetTasks* temp = get_tasks_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  get_tasks_ = NULL;
  return temp;
}
inline ::mesos::master::Response_GetTasks* Response_GetState::unsafe_arena_release_get_tasks() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.master.Response.GetState.get_tasks)
  clear_has_get_tasks();
  ::mesos::master::Response_GetTasks* temp = get_tasks_;
  get_tasks_ = NULL;
  return temp;
}
inline ::mesos::master::Response_GetTasks* Response_GetState::mutable_get_tasks() {
  set_has_get_tasks();
  if (get_tasks_ == NULL) {
    _slow_mutable_get_tasks();
  }
  // @@protoc_insertion_point(field_mutable:mesos.master.Response.GetState.get_tasks)
  return get_tasks_;
}
inline void Response_GetState::set_allocated_get_tasks(::mesos::master::Response_GetTasks* get_tasks) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete get_tasks_;
  }
  if (get_tasks) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(get_tasks);
    if (message_arena != submessage_arena) {
      get_tasks = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, get_tasks, submessage_arena);
    }
    set_has_get_tasks();
  } else {
    clear_has_get_tasks();
  }
  get_tasks_ = get_tasks;
  // @@protoc_insertion_point(field_set_allocated:mesos.master.Response.GetState.get_tasks)
}

// optional .mesos.master.Response.GetExecutors get_executors = 2;
inline bool Response_GetState::has_get_executors() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Response_GetState::set_has_get_executors() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Response_GetState::clear_has_get_executors() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Response_GetState::clear_get_executors() {
  if (get_executors_ != NULL) get_executors_->Clear();
  clear_has_get_executors();
}
inline const ::mesos::master::Response_GetExecutors& Response_GetState::get_executors() const {
  const ::mesos::master::Response_GetExecutors* p = get_executors_;
  // @@protoc_insertion_point(field_get:mesos.master.Response.GetState.get_executors)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::master::Response_GetExecutors*>(
      &::mesos::master::_Response_GetExecutors_default_instance_);
}
inline ::mesos::master::Response_GetExecutors* Response_GetState::release_get_executors() {
  // @@protoc_insertion_point(field_release:mesos.master.Response.GetState.get_executors)
  clear_has_get_executors();
  ::mesos::master::Response_GetExecutors* temp = get_executors_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  get_executors_ = NULL;
  return temp;
}
inline ::mesos::master::Response_GetExecutors* Response_GetState::unsafe_arena_release_get_executors() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.master.Response.GetState.get_executors)
  clear_has_get_executors();
  ::mesos::master::Response_GetExecutors* temp = get_executors_;
  get_executors_ = NULL;
  return temp;
}
inline ::mesos::master::Response_GetExecutors* Response_GetState::mutable_get_executors() {
  set_has_get_executors();
  if (get_executors_ == NULL) {
    _slow_mutable_get_executors();
  }
  // @@protoc_insertion_point(field_mutable:mesos.master.Response.GetState.get_executors)
  return get_executors_;
}
inline void Response_GetState::set_allocated_get_executors(::mesos::master::Response_GetExecutors* get_executors) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete get_executors_;
  }
  if (get_executors) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(get_executors);
    if (message_arena != submessage_arena) {
      get_executors = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, get_executors, submessage_arena);
    }
    set_has_get_executors();
  } else {
    clear_has_get_executors();
  }
  get_executors_ = get_executors;
  // @@protoc_insertion_point(field_set_allocated:mesos.master.Response.GetState.get_executors)
}

// optional .mesos.master.Response.GetFrameworks get_frameworks = 3;
inline bool Response_GetState::has_get_frameworks() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Response_GetState::set_has_get_frameworks() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Response_GetState::clear_has_get_frameworks() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Response_GetState::clear_get_frameworks() {
  if (get_frameworks_ != NULL) get_frameworks_->Clear();
  clear_has_get_frameworks();
}
inline const ::mesos::master::Response_GetFrameworks& Response_GetState::get_frameworks() const {
  const ::mesos::master::Response_GetFrameworks* p = get_frameworks_;
  // @@protoc_insertion_point(field_get:mesos.master.Response.GetState.get_frameworks)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::master::Response_GetFrameworks*>(
      &::mesos::master::_Response_GetFrameworks_default_instance_);
}
inline ::mesos::master::Response_GetFrameworks* Response_GetState::release_get_frameworks() {
  // @@protoc_insertion_point(field_release:mesos.master.Response.GetState.get_frameworks)
  clear_has_get_frameworks();
  ::mesos::master::Response_GetFrameworks* temp = get_frameworks_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  get_frameworks_ = NULL;
  return temp;
}
inline ::mesos::master::Response_GetFrameworks* Response_GetState::unsafe_arena_release_get_frameworks() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.master.Response.GetState.get_frameworks)
  clear_has_get_frameworks();
  ::mesos::master::Response_GetFrameworks* temp = get_frameworks_;
  get_frameworks_ = NULL;
  return temp;
}
inline ::mesos::master::Response_GetFrameworks* Response_GetState::mutable_get_frameworks() {
  set_has_get_frameworks();
  if (get_frameworks_ == NULL) {
    _slow_mutable_get_frameworks();
  }
  // @@protoc_insertion_point(field_mutable:mesos.master.Response.GetState.get_frameworks)
  return get_frameworks_;
}
inline void Response_GetState::set_allocated_get_frameworks(::mesos::master::Response_GetFrameworks* get_frameworks) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete get_frameworks_;
  }
  if (get_frameworks) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(get_frameworks);
    if (message_arena != submessage_arena) {
      get_frameworks = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, get_frameworks, submessage_arena);
    }
    set_has_get_frameworks();
  } else {
    clear_has_get_frameworks();
  }
  get_frameworks_ = get_frameworks;
  // @@protoc_insertion_point(field_set_allocated:mesos.master.Response.GetState.get_frameworks)
}

// optional .mesos.master.Response.GetAgents get_agents = 4;
inline bool Response_GetState::has_get_agents() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Response_GetState::set_has_get_agents() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Response_GetState::clear_has_get_agents() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Response_GetState::clear_get_agents() {
  if (get_agents_ != NULL) get_agents_->Clear();
  clear_has_get_agents();
}
inline const ::mesos::master::Response_GetAgents& Response_GetState::get_agents() const {
  const ::mesos::master::Response_GetAgents* p = get_agents_;
  // @@protoc_insertion_point(field_get:mesos.master.Response.GetState.get_agents)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::master::Response_GetAgents*>(
      &::mesos::master::_Response_GetAgents_default_instance_);
}
inline ::mesos::master::Response_GetAgents* Response_GetState::release_get_agents() {
  // @@protoc_insertion_point(field_release:mesos.master.Response.GetState.get_agents)
  clear_has_get_agents();
  ::mesos::master::Response_GetAgents* temp = get_agents_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  get_agents_ = NULL;
  return temp;
}
inline ::mesos::master::Response_GetAgents* Response_GetState::unsafe_arena_release_get_agents() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.master.Response.GetState.get_agents)
  clear_has_get_agents();
  ::mesos::master::Response_GetAgents* temp = get_agents_;
  get_agents_ = NULL;
  return temp;
}
inline ::mesos::master::Response_GetAgents* Response_GetState::mutable_get_agents() {
  set_has_get_agents();
  if (get_agents_ == NULL) {
    _slow_mutable_get_agents();
  }
  // @@protoc_insertion_point(field_mutable:mesos.master.Response.GetState.get_agents)
  return get_agents_;
}
inline void Response_GetState::set_allocated_get_agents(::mesos::master::Response_GetAgents* get_agents) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete get_agents_;
  }
  if (get_agents) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(get_agents);
    if (message_arena != submessage_arena) {
      get_agents = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, get_agents, submessage_arena);
    }
    set_has_get_agents();
  } else {
    clear_has_get_agents();
  }
  get_agents_ = get_agents;
  // @@protoc_insertion_point(field_set_allocated:mesos.master.Response.GetState.get_agents)
}

// -------------------------------------------------------------------

// Response_GetAgents_Agent_ResourceProvider

// required .mesos.ResourceProviderInfo resource_provider_info = 1;
inline bool Response_GetAgents_Agent_ResourceProvider::has_resource_provider_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Response_GetAgents_Agent_ResourceProvider::set_has_resource_provider_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Response_GetAgents_Agent_ResourceProvider::clear_has_resource_provider_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::mesos::ResourceProviderInfo& Response_GetAgents_Agent_ResourceProvider::resource_provider_info() const {
  const ::mesos::ResourceProviderInfo* p = resource_provider_info_;
  // @@protoc_insertion_point(field_get:mesos.master.Response.GetAgents.Agent.ResourceProvider.resource_provider_info)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ResourceProviderInfo*>(
      &::mesos::_ResourceProviderInfo_default_instance_);
}
inline ::mesos::ResourceProviderInfo* Response_GetAgents_Agent_ResourceProvider::release_resource_provider_info() {
  // @@protoc_insertion_point(field_release:mesos.master.Response.GetAgents.Agent.ResourceProvider.resource_provider_info)
  clear_has_resource_provider_info();
  ::mesos::ResourceProviderInfo* temp = resource_provider_info_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  resource_provider_info_ = NULL;
  return temp;
}
inline ::mesos::ResourceProviderInfo* Response_GetAgents_Agent_ResourceProvider::unsafe_arena_release_resource_provider_info() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.master.Response.GetAgents.Agent.ResourceProvider.resource_provider_info)
  clear_has_resource_provider_info();
  ::mesos::ResourceProviderInfo* temp = resource_provider_info_;
  resource_provider_info_ = NULL;
  return temp;
}
inline ::mesos::ResourceProviderInfo* Response_GetAgents_Agent_ResourceProvider::mutable_resource_provider_info() {
  set_has_resource_provider_info();
  if (resource_provider_info_ == NULL) {
    _slow_mutable_resource_provider_info();
  }
  // @@protoc_insertion_point(field_mutable:mesos.master.Response.GetAgents.Agent.ResourceProvider.resource_provider_info)
  return resource_provider_info_;
}
inline void Response_GetAgents_Agent_ResourceProvider::set_allocated_resource_provider_info(::mesos::ResourceProviderInfo* resource_provider_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(resource_provider_info_);
  }
  if (resource_provider_info) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(resource_provider_info)->GetArena();
    if (message_arena != submessage_arena) {
      resource_provider_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, resource_provider_info, submessage_arena);
    }
    set_has_resource_provider_info();
  } else {
    clear_has_resource_provider_info();
  }
  resource_provider_info_ = resource_provider_info;
  // @@protoc_insertion_point(field_set_allocated:mesos.master.Response.GetAgents.Agent.ResourceProvider.resource_provider_info)
}

// repeated .mesos.Resource total_resources = 2;
inline int Response_GetAgents_Agent_ResourceProvider::total_resources_size() const {
  return total_resources_.size();
}
inline const ::mesos::Resource& Response_GetAgents_Agent_ResourceProvider::total_resources(int index) const {
  // @@protoc_insertion_point(field_get:mesos.master.Response.GetAgents.Agent.ResourceProvider.total_resources)
  return total_resources_.Get(index);
}
inline ::mesos::Resource* Response_GetAgents_Agent_ResourceProvider::mutable_total_resources(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.master.Response.GetAgents.Agent.ResourceProvider.total_resources)
  return total_resources_.Mutable(index);
}
inline ::mesos::Resource* Response_GetAgents_Agent_ResourceProvider::add_total_resources() {
  // @@protoc_insertion_point(field_add:mesos.master.Response.GetAgents.Agent.ResourceProvider.total_resources)
  return total_resources_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
Response_GetAgents_Agent_ResourceProvider::mutable_total_resources() {
  // @@protoc_insertion_point(field_mutable_list:mesos.master.Response.GetAgents.Agent.ResourceProvider.total_resources)
  return &total_resources_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
Response_GetAgents_Agent_ResourceProvider::total_resources() const {
  // @@protoc_insertion_point(field_list:mesos.master.Response.GetAgents.Agent.ResourceProvider.total_resources)
  return total_resources_;
}

// -------------------------------------------------------------------

// Response_GetAgents_Agent

// required .mesos.SlaveInfo agent_info = 1;
inline bool Response_GetAgents_Agent::has_agent_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Response_GetAgents_Agent::set_has_agent_info() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Response_GetAgents_Agent::clear_has_agent_info() {
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::mesos::SlaveInfo& Response_GetAgents_Agent::agent_info() const {
  const ::mesos::SlaveInfo* p = agent_info_;
  // @@protoc_insertion_point(field_get:mesos.master.Response.GetAgents.Agent.agent_info)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::SlaveInfo*>(
      &::mesos::_SlaveInfo_default_instance_);
}
inline ::mesos::SlaveInfo* Response_GetAgents_Agent::release_agent_info() {
  // @@protoc_insertion_point(field_release:mesos.master.Response.GetAgents.Agent.agent_info)
  clear_has_agent_info();
  ::mesos::SlaveInfo* temp = agent_info_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  agent_info_ = NULL;
  return temp;
}
inline ::mesos::SlaveInfo* Response_GetAgents_Agent::unsafe_arena_release_agent_info() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.master.Response.GetAgents.Agent.agent_info)
  clear_has_agent_info();
  ::mesos::SlaveInfo* temp = agent_info_;
  agent_info_ = NULL;
  return temp;
}
inline ::mesos::SlaveInfo* Response_GetAgents_Agent::mutable_agent_info() {
  set_has_agent_info();
  if (agent_info_ == NULL) {
    _slow_mutable_agent_info();
  }
  // @@protoc_insertion_point(field_mutable:mesos.master.Response.GetAgents.Agent.agent_info)
  return agent_info_;
}
inline void Response_GetAgents_Agent::set_allocated_agent_info(::mesos::SlaveInfo* agent_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(agent_info_);
  }
  if (agent_info) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(agent_info)->GetArena();
    if (message_arena != submessage_arena) {
      agent_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, agent_info, submessage_arena);
    }
    set_has_agent_info();
  } else {
    clear_has_agent_info();
  }
  agent_info_ = agent_info;
  // @@protoc_insertion_point(field_set_allocated:mesos.master.Response.GetAgents.Agent.agent_info)
}

// required bool active = 2;
inline bool Response_GetAgents_Agent::has_active() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Response_GetAgents_Agent::set_has_active() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Response_GetAgents_Agent::clear_has_active() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Response_GetAgents_Agent::clear_active() {
  active_ = false;
  clear_has_active();
}
inline bool Response_GetAgents_Agent::active() const {
  // @@protoc_insertion_point(field_get:mesos.master.Response.GetAgents.Agent.active)
  return active_;
}
inline void Response_GetAgents_Agent::set_active(bool value) {
  set_has_active();
  active_ = value;
  // @@protoc_insertion_point(field_set:mesos.master.Response.GetAgents.Agent.active)
}

// required string version = 3;
inline bool Response_GetAgents_Agent::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Response_GetAgents_Agent::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Response_GetAgents_Agent::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Response_GetAgents_Agent::clear_version() {
  version_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_version();
}
inline const ::std::string& Response_GetAgents_Agent::version() const {
  // @@protoc_insertion_point(field_get:mesos.master.Response.GetAgents.Agent.version)
  return version_.Get();
}
inline void Response_GetAgents_Agent::set_version(const ::std::string& value) {
  set_has_version();
  version_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.master.Response.GetAgents.Agent.version)
}
#if LANG_CXX11
inline void Response_GetAgents_Agent::set_version(::std::string&& value) {
  set_has_version();
  version_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.master.Response.GetAgents.Agent.version)
}
#endif
inline void Response_GetAgents_Agent::set_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_version();
  version_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.master.Response.GetAgents.Agent.version)
}
inline void Response_GetAgents_Agent::set_version(const char* value,
    size_t size) {
  set_has_version();
  version_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.master.Response.GetAgents.Agent.version)
}
inline ::std::string* Response_GetAgents_Agent::mutable_version() {
  set_has_version();
  // @@protoc_insertion_point(field_mutable:mesos.master.Response.GetAgents.Agent.version)
  return version_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* Response_GetAgents_Agent::release_version() {
  // @@protoc_insertion_point(field_release:mesos.master.Response.GetAgents.Agent.version)
  clear_has_version();
  return version_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void Response_GetAgents_Agent::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    set_has_version();
  } else {
    clear_has_version();
  }
  version_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.master.Response.GetAgents.Agent.version)
}
inline ::std::string* Response_GetAgents_Agent::unsafe_arena_release_version() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.master.Response.GetAgents.Agent.version)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_version();
  return version_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void Response_GetAgents_Agent::unsafe_arena_set_allocated_version(
    ::std::string* version) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (version != NULL) {
    set_has_version();
  } else {
    clear_has_version();
  }
  version_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      version, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.master.Response.GetAgents.Agent.version)
}

// optional string pid = 4;
inline bool Response_GetAgents_Agent::has_pid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Response_GetAgents_Agent::set_has_pid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Response_GetAgents_Agent::clear_has_pid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Response_GetAgents_Agent::clear_pid() {
  pid_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_pid();
}
inline const ::std::string& Response_GetAgents_Agent::pid() const {
  // @@protoc_insertion_point(field_get:mesos.master.Response.GetAgents.Agent.pid)
  return pid_.Get();
}
inline void Response_GetAgents_Agent::set_pid(const ::std::string& value) {
  set_has_pid();
  pid_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.master.Response.GetAgents.Agent.pid)
}
#if LANG_CXX11
inline void Response_GetAgents_Agent::set_pid(::std::string&& value) {
  set_has_pid();
  pid_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.master.Response.GetAgents.Agent.pid)
}
#endif
inline void Response_GetAgents_Agent::set_pid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_pid();
  pid_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.master.Response.GetAgents.Agent.pid)
}
inline void Response_GetAgents_Agent::set_pid(const char* value,
    size_t size) {
  set_has_pid();
  pid_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.master.Response.GetAgents.Agent.pid)
}
inline ::std::string* Response_GetAgents_Agent::mutable_pid() {
  set_has_pid();
  // @@protoc_insertion_point(field_mutable:mesos.master.Response.GetAgents.Agent.pid)
  return pid_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* Response_GetAgents_Agent::release_pid() {
  // @@protoc_insertion_point(field_release:mesos.master.Response.GetAgents.Agent.pid)
  clear_has_pid();
  return pid_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void Response_GetAgents_Agent::set_allocated_pid(::std::string* pid) {
  if (pid != NULL) {
    set_has_pid();
  } else {
    clear_has_pid();
  }
  pid_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pid,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.master.Response.GetAgents.Agent.pid)
}
inline ::std::string* Response_GetAgents_Agent::unsafe_arena_release_pid() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.master.Response.GetAgents.Agent.pid)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_pid();
  return pid_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void Response_GetAgents_Agent::unsafe_arena_set_allocated_pid(
    ::std::string* pid) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (pid != NULL) {
    set_has_pid();
  } else {
    clear_has_pid();
  }
  pid_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      pid, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.master.Response.GetAgents.Agent.pid)
}

// optional .mesos.TimeInfo registered_time = 5;
inline bool Response_GetAgents_Agent::has_registered_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Response_GetAgents_Agent::set_has_registered_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Response_GetAgents_Agent::clear_has_registered_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::mesos::TimeInfo& Response_GetAgents_Agent::registered_time() const {
  const ::mesos::TimeInfo* p = registered_time_;
  // @@protoc_insertion_point(field_get:mesos.master.Response.GetAgents.Agent.registered_time)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::TimeInfo*>(
      &::mesos::_TimeInfo_default_instance_);
}
inline ::mesos::TimeInfo* Response_GetAgents_Agent::release_registered_time() {
  // @@protoc_insertion_point(field_release:mesos.master.Response.GetAgents.Agent.registered_time)
  clear_has_registered_time();
  ::mesos::TimeInfo* temp = registered_time_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  registered_time_ = NULL;
  return temp;
}
inline ::mesos::TimeInfo* Response_GetAgents_Agent::unsafe_arena_release_registered_time() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.master.Response.GetAgents.Agent.registered_time)
  clear_has_registered_time();
  ::mesos::TimeInfo* temp = registered_time_;
  registered_time_ = NULL;
  return temp;
}
inline ::mesos::TimeInfo* Response_GetAgents_Agent::mutable_registered_time() {
  set_has_registered_time();
  if (registered_time_ == NULL) {
    _slow_mutable_registered_time();
  }
  // @@protoc_insertion_point(field_mutable:mesos.master.Response.GetAgents.Agent.registered_time)
  return registered_time_;
}
inline void Response_GetAgents_Agent::set_allocated_registered_time(::mesos::TimeInfo* registered_time) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(registered_time_);
  }
  if (registered_time) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(registered_time)->GetArena();
    if (message_arena != submessage_arena) {
      registered_time = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, registered_time, submessage_arena);
    }
    set_has_registered_time();
  } else {
    clear_has_registered_time();
  }
  registered_time_ = registered_time;
  // @@protoc_insertion_point(field_set_allocated:mesos.master.Response.GetAgents.Agent.registered_time)
}

// optional .mesos.TimeInfo reregistered_time = 6;
inline bool Response_GetAgents_Agent::has_reregistered_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Response_GetAgents_Agent::set_has_reregistered_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Response_GetAgents_Agent::clear_has_reregistered_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::mesos::TimeInfo& Response_GetAgents_Agent::reregistered_time() const {
  const ::mesos::TimeInfo* p = reregistered_time_;
  // @@protoc_insertion_point(field_get:mesos.master.Response.GetAgents.Agent.reregistered_time)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::TimeInfo*>(
      &::mesos::_TimeInfo_default_instance_);
}
inline ::mesos::TimeInfo* Response_GetAgents_Agent::release_reregistered_time() {
  // @@protoc_insertion_point(field_release:mesos.master.Response.GetAgents.Agent.reregistered_time)
  clear_has_reregistered_time();
  ::mesos::TimeInfo* temp = reregistered_time_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  reregistered_time_ = NULL;
  return temp;
}
inline ::mesos::TimeInfo* Response_GetAgents_Agent::unsafe_arena_release_reregistered_time() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.master.Response.GetAgents.Agent.reregistered_time)
  clear_has_reregistered_time();
  ::mesos::TimeInfo* temp = reregistered_time_;
  reregistered_time_ = NULL;
  return temp;
}
inline ::mesos::TimeInfo* Response_GetAgents_Agent::mutable_reregistered_time() {
  set_has_reregistered_time();
  if (reregistered_time_ == NULL) {
    _slow_mutable_reregistered_time();
  }
  // @@protoc_insertion_point(field_mutable:mesos.master.Response.GetAgents.Agent.reregistered_time)
  return reregistered_time_;
}
inline void Response_GetAgents_Agent::set_allocated_reregistered_time(::mesos::TimeInfo* reregistered_time) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(reregistered_time_);
  }
  if (reregistered_time) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(reregistered_time)->GetArena();
    if (message_arena != submessage_arena) {
      reregistered_time = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, reregistered_time, submessage_arena);
    }
    set_has_reregistered_time();
  } else {
    clear_has_reregistered_time();
  }
  reregistered_time_ = reregistered_time;
  // @@protoc_insertion_point(field_set_allocated:mesos.master.Response.GetAgents.Agent.reregistered_time)
}

// repeated .mesos.Resource total_resources = 7;
inline int Response_GetAgents_Agent::total_resources_size() const {
  return total_resources_.size();
}
inline const ::mesos::Resource& Response_GetAgents_Agent::total_resources(int index) const {
  // @@protoc_insertion_point(field_get:mesos.master.Response.GetAgents.Agent.total_resources)
  return total_resources_.Get(index);
}
inline ::mesos::Resource* Response_GetAgents_Agent::mutable_total_resources(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.master.Response.GetAgents.Agent.total_resources)
  return total_resources_.Mutable(index);
}
inline ::mesos::Resource* Response_GetAgents_Agent::add_total_resources() {
  // @@protoc_insertion_point(field_add:mesos.master.Response.GetAgents.Agent.total_resources)
  return total_resources_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
Response_GetAgents_Agent::mutable_total_resources() {
  // @@protoc_insertion_point(field_mutable_list:mesos.master.Response.GetAgents.Agent.total_resources)
  return &total_resources_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
Response_GetAgents_Agent::total_resources() const {
  // @@protoc_insertion_point(field_list:mesos.master.Response.GetAgents.Agent.total_resources)
  return total_resources_;
}

// repeated .mesos.Resource allocated_resources = 8;
inline int Response_GetAgents_Agent::allocated_resources_size() const {
  return allocated_resources_.size();
}
inline const ::mesos::Resource& Response_GetAgents_Agent::allocated_resources(int index) const {
  // @@protoc_insertion_point(field_get:mesos.master.Response.GetAgents.Agent.allocated_resources)
  return allocated_resources_.Get(index);
}
inline ::mesos::Resource* Response_GetAgents_Agent::mutable_allocated_resources(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.master.Response.GetAgents.Agent.allocated_resources)
  return allocated_resources_.Mutable(index);
}
inline ::mesos::Resource* Response_GetAgents_Agent::add_allocated_resources() {
  // @@protoc_insertion_point(field_add:mesos.master.Response.GetAgents.Agent.allocated_resources)
  return allocated_resources_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
Response_GetAgents_Agent::mutable_allocated_resources() {
  // @@protoc_insertion_point(field_mutable_list:mesos.master.Response.GetAgents.Agent.allocated_resources)
  return &allocated_resources_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
Response_GetAgents_Agent::allocated_resources() const {
  // @@protoc_insertion_point(field_list:mesos.master.Response.GetAgents.Agent.allocated_resources)
  return allocated_resources_;
}

// repeated .mesos.Resource offered_resources = 9;
inline int Response_GetAgents_Agent::offered_resources_size() const {
  return offered_resources_.size();
}
inline const ::mesos::Resource& Response_GetAgents_Agent::offered_resources(int index) const {
  // @@protoc_insertion_point(field_get:mesos.master.Response.GetAgents.Agent.offered_resources)
  return offered_resources_.Get(index);
}
inline ::mesos::Resource* Response_GetAgents_Agent::mutable_offered_resources(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.master.Response.GetAgents.Agent.offered_resources)
  return offered_resources_.Mutable(index);
}
inline ::mesos::Resource* Response_GetAgents_Agent::add_offered_resources() {
  // @@protoc_insertion_point(field_add:mesos.master.Response.GetAgents.Agent.offered_resources)
  return offered_resources_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
Response_GetAgents_Agent::mutable_offered_resources() {
  // @@protoc_insertion_point(field_mutable_list:mesos.master.Response.GetAgents.Agent.offered_resources)
  return &offered_resources_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
Response_GetAgents_Agent::offered_resources() const {
  // @@protoc_insertion_point(field_list:mesos.master.Response.GetAgents.Agent.offered_resources)
  return offered_resources_;
}

// repeated .mesos.SlaveInfo.Capability capabilities = 10;
inline int Response_GetAgents_Agent::capabilities_size() const {
  return capabilities_.size();
}
inline const ::mesos::SlaveInfo_Capability& Response_GetAgents_Agent::capabilities(int index) const {
  // @@protoc_insertion_point(field_get:mesos.master.Response.GetAgents.Agent.capabilities)
  return capabilities_.Get(index);
}
inline ::mesos::SlaveInfo_Capability* Response_GetAgents_Agent::mutable_capabilities(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.master.Response.GetAgents.Agent.capabilities)
  return capabilities_.Mutable(index);
}
inline ::mesos::SlaveInfo_Capability* Response_GetAgents_Agent::add_capabilities() {
  // @@protoc_insertion_point(field_add:mesos.master.Response.GetAgents.Agent.capabilities)
  return capabilities_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::SlaveInfo_Capability >*
Response_GetAgents_Agent::mutable_capabilities() {
  // @@protoc_insertion_point(field_mutable_list:mesos.master.Response.GetAgents.Agent.capabilities)
  return &capabilities_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::SlaveInfo_Capability >&
Response_GetAgents_Agent::capabilities() const {
  // @@protoc_insertion_point(field_list:mesos.master.Response.GetAgents.Agent.capabilities)
  return capabilities_;
}

// repeated .mesos.master.Response.GetAgents.Agent.ResourceProvider resource_providers = 11;
inline int Response_GetAgents_Agent::resource_providers_size() const {
  return resource_providers_.size();
}
inline void Response_GetAgents_Agent::clear_resource_providers() {
  resource_providers_.Clear();
}
inline const ::mesos::master::Response_GetAgents_Agent_ResourceProvider& Response_GetAgents_Agent::resource_providers(int index) const {
  // @@protoc_insertion_point(field_get:mesos.master.Response.GetAgents.Agent.resource_providers)
  return resource_providers_.Get(index);
}
inline ::mesos::master::Response_GetAgents_Agent_ResourceProvider* Response_GetAgents_Agent::mutable_resource_providers(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.master.Response.GetAgents.Agent.resource_providers)
  return resource_providers_.Mutable(index);
}
inline ::mesos::master::Response_GetAgents_Agent_ResourceProvider* Response_GetAgents_Agent::add_resource_providers() {
  // @@protoc_insertion_point(field_add:mesos.master.Response.GetAgents.Agent.resource_providers)
  return resource_providers_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::master::Response_GetAgents_Agent_ResourceProvider >*
Response_GetAgents_Agent::mutable_resource_providers() {
  // @@protoc_insertion_point(field_mutable_list:mesos.master.Response.GetAgents.Agent.resource_providers)
  return &resource_providers_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::master::Response_GetAgents_Agent_ResourceProvider >&
Response_GetAgents_Agent::resource_providers() const {
  // @@protoc_insertion_point(field_list:mesos.master.Response.GetAgents.Agent.resource_providers)
  return resource_providers_;
}

// -------------------------------------------------------------------

// Response_GetAgents

// repeated .mesos.master.Response.GetAgents.Agent agents = 1;
inline int Response_GetAgents::agents_size() const {
  return agents_.size();
}
inline void Response_GetAgents::clear_agents() {
  agents_.Clear();
}
inline const ::mesos::master::Response_GetAgents_Agent& Response_GetAgents::agents(int index) const {
  // @@protoc_insertion_point(field_get:mesos.master.Response.GetAgents.agents)
  return agents_.Get(index);
}
inline ::mesos::master::Response_GetAgents_Agent* Response_GetAgents::mutable_agents(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.master.Response.GetAgents.agents)
  return agents_.Mutable(index);
}
inline ::mesos::master::Response_GetAgents_Agent* Response_GetAgents::add_agents() {
  // @@protoc_insertion_point(field_add:mesos.master.Response.GetAgents.agents)
  return agents_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::master::Response_GetAgents_Agent >*
Response_GetAgents::mutable_agents() {
  // @@protoc_insertion_point(field_mutable_list:mesos.master.Response.GetAgents.agents)
  return &agents_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::master::Response_GetAgents_Agent >&
Response_GetAgents::agents() const {
  // @@protoc_insertion_point(field_list:mesos.master.Response.GetAgents.agents)
  return agents_;
}

// repeated .mesos.SlaveInfo recovered_agents = 2;
inline int Response_GetAgents::recovered_agents_size() const {
  return recovered_agents_.size();
}
inline const ::mesos::SlaveInfo& Response_GetAgents::recovered_agents(int index) const {
  // @@protoc_insertion_point(field_get:mesos.master.Response.GetAgents.recovered_agents)
  return recovered_agents_.Get(index);
}
inline ::mesos::SlaveInfo* Response_GetAgents::mutable_recovered_agents(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.master.Response.GetAgents.recovered_agents)
  return recovered_agents_.Mutable(index);
}
inline ::mesos::SlaveInfo* Response_GetAgents::add_recovered_agents() {
  // @@protoc_insertion_point(field_add:mesos.master.Response.GetAgents.recovered_agents)
  return recovered_agents_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::SlaveInfo >*
Response_GetAgents::mutable_recovered_agents() {
  // @@protoc_insertion_point(field_mutable_list:mesos.master.Response.GetAgents.recovered_agents)
  return &recovered_agents_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::SlaveInfo >&
Response_GetAgents::recovered_agents() const {
  // @@protoc_insertion_point(field_list:mesos.master.Response.GetAgents.recovered_agents)
  return recovered_agents_;
}

// -------------------------------------------------------------------

// Response_GetFrameworks_Framework

// required .mesos.FrameworkInfo framework_info = 1;
inline bool Response_GetFrameworks_Framework::has_framework_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Response_GetFrameworks_Framework::set_has_framework_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Response_GetFrameworks_Framework::clear_has_framework_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::mesos::FrameworkInfo& Response_GetFrameworks_Framework::framework_info() const {
  const ::mesos::FrameworkInfo* p = framework_info_;
  // @@protoc_insertion_point(field_get:mesos.master.Response.GetFrameworks.Framework.framework_info)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::FrameworkInfo*>(
      &::mesos::_FrameworkInfo_default_instance_);
}
inline ::mesos::FrameworkInfo* Response_GetFrameworks_Framework::release_framework_info() {
  // @@protoc_insertion_point(field_release:mesos.master.Response.GetFrameworks.Framework.framework_info)
  clear_has_framework_info();
  ::mesos::FrameworkInfo* temp = framework_info_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  framework_info_ = NULL;
  return temp;
}
inline ::mesos::FrameworkInfo* Response_GetFrameworks_Framework::unsafe_arena_release_framework_info() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.master.Response.GetFrameworks.Framework.framework_info)
  clear_has_framework_info();
  ::mesos::FrameworkInfo* temp = framework_info_;
  framework_info_ = NULL;
  return temp;
}
inline ::mesos::FrameworkInfo* Response_GetFrameworks_Framework::mutable_framework_info() {
  set_has_framework_info();
  if (framework_info_ == NULL) {
    _slow_mutable_framework_info();
  }
  // @@protoc_insertion_point(field_mutable:mesos.master.Response.GetFrameworks.Framework.framework_info)
  return framework_info_;
}
inline void Response_GetFrameworks_Framework::set_allocated_framework_info(::mesos::FrameworkInfo* framework_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(framework_info_);
  }
  if (framework_info) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(framework_info)->GetArena();
    if (message_arena != submessage_arena) {
      framework_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, framework_info, submessage_arena);
    }
    set_has_framework_info();
  } else {
    clear_has_framework_info();
  }
  framework_info_ = framework_info;
  // @@protoc_insertion_point(field_set_allocated:mesos.master.Response.GetFrameworks.Framework.framework_info)
}

// required bool active = 2;
inline bool Response_GetFrameworks_Framework::has_active() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Response_GetFrameworks_Framework::set_has_active() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Response_GetFrameworks_Framework::clear_has_active() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Response_GetFrameworks_Framework::clear_active() {
  active_ = false;
  clear_has_active();
}
inline bool Response_GetFrameworks_Framework::active() const {
  // @@protoc_insertion_point(field_get:mesos.master.Response.GetFrameworks.Framework.active)
  return active_;
}
inline void Response_GetFrameworks_Framework::set_active(bool value) {
  set_has_active();
  active_ = value;
  // @@protoc_insertion_point(field_set:mesos.master.Response.GetFrameworks.Framework.active)
}

// required bool connected = 3;
inline bool Response_GetFrameworks_Framework::has_connected() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Response_GetFrameworks_Framework::set_has_connected() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Response_GetFrameworks_Framework::clear_has_connected() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Response_GetFrameworks_Framework::clear_connected() {
  connected_ = false;
  clear_has_connected();
}
inline bool Response_GetFrameworks_Framework::connected() const {
  // @@protoc_insertion_point(field_get:mesos.master.Response.GetFrameworks.Framework.connected)
  return connected_;
}
inline void Response_GetFrameworks_Framework::set_connected(bool value) {
  set_has_connected();
  connected_ = value;
  // @@protoc_insertion_point(field_set:mesos.master.Response.GetFrameworks.Framework.connected)
}

// required bool recovered = 11;
inline bool Response_GetFrameworks_Framework::has_recovered() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Response_GetFrameworks_Framework::set_has_recovered() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Response_GetFrameworks_Framework::clear_has_recovered() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Response_GetFrameworks_Framework::clear_recovered() {
  recovered_ = false;
  clear_has_recovered();
}
inline bool Response_GetFrameworks_Framework::recovered() const {
  // @@protoc_insertion_point(field_get:mesos.master.Response.GetFrameworks.Framework.recovered)
  return recovered_;
}
inline void Response_GetFrameworks_Framework::set_recovered(bool value) {
  set_has_recovered();
  recovered_ = value;
  // @@protoc_insertion_point(field_set:mesos.master.Response.GetFrameworks.Framework.recovered)
}

// optional .mesos.TimeInfo registered_time = 4;
inline bool Response_GetFrameworks_Framework::has_registered_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Response_GetFrameworks_Framework::set_has_registered_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Response_GetFrameworks_Framework::clear_has_registered_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::mesos::TimeInfo& Response_GetFrameworks_Framework::registered_time() const {
  const ::mesos::TimeInfo* p = registered_time_;
  // @@protoc_insertion_point(field_get:mesos.master.Response.GetFrameworks.Framework.registered_time)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::TimeInfo*>(
      &::mesos::_TimeInfo_default_instance_);
}
inline ::mesos::TimeInfo* Response_GetFrameworks_Framework::release_registered_time() {
  // @@protoc_insertion_point(field_release:mesos.master.Response.GetFrameworks.Framework.registered_time)
  clear_has_registered_time();
  ::mesos::TimeInfo* temp = registered_time_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  registered_time_ = NULL;
  return temp;
}
inline ::mesos::TimeInfo* Response_GetFrameworks_Framework::unsafe_arena_release_registered_time() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.master.Response.GetFrameworks.Framework.registered_time)
  clear_has_registered_time();
  ::mesos::TimeInfo* temp = registered_time_;
  registered_time_ = NULL;
  return temp;
}
inline ::mesos::TimeInfo* Response_GetFrameworks_Framework::mutable_registered_time() {
  set_has_registered_time();
  if (registered_time_ == NULL) {
    _slow_mutable_registered_time();
  }
  // @@protoc_insertion_point(field_mutable:mesos.master.Response.GetFrameworks.Framework.registered_time)
  return registered_time_;
}
inline void Response_GetFrameworks_Framework::set_allocated_registered_time(::mesos::TimeInfo* registered_time) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(registered_time_);
  }
  if (registered_time) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(registered_time)->GetArena();
    if (message_arena != submessage_arena) {
      registered_time = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, registered_time, submessage_arena);
    }
    set_has_registered_time();
  } else {
    clear_has_registered_time();
  }
  registered_time_ = registered_time;
  // @@protoc_insertion_point(field_set_allocated:mesos.master.Response.GetFrameworks.Framework.registered_time)
}

// optional .mesos.TimeInfo reregistered_time = 5;
inline bool Response_GetFrameworks_Framework::has_reregistered_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Response_GetFrameworks_Framework::set_has_reregistered_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Response_GetFrameworks_Framework::clear_has_reregistered_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::mesos::TimeInfo& Response_GetFrameworks_Framework::reregistered_time() const {
  const ::mesos::TimeInfo* p = reregistered_time_;
  // @@protoc_insertion_point(field_get:mesos.master.Response.GetFrameworks.Framework.reregistered_time)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::TimeInfo*>(
      &::mesos::_TimeInfo_default_instance_);
}
inline ::mesos::TimeInfo* Response_GetFrameworks_Framework::release_reregistered_time() {
  // @@protoc_insertion_point(field_release:mesos.master.Response.GetFrameworks.Framework.reregistered_time)
  clear_has_reregistered_time();
  ::mesos::TimeInfo* temp = reregistered_time_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  reregistered_time_ = NULL;
  return temp;
}
inline ::mesos::TimeInfo* Response_GetFrameworks_Framework::unsafe_arena_release_reregistered_time() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.master.Response.GetFrameworks.Framework.reregistered_time)
  clear_has_reregistered_time();
  ::mesos::TimeInfo* temp = reregistered_time_;
  reregistered_time_ = NULL;
  return temp;
}
inline ::mesos::TimeInfo* Response_GetFrameworks_Framework::mutable_reregistered_time() {
  set_has_reregistered_time();
  if (reregistered_time_ == NULL) {
    _slow_mutable_reregistered_time();
  }
  // @@protoc_insertion_point(field_mutable:mesos.master.Response.GetFrameworks.Framework.reregistered_time)
  return reregistered_time_;
}
inline void Response_GetFrameworks_Framework::set_allocated_reregistered_time(::mesos::TimeInfo* reregistered_time) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(reregistered_time_);
  }
  if (reregistered_time) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(reregistered_time)->GetArena();
    if (message_arena != submessage_arena) {
      reregistered_time = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, reregistered_time, submessage_arena);
    }
    set_has_reregistered_time();
  } else {
    clear_has_reregistered_time();
  }
  reregistered_time_ = reregistered_time;
  // @@protoc_insertion_point(field_set_allocated:mesos.master.Response.GetFrameworks.Framework.reregistered_time)
}

// optional .mesos.TimeInfo unregistered_time = 6;
inline bool Response_GetFrameworks_Framework::has_unregistered_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Response_GetFrameworks_Framework::set_has_unregistered_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Response_GetFrameworks_Framework::clear_has_unregistered_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::mesos::TimeInfo& Response_GetFrameworks_Framework::unregistered_time() const {
  const ::mesos::TimeInfo* p = unregistered_time_;
  // @@protoc_insertion_point(field_get:mesos.master.Response.GetFrameworks.Framework.unregistered_time)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::TimeInfo*>(
      &::mesos::_TimeInfo_default_instance_);
}
inline ::mesos::TimeInfo* Response_GetFrameworks_Framework::release_unregistered_time() {
  // @@protoc_insertion_point(field_release:mesos.master.Response.GetFrameworks.Framework.unregistered_time)
  clear_has_unregistered_time();
  ::mesos::TimeInfo* temp = unregistered_time_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  unregistered_time_ = NULL;
  return temp;
}
inline ::mesos::TimeInfo* Response_GetFrameworks_Framework::unsafe_arena_release_unregistered_time() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.master.Response.GetFrameworks.Framework.unregistered_time)
  clear_has_unregistered_time();
  ::mesos::TimeInfo* temp = unregistered_time_;
  unregistered_time_ = NULL;
  return temp;
}
inline ::mesos::TimeInfo* Response_GetFrameworks_Framework::mutable_unregistered_time() {
  set_has_unregistered_time();
  if (unregistered_time_ == NULL) {
    _slow_mutable_unregistered_time();
  }
  // @@protoc_insertion_point(field_mutable:mesos.master.Response.GetFrameworks.Framework.unregistered_time)
  return unregistered_time_;
}
inline void Response_GetFrameworks_Framework::set_allocated_unregistered_time(::mesos::TimeInfo* unregistered_time) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(unregistered_time_);
  }
  if (unregistered_time) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(unregistered_time)->GetArena();
    if (message_arena != submessage_arena) {
      unregistered_time = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, unregistered_time, submessage_arena);
    }
    set_has_unregistered_time();
  } else {
    clear_has_unregistered_time();
  }
  unregistered_time_ = unregistered_time;
  // @@protoc_insertion_point(field_set_allocated:mesos.master.Response.GetFrameworks.Framework.unregistered_time)
}

// repeated .mesos.Offer offers = 7;
inline int Response_GetFrameworks_Framework::offers_size() const {
  return offers_.size();
}
inline const ::mesos::Offer& Response_GetFrameworks_Framework::offers(int index) const {
  // @@protoc_insertion_point(field_get:mesos.master.Response.GetFrameworks.Framework.offers)
  return offers_.Get(index);
}
inline ::mesos::Offer* Response_GetFrameworks_Framework::mutable_offers(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.master.Response.GetFrameworks.Framework.offers)
  return offers_.Mutable(index);
}
inline ::mesos::Offer* Response_GetFrameworks_Framework::add_offers() {
  // @@protoc_insertion_point(field_add:mesos.master.Response.GetFrameworks.Framework.offers)
  return offers_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Offer >*
Response_GetFrameworks_Framework::mutable_offers() {
  // @@protoc_insertion_point(field_mutable_list:mesos.master.Response.GetFrameworks.Framework.offers)
  return &offers_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Offer >&
Response_GetFrameworks_Framework::offers() const {
  // @@protoc_insertion_point(field_list:mesos.master.Response.GetFrameworks.Framework.offers)
  return offers_;
}

// repeated .mesos.InverseOffer inverse_offers = 8;
inline int Response_GetFrameworks_Framework::inverse_offers_size() const {
  return inverse_offers_.size();
}
inline const ::mesos::InverseOffer& Response_GetFrameworks_Framework::inverse_offers(int index) const {
  // @@protoc_insertion_point(field_get:mesos.master.Response.GetFrameworks.Framework.inverse_offers)
  return inverse_offers_.Get(index);
}
inline ::mesos::InverseOffer* Response_GetFrameworks_Framework::mutable_inverse_offers(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.master.Response.GetFrameworks.Framework.inverse_offers)
  return inverse_offers_.Mutable(index);
}
inline ::mesos::InverseOffer* Response_GetFrameworks_Framework::add_inverse_offers() {
  // @@protoc_insertion_point(field_add:mesos.master.Response.GetFrameworks.Framework.inverse_offers)
  return inverse_offers_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::InverseOffer >*
Response_GetFrameworks_Framework::mutable_inverse_offers() {
  // @@protoc_insertion_point(field_mutable_list:mesos.master.Response.GetFrameworks.Framework.inverse_offers)
  return &inverse_offers_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::InverseOffer >&
Response_GetFrameworks_Framework::inverse_offers() const {
  // @@protoc_insertion_point(field_list:mesos.master.Response.GetFrameworks.Framework.inverse_offers)
  return inverse_offers_;
}

// repeated .mesos.Resource allocated_resources = 9;
inline int Response_GetFrameworks_Framework::allocated_resources_size() const {
  return allocated_resources_.size();
}
inline const ::mesos::Resource& Response_GetFrameworks_Framework::allocated_resources(int index) const {
  // @@protoc_insertion_point(field_get:mesos.master.Response.GetFrameworks.Framework.allocated_resources)
  return allocated_resources_.Get(index);
}
inline ::mesos::Resource* Response_GetFrameworks_Framework::mutable_allocated_resources(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.master.Response.GetFrameworks.Framework.allocated_resources)
  return allocated_resources_.Mutable(index);
}
inline ::mesos::Resource* Response_GetFrameworks_Framework::add_allocated_resources() {
  // @@protoc_insertion_point(field_add:mesos.master.Response.GetFrameworks.Framework.allocated_resources)
  return allocated_resources_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
Response_GetFrameworks_Framework::mutable_allocated_resources() {
  // @@protoc_insertion_point(field_mutable_list:mesos.master.Response.GetFrameworks.Framework.allocated_resources)
  return &allocated_resources_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
Response_GetFrameworks_Framework::allocated_resources() const {
  // @@protoc_insertion_point(field_list:mesos.master.Response.GetFrameworks.Framework.allocated_resources)
  return allocated_resources_;
}

// repeated .mesos.Resource offered_resources = 10;
inline int Response_GetFrameworks_Framework::offered_resources_size() const {
  return offered_resources_.size();
}
inline const ::mesos::Resource& Response_GetFrameworks_Framework::offered_resources(int index) const {
  // @@protoc_insertion_point(field_get:mesos.master.Response.GetFrameworks.Framework.offered_resources)
  return offered_resources_.Get(index);
}
inline ::mesos::Resource* Response_GetFrameworks_Framework::mutable_offered_resources(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.master.Response.GetFrameworks.Framework.offered_resources)
  return offered_resources_.Mutable(index);
}
inline ::mesos::Resource* Response_GetFrameworks_Framework::add_offered_resources() {
  // @@protoc_insertion_point(field_add:mesos.master.Response.GetFrameworks.Framework.offered_resources)
  return offered_resources_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
Response_GetFrameworks_Framework::mutable_offered_resources() {
  // @@protoc_insertion_point(field_mutable_list:mesos.master.Response.GetFrameworks.Framework.offered_resources)
  return &offered_resources_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
Response_GetFrameworks_Framework::offered_resources() const {
  // @@protoc_insertion_point(field_list:mesos.master.Response.GetFrameworks.Framework.offered_resources)
  return offered_resources_;
}

// -------------------------------------------------------------------

// Response_GetFrameworks

// repeated .mesos.master.Response.GetFrameworks.Framework frameworks = 1;
inline int Response_GetFrameworks::frameworks_size() const {
  return frameworks_.size();
}
inline void Response_GetFrameworks::clear_frameworks() {
  frameworks_.Clear();
}
inline const ::mesos::master::Response_GetFrameworks_Framework& Response_GetFrameworks::frameworks(int index) const {
  // @@protoc_insertion_point(field_get:mesos.master.Response.GetFrameworks.frameworks)
  return frameworks_.Get(index);
}
inline ::mesos::master::Response_GetFrameworks_Framework* Response_GetFrameworks::mutable_frameworks(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.master.Response.GetFrameworks.frameworks)
  return frameworks_.Mutable(index);
}
inline ::mesos::master::Response_GetFrameworks_Framework* Response_GetFrameworks::add_frameworks() {
  // @@protoc_insertion_point(field_add:mesos.master.Response.GetFrameworks.frameworks)
  return frameworks_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::master::Response_GetFrameworks_Framework >*
Response_GetFrameworks::mutable_frameworks() {
  // @@protoc_insertion_point(field_mutable_list:mesos.master.Response.GetFrameworks.frameworks)
  return &frameworks_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::master::Response_GetFrameworks_Framework >&
Response_GetFrameworks::frameworks() const {
  // @@protoc_insertion_point(field_list:mesos.master.Response.GetFrameworks.frameworks)
  return frameworks_;
}

// repeated .mesos.master.Response.GetFrameworks.Framework completed_frameworks = 2;
inline int Response_GetFrameworks::completed_frameworks_size() const {
  return completed_frameworks_.size();
}
inline void Response_GetFrameworks::clear_completed_frameworks() {
  completed_frameworks_.Clear();
}
inline const ::mesos::master::Response_GetFrameworks_Framework& Response_GetFrameworks::completed_frameworks(int index) const {
  // @@protoc_insertion_point(field_get:mesos.master.Response.GetFrameworks.completed_frameworks)
  return completed_frameworks_.Get(index);
}
inline ::mesos::master::Response_GetFrameworks_Framework* Response_GetFrameworks::mutable_completed_frameworks(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.master.Response.GetFrameworks.completed_frameworks)
  return completed_frameworks_.Mutable(index);
}
inline ::mesos::master::Response_GetFrameworks_Framework* Response_GetFrameworks::add_completed_frameworks() {
  // @@protoc_insertion_point(field_add:mesos.master.Response.GetFrameworks.completed_frameworks)
  return completed_frameworks_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::master::Response_GetFrameworks_Framework >*
Response_GetFrameworks::mutable_completed_frameworks() {
  // @@protoc_insertion_point(field_mutable_list:mesos.master.Response.GetFrameworks.completed_frameworks)
  return &completed_frameworks_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::master::Response_GetFrameworks_Framework >&
Response_GetFrameworks::completed_frameworks() const {
  // @@protoc_insertion_point(field_list:mesos.master.Response.GetFrameworks.completed_frameworks)
  return completed_frameworks_;
}

// repeated .mesos.FrameworkInfo recovered_frameworks = 3 [deprecated = true];
inline int Response_GetFrameworks::recovered_frameworks_size() const {
  return recovered_frameworks_.size();
}
inline const ::mesos::FrameworkInfo& Response_GetFrameworks::recovered_frameworks(int index) const {
  // @@protoc_insertion_point(field_get:mesos.master.Response.GetFrameworks.recovered_frameworks)
  return recovered_frameworks_.Get(index);
}
inline ::mesos::FrameworkInfo* Response_GetFrameworks::mutable_recovered_frameworks(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.master.Response.GetFrameworks.recovered_frameworks)
  return recovered_frameworks_.Mutable(index);
}
inline ::mesos::FrameworkInfo* Response_GetFrameworks::add_recovered_frameworks() {
  // @@protoc_insertion_point(field_add:mesos.master.Response.GetFrameworks.recovered_frameworks)
  return recovered_frameworks_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::FrameworkInfo >*
Response_GetFrameworks::mutable_recovered_frameworks() {
  // @@protoc_insertion_point(field_mutable_list:mesos.master.Response.GetFrameworks.recovered_frameworks)
  return &recovered_frameworks_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::FrameworkInfo >&
Response_GetFrameworks::recovered_frameworks() const {
  // @@protoc_insertion_point(field_list:mesos.master.Response.GetFrameworks.recovered_frameworks)
  return recovered_frameworks_;
}

// -------------------------------------------------------------------

// Response_GetExecutors_Executor

// required .mesos.ExecutorInfo executor_info = 1;
inline bool Response_GetExecutors_Executor::has_executor_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Response_GetExecutors_Executor::set_has_executor_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Response_GetExecutors_Executor::clear_has_executor_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::mesos::ExecutorInfo& Response_GetExecutors_Executor::executor_info() const {
  const ::mesos::ExecutorInfo* p = executor_info_;
  // @@protoc_insertion_point(field_get:mesos.master.Response.GetExecutors.Executor.executor_info)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ExecutorInfo*>(
      &::mesos::_ExecutorInfo_default_instance_);
}
inline ::mesos::ExecutorInfo* Response_GetExecutors_Executor::release_executor_info() {
  // @@protoc_insertion_point(field_release:mesos.master.Response.GetExecutors.Executor.executor_info)
  clear_has_executor_info();
  ::mesos::ExecutorInfo* temp = executor_info_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  executor_info_ = NULL;
  return temp;
}
inline ::mesos::ExecutorInfo* Response_GetExecutors_Executor::unsafe_arena_release_executor_info() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.master.Response.GetExecutors.Executor.executor_info)
  clear_has_executor_info();
  ::mesos::ExecutorInfo* temp = executor_info_;
  executor_info_ = NULL;
  return temp;
}
inline ::mesos::ExecutorInfo* Response_GetExecutors_Executor::mutable_executor_info() {
  set_has_executor_info();
  if (executor_info_ == NULL) {
    _slow_mutable_executor_info();
  }
  // @@protoc_insertion_point(field_mutable:mesos.master.Response.GetExecutors.Executor.executor_info)
  return executor_info_;
}
inline void Response_GetExecutors_Executor::set_allocated_executor_info(::mesos::ExecutorInfo* executor_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(executor_info_);
  }
  if (executor_info) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(executor_info)->GetArena();
    if (message_arena != submessage_arena) {
      executor_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, executor_info, submessage_arena);
    }
    set_has_executor_info();
  } else {
    clear_has_executor_info();
  }
  executor_info_ = executor_info;
  // @@protoc_insertion_point(field_set_allocated:mesos.master.Response.GetExecutors.Executor.executor_info)
}

// required .mesos.SlaveID slave_id = 2;
inline bool Response_GetExecutors_Executor::has_slave_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Response_GetExecutors_Executor::set_has_slave_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Response_GetExecutors_Executor::clear_has_slave_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::mesos::SlaveID& Response_GetExecutors_Executor::slave_id() const {
  const ::mesos::SlaveID* p = slave_id_;
  // @@protoc_insertion_point(field_get:mesos.master.Response.GetExecutors.Executor.slave_id)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::SlaveID*>(
      &::mesos::_SlaveID_default_instance_);
}
inline ::mesos::SlaveID* Response_GetExecutors_Executor::release_slave_id() {
  // @@protoc_insertion_point(field_release:mesos.master.Response.GetExecutors.Executor.slave_id)
  clear_has_slave_id();
  ::mesos::SlaveID* temp = slave_id_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  slave_id_ = NULL;
  return temp;
}
inline ::mesos::SlaveID* Response_GetExecutors_Executor::unsafe_arena_release_slave_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.master.Response.GetExecutors.Executor.slave_id)
  clear_has_slave_id();
  ::mesos::SlaveID* temp = slave_id_;
  slave_id_ = NULL;
  return temp;
}
inline ::mesos::SlaveID* Response_GetExecutors_Executor::mutable_slave_id() {
  set_has_slave_id();
  if (slave_id_ == NULL) {
    _slow_mutable_slave_id();
  }
  // @@protoc_insertion_point(field_mutable:mesos.master.Response.GetExecutors.Executor.slave_id)
  return slave_id_;
}
inline void Response_GetExecutors_Executor::set_allocated_slave_id(::mesos::SlaveID* slave_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(slave_id_);
  }
  if (slave_id) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(slave_id)->GetArena();
    if (message_arena != submessage_arena) {
      slave_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, slave_id, submessage_arena);
    }
    set_has_slave_id();
  } else {
    clear_has_slave_id();
  }
  slave_id_ = slave_id;
  // @@protoc_insertion_point(field_set_allocated:mesos.master.Response.GetExecutors.Executor.slave_id)
}

// -------------------------------------------------------------------

// Response_GetExecutors

// repeated .mesos.master.Response.GetExecutors.Executor executors = 1;
inline int Response_GetExecutors::executors_size() const {
  return executors_.size();
}
inline void Response_GetExecutors::clear_executors() {
  executors_.Clear();
}
inline const ::mesos::master::Response_GetExecutors_Executor& Response_GetExecutors::executors(int index) const {
  // @@protoc_insertion_point(field_get:mesos.master.Response.GetExecutors.executors)
  return executors_.Get(index);
}
inline ::mesos::master::Response_GetExecutors_Executor* Response_GetExecutors::mutable_executors(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.master.Response.GetExecutors.executors)
  return executors_.Mutable(index);
}
inline ::mesos::master::Response_GetExecutors_Executor* Response_GetExecutors::add_executors() {
  // @@protoc_insertion_point(field_add:mesos.master.Response.GetExecutors.executors)
  return executors_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::master::Response_GetExecutors_Executor >*
Response_GetExecutors::mutable_executors() {
  // @@protoc_insertion_point(field_mutable_list:mesos.master.Response.GetExecutors.executors)
  return &executors_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::master::Response_GetExecutors_Executor >&
Response_GetExecutors::executors() const {
  // @@protoc_insertion_point(field_list:mesos.master.Response.GetExecutors.executors)
  return executors_;
}

// repeated .mesos.master.Response.GetExecutors.Executor orphan_executors = 2 [deprecated = true];
inline int Response_GetExecutors::orphan_executors_size() const {
  return orphan_executors_.size();
}
inline void Response_GetExecutors::clear_orphan_executors() {
  orphan_executors_.Clear();
}
inline const ::mesos::master::Response_GetExecutors_Executor& Response_GetExecutors::orphan_executors(int index) const {
  // @@protoc_insertion_point(field_get:mesos.master.Response.GetExecutors.orphan_executors)
  return orphan_executors_.Get(index);
}
inline ::mesos::master::Response_GetExecutors_Executor* Response_GetExecutors::mutable_orphan_executors(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.master.Response.GetExecutors.orphan_executors)
  return orphan_executors_.Mutable(index);
}
inline ::mesos::master::Response_GetExecutors_Executor* Response_GetExecutors::add_orphan_executors() {
  // @@protoc_insertion_point(field_add:mesos.master.Response.GetExecutors.orphan_executors)
  return orphan_executors_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::master::Response_GetExecutors_Executor >*
Response_GetExecutors::mutable_orphan_executors() {
  // @@protoc_insertion_point(field_mutable_list:mesos.master.Response.GetExecutors.orphan_executors)
  return &orphan_executors_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::master::Response_GetExecutors_Executor >&
Response_GetExecutors::orphan_executors() const {
  // @@protoc_insertion_point(field_list:mesos.master.Response.GetExecutors.orphan_executors)
  return orphan_executors_;
}

// -------------------------------------------------------------------

// Response_GetOperations

// repeated .mesos.Operation operations = 1;
inline int Response_GetOperations::operations_size() const {
  return operations_.size();
}
inline const ::mesos::Operation& Response_GetOperations::operations(int index) const {
  // @@protoc_insertion_point(field_get:mesos.master.Response.GetOperations.operations)
  return operations_.Get(index);
}
inline ::mesos::Operation* Response_GetOperations::mutable_operations(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.master.Response.GetOperations.operations)
  return operations_.Mutable(index);
}
inline ::mesos::Operation* Response_GetOperations::add_operations() {
  // @@protoc_insertion_point(field_add:mesos.master.Response.GetOperations.operations)
  return operations_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Operation >*
Response_GetOperations::mutable_operations() {
  // @@protoc_insertion_point(field_mutable_list:mesos.master.Response.GetOperations.operations)
  return &operations_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Operation >&
Response_GetOperations::operations() const {
  // @@protoc_insertion_point(field_list:mesos.master.Response.GetOperations.operations)
  return operations_;
}

// -------------------------------------------------------------------

// Response_GetTasks

// repeated .mesos.Task pending_tasks = 1;
inline int Response_GetTasks::pending_tasks_size() const {
  return pending_tasks_.size();
}
inline const ::mesos::Task& Response_GetTasks::pending_tasks(int index) const {
  // @@protoc_insertion_point(field_get:mesos.master.Response.GetTasks.pending_tasks)
  return pending_tasks_.Get(index);
}
inline ::mesos::Task* Response_GetTasks::mutable_pending_tasks(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.master.Response.GetTasks.pending_tasks)
  return pending_tasks_.Mutable(index);
}
inline ::mesos::Task* Response_GetTasks::add_pending_tasks() {
  // @@protoc_insertion_point(field_add:mesos.master.Response.GetTasks.pending_tasks)
  return pending_tasks_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Task >*
Response_GetTasks::mutable_pending_tasks() {
  // @@protoc_insertion_point(field_mutable_list:mesos.master.Response.GetTasks.pending_tasks)
  return &pending_tasks_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Task >&
Response_GetTasks::pending_tasks() const {
  // @@protoc_insertion_point(field_list:mesos.master.Response.GetTasks.pending_tasks)
  return pending_tasks_;
}

// repeated .mesos.Task tasks = 2;
inline int Response_GetTasks::tasks_size() const {
  return tasks_.size();
}
inline const ::mesos::Task& Response_GetTasks::tasks(int index) const {
  // @@protoc_insertion_point(field_get:mesos.master.Response.GetTasks.tasks)
  return tasks_.Get(index);
}
inline ::mesos::Task* Response_GetTasks::mutable_tasks(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.master.Response.GetTasks.tasks)
  return tasks_.Mutable(index);
}
inline ::mesos::Task* Response_GetTasks::add_tasks() {
  // @@protoc_insertion_point(field_add:mesos.master.Response.GetTasks.tasks)
  return tasks_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Task >*
Response_GetTasks::mutable_tasks() {
  // @@protoc_insertion_point(field_mutable_list:mesos.master.Response.GetTasks.tasks)
  return &tasks_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Task >&
Response_GetTasks::tasks() const {
  // @@protoc_insertion_point(field_list:mesos.master.Response.GetTasks.tasks)
  return tasks_;
}

// repeated .mesos.Task unreachable_tasks = 5;
inline int Response_GetTasks::unreachable_tasks_size() const {
  return unreachable_tasks_.size();
}
inline const ::mesos::Task& Response_GetTasks::unreachable_tasks(int index) const {
  // @@protoc_insertion_point(field_get:mesos.master.Response.GetTasks.unreachable_tasks)
  return unreachable_tasks_.Get(index);
}
inline ::mesos::Task* Response_GetTasks::mutable_unreachable_tasks(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.master.Response.GetTasks.unreachable_tasks)
  return unreachable_tasks_.Mutable(index);
}
inline ::mesos::Task* Response_GetTasks::add_unreachable_tasks() {
  // @@protoc_insertion_point(field_add:mesos.master.Response.GetTasks.unreachable_tasks)
  return unreachable_tasks_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Task >*
Response_GetTasks::mutable_unreachable_tasks() {
  // @@protoc_insertion_point(field_mutable_list:mesos.master.Response.GetTasks.unreachable_tasks)
  return &unreachable_tasks_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Task >&
Response_GetTasks::unreachable_tasks() const {
  // @@protoc_insertion_point(field_list:mesos.master.Response.GetTasks.unreachable_tasks)
  return unreachable_tasks_;
}

// repeated .mesos.Task completed_tasks = 3;
inline int Response_GetTasks::completed_tasks_size() const {
  return completed_tasks_.size();
}
inline const ::mesos::Task& Response_GetTasks::completed_tasks(int index) const {
  // @@protoc_insertion_point(field_get:mesos.master.Response.GetTasks.completed_tasks)
  return completed_tasks_.Get(index);
}
inline ::mesos::Task* Response_GetTasks::mutable_completed_tasks(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.master.Response.GetTasks.completed_tasks)
  return completed_tasks_.Mutable(index);
}
inline ::mesos::Task* Response_GetTasks::add_completed_tasks() {
  // @@protoc_insertion_point(field_add:mesos.master.Response.GetTasks.completed_tasks)
  return completed_tasks_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Task >*
Response_GetTasks::mutable_completed_tasks() {
  // @@protoc_insertion_point(field_mutable_list:mesos.master.Response.GetTasks.completed_tasks)
  return &completed_tasks_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Task >&
Response_GetTasks::completed_tasks() const {
  // @@protoc_insertion_point(field_list:mesos.master.Response.GetTasks.completed_tasks)
  return completed_tasks_;
}

// repeated .mesos.Task orphan_tasks = 4 [deprecated = true];
inline int Response_GetTasks::orphan_tasks_size() const {
  return orphan_tasks_.size();
}
inline const ::mesos::Task& Response_GetTasks::orphan_tasks(int index) const {
  // @@protoc_insertion_point(field_get:mesos.master.Response.GetTasks.orphan_tasks)
  return orphan_tasks_.Get(index);
}
inline ::mesos::Task* Response_GetTasks::mutable_orphan_tasks(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.master.Response.GetTasks.orphan_tasks)
  return orphan_tasks_.Mutable(index);
}
inline ::mesos::Task* Response_GetTasks::add_orphan_tasks() {
  // @@protoc_insertion_point(field_add:mesos.master.Response.GetTasks.orphan_tasks)
  return orphan_tasks_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Task >*
Response_GetTasks::mutable_orphan_tasks() {
  // @@protoc_insertion_point(field_mutable_list:mesos.master.Response.GetTasks.orphan_tasks)
  return &orphan_tasks_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Task >&
Response_GetTasks::orphan_tasks() const {
  // @@protoc_insertion_point(field_list:mesos.master.Response.GetTasks.orphan_tasks)
  return orphan_tasks_;
}

// -------------------------------------------------------------------

// Response_GetRoles

// repeated .mesos.Role roles = 1;
inline int Response_GetRoles::roles_size() const {
  return roles_.size();
}
inline const ::mesos::Role& Response_GetRoles::roles(int index) const {
  // @@protoc_insertion_point(field_get:mesos.master.Response.GetRoles.roles)
  return roles_.Get(index);
}
inline ::mesos::Role* Response_GetRoles::mutable_roles(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.master.Response.GetRoles.roles)
  return roles_.Mutable(index);
}
inline ::mesos::Role* Response_GetRoles::add_roles() {
  // @@protoc_insertion_point(field_add:mesos.master.Response.GetRoles.roles)
  return roles_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Role >*
Response_GetRoles::mutable_roles() {
  // @@protoc_insertion_point(field_mutable_list:mesos.master.Response.GetRoles.roles)
  return &roles_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Role >&
Response_GetRoles::roles() const {
  // @@protoc_insertion_point(field_list:mesos.master.Response.GetRoles.roles)
  return roles_;
}

// -------------------------------------------------------------------

// Response_GetWeights

// repeated .mesos.WeightInfo weight_infos = 1;
inline int Response_GetWeights::weight_infos_size() const {
  return weight_infos_.size();
}
inline const ::mesos::WeightInfo& Response_GetWeights::weight_infos(int index) const {
  // @@protoc_insertion_point(field_get:mesos.master.Response.GetWeights.weight_infos)
  return weight_infos_.Get(index);
}
inline ::mesos::WeightInfo* Response_GetWeights::mutable_weight_infos(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.master.Response.GetWeights.weight_infos)
  return weight_infos_.Mutable(index);
}
inline ::mesos::WeightInfo* Response_GetWeights::add_weight_infos() {
  // @@protoc_insertion_point(field_add:mesos.master.Response.GetWeights.weight_infos)
  return weight_infos_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::WeightInfo >*
Response_GetWeights::mutable_weight_infos() {
  // @@protoc_insertion_point(field_mutable_list:mesos.master.Response.GetWeights.weight_infos)
  return &weight_infos_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::WeightInfo >&
Response_GetWeights::weight_infos() const {
  // @@protoc_insertion_point(field_list:mesos.master.Response.GetWeights.weight_infos)
  return weight_infos_;
}

// -------------------------------------------------------------------

// Response_GetMaster

// optional .mesos.MasterInfo master_info = 1;
inline bool Response_GetMaster::has_master_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Response_GetMaster::set_has_master_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Response_GetMaster::clear_has_master_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::mesos::MasterInfo& Response_GetMaster::master_info() const {
  const ::mesos::MasterInfo* p = master_info_;
  // @@protoc_insertion_point(field_get:mesos.master.Response.GetMaster.master_info)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::MasterInfo*>(
      &::mesos::_MasterInfo_default_instance_);
}
inline ::mesos::MasterInfo* Response_GetMaster::release_master_info() {
  // @@protoc_insertion_point(field_release:mesos.master.Response.GetMaster.master_info)
  clear_has_master_info();
  ::mesos::MasterInfo* temp = master_info_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  master_info_ = NULL;
  return temp;
}
inline ::mesos::MasterInfo* Response_GetMaster::unsafe_arena_release_master_info() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.master.Response.GetMaster.master_info)
  clear_has_master_info();
  ::mesos::MasterInfo* temp = master_info_;
  master_info_ = NULL;
  return temp;
}
inline ::mesos::MasterInfo* Response_GetMaster::mutable_master_info() {
  set_has_master_info();
  if (master_info_ == NULL) {
    _slow_mutable_master_info();
  }
  // @@protoc_insertion_point(field_mutable:mesos.master.Response.GetMaster.master_info)
  return master_info_;
}
inline void Response_GetMaster::set_allocated_master_info(::mesos::MasterInfo* master_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(master_info_);
  }
  if (master_info) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(master_info)->GetArena();
    if (message_arena != submessage_arena) {
      master_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, master_info, submessage_arena);
    }
    set_has_master_info();
  } else {
    clear_has_master_info();
  }
  master_info_ = master_info;
  // @@protoc_insertion_point(field_set_allocated:mesos.master.Response.GetMaster.master_info)
}

// optional double start_time = 2;
inline bool Response_GetMaster::has_start_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Response_GetMaster::set_has_start_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Response_GetMaster::clear_has_start_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Response_GetMaster::clear_start_time() {
  start_time_ = 0;
  clear_has_start_time();
}
inline double Response_GetMaster::start_time() const {
  // @@protoc_insertion_point(field_get:mesos.master.Response.GetMaster.start_time)
  return start_time_;
}
inline void Response_GetMaster::set_start_time(double value) {
  set_has_start_time();
  start_time_ = value;
  // @@protoc_insertion_point(field_set:mesos.master.Response.GetMaster.start_time)
}

// optional double elected_time = 3;
inline bool Response_GetMaster::has_elected_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Response_GetMaster::set_has_elected_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Response_GetMaster::clear_has_elected_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Response_GetMaster::clear_elected_time() {
  elected_time_ = 0;
  clear_has_elected_time();
}
inline double Response_GetMaster::elected_time() const {
  // @@protoc_insertion_point(field_get:mesos.master.Response.GetMaster.elected_time)
  return elected_time_;
}
inline void Response_GetMaster::set_elected_time(double value) {
  set_has_elected_time();
  elected_time_ = value;
  // @@protoc_insertion_point(field_set:mesos.master.Response.GetMaster.elected_time)
}

// -------------------------------------------------------------------

// Response_GetMaintenanceStatus

// required .mesos.maintenance.ClusterStatus status = 1;
inline bool Response_GetMaintenanceStatus::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Response_GetMaintenanceStatus::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Response_GetMaintenanceStatus::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::mesos::maintenance::ClusterStatus& Response_GetMaintenanceStatus::status() const {
  const ::mesos::maintenance::ClusterStatus* p = status_;
  // @@protoc_insertion_point(field_get:mesos.master.Response.GetMaintenanceStatus.status)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::maintenance::ClusterStatus*>(
      &::mesos::maintenance::_ClusterStatus_default_instance_);
}
inline ::mesos::maintenance::ClusterStatus* Response_GetMaintenanceStatus::release_status() {
  // @@protoc_insertion_point(field_release:mesos.master.Response.GetMaintenanceStatus.status)
  clear_has_status();
  ::mesos::maintenance::ClusterStatus* temp = status_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  status_ = NULL;
  return temp;
}
inline ::mesos::maintenance::ClusterStatus* Response_GetMaintenanceStatus::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.master.Response.GetMaintenanceStatus.status)
  clear_has_status();
  ::mesos::maintenance::ClusterStatus* temp = status_;
  status_ = NULL;
  return temp;
}
inline ::mesos::maintenance::ClusterStatus* Response_GetMaintenanceStatus::mutable_status() {
  set_has_status();
  if (status_ == NULL) {
    _slow_mutable_status();
  }
  // @@protoc_insertion_point(field_mutable:mesos.master.Response.GetMaintenanceStatus.status)
  return status_;
}
inline void Response_GetMaintenanceStatus::set_allocated_status(::mesos::maintenance::ClusterStatus* status) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(status_);
  }
  if (status) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      status = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    set_has_status();
  } else {
    clear_has_status();
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:mesos.master.Response.GetMaintenanceStatus.status)
}

// -------------------------------------------------------------------

// Response_GetMaintenanceSchedule

// required .mesos.maintenance.Schedule schedule = 1;
inline bool Response_GetMaintenanceSchedule::has_schedule() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Response_GetMaintenanceSchedule::set_has_schedule() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Response_GetMaintenanceSchedule::clear_has_schedule() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::mesos::maintenance::Schedule& Response_GetMaintenanceSchedule::schedule() const {
  const ::mesos::maintenance::Schedule* p = schedule_;
  // @@protoc_insertion_point(field_get:mesos.master.Response.GetMaintenanceSchedule.schedule)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::maintenance::Schedule*>(
      &::mesos::maintenance::_Schedule_default_instance_);
}
inline ::mesos::maintenance::Schedule* Response_GetMaintenanceSchedule::release_schedule() {
  // @@protoc_insertion_point(field_release:mesos.master.Response.GetMaintenanceSchedule.schedule)
  clear_has_schedule();
  ::mesos::maintenance::Schedule* temp = schedule_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  schedule_ = NULL;
  return temp;
}
inline ::mesos::maintenance::Schedule* Response_GetMaintenanceSchedule::unsafe_arena_release_schedule() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.master.Response.GetMaintenanceSchedule.schedule)
  clear_has_schedule();
  ::mesos::maintenance::Schedule* temp = schedule_;
  schedule_ = NULL;
  return temp;
}
inline ::mesos::maintenance::Schedule* Response_GetMaintenanceSchedule::mutable_schedule() {
  set_has_schedule();
  if (schedule_ == NULL) {
    _slow_mutable_schedule();
  }
  // @@protoc_insertion_point(field_mutable:mesos.master.Response.GetMaintenanceSchedule.schedule)
  return schedule_;
}
inline void Response_GetMaintenanceSchedule::set_allocated_schedule(::mesos::maintenance::Schedule* schedule) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(schedule_);
  }
  if (schedule) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      schedule = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, schedule, submessage_arena);
    }
    set_has_schedule();
  } else {
    clear_has_schedule();
  }
  schedule_ = schedule;
  // @@protoc_insertion_point(field_set_allocated:mesos.master.Response.GetMaintenanceSchedule.schedule)
}

// -------------------------------------------------------------------

// Response_GetQuota

// required .mesos.quota.QuotaStatus status = 1;
inline bool Response_GetQuota::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Response_GetQuota::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Response_GetQuota::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::mesos::quota::QuotaStatus& Response_GetQuota::status() const {
  const ::mesos::quota::QuotaStatus* p = status_;
  // @@protoc_insertion_point(field_get:mesos.master.Response.GetQuota.status)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::quota::QuotaStatus*>(
      &::mesos::quota::_QuotaStatus_default_instance_);
}
inline ::mesos::quota::QuotaStatus* Response_GetQuota::release_status() {
  // @@protoc_insertion_point(field_release:mesos.master.Response.GetQuota.status)
  clear_has_status();
  ::mesos::quota::QuotaStatus* temp = status_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  status_ = NULL;
  return temp;
}
inline ::mesos::quota::QuotaStatus* Response_GetQuota::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.master.Response.GetQuota.status)
  clear_has_status();
  ::mesos::quota::QuotaStatus* temp = status_;
  status_ = NULL;
  return temp;
}
inline ::mesos::quota::QuotaStatus* Response_GetQuota::mutable_status() {
  set_has_status();
  if (status_ == NULL) {
    _slow_mutable_status();
  }
  // @@protoc_insertion_point(field_mutable:mesos.master.Response.GetQuota.status)
  return status_;
}
inline void Response_GetQuota::set_allocated_status(::mesos::quota::QuotaStatus* status) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(status_);
  }
  if (status) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      status = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    set_has_status();
  } else {
    clear_has_status();
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:mesos.master.Response.GetQuota.status)
}

// -------------------------------------------------------------------

// Response

// optional .mesos.master.Response.Type type = 1;
inline bool Response::has_type() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void Response::set_has_type() {
  _has_bits_[0] |= 0x00080000u;
}
inline void Response::clear_has_type() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void Response::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::mesos::master::Response_Type Response::type() const {
  // @@protoc_insertion_point(field_get:mesos.master.Response.type)
  return static_cast< ::mesos::master::Response_Type >(type_);
}
inline void Response::set_type(::mesos::master::Response_Type value) {
  assert(::mesos::master::Response_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:mesos.master.Response.type)
}

// optional .mesos.master.Response.GetHealth get_health = 2;
inline bool Response::has_get_health() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Response::set_has_get_health() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Response::clear_has_get_health() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Response::clear_get_health() {
  if (get_health_ != NULL) get_health_->Clear();
  clear_has_get_health();
}
inline const ::mesos::master::Response_GetHealth& Response::get_health() const {
  const ::mesos::master::Response_GetHealth* p = get_health_;
  // @@protoc_insertion_point(field_get:mesos.master.Response.get_health)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::master::Response_GetHealth*>(
      &::mesos::master::_Response_GetHealth_default_instance_);
}
inline ::mesos::master::Response_GetHealth* Response::release_get_health() {
  // @@protoc_insertion_point(field_release:mesos.master.Response.get_health)
  clear_has_get_health();
  ::mesos::master::Response_GetHealth* temp = get_health_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  get_health_ = NULL;
  return temp;
}
inline ::mesos::master::Response_GetHealth* Response::unsafe_arena_release_get_health() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.master.Response.get_health)
  clear_has_get_health();
  ::mesos::master::Response_GetHealth* temp = get_health_;
  get_health_ = NULL;
  return temp;
}
inline ::mesos::master::Response_GetHealth* Response::mutable_get_health() {
  set_has_get_health();
  if (get_health_ == NULL) {
    _slow_mutable_get_health();
  }
  // @@protoc_insertion_point(field_mutable:mesos.master.Response.get_health)
  return get_health_;
}
inline void Response::set_allocated_get_health(::mesos::master::Response_GetHealth* get_health) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete get_health_;
  }
  if (get_health) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(get_health);
    if (message_arena != submessage_arena) {
      get_health = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, get_health, submessage_arena);
    }
    set_has_get_health();
  } else {
    clear_has_get_health();
  }
  get_health_ = get_health;
  // @@protoc_insertion_point(field_set_allocated:mesos.master.Response.get_health)
}

// optional .mesos.master.Response.GetFlags get_flags = 3;
inline bool Response::has_get_flags() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Response::set_has_get_flags() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Response::clear_has_get_flags() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Response::clear_get_flags() {
  if (get_flags_ != NULL) get_flags_->Clear();
  clear_has_get_flags();
}
inline const ::mesos::master::Response_GetFlags& Response::get_flags() const {
  const ::mesos::master::Response_GetFlags* p = get_flags_;
  // @@protoc_insertion_point(field_get:mesos.master.Response.get_flags)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::master::Response_GetFlags*>(
      &::mesos::master::_Response_GetFlags_default_instance_);
}
inline ::mesos::master::Response_GetFlags* Response::release_get_flags() {
  // @@protoc_insertion_point(field_release:mesos.master.Response.get_flags)
  clear_has_get_flags();
  ::mesos::master::Response_GetFlags* temp = get_flags_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  get_flags_ = NULL;
  return temp;
}
inline ::mesos::master::Response_GetFlags* Response::unsafe_arena_release_get_flags() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.master.Response.get_flags)
  clear_has_get_flags();
  ::mesos::master::Response_GetFlags* temp = get_flags_;
  get_flags_ = NULL;
  return temp;
}
inline ::mesos::master::Response_GetFlags* Response::mutable_get_flags() {
  set_has_get_flags();
  if (get_flags_ == NULL) {
    _slow_mutable_get_flags();
  }
  // @@protoc_insertion_point(field_mutable:mesos.master.Response.get_flags)
  return get_flags_;
}
inline void Response::set_allocated_get_flags(::mesos::master::Response_GetFlags* get_flags) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete get_flags_;
  }
  if (get_flags) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(get_flags);
    if (message_arena != submessage_arena) {
      get_flags = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, get_flags, submessage_arena);
    }
    set_has_get_flags();
  } else {
    clear_has_get_flags();
  }
  get_flags_ = get_flags;
  // @@protoc_insertion_point(field_set_allocated:mesos.master.Response.get_flags)
}

// optional .mesos.master.Response.GetVersion get_version = 4;
inline bool Response::has_get_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Response::set_has_get_version() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Response::clear_has_get_version() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Response::clear_get_version() {
  if (get_version_ != NULL) get_version_->Clear();
  clear_has_get_version();
}
inline const ::mesos::master::Response_GetVersion& Response::get_version() const {
  const ::mesos::master::Response_GetVersion* p = get_version_;
  // @@protoc_insertion_point(field_get:mesos.master.Response.get_version)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::master::Response_GetVersion*>(
      &::mesos::master::_Response_GetVersion_default_instance_);
}
inline ::mesos::master::Response_GetVersion* Response::release_get_version() {
  // @@protoc_insertion_point(field_release:mesos.master.Response.get_version)
  clear_has_get_version();
  ::mesos::master::Response_GetVersion* temp = get_version_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  get_version_ = NULL;
  return temp;
}
inline ::mesos::master::Response_GetVersion* Response::unsafe_arena_release_get_version() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.master.Response.get_version)
  clear_has_get_version();
  ::mesos::master::Response_GetVersion* temp = get_version_;
  get_version_ = NULL;
  return temp;
}
inline ::mesos::master::Response_GetVersion* Response::mutable_get_version() {
  set_has_get_version();
  if (get_version_ == NULL) {
    _slow_mutable_get_version();
  }
  // @@protoc_insertion_point(field_mutable:mesos.master.Response.get_version)
  return get_version_;
}
inline void Response::set_allocated_get_version(::mesos::master::Response_GetVersion* get_version) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete get_version_;
  }
  if (get_version) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(get_version);
    if (message_arena != submessage_arena) {
      get_version = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, get_version, submessage_arena);
    }
    set_has_get_version();
  } else {
    clear_has_get_version();
  }
  get_version_ = get_version;
  // @@protoc_insertion_point(field_set_allocated:mesos.master.Response.get_version)
}

// optional .mesos.master.Response.GetMetrics get_metrics = 5;
inline bool Response::has_get_metrics() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Response::set_has_get_metrics() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Response::clear_has_get_metrics() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Response::clear_get_metrics() {
  if (get_metrics_ != NULL) get_metrics_->Clear();
  clear_has_get_metrics();
}
inline const ::mesos::master::Response_GetMetrics& Response::get_metrics() const {
  const ::mesos::master::Response_GetMetrics* p = get_metrics_;
  // @@protoc_insertion_point(field_get:mesos.master.Response.get_metrics)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::master::Response_GetMetrics*>(
      &::mesos::master::_Response_GetMetrics_default_instance_);
}
inline ::mesos::master::Response_GetMetrics* Response::release_get_metrics() {
  // @@protoc_insertion_point(field_release:mesos.master.Response.get_metrics)
  clear_has_get_metrics();
  ::mesos::master::Response_GetMetrics* temp = get_metrics_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  get_metrics_ = NULL;
  return temp;
}
inline ::mesos::master::Response_GetMetrics* Response::unsafe_arena_release_get_metrics() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.master.Response.get_metrics)
  clear_has_get_metrics();
  ::mesos::master::Response_GetMetrics* temp = get_metrics_;
  get_metrics_ = NULL;
  return temp;
}
inline ::mesos::master::Response_GetMetrics* Response::mutable_get_metrics() {
  set_has_get_metrics();
  if (get_metrics_ == NULL) {
    _slow_mutable_get_metrics();
  }
  // @@protoc_insertion_point(field_mutable:mesos.master.Response.get_metrics)
  return get_metrics_;
}
inline void Response::set_allocated_get_metrics(::mesos::master::Response_GetMetrics* get_metrics) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete get_metrics_;
  }
  if (get_metrics) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(get_metrics);
    if (message_arena != submessage_arena) {
      get_metrics = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, get_metrics, submessage_arena);
    }
    set_has_get_metrics();
  } else {
    clear_has_get_metrics();
  }
  get_metrics_ = get_metrics;
  // @@protoc_insertion_point(field_set_allocated:mesos.master.Response.get_metrics)
}

// optional .mesos.master.Response.GetLoggingLevel get_logging_level = 6;
inline bool Response::has_get_logging_level() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Response::set_has_get_logging_level() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Response::clear_has_get_logging_level() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Response::clear_get_logging_level() {
  if (get_logging_level_ != NULL) get_logging_level_->Clear();
  clear_has_get_logging_level();
}
inline const ::mesos::master::Response_GetLoggingLevel& Response::get_logging_level() const {
  const ::mesos::master::Response_GetLoggingLevel* p = get_logging_level_;
  // @@protoc_insertion_point(field_get:mesos.master.Response.get_logging_level)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::master::Response_GetLoggingLevel*>(
      &::mesos::master::_Response_GetLoggingLevel_default_instance_);
}
inline ::mesos::master::Response_GetLoggingLevel* Response::release_get_logging_level() {
  // @@protoc_insertion_point(field_release:mesos.master.Response.get_logging_level)
  clear_has_get_logging_level();
  ::mesos::master::Response_GetLoggingLevel* temp = get_logging_level_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  get_logging_level_ = NULL;
  return temp;
}
inline ::mesos::master::Response_GetLoggingLevel* Response::unsafe_arena_release_get_logging_level() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.master.Response.get_logging_level)
  clear_has_get_logging_level();
  ::mesos::master::Response_GetLoggingLevel* temp = get_logging_level_;
  get_logging_level_ = NULL;
  return temp;
}
inline ::mesos::master::Response_GetLoggingLevel* Response::mutable_get_logging_level() {
  set_has_get_logging_level();
  if (get_logging_level_ == NULL) {
    _slow_mutable_get_logging_level();
  }
  // @@protoc_insertion_point(field_mutable:mesos.master.Response.get_logging_level)
  return get_logging_level_;
}
inline void Response::set_allocated_get_logging_level(::mesos::master::Response_GetLoggingLevel* get_logging_level) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete get_logging_level_;
  }
  if (get_logging_level) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(get_logging_level);
    if (message_arena != submessage_arena) {
      get_logging_level = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, get_logging_level, submessage_arena);
    }
    set_has_get_logging_level();
  } else {
    clear_has_get_logging_level();
  }
  get_logging_level_ = get_logging_level;
  // @@protoc_insertion_point(field_set_allocated:mesos.master.Response.get_logging_level)
}

// optional .mesos.master.Response.ListFiles list_files = 7;
inline bool Response::has_list_files() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Response::set_has_list_files() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Response::clear_has_list_files() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Response::clear_list_files() {
  if (list_files_ != NULL) list_files_->Clear();
  clear_has_list_files();
}
inline const ::mesos::master::Response_ListFiles& Response::list_files() const {
  const ::mesos::master::Response_ListFiles* p = list_files_;
  // @@protoc_insertion_point(field_get:mesos.master.Response.list_files)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::master::Response_ListFiles*>(
      &::mesos::master::_Response_ListFiles_default_instance_);
}
inline ::mesos::master::Response_ListFiles* Response::release_list_files() {
  // @@protoc_insertion_point(field_release:mesos.master.Response.list_files)
  clear_has_list_files();
  ::mesos::master::Response_ListFiles* temp = list_files_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  list_files_ = NULL;
  return temp;
}
inline ::mesos::master::Response_ListFiles* Response::unsafe_arena_release_list_files() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.master.Response.list_files)
  clear_has_list_files();
  ::mesos::master::Response_ListFiles* temp = list_files_;
  list_files_ = NULL;
  return temp;
}
inline ::mesos::master::Response_ListFiles* Response::mutable_list_files() {
  set_has_list_files();
  if (list_files_ == NULL) {
    _slow_mutable_list_files();
  }
  // @@protoc_insertion_point(field_mutable:mesos.master.Response.list_files)
  return list_files_;
}
inline void Response::set_allocated_list_files(::mesos::master::Response_ListFiles* list_files) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete list_files_;
  }
  if (list_files) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(list_files);
    if (message_arena != submessage_arena) {
      list_files = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, list_files, submessage_arena);
    }
    set_has_list_files();
  } else {
    clear_has_list_files();
  }
  list_files_ = list_files;
  // @@protoc_insertion_point(field_set_allocated:mesos.master.Response.list_files)
}

// optional .mesos.master.Response.ReadFile read_file = 8;
inline bool Response::has_read_file() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Response::set_has_read_file() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Response::clear_has_read_file() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Response::clear_read_file() {
  if (read_file_ != NULL) read_file_->Clear();
  clear_has_read_file();
}
inline const ::mesos::master::Response_ReadFile& Response::read_file() const {
  const ::mesos::master::Response_ReadFile* p = read_file_;
  // @@protoc_insertion_point(field_get:mesos.master.Response.read_file)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::master::Response_ReadFile*>(
      &::mesos::master::_Response_ReadFile_default_instance_);
}
inline ::mesos::master::Response_ReadFile* Response::release_read_file() {
  // @@protoc_insertion_point(field_release:mesos.master.Response.read_file)
  clear_has_read_file();
  ::mesos::master::Response_ReadFile* temp = read_file_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  read_file_ = NULL;
  return temp;
}
inline ::mesos::master::Response_ReadFile* Response::unsafe_arena_release_read_file() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.master.Response.read_file)
  clear_has_read_file();
  ::mesos::master::Response_ReadFile* temp = read_file_;
  read_file_ = NULL;
  return temp;
}
inline ::mesos::master::Response_ReadFile* Response::mutable_read_file() {
  set_has_read_file();
  if (read_file_ == NULL) {
    _slow_mutable_read_file();
  }
  // @@protoc_insertion_point(field_mutable:mesos.master.Response.read_file)
  return read_file_;
}
inline void Response::set_allocated_read_file(::mesos::master::Response_ReadFile* read_file) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete read_file_;
  }
  if (read_file) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(read_file);
    if (message_arena != submessage_arena) {
      read_file = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, read_file, submessage_arena);
    }
    set_has_read_file();
  } else {
    clear_has_read_file();
  }
  read_file_ = read_file;
  // @@protoc_insertion_point(field_set_allocated:mesos.master.Response.read_file)
}

// optional .mesos.master.Response.GetState get_state = 9;
inline bool Response::has_get_state() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Response::set_has_get_state() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Response::clear_has_get_state() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Response::clear_get_state() {
  if (get_state_ != NULL) get_state_->Clear();
  clear_has_get_state();
}
inline const ::mesos::master::Response_GetState& Response::get_state() const {
  const ::mesos::master::Response_GetState* p = get_state_;
  // @@protoc_insertion_point(field_get:mesos.master.Response.get_state)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::master::Response_GetState*>(
      &::mesos::master::_Response_GetState_default_instance_);
}
inline ::mesos::master::Response_GetState* Response::release_get_state() {
  // @@protoc_insertion_point(field_release:mesos.master.Response.get_state)
  clear_has_get_state();
  ::mesos::master::Response_GetState* temp = get_state_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  get_state_ = NULL;
  return temp;
}
inline ::mesos::master::Response_GetState* Response::unsafe_arena_release_get_state() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.master.Response.get_state)
  clear_has_get_state();
  ::mesos::master::Response_GetState* temp = get_state_;
  get_state_ = NULL;
  return temp;
}
inline ::mesos::master::Response_GetState* Response::mutable_get_state() {
  set_has_get_state();
  if (get_state_ == NULL) {
    _slow_mutable_get_state();
  }
  // @@protoc_insertion_point(field_mutable:mesos.master.Response.get_state)
  return get_state_;
}
inline void Response::set_allocated_get_state(::mesos::master::Response_GetState* get_state) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete get_state_;
  }
  if (get_state) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(get_state);
    if (message_arena != submessage_arena) {
      get_state = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, get_state, submessage_arena);
    }
    set_has_get_state();
  } else {
    clear_has_get_state();
  }
  get_state_ = get_state;
  // @@protoc_insertion_point(field_set_allocated:mesos.master.Response.get_state)
}

// optional .mesos.master.Response.GetAgents get_agents = 10;
inline bool Response::has_get_agents() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Response::set_has_get_agents() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Response::clear_has_get_agents() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Response::clear_get_agents() {
  if (get_agents_ != NULL) get_agents_->Clear();
  clear_has_get_agents();
}
inline const ::mesos::master::Response_GetAgents& Response::get_agents() const {
  const ::mesos::master::Response_GetAgents* p = get_agents_;
  // @@protoc_insertion_point(field_get:mesos.master.Response.get_agents)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::master::Response_GetAgents*>(
      &::mesos::master::_Response_GetAgents_default_instance_);
}
inline ::mesos::master::Response_GetAgents* Response::release_get_agents() {
  // @@protoc_insertion_point(field_release:mesos.master.Response.get_agents)
  clear_has_get_agents();
  ::mesos::master::Response_GetAgents* temp = get_agents_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  get_agents_ = NULL;
  return temp;
}
inline ::mesos::master::Response_GetAgents* Response::unsafe_arena_release_get_agents() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.master.Response.get_agents)
  clear_has_get_agents();
  ::mesos::master::Response_GetAgents* temp = get_agents_;
  get_agents_ = NULL;
  return temp;
}
inline ::mesos::master::Response_GetAgents* Response::mutable_get_agents() {
  set_has_get_agents();
  if (get_agents_ == NULL) {
    _slow_mutable_get_agents();
  }
  // @@protoc_insertion_point(field_mutable:mesos.master.Response.get_agents)
  return get_agents_;
}
inline void Response::set_allocated_get_agents(::mesos::master::Response_GetAgents* get_agents) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete get_agents_;
  }
  if (get_agents) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(get_agents);
    if (message_arena != submessage_arena) {
      get_agents = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, get_agents, submessage_arena);
    }
    set_has_get_agents();
  } else {
    clear_has_get_agents();
  }
  get_agents_ = get_agents;
  // @@protoc_insertion_point(field_set_allocated:mesos.master.Response.get_agents)
}

// optional .mesos.master.Response.GetFrameworks get_frameworks = 11;
inline bool Response::has_get_frameworks() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Response::set_has_get_frameworks() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Response::clear_has_get_frameworks() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Response::clear_get_frameworks() {
  if (get_frameworks_ != NULL) get_frameworks_->Clear();
  clear_has_get_frameworks();
}
inline const ::mesos::master::Response_GetFrameworks& Response::get_frameworks() const {
  const ::mesos::master::Response_GetFrameworks* p = get_frameworks_;
  // @@protoc_insertion_point(field_get:mesos.master.Response.get_frameworks)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::master::Response_GetFrameworks*>(
      &::mesos::master::_Response_GetFrameworks_default_instance_);
}
inline ::mesos::master::Response_GetFrameworks* Response::release_get_frameworks() {
  // @@protoc_insertion_point(field_release:mesos.master.Response.get_frameworks)
  clear_has_get_frameworks();
  ::mesos::master::Response_GetFrameworks* temp = get_frameworks_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  get_frameworks_ = NULL;
  return temp;
}
inline ::mesos::master::Response_GetFrameworks* Response::unsafe_arena_release_get_frameworks() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.master.Response.get_frameworks)
  clear_has_get_frameworks();
  ::mesos::master::Response_GetFrameworks* temp = get_frameworks_;
  get_frameworks_ = NULL;
  return temp;
}
inline ::mesos::master::Response_GetFrameworks* Response::mutable_get_frameworks() {
  set_has_get_frameworks();
  if (get_frameworks_ == NULL) {
    _slow_mutable_get_frameworks();
  }
  // @@protoc_insertion_point(field_mutable:mesos.master.Response.get_frameworks)
  return get_frameworks_;
}
inline void Response::set_allocated_get_frameworks(::mesos::master::Response_GetFrameworks* get_frameworks) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete get_frameworks_;
  }
  if (get_frameworks) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(get_frameworks);
    if (message_arena != submessage_arena) {
      get_frameworks = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, get_frameworks, submessage_arena);
    }
    set_has_get_frameworks();
  } else {
    clear_has_get_frameworks();
  }
  get_frameworks_ = get_frameworks;
  // @@protoc_insertion_point(field_set_allocated:mesos.master.Response.get_frameworks)
}

// optional .mesos.master.Response.GetExecutors get_executors = 12;
inline bool Response::has_get_executors() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Response::set_has_get_executors() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Response::clear_has_get_executors() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Response::clear_get_executors() {
  if (get_executors_ != NULL) get_executors_->Clear();
  clear_has_get_executors();
}
inline const ::mesos::master::Response_GetExecutors& Response::get_executors() const {
  const ::mesos::master::Response_GetExecutors* p = get_executors_;
  // @@protoc_insertion_point(field_get:mesos.master.Response.get_executors)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::master::Response_GetExecutors*>(
      &::mesos::master::_Response_GetExecutors_default_instance_);
}
inline ::mesos::master::Response_GetExecutors* Response::release_get_executors() {
  // @@protoc_insertion_point(field_release:mesos.master.Response.get_executors)
  clear_has_get_executors();
  ::mesos::master::Response_GetExecutors* temp = get_executors_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  get_executors_ = NULL;
  return temp;
}
inline ::mesos::master::Response_GetExecutors* Response::unsafe_arena_release_get_executors() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.master.Response.get_executors)
  clear_has_get_executors();
  ::mesos::master::Response_GetExecutors* temp = get_executors_;
  get_executors_ = NULL;
  return temp;
}
inline ::mesos::master::Response_GetExecutors* Response::mutable_get_executors() {
  set_has_get_executors();
  if (get_executors_ == NULL) {
    _slow_mutable_get_executors();
  }
  // @@protoc_insertion_point(field_mutable:mesos.master.Response.get_executors)
  return get_executors_;
}
inline void Response::set_allocated_get_executors(::mesos::master::Response_GetExecutors* get_executors) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete get_executors_;
  }
  if (get_executors) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(get_executors);
    if (message_arena != submessage_arena) {
      get_executors = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, get_executors, submessage_arena);
    }
    set_has_get_executors();
  } else {
    clear_has_get_executors();
  }
  get_executors_ = get_executors;
  // @@protoc_insertion_point(field_set_allocated:mesos.master.Response.get_executors)
}

// optional .mesos.master.Response.GetOperations get_operations = 20;
inline bool Response::has_get_operations() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void Response::set_has_get_operations() {
  _has_bits_[0] |= 0x00040000u;
}
inline void Response::clear_has_get_operations() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void Response::clear_get_operations() {
  if (get_operations_ != NULL) get_operations_->Clear();
  clear_has_get_operations();
}
inline const ::mesos::master::Response_GetOperations& Response::get_operations() const {
  const ::mesos::master::Response_GetOperations* p = get_operations_;
  // @@protoc_insertion_point(field_get:mesos.master.Response.get_operations)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::master::Response_GetOperations*>(
      &::mesos::master::_Response_GetOperations_default_instance_);
}
inline ::mesos::master::Response_GetOperations* Response::release_get_operations() {
  // @@protoc_insertion_point(field_release:mesos.master.Response.get_operations)
  clear_has_get_operations();
  ::mesos::master::Response_GetOperations* temp = get_operations_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  get_operations_ = NULL;
  return temp;
}
inline ::mesos::master::Response_GetOperations* Response::unsafe_arena_release_get_operations() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.master.Response.get_operations)
  clear_has_get_operations();
  ::mesos::master::Response_GetOperations* temp = get_operations_;
  get_operations_ = NULL;
  return temp;
}
inline ::mesos::master::Response_GetOperations* Response::mutable_get_operations() {
  set_has_get_operations();
  if (get_operations_ == NULL) {
    _slow_mutable_get_operations();
  }
  // @@protoc_insertion_point(field_mutable:mesos.master.Response.get_operations)
  return get_operations_;
}
inline void Response::set_allocated_get_operations(::mesos::master::Response_GetOperations* get_operations) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete get_operations_;
  }
  if (get_operations) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(get_operations);
    if (message_arena != submessage_arena) {
      get_operations = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, get_operations, submessage_arena);
    }
    set_has_get_operations();
  } else {
    clear_has_get_operations();
  }
  get_operations_ = get_operations;
  // @@protoc_insertion_point(field_set_allocated:mesos.master.Response.get_operations)
}

// optional .mesos.master.Response.GetTasks get_tasks = 13;
inline bool Response::has_get_tasks() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Response::set_has_get_tasks() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Response::clear_has_get_tasks() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Response::clear_get_tasks() {
  if (get_tasks_ != NULL) get_tasks_->Clear();
  clear_has_get_tasks();
}
inline const ::mesos::master::Response_GetTasks& Response::get_tasks() const {
  const ::mesos::master::Response_GetTasks* p = get_tasks_;
  // @@protoc_insertion_point(field_get:mesos.master.Response.get_tasks)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::master::Response_GetTasks*>(
      &::mesos::master::_Response_GetTasks_default_instance_);
}
inline ::mesos::master::Response_GetTasks* Response::release_get_tasks() {
  // @@protoc_insertion_point(field_release:mesos.master.Response.get_tasks)
  clear_has_get_tasks();
  ::mesos::master::Response_GetTasks* temp = get_tasks_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  get_tasks_ = NULL;
  return temp;
}
inline ::mesos::master::Response_GetTasks* Response::unsafe_arena_release_get_tasks() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.master.Response.get_tasks)
  clear_has_get_tasks();
  ::mesos::master::Response_GetTasks* temp = get_tasks_;
  get_tasks_ = NULL;
  return temp;
}
inline ::mesos::master::Response_GetTasks* Response::mutable_get_tasks() {
  set_has_get_tasks();
  if (get_tasks_ == NULL) {
    _slow_mutable_get_tasks();
  }
  // @@protoc_insertion_point(field_mutable:mesos.master.Response.get_tasks)
  return get_tasks_;
}
inline void Response::set_allocated_get_tasks(::mesos::master::Response_GetTasks* get_tasks) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete get_tasks_;
  }
  if (get_tasks) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(get_tasks);
    if (message_arena != submessage_arena) {
      get_tasks = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, get_tasks, submessage_arena);
    }
    set_has_get_tasks();
  } else {
    clear_has_get_tasks();
  }
  get_tasks_ = get_tasks;
  // @@protoc_insertion_point(field_set_allocated:mesos.master.Response.get_tasks)
}

// optional .mesos.master.Response.GetRoles get_roles = 14;
inline bool Response::has_get_roles() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Response::set_has_get_roles() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Response::clear_has_get_roles() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Response::clear_get_roles() {
  if (get_roles_ != NULL) get_roles_->Clear();
  clear_has_get_roles();
}
inline const ::mesos::master::Response_GetRoles& Response::get_roles() const {
  const ::mesos::master::Response_GetRoles* p = get_roles_;
  // @@protoc_insertion_point(field_get:mesos.master.Response.get_roles)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::master::Response_GetRoles*>(
      &::mesos::master::_Response_GetRoles_default_instance_);
}
inline ::mesos::master::Response_GetRoles* Response::release_get_roles() {
  // @@protoc_insertion_point(field_release:mesos.master.Response.get_roles)
  clear_has_get_roles();
  ::mesos::master::Response_GetRoles* temp = get_roles_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  get_roles_ = NULL;
  return temp;
}
inline ::mesos::master::Response_GetRoles* Response::unsafe_arena_release_get_roles() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.master.Response.get_roles)
  clear_has_get_roles();
  ::mesos::master::Response_GetRoles* temp = get_roles_;
  get_roles_ = NULL;
  return temp;
}
inline ::mesos::master::Response_GetRoles* Response::mutable_get_roles() {
  set_has_get_roles();
  if (get_roles_ == NULL) {
    _slow_mutable_get_roles();
  }
  // @@protoc_insertion_point(field_mutable:mesos.master.Response.get_roles)
  return get_roles_;
}
inline void Response::set_allocated_get_roles(::mesos::master::Response_GetRoles* get_roles) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete get_roles_;
  }
  if (get_roles) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(get_roles);
    if (message_arena != submessage_arena) {
      get_roles = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, get_roles, submessage_arena);
    }
    set_has_get_roles();
  } else {
    clear_has_get_roles();
  }
  get_roles_ = get_roles;
  // @@protoc_insertion_point(field_set_allocated:mesos.master.Response.get_roles)
}

// optional .mesos.master.Response.GetWeights get_weights = 15;
inline bool Response::has_get_weights() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Response::set_has_get_weights() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Response::clear_has_get_weights() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Response::clear_get_weights() {
  if (get_weights_ != NULL) get_weights_->Clear();
  clear_has_get_weights();
}
inline const ::mesos::master::Response_GetWeights& Response::get_weights() const {
  const ::mesos::master::Response_GetWeights* p = get_weights_;
  // @@protoc_insertion_point(field_get:mesos.master.Response.get_weights)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::master::Response_GetWeights*>(
      &::mesos::master::_Response_GetWeights_default_instance_);
}
inline ::mesos::master::Response_GetWeights* Response::release_get_weights() {
  // @@protoc_insertion_point(field_release:mesos.master.Response.get_weights)
  clear_has_get_weights();
  ::mesos::master::Response_GetWeights* temp = get_weights_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  get_weights_ = NULL;
  return temp;
}
inline ::mesos::master::Response_GetWeights* Response::unsafe_arena_release_get_weights() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.master.Response.get_weights)
  clear_has_get_weights();
  ::mesos::master::Response_GetWeights* temp = get_weights_;
  get_weights_ = NULL;
  return temp;
}
inline ::mesos::master::Response_GetWeights* Response::mutable_get_weights() {
  set_has_get_weights();
  if (get_weights_ == NULL) {
    _slow_mutable_get_weights();
  }
  // @@protoc_insertion_point(field_mutable:mesos.master.Response.get_weights)
  return get_weights_;
}
inline void Response::set_allocated_get_weights(::mesos::master::Response_GetWeights* get_weights) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete get_weights_;
  }
  if (get_weights) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(get_weights);
    if (message_arena != submessage_arena) {
      get_weights = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, get_weights, submessage_arena);
    }
    set_has_get_weights();
  } else {
    clear_has_get_weights();
  }
  get_weights_ = get_weights;
  // @@protoc_insertion_point(field_set_allocated:mesos.master.Response.get_weights)
}

// optional .mesos.master.Response.GetMaster get_master = 16;
inline bool Response::has_get_master() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Response::set_has_get_master() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Response::clear_has_get_master() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Response::clear_get_master() {
  if (get_master_ != NULL) get_master_->Clear();
  clear_has_get_master();
}
inline const ::mesos::master::Response_GetMaster& Response::get_master() const {
  const ::mesos::master::Response_GetMaster* p = get_master_;
  // @@protoc_insertion_point(field_get:mesos.master.Response.get_master)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::master::Response_GetMaster*>(
      &::mesos::master::_Response_GetMaster_default_instance_);
}
inline ::mesos::master::Response_GetMaster* Response::release_get_master() {
  // @@protoc_insertion_point(field_release:mesos.master.Response.get_master)
  clear_has_get_master();
  ::mesos::master::Response_GetMaster* temp = get_master_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  get_master_ = NULL;
  return temp;
}
inline ::mesos::master::Response_GetMaster* Response::unsafe_arena_release_get_master() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.master.Response.get_master)
  clear_has_get_master();
  ::mesos::master::Response_GetMaster* temp = get_master_;
  get_master_ = NULL;
  return temp;
}
inline ::mesos::master::Response_GetMaster* Response::mutable_get_master() {
  set_has_get_master();
  if (get_master_ == NULL) {
    _slow_mutable_get_master();
  }
  // @@protoc_insertion_point(field_mutable:mesos.master.Response.get_master)
  return get_master_;
}
inline void Response::set_allocated_get_master(::mesos::master::Response_GetMaster* get_master) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete get_master_;
  }
  if (get_master) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(get_master);
    if (message_arena != submessage_arena) {
      get_master = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, get_master, submessage_arena);
    }
    set_has_get_master();
  } else {
    clear_has_get_master();
  }
  get_master_ = get_master;
  // @@protoc_insertion_point(field_set_allocated:mesos.master.Response.get_master)
}

// optional .mesos.master.Response.GetMaintenanceStatus get_maintenance_status = 17;
inline bool Response::has_get_maintenance_status() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Response::set_has_get_maintenance_status() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Response::clear_has_get_maintenance_status() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Response::clear_get_maintenance_status() {
  if (get_maintenance_status_ != NULL) get_maintenance_status_->Clear();
  clear_has_get_maintenance_status();
}
inline const ::mesos::master::Response_GetMaintenanceStatus& Response::get_maintenance_status() const {
  const ::mesos::master::Response_GetMaintenanceStatus* p = get_maintenance_status_;
  // @@protoc_insertion_point(field_get:mesos.master.Response.get_maintenance_status)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::master::Response_GetMaintenanceStatus*>(
      &::mesos::master::_Response_GetMaintenanceStatus_default_instance_);
}
inline ::mesos::master::Response_GetMaintenanceStatus* Response::release_get_maintenance_status() {
  // @@protoc_insertion_point(field_release:mesos.master.Response.get_maintenance_status)
  clear_has_get_maintenance_status();
  ::mesos::master::Response_GetMaintenanceStatus* temp = get_maintenance_status_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  get_maintenance_status_ = NULL;
  return temp;
}
inline ::mesos::master::Response_GetMaintenanceStatus* Response::unsafe_arena_release_get_maintenance_status() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.master.Response.get_maintenance_status)
  clear_has_get_maintenance_status();
  ::mesos::master::Response_GetMaintenanceStatus* temp = get_maintenance_status_;
  get_maintenance_status_ = NULL;
  return temp;
}
inline ::mesos::master::Response_GetMaintenanceStatus* Response::mutable_get_maintenance_status() {
  set_has_get_maintenance_status();
  if (get_maintenance_status_ == NULL) {
    _slow_mutable_get_maintenance_status();
  }
  // @@protoc_insertion_point(field_mutable:mesos.master.Response.get_maintenance_status)
  return get_maintenance_status_;
}
inline void Response::set_allocated_get_maintenance_status(::mesos::master::Response_GetMaintenanceStatus* get_maintenance_status) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete get_maintenance_status_;
  }
  if (get_maintenance_status) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(get_maintenance_status);
    if (message_arena != submessage_arena) {
      get_maintenance_status = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, get_maintenance_status, submessage_arena);
    }
    set_has_get_maintenance_status();
  } else {
    clear_has_get_maintenance_status();
  }
  get_maintenance_status_ = get_maintenance_status;
  // @@protoc_insertion_point(field_set_allocated:mesos.master.Response.get_maintenance_status)
}

// optional .mesos.master.Response.GetMaintenanceSchedule get_maintenance_schedule = 18;
inline bool Response::has_get_maintenance_schedule() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Response::set_has_get_maintenance_schedule() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Response::clear_has_get_maintenance_schedule() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Response::clear_get_maintenance_schedule() {
  if (get_maintenance_schedule_ != NULL) get_maintenance_schedule_->Clear();
  clear_has_get_maintenance_schedule();
}
inline const ::mesos::master::Response_GetMaintenanceSchedule& Response::get_maintenance_schedule() const {
  const ::mesos::master::Response_GetMaintenanceSchedule* p = get_maintenance_schedule_;
  // @@protoc_insertion_point(field_get:mesos.master.Response.get_maintenance_schedule)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::master::Response_GetMaintenanceSchedule*>(
      &::mesos::master::_Response_GetMaintenanceSchedule_default_instance_);
}
inline ::mesos::master::Response_GetMaintenanceSchedule* Response::release_get_maintenance_schedule() {
  // @@protoc_insertion_point(field_release:mesos.master.Response.get_maintenance_schedule)
  clear_has_get_maintenance_schedule();
  ::mesos::master::Response_GetMaintenanceSchedule* temp = get_maintenance_schedule_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  get_maintenance_schedule_ = NULL;
  return temp;
}
inline ::mesos::master::Response_GetMaintenanceSchedule* Response::unsafe_arena_release_get_maintenance_schedule() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.master.Response.get_maintenance_schedule)
  clear_has_get_maintenance_schedule();
  ::mesos::master::Response_GetMaintenanceSchedule* temp = get_maintenance_schedule_;
  get_maintenance_schedule_ = NULL;
  return temp;
}
inline ::mesos::master::Response_GetMaintenanceSchedule* Response::mutable_get_maintenance_schedule() {
  set_has_get_maintenance_schedule();
  if (get_maintenance_schedule_ == NULL) {
    _slow_mutable_get_maintenance_schedule();
  }
  // @@protoc_insertion_point(field_mutable:mesos.master.Response.get_maintenance_schedule)
  return get_maintenance_schedule_;
}
inline void Response::set_allocated_get_maintenance_schedule(::mesos::master::Response_GetMaintenanceSchedule* get_maintenance_schedule) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete get_maintenance_schedule_;
  }
  if (get_maintenance_schedule) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(get_maintenance_schedule);
    if (message_arena != submessage_arena) {
      get_maintenance_schedule = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, get_maintenance_schedule, submessage_arena);
    }
    set_has_get_maintenance_schedule();
  } else {
    clear_has_get_maintenance_schedule();
  }
  get_maintenance_schedule_ = get_maintenance_schedule;
  // @@protoc_insertion_point(field_set_allocated:mesos.master.Response.get_maintenance_schedule)
}

// optional .mesos.master.Response.GetQuota get_quota = 19;
inline bool Response::has_get_quota() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void Response::set_has_get_quota() {
  _has_bits_[0] |= 0x00020000u;
}
inline void Response::clear_has_get_quota() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void Response::clear_get_quota() {
  if (get_quota_ != NULL) get_quota_->Clear();
  clear_has_get_quota();
}
inline const ::mesos::master::Response_GetQuota& Response::get_quota() const {
  const ::mesos::master::Response_GetQuota* p = get_quota_;
  // @@protoc_insertion_point(field_get:mesos.master.Response.get_quota)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::master::Response_GetQuota*>(
      &::mesos::master::_Response_GetQuota_default_instance_);
}
inline ::mesos::master::Response_GetQuota* Response::release_get_quota() {
  // @@protoc_insertion_point(field_release:mesos.master.Response.get_quota)
  clear_has_get_quota();
  ::mesos::master::Response_GetQuota* temp = get_quota_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  get_quota_ = NULL;
  return temp;
}
inline ::mesos::master::Response_GetQuota* Response::unsafe_arena_release_get_quota() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.master.Response.get_quota)
  clear_has_get_quota();
  ::mesos::master::Response_GetQuota* temp = get_quota_;
  get_quota_ = NULL;
  return temp;
}
inline ::mesos::master::Response_GetQuota* Response::mutable_get_quota() {
  set_has_get_quota();
  if (get_quota_ == NULL) {
    _slow_mutable_get_quota();
  }
  // @@protoc_insertion_point(field_mutable:mesos.master.Response.get_quota)
  return get_quota_;
}
inline void Response::set_allocated_get_quota(::mesos::master::Response_GetQuota* get_quota) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete get_quota_;
  }
  if (get_quota) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(get_quota);
    if (message_arena != submessage_arena) {
      get_quota = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, get_quota, submessage_arena);
    }
    set_has_get_quota();
  } else {
    clear_has_get_quota();
  }
  get_quota_ = get_quota;
  // @@protoc_insertion_point(field_set_allocated:mesos.master.Response.get_quota)
}

// -------------------------------------------------------------------

// Event_Subscribed

// optional .mesos.master.Response.GetState get_state = 1;
inline bool Event_Subscribed::has_get_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Event_Subscribed::set_has_get_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Event_Subscribed::clear_has_get_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Event_Subscribed::clear_get_state() {
  if (get_state_ != NULL) get_state_->Clear();
  clear_has_get_state();
}
inline const ::mesos::master::Response_GetState& Event_Subscribed::get_state() const {
  const ::mesos::master::Response_GetState* p = get_state_;
  // @@protoc_insertion_point(field_get:mesos.master.Event.Subscribed.get_state)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::master::Response_GetState*>(
      &::mesos::master::_Response_GetState_default_instance_);
}
inline ::mesos::master::Response_GetState* Event_Subscribed::release_get_state() {
  // @@protoc_insertion_point(field_release:mesos.master.Event.Subscribed.get_state)
  clear_has_get_state();
  ::mesos::master::Response_GetState* temp = get_state_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  get_state_ = NULL;
  return temp;
}
inline ::mesos::master::Response_GetState* Event_Subscribed::unsafe_arena_release_get_state() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.master.Event.Subscribed.get_state)
  clear_has_get_state();
  ::mesos::master::Response_GetState* temp = get_state_;
  get_state_ = NULL;
  return temp;
}
inline ::mesos::master::Response_GetState* Event_Subscribed::mutable_get_state() {
  set_has_get_state();
  if (get_state_ == NULL) {
    _slow_mutable_get_state();
  }
  // @@protoc_insertion_point(field_mutable:mesos.master.Event.Subscribed.get_state)
  return get_state_;
}
inline void Event_Subscribed::set_allocated_get_state(::mesos::master::Response_GetState* get_state) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete get_state_;
  }
  if (get_state) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(get_state);
    if (message_arena != submessage_arena) {
      get_state = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, get_state, submessage_arena);
    }
    set_has_get_state();
  } else {
    clear_has_get_state();
  }
  get_state_ = get_state;
  // @@protoc_insertion_point(field_set_allocated:mesos.master.Event.Subscribed.get_state)
}

// optional double heartbeat_interval_seconds = 2;
inline bool Event_Subscribed::has_heartbeat_interval_seconds() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Event_Subscribed::set_has_heartbeat_interval_seconds() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Event_Subscribed::clear_has_heartbeat_interval_seconds() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Event_Subscribed::clear_heartbeat_interval_seconds() {
  heartbeat_interval_seconds_ = 0;
  clear_has_heartbeat_interval_seconds();
}
inline double Event_Subscribed::heartbeat_interval_seconds() const {
  // @@protoc_insertion_point(field_get:mesos.master.Event.Subscribed.heartbeat_interval_seconds)
  return heartbeat_interval_seconds_;
}
inline void Event_Subscribed::set_heartbeat_interval_seconds(double value) {
  set_has_heartbeat_interval_seconds();
  heartbeat_interval_seconds_ = value;
  // @@protoc_insertion_point(field_set:mesos.master.Event.Subscribed.heartbeat_interval_seconds)
}

// -------------------------------------------------------------------

// Event_TaskAdded

// required .mesos.Task task = 1;
inline bool Event_TaskAdded::has_task() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Event_TaskAdded::set_has_task() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Event_TaskAdded::clear_has_task() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::mesos::Task& Event_TaskAdded::task() const {
  const ::mesos::Task* p = task_;
  // @@protoc_insertion_point(field_get:mesos.master.Event.TaskAdded.task)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::Task*>(
      &::mesos::_Task_default_instance_);
}
inline ::mesos::Task* Event_TaskAdded::release_task() {
  // @@protoc_insertion_point(field_release:mesos.master.Event.TaskAdded.task)
  clear_has_task();
  ::mesos::Task* temp = task_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  task_ = NULL;
  return temp;
}
inline ::mesos::Task* Event_TaskAdded::unsafe_arena_release_task() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.master.Event.TaskAdded.task)
  clear_has_task();
  ::mesos::Task* temp = task_;
  task_ = NULL;
  return temp;
}
inline ::mesos::Task* Event_TaskAdded::mutable_task() {
  set_has_task();
  if (task_ == NULL) {
    _slow_mutable_task();
  }
  // @@protoc_insertion_point(field_mutable:mesos.master.Event.TaskAdded.task)
  return task_;
}
inline void Event_TaskAdded::set_allocated_task(::mesos::Task* task) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(task_);
  }
  if (task) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(task)->GetArena();
    if (message_arena != submessage_arena) {
      task = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, task, submessage_arena);
    }
    set_has_task();
  } else {
    clear_has_task();
  }
  task_ = task;
  // @@protoc_insertion_point(field_set_allocated:mesos.master.Event.TaskAdded.task)
}

// -------------------------------------------------------------------

// Event_TaskUpdated

// required .mesos.FrameworkID framework_id = 1;
inline bool Event_TaskUpdated::has_framework_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Event_TaskUpdated::set_has_framework_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Event_TaskUpdated::clear_has_framework_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::mesos::FrameworkID& Event_TaskUpdated::framework_id() const {
  const ::mesos::FrameworkID* p = framework_id_;
  // @@protoc_insertion_point(field_get:mesos.master.Event.TaskUpdated.framework_id)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::FrameworkID*>(
      &::mesos::_FrameworkID_default_instance_);
}
inline ::mesos::FrameworkID* Event_TaskUpdated::release_framework_id() {
  // @@protoc_insertion_point(field_release:mesos.master.Event.TaskUpdated.framework_id)
  clear_has_framework_id();
  ::mesos::FrameworkID* temp = framework_id_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  framework_id_ = NULL;
  return temp;
}
inline ::mesos::FrameworkID* Event_TaskUpdated::unsafe_arena_release_framework_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.master.Event.TaskUpdated.framework_id)
  clear_has_framework_id();
  ::mesos::FrameworkID* temp = framework_id_;
  framework_id_ = NULL;
  return temp;
}
inline ::mesos::FrameworkID* Event_TaskUpdated::mutable_framework_id() {
  set_has_framework_id();
  if (framework_id_ == NULL) {
    _slow_mutable_framework_id();
  }
  // @@protoc_insertion_point(field_mutable:mesos.master.Event.TaskUpdated.framework_id)
  return framework_id_;
}
inline void Event_TaskUpdated::set_allocated_framework_id(::mesos::FrameworkID* framework_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(framework_id_);
  }
  if (framework_id) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(framework_id)->GetArena();
    if (message_arena != submessage_arena) {
      framework_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, framework_id, submessage_arena);
    }
    set_has_framework_id();
  } else {
    clear_has_framework_id();
  }
  framework_id_ = framework_id;
  // @@protoc_insertion_point(field_set_allocated:mesos.master.Event.TaskUpdated.framework_id)
}

// required .mesos.TaskStatus status = 2;
inline bool Event_TaskUpdated::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Event_TaskUpdated::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Event_TaskUpdated::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::mesos::TaskStatus& Event_TaskUpdated::status() const {
  const ::mesos::TaskStatus* p = status_;
  // @@protoc_insertion_point(field_get:mesos.master.Event.TaskUpdated.status)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::TaskStatus*>(
      &::mesos::_TaskStatus_default_instance_);
}
inline ::mesos::TaskStatus* Event_TaskUpdated::release_status() {
  // @@protoc_insertion_point(field_release:mesos.master.Event.TaskUpdated.status)
  clear_has_status();
  ::mesos::TaskStatus* temp = status_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  status_ = NULL;
  return temp;
}
inline ::mesos::TaskStatus* Event_TaskUpdated::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.master.Event.TaskUpdated.status)
  clear_has_status();
  ::mesos::TaskStatus* temp = status_;
  status_ = NULL;
  return temp;
}
inline ::mesos::TaskStatus* Event_TaskUpdated::mutable_status() {
  set_has_status();
  if (status_ == NULL) {
    _slow_mutable_status();
  }
  // @@protoc_insertion_point(field_mutable:mesos.master.Event.TaskUpdated.status)
  return status_;
}
inline void Event_TaskUpdated::set_allocated_status(::mesos::TaskStatus* status) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(status_);
  }
  if (status) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(status)->GetArena();
    if (message_arena != submessage_arena) {
      status = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    set_has_status();
  } else {
    clear_has_status();
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:mesos.master.Event.TaskUpdated.status)
}

// required .mesos.TaskState state = 3;
inline bool Event_TaskUpdated::has_state() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Event_TaskUpdated::set_has_state() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Event_TaskUpdated::clear_has_state() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Event_TaskUpdated::clear_state() {
  state_ = 6;
  clear_has_state();
}
inline ::mesos::TaskState Event_TaskUpdated::state() const {
  // @@protoc_insertion_point(field_get:mesos.master.Event.TaskUpdated.state)
  return static_cast< ::mesos::TaskState >(state_);
}
inline void Event_TaskUpdated::set_state(::mesos::TaskState value) {
  assert(::mesos::TaskState_IsValid(value));
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:mesos.master.Event.TaskUpdated.state)
}

// -------------------------------------------------------------------

// Event_FrameworkAdded

// required .mesos.master.Response.GetFrameworks.Framework framework = 1;
inline bool Event_FrameworkAdded::has_framework() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Event_FrameworkAdded::set_has_framework() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Event_FrameworkAdded::clear_has_framework() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Event_FrameworkAdded::clear_framework() {
  if (framework_ != NULL) framework_->Clear();
  clear_has_framework();
}
inline const ::mesos::master::Response_GetFrameworks_Framework& Event_FrameworkAdded::framework() const {
  const ::mesos::master::Response_GetFrameworks_Framework* p = framework_;
  // @@protoc_insertion_point(field_get:mesos.master.Event.FrameworkAdded.framework)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::master::Response_GetFrameworks_Framework*>(
      &::mesos::master::_Response_GetFrameworks_Framework_default_instance_);
}
inline ::mesos::master::Response_GetFrameworks_Framework* Event_FrameworkAdded::release_framework() {
  // @@protoc_insertion_point(field_release:mesos.master.Event.FrameworkAdded.framework)
  clear_has_framework();
  ::mesos::master::Response_GetFrameworks_Framework* temp = framework_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  framework_ = NULL;
  return temp;
}
inline ::mesos::master::Response_GetFrameworks_Framework* Event_FrameworkAdded::unsafe_arena_release_framework() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.master.Event.FrameworkAdded.framework)
  clear_has_framework();
  ::mesos::master::Response_GetFrameworks_Framework* temp = framework_;
  framework_ = NULL;
  return temp;
}
inline ::mesos::master::Response_GetFrameworks_Framework* Event_FrameworkAdded::mutable_framework() {
  set_has_framework();
  if (framework_ == NULL) {
    _slow_mutable_framework();
  }
  // @@protoc_insertion_point(field_mutable:mesos.master.Event.FrameworkAdded.framework)
  return framework_;
}
inline void Event_FrameworkAdded::set_allocated_framework(::mesos::master::Response_GetFrameworks_Framework* framework) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete framework_;
  }
  if (framework) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(framework);
    if (message_arena != submessage_arena) {
      framework = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, framework, submessage_arena);
    }
    set_has_framework();
  } else {
    clear_has_framework();
  }
  framework_ = framework;
  // @@protoc_insertion_point(field_set_allocated:mesos.master.Event.FrameworkAdded.framework)
}

// -------------------------------------------------------------------

// Event_FrameworkUpdated

// required .mesos.master.Response.GetFrameworks.Framework framework = 1;
inline bool Event_FrameworkUpdated::has_framework() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Event_FrameworkUpdated::set_has_framework() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Event_FrameworkUpdated::clear_has_framework() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Event_FrameworkUpdated::clear_framework() {
  if (framework_ != NULL) framework_->Clear();
  clear_has_framework();
}
inline const ::mesos::master::Response_GetFrameworks_Framework& Event_FrameworkUpdated::framework() const {
  const ::mesos::master::Response_GetFrameworks_Framework* p = framework_;
  // @@protoc_insertion_point(field_get:mesos.master.Event.FrameworkUpdated.framework)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::master::Response_GetFrameworks_Framework*>(
      &::mesos::master::_Response_GetFrameworks_Framework_default_instance_);
}
inline ::mesos::master::Response_GetFrameworks_Framework* Event_FrameworkUpdated::release_framework() {
  // @@protoc_insertion_point(field_release:mesos.master.Event.FrameworkUpdated.framework)
  clear_has_framework();
  ::mesos::master::Response_GetFrameworks_Framework* temp = framework_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  framework_ = NULL;
  return temp;
}
inline ::mesos::master::Response_GetFrameworks_Framework* Event_FrameworkUpdated::unsafe_arena_release_framework() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.master.Event.FrameworkUpdated.framework)
  clear_has_framework();
  ::mesos::master::Response_GetFrameworks_Framework* temp = framework_;
  framework_ = NULL;
  return temp;
}
inline ::mesos::master::Response_GetFrameworks_Framework* Event_FrameworkUpdated::mutable_framework() {
  set_has_framework();
  if (framework_ == NULL) {
    _slow_mutable_framework();
  }
  // @@protoc_insertion_point(field_mutable:mesos.master.Event.FrameworkUpdated.framework)
  return framework_;
}
inline void Event_FrameworkUpdated::set_allocated_framework(::mesos::master::Response_GetFrameworks_Framework* framework) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete framework_;
  }
  if (framework) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(framework);
    if (message_arena != submessage_arena) {
      framework = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, framework, submessage_arena);
    }
    set_has_framework();
  } else {
    clear_has_framework();
  }
  framework_ = framework;
  // @@protoc_insertion_point(field_set_allocated:mesos.master.Event.FrameworkUpdated.framework)
}

// -------------------------------------------------------------------

// Event_FrameworkRemoved

// required .mesos.FrameworkInfo framework_info = 1;
inline bool Event_FrameworkRemoved::has_framework_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Event_FrameworkRemoved::set_has_framework_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Event_FrameworkRemoved::clear_has_framework_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::mesos::FrameworkInfo& Event_FrameworkRemoved::framework_info() const {
  const ::mesos::FrameworkInfo* p = framework_info_;
  // @@protoc_insertion_point(field_get:mesos.master.Event.FrameworkRemoved.framework_info)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::FrameworkInfo*>(
      &::mesos::_FrameworkInfo_default_instance_);
}
inline ::mesos::FrameworkInfo* Event_FrameworkRemoved::release_framework_info() {
  // @@protoc_insertion_point(field_release:mesos.master.Event.FrameworkRemoved.framework_info)
  clear_has_framework_info();
  ::mesos::FrameworkInfo* temp = framework_info_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  framework_info_ = NULL;
  return temp;
}
inline ::mesos::FrameworkInfo* Event_FrameworkRemoved::unsafe_arena_release_framework_info() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.master.Event.FrameworkRemoved.framework_info)
  clear_has_framework_info();
  ::mesos::FrameworkInfo* temp = framework_info_;
  framework_info_ = NULL;
  return temp;
}
inline ::mesos::FrameworkInfo* Event_FrameworkRemoved::mutable_framework_info() {
  set_has_framework_info();
  if (framework_info_ == NULL) {
    _slow_mutable_framework_info();
  }
  // @@protoc_insertion_point(field_mutable:mesos.master.Event.FrameworkRemoved.framework_info)
  return framework_info_;
}
inline void Event_FrameworkRemoved::set_allocated_framework_info(::mesos::FrameworkInfo* framework_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(framework_info_);
  }
  if (framework_info) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(framework_info)->GetArena();
    if (message_arena != submessage_arena) {
      framework_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, framework_info, submessage_arena);
    }
    set_has_framework_info();
  } else {
    clear_has_framework_info();
  }
  framework_info_ = framework_info;
  // @@protoc_insertion_point(field_set_allocated:mesos.master.Event.FrameworkRemoved.framework_info)
}

// -------------------------------------------------------------------

// Event_AgentAdded

// required .mesos.master.Response.GetAgents.Agent agent = 1;
inline bool Event_AgentAdded::has_agent() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Event_AgentAdded::set_has_agent() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Event_AgentAdded::clear_has_agent() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Event_AgentAdded::clear_agent() {
  if (agent_ != NULL) agent_->Clear();
  clear_has_agent();
}
inline const ::mesos::master::Response_GetAgents_Agent& Event_AgentAdded::agent() const {
  const ::mesos::master::Response_GetAgents_Agent* p = agent_;
  // @@protoc_insertion_point(field_get:mesos.master.Event.AgentAdded.agent)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::master::Response_GetAgents_Agent*>(
      &::mesos::master::_Response_GetAgents_Agent_default_instance_);
}
inline ::mesos::master::Response_GetAgents_Agent* Event_AgentAdded::release_agent() {
  // @@protoc_insertion_point(field_release:mesos.master.Event.AgentAdded.agent)
  clear_has_agent();
  ::mesos::master::Response_GetAgents_Agent* temp = agent_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  agent_ = NULL;
  return temp;
}
inline ::mesos::master::Response_GetAgents_Agent* Event_AgentAdded::unsafe_arena_release_agent() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.master.Event.AgentAdded.agent)
  clear_has_agent();
  ::mesos::master::Response_GetAgents_Agent* temp = agent_;
  agent_ = NULL;
  return temp;
}
inline ::mesos::master::Response_GetAgents_Agent* Event_AgentAdded::mutable_agent() {
  set_has_agent();
  if (agent_ == NULL) {
    _slow_mutable_agent();
  }
  // @@protoc_insertion_point(field_mutable:mesos.master.Event.AgentAdded.agent)
  return agent_;
}
inline void Event_AgentAdded::set_allocated_agent(::mesos::master::Response_GetAgents_Agent* agent) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete agent_;
  }
  if (agent) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(agent);
    if (message_arena != submessage_arena) {
      agent = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, agent, submessage_arena);
    }
    set_has_agent();
  } else {
    clear_has_agent();
  }
  agent_ = agent;
  // @@protoc_insertion_point(field_set_allocated:mesos.master.Event.AgentAdded.agent)
}

// -------------------------------------------------------------------

// Event_AgentRemoved

// required .mesos.SlaveID agent_id = 1;
inline bool Event_AgentRemoved::has_agent_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Event_AgentRemoved::set_has_agent_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Event_AgentRemoved::clear_has_agent_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::mesos::SlaveID& Event_AgentRemoved::agent_id() const {
  const ::mesos::SlaveID* p = agent_id_;
  // @@protoc_insertion_point(field_get:mesos.master.Event.AgentRemoved.agent_id)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::SlaveID*>(
      &::mesos::_SlaveID_default_instance_);
}
inline ::mesos::SlaveID* Event_AgentRemoved::release_agent_id() {
  // @@protoc_insertion_point(field_release:mesos.master.Event.AgentRemoved.agent_id)
  clear_has_agent_id();
  ::mesos::SlaveID* temp = agent_id_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  agent_id_ = NULL;
  return temp;
}
inline ::mesos::SlaveID* Event_AgentRemoved::unsafe_arena_release_agent_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.master.Event.AgentRemoved.agent_id)
  clear_has_agent_id();
  ::mesos::SlaveID* temp = agent_id_;
  agent_id_ = NULL;
  return temp;
}
inline ::mesos::SlaveID* Event_AgentRemoved::mutable_agent_id() {
  set_has_agent_id();
  if (agent_id_ == NULL) {
    _slow_mutable_agent_id();
  }
  // @@protoc_insertion_point(field_mutable:mesos.master.Event.AgentRemoved.agent_id)
  return agent_id_;
}
inline void Event_AgentRemoved::set_allocated_agent_id(::mesos::SlaveID* agent_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(agent_id_);
  }
  if (agent_id) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(agent_id)->GetArena();
    if (message_arena != submessage_arena) {
      agent_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, agent_id, submessage_arena);
    }
    set_has_agent_id();
  } else {
    clear_has_agent_id();
  }
  agent_id_ = agent_id;
  // @@protoc_insertion_point(field_set_allocated:mesos.master.Event.AgentRemoved.agent_id)
}

// -------------------------------------------------------------------

// Event

// optional .mesos.master.Event.Type type = 1;
inline bool Event::has_type() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Event::set_has_type() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Event::clear_has_type() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Event::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::mesos::master::Event_Type Event::type() const {
  // @@protoc_insertion_point(field_get:mesos.master.Event.type)
  return static_cast< ::mesos::master::Event_Type >(type_);
}
inline void Event::set_type(::mesos::master::Event_Type value) {
  assert(::mesos::master::Event_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:mesos.master.Event.type)
}

// optional .mesos.master.Event.Subscribed subscribed = 2;
inline bool Event::has_subscribed() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Event::set_has_subscribed() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Event::clear_has_subscribed() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Event::clear_subscribed() {
  if (subscribed_ != NULL) subscribed_->Clear();
  clear_has_subscribed();
}
inline const ::mesos::master::Event_Subscribed& Event::subscribed() const {
  const ::mesos::master::Event_Subscribed* p = subscribed_;
  // @@protoc_insertion_point(field_get:mesos.master.Event.subscribed)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::master::Event_Subscribed*>(
      &::mesos::master::_Event_Subscribed_default_instance_);
}
inline ::mesos::master::Event_Subscribed* Event::release_subscribed() {
  // @@protoc_insertion_point(field_release:mesos.master.Event.subscribed)
  clear_has_subscribed();
  ::mesos::master::Event_Subscribed* temp = subscribed_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  subscribed_ = NULL;
  return temp;
}
inline ::mesos::master::Event_Subscribed* Event::unsafe_arena_release_subscribed() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.master.Event.subscribed)
  clear_has_subscribed();
  ::mesos::master::Event_Subscribed* temp = subscribed_;
  subscribed_ = NULL;
  return temp;
}
inline ::mesos::master::Event_Subscribed* Event::mutable_subscribed() {
  set_has_subscribed();
  if (subscribed_ == NULL) {
    _slow_mutable_subscribed();
  }
  // @@protoc_insertion_point(field_mutable:mesos.master.Event.subscribed)
  return subscribed_;
}
inline void Event::set_allocated_subscribed(::mesos::master::Event_Subscribed* subscribed) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete subscribed_;
  }
  if (subscribed) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(subscribed);
    if (message_arena != submessage_arena) {
      subscribed = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, subscribed, submessage_arena);
    }
    set_has_subscribed();
  } else {
    clear_has_subscribed();
  }
  subscribed_ = subscribed;
  // @@protoc_insertion_point(field_set_allocated:mesos.master.Event.subscribed)
}

// optional .mesos.master.Event.TaskAdded task_added = 3;
inline bool Event::has_task_added() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Event::set_has_task_added() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Event::clear_has_task_added() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Event::clear_task_added() {
  if (task_added_ != NULL) task_added_->Clear();
  clear_has_task_added();
}
inline const ::mesos::master::Event_TaskAdded& Event::task_added() const {
  const ::mesos::master::Event_TaskAdded* p = task_added_;
  // @@protoc_insertion_point(field_get:mesos.master.Event.task_added)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::master::Event_TaskAdded*>(
      &::mesos::master::_Event_TaskAdded_default_instance_);
}
inline ::mesos::master::Event_TaskAdded* Event::release_task_added() {
  // @@protoc_insertion_point(field_release:mesos.master.Event.task_added)
  clear_has_task_added();
  ::mesos::master::Event_TaskAdded* temp = task_added_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  task_added_ = NULL;
  return temp;
}
inline ::mesos::master::Event_TaskAdded* Event::unsafe_arena_release_task_added() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.master.Event.task_added)
  clear_has_task_added();
  ::mesos::master::Event_TaskAdded* temp = task_added_;
  task_added_ = NULL;
  return temp;
}
inline ::mesos::master::Event_TaskAdded* Event::mutable_task_added() {
  set_has_task_added();
  if (task_added_ == NULL) {
    _slow_mutable_task_added();
  }
  // @@protoc_insertion_point(field_mutable:mesos.master.Event.task_added)
  return task_added_;
}
inline void Event::set_allocated_task_added(::mesos::master::Event_TaskAdded* task_added) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete task_added_;
  }
  if (task_added) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(task_added);
    if (message_arena != submessage_arena) {
      task_added = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, task_added, submessage_arena);
    }
    set_has_task_added();
  } else {
    clear_has_task_added();
  }
  task_added_ = task_added;
  // @@protoc_insertion_point(field_set_allocated:mesos.master.Event.task_added)
}

// optional .mesos.master.Event.TaskUpdated task_updated = 4;
inline bool Event::has_task_updated() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Event::set_has_task_updated() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Event::clear_has_task_updated() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Event::clear_task_updated() {
  if (task_updated_ != NULL) task_updated_->Clear();
  clear_has_task_updated();
}
inline const ::mesos::master::Event_TaskUpdated& Event::task_updated() const {
  const ::mesos::master::Event_TaskUpdated* p = task_updated_;
  // @@protoc_insertion_point(field_get:mesos.master.Event.task_updated)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::master::Event_TaskUpdated*>(
      &::mesos::master::_Event_TaskUpdated_default_instance_);
}
inline ::mesos::master::Event_TaskUpdated* Event::release_task_updated() {
  // @@protoc_insertion_point(field_release:mesos.master.Event.task_updated)
  clear_has_task_updated();
  ::mesos::master::Event_TaskUpdated* temp = task_updated_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  task_updated_ = NULL;
  return temp;
}
inline ::mesos::master::Event_TaskUpdated* Event::unsafe_arena_release_task_updated() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.master.Event.task_updated)
  clear_has_task_updated();
  ::mesos::master::Event_TaskUpdated* temp = task_updated_;
  task_updated_ = NULL;
  return temp;
}
inline ::mesos::master::Event_TaskUpdated* Event::mutable_task_updated() {
  set_has_task_updated();
  if (task_updated_ == NULL) {
    _slow_mutable_task_updated();
  }
  // @@protoc_insertion_point(field_mutable:mesos.master.Event.task_updated)
  return task_updated_;
}
inline void Event::set_allocated_task_updated(::mesos::master::Event_TaskUpdated* task_updated) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete task_updated_;
  }
  if (task_updated) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(task_updated);
    if (message_arena != submessage_arena) {
      task_updated = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, task_updated, submessage_arena);
    }
    set_has_task_updated();
  } else {
    clear_has_task_updated();
  }
  task_updated_ = task_updated;
  // @@protoc_insertion_point(field_set_allocated:mesos.master.Event.task_updated)
}

// optional .mesos.master.Event.AgentAdded agent_added = 5;
inline bool Event::has_agent_added() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Event::set_has_agent_added() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Event::clear_has_agent_added() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Event::clear_agent_added() {
  if (agent_added_ != NULL) agent_added_->Clear();
  clear_has_agent_added();
}
inline const ::mesos::master::Event_AgentAdded& Event::agent_added() const {
  const ::mesos::master::Event_AgentAdded* p = agent_added_;
  // @@protoc_insertion_point(field_get:mesos.master.Event.agent_added)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::master::Event_AgentAdded*>(
      &::mesos::master::_Event_AgentAdded_default_instance_);
}
inline ::mesos::master::Event_AgentAdded* Event::release_agent_added() {
  // @@protoc_insertion_point(field_release:mesos.master.Event.agent_added)
  clear_has_agent_added();
  ::mesos::master::Event_AgentAdded* temp = agent_added_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  agent_added_ = NULL;
  return temp;
}
inline ::mesos::master::Event_AgentAdded* Event::unsafe_arena_release_agent_added() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.master.Event.agent_added)
  clear_has_agent_added();
  ::mesos::master::Event_AgentAdded* temp = agent_added_;
  agent_added_ = NULL;
  return temp;
}
inline ::mesos::master::Event_AgentAdded* Event::mutable_agent_added() {
  set_has_agent_added();
  if (agent_added_ == NULL) {
    _slow_mutable_agent_added();
  }
  // @@protoc_insertion_point(field_mutable:mesos.master.Event.agent_added)
  return agent_added_;
}
inline void Event::set_allocated_agent_added(::mesos::master::Event_AgentAdded* agent_added) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete agent_added_;
  }
  if (agent_added) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(agent_added);
    if (message_arena != submessage_arena) {
      agent_added = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, agent_added, submessage_arena);
    }
    set_has_agent_added();
  } else {
    clear_has_agent_added();
  }
  agent_added_ = agent_added;
  // @@protoc_insertion_point(field_set_allocated:mesos.master.Event.agent_added)
}

// optional .mesos.master.Event.AgentRemoved agent_removed = 6;
inline bool Event::has_agent_removed() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Event::set_has_agent_removed() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Event::clear_has_agent_removed() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Event::clear_agent_removed() {
  if (agent_removed_ != NULL) agent_removed_->Clear();
  clear_has_agent_removed();
}
inline const ::mesos::master::Event_AgentRemoved& Event::agent_removed() const {
  const ::mesos::master::Event_AgentRemoved* p = agent_removed_;
  // @@protoc_insertion_point(field_get:mesos.master.Event.agent_removed)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::master::Event_AgentRemoved*>(
      &::mesos::master::_Event_AgentRemoved_default_instance_);
}
inline ::mesos::master::Event_AgentRemoved* Event::release_agent_removed() {
  // @@protoc_insertion_point(field_release:mesos.master.Event.agent_removed)
  clear_has_agent_removed();
  ::mesos::master::Event_AgentRemoved* temp = agent_removed_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  agent_removed_ = NULL;
  return temp;
}
inline ::mesos::master::Event_AgentRemoved* Event::unsafe_arena_release_agent_removed() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.master.Event.agent_removed)
  clear_has_agent_removed();
  ::mesos::master::Event_AgentRemoved* temp = agent_removed_;
  agent_removed_ = NULL;
  return temp;
}
inline ::mesos::master::Event_AgentRemoved* Event::mutable_agent_removed() {
  set_has_agent_removed();
  if (agent_removed_ == NULL) {
    _slow_mutable_agent_removed();
  }
  // @@protoc_insertion_point(field_mutable:mesos.master.Event.agent_removed)
  return agent_removed_;
}
inline void Event::set_allocated_agent_removed(::mesos::master::Event_AgentRemoved* agent_removed) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete agent_removed_;
  }
  if (agent_removed) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(agent_removed);
    if (message_arena != submessage_arena) {
      agent_removed = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, agent_removed, submessage_arena);
    }
    set_has_agent_removed();
  } else {
    clear_has_agent_removed();
  }
  agent_removed_ = agent_removed;
  // @@protoc_insertion_point(field_set_allocated:mesos.master.Event.agent_removed)
}

// optional .mesos.master.Event.FrameworkAdded framework_added = 7;
inline bool Event::has_framework_added() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Event::set_has_framework_added() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Event::clear_has_framework_added() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Event::clear_framework_added() {
  if (framework_added_ != NULL) framework_added_->Clear();
  clear_has_framework_added();
}
inline const ::mesos::master::Event_FrameworkAdded& Event::framework_added() const {
  const ::mesos::master::Event_FrameworkAdded* p = framework_added_;
  // @@protoc_insertion_point(field_get:mesos.master.Event.framework_added)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::master::Event_FrameworkAdded*>(
      &::mesos::master::_Event_FrameworkAdded_default_instance_);
}
inline ::mesos::master::Event_FrameworkAdded* Event::release_framework_added() {
  // @@protoc_insertion_point(field_release:mesos.master.Event.framework_added)
  clear_has_framework_added();
  ::mesos::master::Event_FrameworkAdded* temp = framework_added_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  framework_added_ = NULL;
  return temp;
}
inline ::mesos::master::Event_FrameworkAdded* Event::unsafe_arena_release_framework_added() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.master.Event.framework_added)
  clear_has_framework_added();
  ::mesos::master::Event_FrameworkAdded* temp = framework_added_;
  framework_added_ = NULL;
  return temp;
}
inline ::mesos::master::Event_FrameworkAdded* Event::mutable_framework_added() {
  set_has_framework_added();
  if (framework_added_ == NULL) {
    _slow_mutable_framework_added();
  }
  // @@protoc_insertion_point(field_mutable:mesos.master.Event.framework_added)
  return framework_added_;
}
inline void Event::set_allocated_framework_added(::mesos::master::Event_FrameworkAdded* framework_added) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete framework_added_;
  }
  if (framework_added) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(framework_added);
    if (message_arena != submessage_arena) {
      framework_added = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, framework_added, submessage_arena);
    }
    set_has_framework_added();
  } else {
    clear_has_framework_added();
  }
  framework_added_ = framework_added;
  // @@protoc_insertion_point(field_set_allocated:mesos.master.Event.framework_added)
}

// optional .mesos.master.Event.FrameworkUpdated framework_updated = 8;
inline bool Event::has_framework_updated() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Event::set_has_framework_updated() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Event::clear_has_framework_updated() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Event::clear_framework_updated() {
  if (framework_updated_ != NULL) framework_updated_->Clear();
  clear_has_framework_updated();
}
inline const ::mesos::master::Event_FrameworkUpdated& Event::framework_updated() const {
  const ::mesos::master::Event_FrameworkUpdated* p = framework_updated_;
  // @@protoc_insertion_point(field_get:mesos.master.Event.framework_updated)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::master::Event_FrameworkUpdated*>(
      &::mesos::master::_Event_FrameworkUpdated_default_instance_);
}
inline ::mesos::master::Event_FrameworkUpdated* Event::release_framework_updated() {
  // @@protoc_insertion_point(field_release:mesos.master.Event.framework_updated)
  clear_has_framework_updated();
  ::mesos::master::Event_FrameworkUpdated* temp = framework_updated_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  framework_updated_ = NULL;
  return temp;
}
inline ::mesos::master::Event_FrameworkUpdated* Event::unsafe_arena_release_framework_updated() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.master.Event.framework_updated)
  clear_has_framework_updated();
  ::mesos::master::Event_FrameworkUpdated* temp = framework_updated_;
  framework_updated_ = NULL;
  return temp;
}
inline ::mesos::master::Event_FrameworkUpdated* Event::mutable_framework_updated() {
  set_has_framework_updated();
  if (framework_updated_ == NULL) {
    _slow_mutable_framework_updated();
  }
  // @@protoc_insertion_point(field_mutable:mesos.master.Event.framework_updated)
  return framework_updated_;
}
inline void Event::set_allocated_framework_updated(::mesos::master::Event_FrameworkUpdated* framework_updated) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete framework_updated_;
  }
  if (framework_updated) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(framework_updated);
    if (message_arena != submessage_arena) {
      framework_updated = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, framework_updated, submessage_arena);
    }
    set_has_framework_updated();
  } else {
    clear_has_framework_updated();
  }
  framework_updated_ = framework_updated;
  // @@protoc_insertion_point(field_set_allocated:mesos.master.Event.framework_updated)
}

// optional .mesos.master.Event.FrameworkRemoved framework_removed = 9;
inline bool Event::has_framework_removed() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Event::set_has_framework_removed() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Event::clear_has_framework_removed() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Event::clear_framework_removed() {
  if (framework_removed_ != NULL) framework_removed_->Clear();
  clear_has_framework_removed();
}
inline const ::mesos::master::Event_FrameworkRemoved& Event::framework_removed() const {
  const ::mesos::master::Event_FrameworkRemoved* p = framework_removed_;
  // @@protoc_insertion_point(field_get:mesos.master.Event.framework_removed)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::master::Event_FrameworkRemoved*>(
      &::mesos::master::_Event_FrameworkRemoved_default_instance_);
}
inline ::mesos::master::Event_FrameworkRemoved* Event::release_framework_removed() {
  // @@protoc_insertion_point(field_release:mesos.master.Event.framework_removed)
  clear_has_framework_removed();
  ::mesos::master::Event_FrameworkRemoved* temp = framework_removed_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  framework_removed_ = NULL;
  return temp;
}
inline ::mesos::master::Event_FrameworkRemoved* Event::unsafe_arena_release_framework_removed() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.master.Event.framework_removed)
  clear_has_framework_removed();
  ::mesos::master::Event_FrameworkRemoved* temp = framework_removed_;
  framework_removed_ = NULL;
  return temp;
}
inline ::mesos::master::Event_FrameworkRemoved* Event::mutable_framework_removed() {
  set_has_framework_removed();
  if (framework_removed_ == NULL) {
    _slow_mutable_framework_removed();
  }
  // @@protoc_insertion_point(field_mutable:mesos.master.Event.framework_removed)
  return framework_removed_;
}
inline void Event::set_allocated_framework_removed(::mesos::master::Event_FrameworkRemoved* framework_removed) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete framework_removed_;
  }
  if (framework_removed) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(framework_removed);
    if (message_arena != submessage_arena) {
      framework_removed = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, framework_removed, submessage_arena);
    }
    set_has_framework_removed();
  } else {
    clear_has_framework_removed();
  }
  framework_removed_ = framework_removed;
  // @@protoc_insertion_point(field_set_allocated:mesos.master.Event.framework_removed)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace master
}  // namespace mesos

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::mesos::master::Call_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mesos::master::Call_Type>() {
  return ::mesos::master::Call_Type_descriptor();
}
template <> struct is_proto_enum< ::mesos::master::Response_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mesos::master::Response_Type>() {
  return ::mesos::master::Response_Type_descriptor();
}
template <> struct is_proto_enum< ::mesos::master::Event_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mesos::master::Event_Type>() {
  return ::mesos::master::Event_Type_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_mesos_2fmaster_2fmaster_2eproto__INCLUDED
