// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mesos/mesos.proto

#ifndef PROTOBUF_mesos_2fmesos_2eproto__INCLUDED
#define PROTOBUF_mesos_2fmesos_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protobuf_mesos_2fmesos_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[157];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsFrameworkIDImpl();
void InitDefaultsFrameworkID();
void InitDefaultsOfferIDImpl();
void InitDefaultsOfferID();
void InitDefaultsSlaveIDImpl();
void InitDefaultsSlaveID();
void InitDefaultsTaskIDImpl();
void InitDefaultsTaskID();
void InitDefaultsExecutorIDImpl();
void InitDefaultsExecutorID();
void InitDefaultsContainerIDImpl();
void InitDefaultsContainerID();
void InitDefaultsResourceProviderIDImpl();
void InitDefaultsResourceProviderID();
void InitDefaultsOperationIDImpl();
void InitDefaultsOperationID();
void InitDefaultsTimeInfoImpl();
void InitDefaultsTimeInfo();
void InitDefaultsDurationInfoImpl();
void InitDefaultsDurationInfo();
void InitDefaultsAddressImpl();
void InitDefaultsAddress();
void InitDefaultsURLImpl();
void InitDefaultsURL();
void InitDefaultsUnavailabilityImpl();
void InitDefaultsUnavailability();
void InitDefaultsMachineIDImpl();
void InitDefaultsMachineID();
void InitDefaultsMachineInfoImpl();
void InitDefaultsMachineInfo();
void InitDefaultsFrameworkInfo_CapabilityImpl();
void InitDefaultsFrameworkInfo_Capability();
void InitDefaultsFrameworkInfoImpl();
void InitDefaultsFrameworkInfo();
void InitDefaultsCheckInfo_CommandImpl();
void InitDefaultsCheckInfo_Command();
void InitDefaultsCheckInfo_HttpImpl();
void InitDefaultsCheckInfo_Http();
void InitDefaultsCheckInfo_TcpImpl();
void InitDefaultsCheckInfo_Tcp();
void InitDefaultsCheckInfoImpl();
void InitDefaultsCheckInfo();
void InitDefaultsHealthCheck_HTTPCheckInfoImpl();
void InitDefaultsHealthCheck_HTTPCheckInfo();
void InitDefaultsHealthCheck_TCPCheckInfoImpl();
void InitDefaultsHealthCheck_TCPCheckInfo();
void InitDefaultsHealthCheckImpl();
void InitDefaultsHealthCheck();
void InitDefaultsKillPolicyImpl();
void InitDefaultsKillPolicy();
void InitDefaultsCommandInfo_URIImpl();
void InitDefaultsCommandInfo_URI();
void InitDefaultsCommandInfoImpl();
void InitDefaultsCommandInfo();
void InitDefaultsExecutorInfoImpl();
void InitDefaultsExecutorInfo();
void InitDefaultsDomainInfo_FaultDomain_RegionInfoImpl();
void InitDefaultsDomainInfo_FaultDomain_RegionInfo();
void InitDefaultsDomainInfo_FaultDomain_ZoneInfoImpl();
void InitDefaultsDomainInfo_FaultDomain_ZoneInfo();
void InitDefaultsDomainInfo_FaultDomainImpl();
void InitDefaultsDomainInfo_FaultDomain();
void InitDefaultsDomainInfoImpl();
void InitDefaultsDomainInfo();
void InitDefaultsMasterInfo_CapabilityImpl();
void InitDefaultsMasterInfo_Capability();
void InitDefaultsMasterInfoImpl();
void InitDefaultsMasterInfo();
void InitDefaultsSlaveInfo_CapabilityImpl();
void InitDefaultsSlaveInfo_Capability();
void InitDefaultsSlaveInfoImpl();
void InitDefaultsSlaveInfo();
void InitDefaultsCSIPluginContainerInfoImpl();
void InitDefaultsCSIPluginContainerInfo();
void InitDefaultsCSIPluginInfoImpl();
void InitDefaultsCSIPluginInfo();
void InitDefaultsResourceProviderInfo_StorageImpl();
void InitDefaultsResourceProviderInfo_Storage();
void InitDefaultsResourceProviderInfoImpl();
void InitDefaultsResourceProviderInfo();
void InitDefaultsValue_ScalarImpl();
void InitDefaultsValue_Scalar();
void InitDefaultsValue_RangeImpl();
void InitDefaultsValue_Range();
void InitDefaultsValue_RangesImpl();
void InitDefaultsValue_Ranges();
void InitDefaultsValue_SetImpl();
void InitDefaultsValue_Set();
void InitDefaultsValue_TextImpl();
void InitDefaultsValue_Text();
void InitDefaultsValueImpl();
void InitDefaultsValue();
void InitDefaultsAttributeImpl();
void InitDefaultsAttribute();
void InitDefaultsResource_AllocationInfoImpl();
void InitDefaultsResource_AllocationInfo();
void InitDefaultsResource_ReservationInfoImpl();
void InitDefaultsResource_ReservationInfo();
void InitDefaultsResource_DiskInfo_PersistenceImpl();
void InitDefaultsResource_DiskInfo_Persistence();
void InitDefaultsResource_DiskInfo_Source_PathImpl();
void InitDefaultsResource_DiskInfo_Source_Path();
void InitDefaultsResource_DiskInfo_Source_MountImpl();
void InitDefaultsResource_DiskInfo_Source_Mount();
void InitDefaultsResource_DiskInfo_SourceImpl();
void InitDefaultsResource_DiskInfo_Source();
void InitDefaultsResource_DiskInfoImpl();
void InitDefaultsResource_DiskInfo();
void InitDefaultsResource_RevocableInfoImpl();
void InitDefaultsResource_RevocableInfo();
void InitDefaultsResource_SharedInfoImpl();
void InitDefaultsResource_SharedInfo();
void InitDefaultsResourceImpl();
void InitDefaultsResource();
void InitDefaultsTrafficControlStatisticsImpl();
void InitDefaultsTrafficControlStatistics();
void InitDefaultsIpStatisticsImpl();
void InitDefaultsIpStatistics();
void InitDefaultsIcmpStatisticsImpl();
void InitDefaultsIcmpStatistics();
void InitDefaultsTcpStatisticsImpl();
void InitDefaultsTcpStatistics();
void InitDefaultsUdpStatisticsImpl();
void InitDefaultsUdpStatistics();
void InitDefaultsSNMPStatisticsImpl();
void InitDefaultsSNMPStatistics();
void InitDefaultsDiskStatisticsImpl();
void InitDefaultsDiskStatistics();
void InitDefaultsResourceStatisticsImpl();
void InitDefaultsResourceStatistics();
void InitDefaultsResourceUsage_Executor_TaskImpl();
void InitDefaultsResourceUsage_Executor_Task();
void InitDefaultsResourceUsage_ExecutorImpl();
void InitDefaultsResourceUsage_Executor();
void InitDefaultsResourceUsageImpl();
void InitDefaultsResourceUsage();
void InitDefaultsPerfStatisticsImpl();
void InitDefaultsPerfStatistics();
void InitDefaultsRequestImpl();
void InitDefaultsRequest();
void InitDefaultsOffer_Operation_LaunchImpl();
void InitDefaultsOffer_Operation_Launch();
void InitDefaultsOffer_Operation_LaunchGroupImpl();
void InitDefaultsOffer_Operation_LaunchGroup();
void InitDefaultsOffer_Operation_ReserveImpl();
void InitDefaultsOffer_Operation_Reserve();
void InitDefaultsOffer_Operation_UnreserveImpl();
void InitDefaultsOffer_Operation_Unreserve();
void InitDefaultsOffer_Operation_CreateImpl();
void InitDefaultsOffer_Operation_Create();
void InitDefaultsOffer_Operation_DestroyImpl();
void InitDefaultsOffer_Operation_Destroy();
void InitDefaultsOffer_Operation_GrowVolumeImpl();
void InitDefaultsOffer_Operation_GrowVolume();
void InitDefaultsOffer_Operation_ShrinkVolumeImpl();
void InitDefaultsOffer_Operation_ShrinkVolume();
void InitDefaultsOffer_Operation_CreateVolumeImpl();
void InitDefaultsOffer_Operation_CreateVolume();
void InitDefaultsOffer_Operation_DestroyVolumeImpl();
void InitDefaultsOffer_Operation_DestroyVolume();
void InitDefaultsOffer_Operation_CreateBlockImpl();
void InitDefaultsOffer_Operation_CreateBlock();
void InitDefaultsOffer_Operation_DestroyBlockImpl();
void InitDefaultsOffer_Operation_DestroyBlock();
void InitDefaultsOffer_OperationImpl();
void InitDefaultsOffer_Operation();
void InitDefaultsOfferImpl();
void InitDefaultsOffer();
void InitDefaultsInverseOfferImpl();
void InitDefaultsInverseOffer();
void InitDefaultsTaskInfoImpl();
void InitDefaultsTaskInfo();
void InitDefaultsTaskGroupInfoImpl();
void InitDefaultsTaskGroupInfo();
void InitDefaultsTaskImpl();
void InitDefaultsTask();
void InitDefaultsTaskResourceLimitationImpl();
void InitDefaultsTaskResourceLimitation();
void InitDefaultsUUIDImpl();
void InitDefaultsUUID();
void InitDefaultsOperationImpl();
void InitDefaultsOperation();
void InitDefaultsOperationStatusImpl();
void InitDefaultsOperationStatus();
void InitDefaultsCheckStatusInfo_CommandImpl();
void InitDefaultsCheckStatusInfo_Command();
void InitDefaultsCheckStatusInfo_HttpImpl();
void InitDefaultsCheckStatusInfo_Http();
void InitDefaultsCheckStatusInfo_TcpImpl();
void InitDefaultsCheckStatusInfo_Tcp();
void InitDefaultsCheckStatusInfoImpl();
void InitDefaultsCheckStatusInfo();
void InitDefaultsTaskStatusImpl();
void InitDefaultsTaskStatus();
void InitDefaultsFiltersImpl();
void InitDefaultsFilters();
void InitDefaultsEnvironment_VariableImpl();
void InitDefaultsEnvironment_Variable();
void InitDefaultsEnvironmentImpl();
void InitDefaultsEnvironment();
void InitDefaultsParameterImpl();
void InitDefaultsParameter();
void InitDefaultsParametersImpl();
void InitDefaultsParameters();
void InitDefaultsCredentialImpl();
void InitDefaultsCredential();
void InitDefaultsCredentialsImpl();
void InitDefaultsCredentials();
void InitDefaultsSecret_ReferenceImpl();
void InitDefaultsSecret_Reference();
void InitDefaultsSecret_ValueImpl();
void InitDefaultsSecret_Value();
void InitDefaultsSecretImpl();
void InitDefaultsSecret();
void InitDefaultsRateLimitImpl();
void InitDefaultsRateLimit();
void InitDefaultsRateLimitsImpl();
void InitDefaultsRateLimits();
void InitDefaultsImage_AppcImpl();
void InitDefaultsImage_Appc();
void InitDefaultsImage_DockerImpl();
void InitDefaultsImage_Docker();
void InitDefaultsImageImpl();
void InitDefaultsImage();
void InitDefaultsMountPropagationImpl();
void InitDefaultsMountPropagation();
void InitDefaultsVolume_Source_DockerVolumeImpl();
void InitDefaultsVolume_Source_DockerVolume();
void InitDefaultsVolume_Source_HostPathImpl();
void InitDefaultsVolume_Source_HostPath();
void InitDefaultsVolume_Source_SandboxPathImpl();
void InitDefaultsVolume_Source_SandboxPath();
void InitDefaultsVolume_SourceImpl();
void InitDefaultsVolume_Source();
void InitDefaultsVolumeImpl();
void InitDefaultsVolume();
void InitDefaultsNetworkInfo_IPAddressImpl();
void InitDefaultsNetworkInfo_IPAddress();
void InitDefaultsNetworkInfo_PortMappingImpl();
void InitDefaultsNetworkInfo_PortMapping();
void InitDefaultsNetworkInfoImpl();
void InitDefaultsNetworkInfo();
void InitDefaultsCapabilityInfoImpl();
void InitDefaultsCapabilityInfo();
void InitDefaultsLinuxInfoImpl();
void InitDefaultsLinuxInfo();
void InitDefaultsRLimitInfo_RLimitImpl();
void InitDefaultsRLimitInfo_RLimit();
void InitDefaultsRLimitInfoImpl();
void InitDefaultsRLimitInfo();
void InitDefaultsTTYInfo_WindowSizeImpl();
void InitDefaultsTTYInfo_WindowSize();
void InitDefaultsTTYInfoImpl();
void InitDefaultsTTYInfo();
void InitDefaultsContainerInfo_DockerInfo_PortMappingImpl();
void InitDefaultsContainerInfo_DockerInfo_PortMapping();
void InitDefaultsContainerInfo_DockerInfoImpl();
void InitDefaultsContainerInfo_DockerInfo();
void InitDefaultsContainerInfo_MesosInfoImpl();
void InitDefaultsContainerInfo_MesosInfo();
void InitDefaultsContainerInfoImpl();
void InitDefaultsContainerInfo();
void InitDefaultsContainerStatusImpl();
void InitDefaultsContainerStatus();
void InitDefaultsCgroupInfo_Blkio_ValueImpl();
void InitDefaultsCgroupInfo_Blkio_Value();
void InitDefaultsCgroupInfo_Blkio_CFQ_StatisticsImpl();
void InitDefaultsCgroupInfo_Blkio_CFQ_Statistics();
void InitDefaultsCgroupInfo_Blkio_CFQImpl();
void InitDefaultsCgroupInfo_Blkio_CFQ();
void InitDefaultsCgroupInfo_Blkio_Throttling_StatisticsImpl();
void InitDefaultsCgroupInfo_Blkio_Throttling_Statistics();
void InitDefaultsCgroupInfo_Blkio_ThrottlingImpl();
void InitDefaultsCgroupInfo_Blkio_Throttling();
void InitDefaultsCgroupInfo_Blkio_StatisticsImpl();
void InitDefaultsCgroupInfo_Blkio_Statistics();
void InitDefaultsCgroupInfo_BlkioImpl();
void InitDefaultsCgroupInfo_Blkio();
void InitDefaultsCgroupInfo_NetClsImpl();
void InitDefaultsCgroupInfo_NetCls();
void InitDefaultsCgroupInfoImpl();
void InitDefaultsCgroupInfo();
void InitDefaultsLabelsImpl();
void InitDefaultsLabels();
void InitDefaultsLabelImpl();
void InitDefaultsLabel();
void InitDefaultsPortImpl();
void InitDefaultsPort();
void InitDefaultsPortsImpl();
void InitDefaultsPorts();
void InitDefaultsDiscoveryInfoImpl();
void InitDefaultsDiscoveryInfo();
void InitDefaultsWeightInfoImpl();
void InitDefaultsWeightInfo();
void InitDefaultsVersionInfoImpl();
void InitDefaultsVersionInfo();
void InitDefaultsFlagImpl();
void InitDefaultsFlag();
void InitDefaultsRoleImpl();
void InitDefaultsRole();
void InitDefaultsMetricImpl();
void InitDefaultsMetric();
void InitDefaultsFileInfoImpl();
void InitDefaultsFileInfo();
void InitDefaultsDevice_NumberImpl();
void InitDefaultsDevice_Number();
void InitDefaultsDeviceImpl();
void InitDefaultsDevice();
void InitDefaultsDeviceAccess_AccessImpl();
void InitDefaultsDeviceAccess_Access();
void InitDefaultsDeviceAccessImpl();
void InitDefaultsDeviceAccess();
void InitDefaultsDeviceWhitelistImpl();
void InitDefaultsDeviceWhitelist();
inline void InitDefaults() {
  InitDefaultsFrameworkID();
  InitDefaultsOfferID();
  InitDefaultsSlaveID();
  InitDefaultsTaskID();
  InitDefaultsExecutorID();
  InitDefaultsContainerID();
  InitDefaultsResourceProviderID();
  InitDefaultsOperationID();
  InitDefaultsTimeInfo();
  InitDefaultsDurationInfo();
  InitDefaultsAddress();
  InitDefaultsURL();
  InitDefaultsUnavailability();
  InitDefaultsMachineID();
  InitDefaultsMachineInfo();
  InitDefaultsFrameworkInfo_Capability();
  InitDefaultsFrameworkInfo();
  InitDefaultsCheckInfo_Command();
  InitDefaultsCheckInfo_Http();
  InitDefaultsCheckInfo_Tcp();
  InitDefaultsCheckInfo();
  InitDefaultsHealthCheck_HTTPCheckInfo();
  InitDefaultsHealthCheck_TCPCheckInfo();
  InitDefaultsHealthCheck();
  InitDefaultsKillPolicy();
  InitDefaultsCommandInfo_URI();
  InitDefaultsCommandInfo();
  InitDefaultsExecutorInfo();
  InitDefaultsDomainInfo_FaultDomain_RegionInfo();
  InitDefaultsDomainInfo_FaultDomain_ZoneInfo();
  InitDefaultsDomainInfo_FaultDomain();
  InitDefaultsDomainInfo();
  InitDefaultsMasterInfo_Capability();
  InitDefaultsMasterInfo();
  InitDefaultsSlaveInfo_Capability();
  InitDefaultsSlaveInfo();
  InitDefaultsCSIPluginContainerInfo();
  InitDefaultsCSIPluginInfo();
  InitDefaultsResourceProviderInfo_Storage();
  InitDefaultsResourceProviderInfo();
  InitDefaultsValue_Scalar();
  InitDefaultsValue_Range();
  InitDefaultsValue_Ranges();
  InitDefaultsValue_Set();
  InitDefaultsValue_Text();
  InitDefaultsValue();
  InitDefaultsAttribute();
  InitDefaultsResource_AllocationInfo();
  InitDefaultsResource_ReservationInfo();
  InitDefaultsResource_DiskInfo_Persistence();
  InitDefaultsResource_DiskInfo_Source_Path();
  InitDefaultsResource_DiskInfo_Source_Mount();
  InitDefaultsResource_DiskInfo_Source();
  InitDefaultsResource_DiskInfo();
  InitDefaultsResource_RevocableInfo();
  InitDefaultsResource_SharedInfo();
  InitDefaultsResource();
  InitDefaultsTrafficControlStatistics();
  InitDefaultsIpStatistics();
  InitDefaultsIcmpStatistics();
  InitDefaultsTcpStatistics();
  InitDefaultsUdpStatistics();
  InitDefaultsSNMPStatistics();
  InitDefaultsDiskStatistics();
  InitDefaultsResourceStatistics();
  InitDefaultsResourceUsage_Executor_Task();
  InitDefaultsResourceUsage_Executor();
  InitDefaultsResourceUsage();
  InitDefaultsPerfStatistics();
  InitDefaultsRequest();
  InitDefaultsOffer_Operation_Launch();
  InitDefaultsOffer_Operation_LaunchGroup();
  InitDefaultsOffer_Operation_Reserve();
  InitDefaultsOffer_Operation_Unreserve();
  InitDefaultsOffer_Operation_Create();
  InitDefaultsOffer_Operation_Destroy();
  InitDefaultsOffer_Operation_GrowVolume();
  InitDefaultsOffer_Operation_ShrinkVolume();
  InitDefaultsOffer_Operation_CreateVolume();
  InitDefaultsOffer_Operation_DestroyVolume();
  InitDefaultsOffer_Operation_CreateBlock();
  InitDefaultsOffer_Operation_DestroyBlock();
  InitDefaultsOffer_Operation();
  InitDefaultsOffer();
  InitDefaultsInverseOffer();
  InitDefaultsTaskInfo();
  InitDefaultsTaskGroupInfo();
  InitDefaultsTask();
  InitDefaultsTaskResourceLimitation();
  InitDefaultsUUID();
  InitDefaultsOperation();
  InitDefaultsOperationStatus();
  InitDefaultsCheckStatusInfo_Command();
  InitDefaultsCheckStatusInfo_Http();
  InitDefaultsCheckStatusInfo_Tcp();
  InitDefaultsCheckStatusInfo();
  InitDefaultsTaskStatus();
  InitDefaultsFilters();
  InitDefaultsEnvironment_Variable();
  InitDefaultsEnvironment();
  InitDefaultsParameter();
  InitDefaultsParameters();
  InitDefaultsCredential();
  InitDefaultsCredentials();
  InitDefaultsSecret_Reference();
  InitDefaultsSecret_Value();
  InitDefaultsSecret();
  InitDefaultsRateLimit();
  InitDefaultsRateLimits();
  InitDefaultsImage_Appc();
  InitDefaultsImage_Docker();
  InitDefaultsImage();
  InitDefaultsMountPropagation();
  InitDefaultsVolume_Source_DockerVolume();
  InitDefaultsVolume_Source_HostPath();
  InitDefaultsVolume_Source_SandboxPath();
  InitDefaultsVolume_Source();
  InitDefaultsVolume();
  InitDefaultsNetworkInfo_IPAddress();
  InitDefaultsNetworkInfo_PortMapping();
  InitDefaultsNetworkInfo();
  InitDefaultsCapabilityInfo();
  InitDefaultsLinuxInfo();
  InitDefaultsRLimitInfo_RLimit();
  InitDefaultsRLimitInfo();
  InitDefaultsTTYInfo_WindowSize();
  InitDefaultsTTYInfo();
  InitDefaultsContainerInfo_DockerInfo_PortMapping();
  InitDefaultsContainerInfo_DockerInfo();
  InitDefaultsContainerInfo_MesosInfo();
  InitDefaultsContainerInfo();
  InitDefaultsContainerStatus();
  InitDefaultsCgroupInfo_Blkio_Value();
  InitDefaultsCgroupInfo_Blkio_CFQ_Statistics();
  InitDefaultsCgroupInfo_Blkio_CFQ();
  InitDefaultsCgroupInfo_Blkio_Throttling_Statistics();
  InitDefaultsCgroupInfo_Blkio_Throttling();
  InitDefaultsCgroupInfo_Blkio_Statistics();
  InitDefaultsCgroupInfo_Blkio();
  InitDefaultsCgroupInfo_NetCls();
  InitDefaultsCgroupInfo();
  InitDefaultsLabels();
  InitDefaultsLabel();
  InitDefaultsPort();
  InitDefaultsPorts();
  InitDefaultsDiscoveryInfo();
  InitDefaultsWeightInfo();
  InitDefaultsVersionInfo();
  InitDefaultsFlag();
  InitDefaultsRole();
  InitDefaultsMetric();
  InitDefaultsFileInfo();
  InitDefaultsDevice_Number();
  InitDefaultsDevice();
  InitDefaultsDeviceAccess_Access();
  InitDefaultsDeviceAccess();
  InitDefaultsDeviceWhitelist();
}
}  // namespace protobuf_mesos_2fmesos_2eproto
namespace mesos {
class Address;
class AddressDefaultTypeInternal;
extern AddressDefaultTypeInternal _Address_default_instance_;
class Attribute;
class AttributeDefaultTypeInternal;
extern AttributeDefaultTypeInternal _Attribute_default_instance_;
class CSIPluginContainerInfo;
class CSIPluginContainerInfoDefaultTypeInternal;
extern CSIPluginContainerInfoDefaultTypeInternal _CSIPluginContainerInfo_default_instance_;
class CSIPluginInfo;
class CSIPluginInfoDefaultTypeInternal;
extern CSIPluginInfoDefaultTypeInternal _CSIPluginInfo_default_instance_;
class CapabilityInfo;
class CapabilityInfoDefaultTypeInternal;
extern CapabilityInfoDefaultTypeInternal _CapabilityInfo_default_instance_;
class CgroupInfo;
class CgroupInfoDefaultTypeInternal;
extern CgroupInfoDefaultTypeInternal _CgroupInfo_default_instance_;
class CgroupInfo_Blkio;
class CgroupInfo_BlkioDefaultTypeInternal;
extern CgroupInfo_BlkioDefaultTypeInternal _CgroupInfo_Blkio_default_instance_;
class CgroupInfo_Blkio_CFQ;
class CgroupInfo_Blkio_CFQDefaultTypeInternal;
extern CgroupInfo_Blkio_CFQDefaultTypeInternal _CgroupInfo_Blkio_CFQ_default_instance_;
class CgroupInfo_Blkio_CFQ_Statistics;
class CgroupInfo_Blkio_CFQ_StatisticsDefaultTypeInternal;
extern CgroupInfo_Blkio_CFQ_StatisticsDefaultTypeInternal _CgroupInfo_Blkio_CFQ_Statistics_default_instance_;
class CgroupInfo_Blkio_Statistics;
class CgroupInfo_Blkio_StatisticsDefaultTypeInternal;
extern CgroupInfo_Blkio_StatisticsDefaultTypeInternal _CgroupInfo_Blkio_Statistics_default_instance_;
class CgroupInfo_Blkio_Throttling;
class CgroupInfo_Blkio_ThrottlingDefaultTypeInternal;
extern CgroupInfo_Blkio_ThrottlingDefaultTypeInternal _CgroupInfo_Blkio_Throttling_default_instance_;
class CgroupInfo_Blkio_Throttling_Statistics;
class CgroupInfo_Blkio_Throttling_StatisticsDefaultTypeInternal;
extern CgroupInfo_Blkio_Throttling_StatisticsDefaultTypeInternal _CgroupInfo_Blkio_Throttling_Statistics_default_instance_;
class CgroupInfo_Blkio_Value;
class CgroupInfo_Blkio_ValueDefaultTypeInternal;
extern CgroupInfo_Blkio_ValueDefaultTypeInternal _CgroupInfo_Blkio_Value_default_instance_;
class CgroupInfo_NetCls;
class CgroupInfo_NetClsDefaultTypeInternal;
extern CgroupInfo_NetClsDefaultTypeInternal _CgroupInfo_NetCls_default_instance_;
class CheckInfo;
class CheckInfoDefaultTypeInternal;
extern CheckInfoDefaultTypeInternal _CheckInfo_default_instance_;
class CheckInfo_Command;
class CheckInfo_CommandDefaultTypeInternal;
extern CheckInfo_CommandDefaultTypeInternal _CheckInfo_Command_default_instance_;
class CheckInfo_Http;
class CheckInfo_HttpDefaultTypeInternal;
extern CheckInfo_HttpDefaultTypeInternal _CheckInfo_Http_default_instance_;
class CheckInfo_Tcp;
class CheckInfo_TcpDefaultTypeInternal;
extern CheckInfo_TcpDefaultTypeInternal _CheckInfo_Tcp_default_instance_;
class CheckStatusInfo;
class CheckStatusInfoDefaultTypeInternal;
extern CheckStatusInfoDefaultTypeInternal _CheckStatusInfo_default_instance_;
class CheckStatusInfo_Command;
class CheckStatusInfo_CommandDefaultTypeInternal;
extern CheckStatusInfo_CommandDefaultTypeInternal _CheckStatusInfo_Command_default_instance_;
class CheckStatusInfo_Http;
class CheckStatusInfo_HttpDefaultTypeInternal;
extern CheckStatusInfo_HttpDefaultTypeInternal _CheckStatusInfo_Http_default_instance_;
class CheckStatusInfo_Tcp;
class CheckStatusInfo_TcpDefaultTypeInternal;
extern CheckStatusInfo_TcpDefaultTypeInternal _CheckStatusInfo_Tcp_default_instance_;
class CommandInfo;
class CommandInfoDefaultTypeInternal;
extern CommandInfoDefaultTypeInternal _CommandInfo_default_instance_;
class CommandInfo_URI;
class CommandInfo_URIDefaultTypeInternal;
extern CommandInfo_URIDefaultTypeInternal _CommandInfo_URI_default_instance_;
class ContainerID;
class ContainerIDDefaultTypeInternal;
extern ContainerIDDefaultTypeInternal _ContainerID_default_instance_;
class ContainerInfo;
class ContainerInfoDefaultTypeInternal;
extern ContainerInfoDefaultTypeInternal _ContainerInfo_default_instance_;
class ContainerInfo_DockerInfo;
class ContainerInfo_DockerInfoDefaultTypeInternal;
extern ContainerInfo_DockerInfoDefaultTypeInternal _ContainerInfo_DockerInfo_default_instance_;
class ContainerInfo_DockerInfo_PortMapping;
class ContainerInfo_DockerInfo_PortMappingDefaultTypeInternal;
extern ContainerInfo_DockerInfo_PortMappingDefaultTypeInternal _ContainerInfo_DockerInfo_PortMapping_default_instance_;
class ContainerInfo_MesosInfo;
class ContainerInfo_MesosInfoDefaultTypeInternal;
extern ContainerInfo_MesosInfoDefaultTypeInternal _ContainerInfo_MesosInfo_default_instance_;
class ContainerStatus;
class ContainerStatusDefaultTypeInternal;
extern ContainerStatusDefaultTypeInternal _ContainerStatus_default_instance_;
class Credential;
class CredentialDefaultTypeInternal;
extern CredentialDefaultTypeInternal _Credential_default_instance_;
class Credentials;
class CredentialsDefaultTypeInternal;
extern CredentialsDefaultTypeInternal _Credentials_default_instance_;
class Device;
class DeviceDefaultTypeInternal;
extern DeviceDefaultTypeInternal _Device_default_instance_;
class DeviceAccess;
class DeviceAccessDefaultTypeInternal;
extern DeviceAccessDefaultTypeInternal _DeviceAccess_default_instance_;
class DeviceAccess_Access;
class DeviceAccess_AccessDefaultTypeInternal;
extern DeviceAccess_AccessDefaultTypeInternal _DeviceAccess_Access_default_instance_;
class DeviceWhitelist;
class DeviceWhitelistDefaultTypeInternal;
extern DeviceWhitelistDefaultTypeInternal _DeviceWhitelist_default_instance_;
class Device_Number;
class Device_NumberDefaultTypeInternal;
extern Device_NumberDefaultTypeInternal _Device_Number_default_instance_;
class DiscoveryInfo;
class DiscoveryInfoDefaultTypeInternal;
extern DiscoveryInfoDefaultTypeInternal _DiscoveryInfo_default_instance_;
class DiskStatistics;
class DiskStatisticsDefaultTypeInternal;
extern DiskStatisticsDefaultTypeInternal _DiskStatistics_default_instance_;
class DomainInfo;
class DomainInfoDefaultTypeInternal;
extern DomainInfoDefaultTypeInternal _DomainInfo_default_instance_;
class DomainInfo_FaultDomain;
class DomainInfo_FaultDomainDefaultTypeInternal;
extern DomainInfo_FaultDomainDefaultTypeInternal _DomainInfo_FaultDomain_default_instance_;
class DomainInfo_FaultDomain_RegionInfo;
class DomainInfo_FaultDomain_RegionInfoDefaultTypeInternal;
extern DomainInfo_FaultDomain_RegionInfoDefaultTypeInternal _DomainInfo_FaultDomain_RegionInfo_default_instance_;
class DomainInfo_FaultDomain_ZoneInfo;
class DomainInfo_FaultDomain_ZoneInfoDefaultTypeInternal;
extern DomainInfo_FaultDomain_ZoneInfoDefaultTypeInternal _DomainInfo_FaultDomain_ZoneInfo_default_instance_;
class DurationInfo;
class DurationInfoDefaultTypeInternal;
extern DurationInfoDefaultTypeInternal _DurationInfo_default_instance_;
class Environment;
class EnvironmentDefaultTypeInternal;
extern EnvironmentDefaultTypeInternal _Environment_default_instance_;
class Environment_Variable;
class Environment_VariableDefaultTypeInternal;
extern Environment_VariableDefaultTypeInternal _Environment_Variable_default_instance_;
class ExecutorID;
class ExecutorIDDefaultTypeInternal;
extern ExecutorIDDefaultTypeInternal _ExecutorID_default_instance_;
class ExecutorInfo;
class ExecutorInfoDefaultTypeInternal;
extern ExecutorInfoDefaultTypeInternal _ExecutorInfo_default_instance_;
class FileInfo;
class FileInfoDefaultTypeInternal;
extern FileInfoDefaultTypeInternal _FileInfo_default_instance_;
class Filters;
class FiltersDefaultTypeInternal;
extern FiltersDefaultTypeInternal _Filters_default_instance_;
class Flag;
class FlagDefaultTypeInternal;
extern FlagDefaultTypeInternal _Flag_default_instance_;
class FrameworkID;
class FrameworkIDDefaultTypeInternal;
extern FrameworkIDDefaultTypeInternal _FrameworkID_default_instance_;
class FrameworkInfo;
class FrameworkInfoDefaultTypeInternal;
extern FrameworkInfoDefaultTypeInternal _FrameworkInfo_default_instance_;
class FrameworkInfo_Capability;
class FrameworkInfo_CapabilityDefaultTypeInternal;
extern FrameworkInfo_CapabilityDefaultTypeInternal _FrameworkInfo_Capability_default_instance_;
class HealthCheck;
class HealthCheckDefaultTypeInternal;
extern HealthCheckDefaultTypeInternal _HealthCheck_default_instance_;
class HealthCheck_HTTPCheckInfo;
class HealthCheck_HTTPCheckInfoDefaultTypeInternal;
extern HealthCheck_HTTPCheckInfoDefaultTypeInternal _HealthCheck_HTTPCheckInfo_default_instance_;
class HealthCheck_TCPCheckInfo;
class HealthCheck_TCPCheckInfoDefaultTypeInternal;
extern HealthCheck_TCPCheckInfoDefaultTypeInternal _HealthCheck_TCPCheckInfo_default_instance_;
class IcmpStatistics;
class IcmpStatisticsDefaultTypeInternal;
extern IcmpStatisticsDefaultTypeInternal _IcmpStatistics_default_instance_;
class Image;
class ImageDefaultTypeInternal;
extern ImageDefaultTypeInternal _Image_default_instance_;
class Image_Appc;
class Image_AppcDefaultTypeInternal;
extern Image_AppcDefaultTypeInternal _Image_Appc_default_instance_;
class Image_Docker;
class Image_DockerDefaultTypeInternal;
extern Image_DockerDefaultTypeInternal _Image_Docker_default_instance_;
class InverseOffer;
class InverseOfferDefaultTypeInternal;
extern InverseOfferDefaultTypeInternal _InverseOffer_default_instance_;
class IpStatistics;
class IpStatisticsDefaultTypeInternal;
extern IpStatisticsDefaultTypeInternal _IpStatistics_default_instance_;
class KillPolicy;
class KillPolicyDefaultTypeInternal;
extern KillPolicyDefaultTypeInternal _KillPolicy_default_instance_;
class Label;
class LabelDefaultTypeInternal;
extern LabelDefaultTypeInternal _Label_default_instance_;
class Labels;
class LabelsDefaultTypeInternal;
extern LabelsDefaultTypeInternal _Labels_default_instance_;
class LinuxInfo;
class LinuxInfoDefaultTypeInternal;
extern LinuxInfoDefaultTypeInternal _LinuxInfo_default_instance_;
class MachineID;
class MachineIDDefaultTypeInternal;
extern MachineIDDefaultTypeInternal _MachineID_default_instance_;
class MachineInfo;
class MachineInfoDefaultTypeInternal;
extern MachineInfoDefaultTypeInternal _MachineInfo_default_instance_;
class MasterInfo;
class MasterInfoDefaultTypeInternal;
extern MasterInfoDefaultTypeInternal _MasterInfo_default_instance_;
class MasterInfo_Capability;
class MasterInfo_CapabilityDefaultTypeInternal;
extern MasterInfo_CapabilityDefaultTypeInternal _MasterInfo_Capability_default_instance_;
class Metric;
class MetricDefaultTypeInternal;
extern MetricDefaultTypeInternal _Metric_default_instance_;
class MountPropagation;
class MountPropagationDefaultTypeInternal;
extern MountPropagationDefaultTypeInternal _MountPropagation_default_instance_;
class NetworkInfo;
class NetworkInfoDefaultTypeInternal;
extern NetworkInfoDefaultTypeInternal _NetworkInfo_default_instance_;
class NetworkInfo_IPAddress;
class NetworkInfo_IPAddressDefaultTypeInternal;
extern NetworkInfo_IPAddressDefaultTypeInternal _NetworkInfo_IPAddress_default_instance_;
class NetworkInfo_PortMapping;
class NetworkInfo_PortMappingDefaultTypeInternal;
extern NetworkInfo_PortMappingDefaultTypeInternal _NetworkInfo_PortMapping_default_instance_;
class Offer;
class OfferDefaultTypeInternal;
extern OfferDefaultTypeInternal _Offer_default_instance_;
class OfferID;
class OfferIDDefaultTypeInternal;
extern OfferIDDefaultTypeInternal _OfferID_default_instance_;
class Offer_Operation;
class Offer_OperationDefaultTypeInternal;
extern Offer_OperationDefaultTypeInternal _Offer_Operation_default_instance_;
class Offer_Operation_Create;
class Offer_Operation_CreateDefaultTypeInternal;
extern Offer_Operation_CreateDefaultTypeInternal _Offer_Operation_Create_default_instance_;
class Offer_Operation_CreateBlock;
class Offer_Operation_CreateBlockDefaultTypeInternal;
extern Offer_Operation_CreateBlockDefaultTypeInternal _Offer_Operation_CreateBlock_default_instance_;
class Offer_Operation_CreateVolume;
class Offer_Operation_CreateVolumeDefaultTypeInternal;
extern Offer_Operation_CreateVolumeDefaultTypeInternal _Offer_Operation_CreateVolume_default_instance_;
class Offer_Operation_Destroy;
class Offer_Operation_DestroyDefaultTypeInternal;
extern Offer_Operation_DestroyDefaultTypeInternal _Offer_Operation_Destroy_default_instance_;
class Offer_Operation_DestroyBlock;
class Offer_Operation_DestroyBlockDefaultTypeInternal;
extern Offer_Operation_DestroyBlockDefaultTypeInternal _Offer_Operation_DestroyBlock_default_instance_;
class Offer_Operation_DestroyVolume;
class Offer_Operation_DestroyVolumeDefaultTypeInternal;
extern Offer_Operation_DestroyVolumeDefaultTypeInternal _Offer_Operation_DestroyVolume_default_instance_;
class Offer_Operation_GrowVolume;
class Offer_Operation_GrowVolumeDefaultTypeInternal;
extern Offer_Operation_GrowVolumeDefaultTypeInternal _Offer_Operation_GrowVolume_default_instance_;
class Offer_Operation_Launch;
class Offer_Operation_LaunchDefaultTypeInternal;
extern Offer_Operation_LaunchDefaultTypeInternal _Offer_Operation_Launch_default_instance_;
class Offer_Operation_LaunchGroup;
class Offer_Operation_LaunchGroupDefaultTypeInternal;
extern Offer_Operation_LaunchGroupDefaultTypeInternal _Offer_Operation_LaunchGroup_default_instance_;
class Offer_Operation_Reserve;
class Offer_Operation_ReserveDefaultTypeInternal;
extern Offer_Operation_ReserveDefaultTypeInternal _Offer_Operation_Reserve_default_instance_;
class Offer_Operation_ShrinkVolume;
class Offer_Operation_ShrinkVolumeDefaultTypeInternal;
extern Offer_Operation_ShrinkVolumeDefaultTypeInternal _Offer_Operation_ShrinkVolume_default_instance_;
class Offer_Operation_Unreserve;
class Offer_Operation_UnreserveDefaultTypeInternal;
extern Offer_Operation_UnreserveDefaultTypeInternal _Offer_Operation_Unreserve_default_instance_;
class Operation;
class OperationDefaultTypeInternal;
extern OperationDefaultTypeInternal _Operation_default_instance_;
class OperationID;
class OperationIDDefaultTypeInternal;
extern OperationIDDefaultTypeInternal _OperationID_default_instance_;
class OperationStatus;
class OperationStatusDefaultTypeInternal;
extern OperationStatusDefaultTypeInternal _OperationStatus_default_instance_;
class Parameter;
class ParameterDefaultTypeInternal;
extern ParameterDefaultTypeInternal _Parameter_default_instance_;
class Parameters;
class ParametersDefaultTypeInternal;
extern ParametersDefaultTypeInternal _Parameters_default_instance_;
class PerfStatistics;
class PerfStatisticsDefaultTypeInternal;
extern PerfStatisticsDefaultTypeInternal _PerfStatistics_default_instance_;
class Port;
class PortDefaultTypeInternal;
extern PortDefaultTypeInternal _Port_default_instance_;
class Ports;
class PortsDefaultTypeInternal;
extern PortsDefaultTypeInternal _Ports_default_instance_;
class RLimitInfo;
class RLimitInfoDefaultTypeInternal;
extern RLimitInfoDefaultTypeInternal _RLimitInfo_default_instance_;
class RLimitInfo_RLimit;
class RLimitInfo_RLimitDefaultTypeInternal;
extern RLimitInfo_RLimitDefaultTypeInternal _RLimitInfo_RLimit_default_instance_;
class RateLimit;
class RateLimitDefaultTypeInternal;
extern RateLimitDefaultTypeInternal _RateLimit_default_instance_;
class RateLimits;
class RateLimitsDefaultTypeInternal;
extern RateLimitsDefaultTypeInternal _RateLimits_default_instance_;
class Request;
class RequestDefaultTypeInternal;
extern RequestDefaultTypeInternal _Request_default_instance_;
class Resource;
class ResourceDefaultTypeInternal;
extern ResourceDefaultTypeInternal _Resource_default_instance_;
class ResourceProviderID;
class ResourceProviderIDDefaultTypeInternal;
extern ResourceProviderIDDefaultTypeInternal _ResourceProviderID_default_instance_;
class ResourceProviderInfo;
class ResourceProviderInfoDefaultTypeInternal;
extern ResourceProviderInfoDefaultTypeInternal _ResourceProviderInfo_default_instance_;
class ResourceProviderInfo_Storage;
class ResourceProviderInfo_StorageDefaultTypeInternal;
extern ResourceProviderInfo_StorageDefaultTypeInternal _ResourceProviderInfo_Storage_default_instance_;
class ResourceStatistics;
class ResourceStatisticsDefaultTypeInternal;
extern ResourceStatisticsDefaultTypeInternal _ResourceStatistics_default_instance_;
class ResourceUsage;
class ResourceUsageDefaultTypeInternal;
extern ResourceUsageDefaultTypeInternal _ResourceUsage_default_instance_;
class ResourceUsage_Executor;
class ResourceUsage_ExecutorDefaultTypeInternal;
extern ResourceUsage_ExecutorDefaultTypeInternal _ResourceUsage_Executor_default_instance_;
class ResourceUsage_Executor_Task;
class ResourceUsage_Executor_TaskDefaultTypeInternal;
extern ResourceUsage_Executor_TaskDefaultTypeInternal _ResourceUsage_Executor_Task_default_instance_;
class Resource_AllocationInfo;
class Resource_AllocationInfoDefaultTypeInternal;
extern Resource_AllocationInfoDefaultTypeInternal _Resource_AllocationInfo_default_instance_;
class Resource_DiskInfo;
class Resource_DiskInfoDefaultTypeInternal;
extern Resource_DiskInfoDefaultTypeInternal _Resource_DiskInfo_default_instance_;
class Resource_DiskInfo_Persistence;
class Resource_DiskInfo_PersistenceDefaultTypeInternal;
extern Resource_DiskInfo_PersistenceDefaultTypeInternal _Resource_DiskInfo_Persistence_default_instance_;
class Resource_DiskInfo_Source;
class Resource_DiskInfo_SourceDefaultTypeInternal;
extern Resource_DiskInfo_SourceDefaultTypeInternal _Resource_DiskInfo_Source_default_instance_;
class Resource_DiskInfo_Source_Mount;
class Resource_DiskInfo_Source_MountDefaultTypeInternal;
extern Resource_DiskInfo_Source_MountDefaultTypeInternal _Resource_DiskInfo_Source_Mount_default_instance_;
class Resource_DiskInfo_Source_Path;
class Resource_DiskInfo_Source_PathDefaultTypeInternal;
extern Resource_DiskInfo_Source_PathDefaultTypeInternal _Resource_DiskInfo_Source_Path_default_instance_;
class Resource_ReservationInfo;
class Resource_ReservationInfoDefaultTypeInternal;
extern Resource_ReservationInfoDefaultTypeInternal _Resource_ReservationInfo_default_instance_;
class Resource_RevocableInfo;
class Resource_RevocableInfoDefaultTypeInternal;
extern Resource_RevocableInfoDefaultTypeInternal _Resource_RevocableInfo_default_instance_;
class Resource_SharedInfo;
class Resource_SharedInfoDefaultTypeInternal;
extern Resource_SharedInfoDefaultTypeInternal _Resource_SharedInfo_default_instance_;
class Role;
class RoleDefaultTypeInternal;
extern RoleDefaultTypeInternal _Role_default_instance_;
class SNMPStatistics;
class SNMPStatisticsDefaultTypeInternal;
extern SNMPStatisticsDefaultTypeInternal _SNMPStatistics_default_instance_;
class Secret;
class SecretDefaultTypeInternal;
extern SecretDefaultTypeInternal _Secret_default_instance_;
class Secret_Reference;
class Secret_ReferenceDefaultTypeInternal;
extern Secret_ReferenceDefaultTypeInternal _Secret_Reference_default_instance_;
class Secret_Value;
class Secret_ValueDefaultTypeInternal;
extern Secret_ValueDefaultTypeInternal _Secret_Value_default_instance_;
class SlaveID;
class SlaveIDDefaultTypeInternal;
extern SlaveIDDefaultTypeInternal _SlaveID_default_instance_;
class SlaveInfo;
class SlaveInfoDefaultTypeInternal;
extern SlaveInfoDefaultTypeInternal _SlaveInfo_default_instance_;
class SlaveInfo_Capability;
class SlaveInfo_CapabilityDefaultTypeInternal;
extern SlaveInfo_CapabilityDefaultTypeInternal _SlaveInfo_Capability_default_instance_;
class TTYInfo;
class TTYInfoDefaultTypeInternal;
extern TTYInfoDefaultTypeInternal _TTYInfo_default_instance_;
class TTYInfo_WindowSize;
class TTYInfo_WindowSizeDefaultTypeInternal;
extern TTYInfo_WindowSizeDefaultTypeInternal _TTYInfo_WindowSize_default_instance_;
class Task;
class TaskDefaultTypeInternal;
extern TaskDefaultTypeInternal _Task_default_instance_;
class TaskGroupInfo;
class TaskGroupInfoDefaultTypeInternal;
extern TaskGroupInfoDefaultTypeInternal _TaskGroupInfo_default_instance_;
class TaskID;
class TaskIDDefaultTypeInternal;
extern TaskIDDefaultTypeInternal _TaskID_default_instance_;
class TaskInfo;
class TaskInfoDefaultTypeInternal;
extern TaskInfoDefaultTypeInternal _TaskInfo_default_instance_;
class TaskResourceLimitation;
class TaskResourceLimitationDefaultTypeInternal;
extern TaskResourceLimitationDefaultTypeInternal _TaskResourceLimitation_default_instance_;
class TaskStatus;
class TaskStatusDefaultTypeInternal;
extern TaskStatusDefaultTypeInternal _TaskStatus_default_instance_;
class TcpStatistics;
class TcpStatisticsDefaultTypeInternal;
extern TcpStatisticsDefaultTypeInternal _TcpStatistics_default_instance_;
class TimeInfo;
class TimeInfoDefaultTypeInternal;
extern TimeInfoDefaultTypeInternal _TimeInfo_default_instance_;
class TrafficControlStatistics;
class TrafficControlStatisticsDefaultTypeInternal;
extern TrafficControlStatisticsDefaultTypeInternal _TrafficControlStatistics_default_instance_;
class URL;
class URLDefaultTypeInternal;
extern URLDefaultTypeInternal _URL_default_instance_;
class UUID;
class UUIDDefaultTypeInternal;
extern UUIDDefaultTypeInternal _UUID_default_instance_;
class UdpStatistics;
class UdpStatisticsDefaultTypeInternal;
extern UdpStatisticsDefaultTypeInternal _UdpStatistics_default_instance_;
class Unavailability;
class UnavailabilityDefaultTypeInternal;
extern UnavailabilityDefaultTypeInternal _Unavailability_default_instance_;
class Value;
class ValueDefaultTypeInternal;
extern ValueDefaultTypeInternal _Value_default_instance_;
class Value_Range;
class Value_RangeDefaultTypeInternal;
extern Value_RangeDefaultTypeInternal _Value_Range_default_instance_;
class Value_Ranges;
class Value_RangesDefaultTypeInternal;
extern Value_RangesDefaultTypeInternal _Value_Ranges_default_instance_;
class Value_Scalar;
class Value_ScalarDefaultTypeInternal;
extern Value_ScalarDefaultTypeInternal _Value_Scalar_default_instance_;
class Value_Set;
class Value_SetDefaultTypeInternal;
extern Value_SetDefaultTypeInternal _Value_Set_default_instance_;
class Value_Text;
class Value_TextDefaultTypeInternal;
extern Value_TextDefaultTypeInternal _Value_Text_default_instance_;
class VersionInfo;
class VersionInfoDefaultTypeInternal;
extern VersionInfoDefaultTypeInternal _VersionInfo_default_instance_;
class Volume;
class VolumeDefaultTypeInternal;
extern VolumeDefaultTypeInternal _Volume_default_instance_;
class Volume_Source;
class Volume_SourceDefaultTypeInternal;
extern Volume_SourceDefaultTypeInternal _Volume_Source_default_instance_;
class Volume_Source_DockerVolume;
class Volume_Source_DockerVolumeDefaultTypeInternal;
extern Volume_Source_DockerVolumeDefaultTypeInternal _Volume_Source_DockerVolume_default_instance_;
class Volume_Source_HostPath;
class Volume_Source_HostPathDefaultTypeInternal;
extern Volume_Source_HostPathDefaultTypeInternal _Volume_Source_HostPath_default_instance_;
class Volume_Source_SandboxPath;
class Volume_Source_SandboxPathDefaultTypeInternal;
extern Volume_Source_SandboxPathDefaultTypeInternal _Volume_Source_SandboxPath_default_instance_;
class WeightInfo;
class WeightInfoDefaultTypeInternal;
extern WeightInfoDefaultTypeInternal _WeightInfo_default_instance_;
}  // namespace mesos
namespace mesos {

enum MachineInfo_Mode {
  MachineInfo_Mode_UP = 1,
  MachineInfo_Mode_DRAINING = 2,
  MachineInfo_Mode_DOWN = 3
};
bool MachineInfo_Mode_IsValid(int value);
const MachineInfo_Mode MachineInfo_Mode_Mode_MIN = MachineInfo_Mode_UP;
const MachineInfo_Mode MachineInfo_Mode_Mode_MAX = MachineInfo_Mode_DOWN;
const int MachineInfo_Mode_Mode_ARRAYSIZE = MachineInfo_Mode_Mode_MAX + 1;

const ::google::protobuf::EnumDescriptor* MachineInfo_Mode_descriptor();
inline const ::std::string& MachineInfo_Mode_Name(MachineInfo_Mode value) {
  return ::google::protobuf::internal::NameOfEnum(
    MachineInfo_Mode_descriptor(), value);
}
inline bool MachineInfo_Mode_Parse(
    const ::std::string& name, MachineInfo_Mode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MachineInfo_Mode>(
    MachineInfo_Mode_descriptor(), name, value);
}
enum FrameworkInfo_Capability_Type {
  FrameworkInfo_Capability_Type_UNKNOWN = 0,
  FrameworkInfo_Capability_Type_REVOCABLE_RESOURCES = 1,
  FrameworkInfo_Capability_Type_TASK_KILLING_STATE = 2,
  FrameworkInfo_Capability_Type_GPU_RESOURCES = 3,
  FrameworkInfo_Capability_Type_SHARED_RESOURCES = 4,
  FrameworkInfo_Capability_Type_PARTITION_AWARE = 5,
  FrameworkInfo_Capability_Type_MULTI_ROLE = 6,
  FrameworkInfo_Capability_Type_RESERVATION_REFINEMENT = 7,
  FrameworkInfo_Capability_Type_REGION_AWARE = 8
};
bool FrameworkInfo_Capability_Type_IsValid(int value);
const FrameworkInfo_Capability_Type FrameworkInfo_Capability_Type_Type_MIN = FrameworkInfo_Capability_Type_UNKNOWN;
const FrameworkInfo_Capability_Type FrameworkInfo_Capability_Type_Type_MAX = FrameworkInfo_Capability_Type_REGION_AWARE;
const int FrameworkInfo_Capability_Type_Type_ARRAYSIZE = FrameworkInfo_Capability_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* FrameworkInfo_Capability_Type_descriptor();
inline const ::std::string& FrameworkInfo_Capability_Type_Name(FrameworkInfo_Capability_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    FrameworkInfo_Capability_Type_descriptor(), value);
}
inline bool FrameworkInfo_Capability_Type_Parse(
    const ::std::string& name, FrameworkInfo_Capability_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FrameworkInfo_Capability_Type>(
    FrameworkInfo_Capability_Type_descriptor(), name, value);
}
enum CheckInfo_Type {
  CheckInfo_Type_UNKNOWN = 0,
  CheckInfo_Type_COMMAND = 1,
  CheckInfo_Type_HTTP = 2,
  CheckInfo_Type_TCP = 3
};
bool CheckInfo_Type_IsValid(int value);
const CheckInfo_Type CheckInfo_Type_Type_MIN = CheckInfo_Type_UNKNOWN;
const CheckInfo_Type CheckInfo_Type_Type_MAX = CheckInfo_Type_TCP;
const int CheckInfo_Type_Type_ARRAYSIZE = CheckInfo_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* CheckInfo_Type_descriptor();
inline const ::std::string& CheckInfo_Type_Name(CheckInfo_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    CheckInfo_Type_descriptor(), value);
}
inline bool CheckInfo_Type_Parse(
    const ::std::string& name, CheckInfo_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CheckInfo_Type>(
    CheckInfo_Type_descriptor(), name, value);
}
enum HealthCheck_Type {
  HealthCheck_Type_UNKNOWN = 0,
  HealthCheck_Type_COMMAND = 1,
  HealthCheck_Type_HTTP = 2,
  HealthCheck_Type_TCP = 3
};
bool HealthCheck_Type_IsValid(int value);
const HealthCheck_Type HealthCheck_Type_Type_MIN = HealthCheck_Type_UNKNOWN;
const HealthCheck_Type HealthCheck_Type_Type_MAX = HealthCheck_Type_TCP;
const int HealthCheck_Type_Type_ARRAYSIZE = HealthCheck_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* HealthCheck_Type_descriptor();
inline const ::std::string& HealthCheck_Type_Name(HealthCheck_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    HealthCheck_Type_descriptor(), value);
}
inline bool HealthCheck_Type_Parse(
    const ::std::string& name, HealthCheck_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<HealthCheck_Type>(
    HealthCheck_Type_descriptor(), name, value);
}
enum ExecutorInfo_Type {
  ExecutorInfo_Type_UNKNOWN = 0,
  ExecutorInfo_Type_DEFAULT = 1,
  ExecutorInfo_Type_CUSTOM = 2
};
bool ExecutorInfo_Type_IsValid(int value);
const ExecutorInfo_Type ExecutorInfo_Type_Type_MIN = ExecutorInfo_Type_UNKNOWN;
const ExecutorInfo_Type ExecutorInfo_Type_Type_MAX = ExecutorInfo_Type_CUSTOM;
const int ExecutorInfo_Type_Type_ARRAYSIZE = ExecutorInfo_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* ExecutorInfo_Type_descriptor();
inline const ::std::string& ExecutorInfo_Type_Name(ExecutorInfo_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    ExecutorInfo_Type_descriptor(), value);
}
inline bool ExecutorInfo_Type_Parse(
    const ::std::string& name, ExecutorInfo_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ExecutorInfo_Type>(
    ExecutorInfo_Type_descriptor(), name, value);
}
enum MasterInfo_Capability_Type {
  MasterInfo_Capability_Type_UNKNOWN = 0,
  MasterInfo_Capability_Type_AGENT_UPDATE = 1
};
bool MasterInfo_Capability_Type_IsValid(int value);
const MasterInfo_Capability_Type MasterInfo_Capability_Type_Type_MIN = MasterInfo_Capability_Type_UNKNOWN;
const MasterInfo_Capability_Type MasterInfo_Capability_Type_Type_MAX = MasterInfo_Capability_Type_AGENT_UPDATE;
const int MasterInfo_Capability_Type_Type_ARRAYSIZE = MasterInfo_Capability_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* MasterInfo_Capability_Type_descriptor();
inline const ::std::string& MasterInfo_Capability_Type_Name(MasterInfo_Capability_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    MasterInfo_Capability_Type_descriptor(), value);
}
inline bool MasterInfo_Capability_Type_Parse(
    const ::std::string& name, MasterInfo_Capability_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MasterInfo_Capability_Type>(
    MasterInfo_Capability_Type_descriptor(), name, value);
}
enum SlaveInfo_Capability_Type {
  SlaveInfo_Capability_Type_UNKNOWN = 0,
  SlaveInfo_Capability_Type_MULTI_ROLE = 1,
  SlaveInfo_Capability_Type_HIERARCHICAL_ROLE = 2,
  SlaveInfo_Capability_Type_RESERVATION_REFINEMENT = 3,
  SlaveInfo_Capability_Type_RESOURCE_PROVIDER = 4,
  SlaveInfo_Capability_Type_RESIZE_VOLUME = 5
};
bool SlaveInfo_Capability_Type_IsValid(int value);
const SlaveInfo_Capability_Type SlaveInfo_Capability_Type_Type_MIN = SlaveInfo_Capability_Type_UNKNOWN;
const SlaveInfo_Capability_Type SlaveInfo_Capability_Type_Type_MAX = SlaveInfo_Capability_Type_RESIZE_VOLUME;
const int SlaveInfo_Capability_Type_Type_ARRAYSIZE = SlaveInfo_Capability_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* SlaveInfo_Capability_Type_descriptor();
inline const ::std::string& SlaveInfo_Capability_Type_Name(SlaveInfo_Capability_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    SlaveInfo_Capability_Type_descriptor(), value);
}
inline bool SlaveInfo_Capability_Type_Parse(
    const ::std::string& name, SlaveInfo_Capability_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SlaveInfo_Capability_Type>(
    SlaveInfo_Capability_Type_descriptor(), name, value);
}
enum CSIPluginContainerInfo_Service {
  CSIPluginContainerInfo_Service_UNKNOWN = 0,
  CSIPluginContainerInfo_Service_CONTROLLER_SERVICE = 1,
  CSIPluginContainerInfo_Service_NODE_SERVICE = 2
};
bool CSIPluginContainerInfo_Service_IsValid(int value);
const CSIPluginContainerInfo_Service CSIPluginContainerInfo_Service_Service_MIN = CSIPluginContainerInfo_Service_UNKNOWN;
const CSIPluginContainerInfo_Service CSIPluginContainerInfo_Service_Service_MAX = CSIPluginContainerInfo_Service_NODE_SERVICE;
const int CSIPluginContainerInfo_Service_Service_ARRAYSIZE = CSIPluginContainerInfo_Service_Service_MAX + 1;

const ::google::protobuf::EnumDescriptor* CSIPluginContainerInfo_Service_descriptor();
inline const ::std::string& CSIPluginContainerInfo_Service_Name(CSIPluginContainerInfo_Service value) {
  return ::google::protobuf::internal::NameOfEnum(
    CSIPluginContainerInfo_Service_descriptor(), value);
}
inline bool CSIPluginContainerInfo_Service_Parse(
    const ::std::string& name, CSIPluginContainerInfo_Service* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CSIPluginContainerInfo_Service>(
    CSIPluginContainerInfo_Service_descriptor(), name, value);
}
enum Value_Type {
  Value_Type_SCALAR = 0,
  Value_Type_RANGES = 1,
  Value_Type_SET = 2,
  Value_Type_TEXT = 3
};
bool Value_Type_IsValid(int value);
const Value_Type Value_Type_Type_MIN = Value_Type_SCALAR;
const Value_Type Value_Type_Type_MAX = Value_Type_TEXT;
const int Value_Type_Type_ARRAYSIZE = Value_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Value_Type_descriptor();
inline const ::std::string& Value_Type_Name(Value_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Value_Type_descriptor(), value);
}
inline bool Value_Type_Parse(
    const ::std::string& name, Value_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Value_Type>(
    Value_Type_descriptor(), name, value);
}
enum Resource_ReservationInfo_Type {
  Resource_ReservationInfo_Type_UNKNOWN = 0,
  Resource_ReservationInfo_Type_STATIC = 1,
  Resource_ReservationInfo_Type_DYNAMIC = 2
};
bool Resource_ReservationInfo_Type_IsValid(int value);
const Resource_ReservationInfo_Type Resource_ReservationInfo_Type_Type_MIN = Resource_ReservationInfo_Type_UNKNOWN;
const Resource_ReservationInfo_Type Resource_ReservationInfo_Type_Type_MAX = Resource_ReservationInfo_Type_DYNAMIC;
const int Resource_ReservationInfo_Type_Type_ARRAYSIZE = Resource_ReservationInfo_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Resource_ReservationInfo_Type_descriptor();
inline const ::std::string& Resource_ReservationInfo_Type_Name(Resource_ReservationInfo_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Resource_ReservationInfo_Type_descriptor(), value);
}
inline bool Resource_ReservationInfo_Type_Parse(
    const ::std::string& name, Resource_ReservationInfo_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Resource_ReservationInfo_Type>(
    Resource_ReservationInfo_Type_descriptor(), name, value);
}
enum Resource_DiskInfo_Source_Type {
  Resource_DiskInfo_Source_Type_UNKNOWN = 0,
  Resource_DiskInfo_Source_Type_PATH = 1,
  Resource_DiskInfo_Source_Type_MOUNT = 2,
  Resource_DiskInfo_Source_Type_BLOCK = 3,
  Resource_DiskInfo_Source_Type_RAW = 4
};
bool Resource_DiskInfo_Source_Type_IsValid(int value);
const Resource_DiskInfo_Source_Type Resource_DiskInfo_Source_Type_Type_MIN = Resource_DiskInfo_Source_Type_UNKNOWN;
const Resource_DiskInfo_Source_Type Resource_DiskInfo_Source_Type_Type_MAX = Resource_DiskInfo_Source_Type_RAW;
const int Resource_DiskInfo_Source_Type_Type_ARRAYSIZE = Resource_DiskInfo_Source_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Resource_DiskInfo_Source_Type_descriptor();
inline const ::std::string& Resource_DiskInfo_Source_Type_Name(Resource_DiskInfo_Source_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Resource_DiskInfo_Source_Type_descriptor(), value);
}
inline bool Resource_DiskInfo_Source_Type_Parse(
    const ::std::string& name, Resource_DiskInfo_Source_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Resource_DiskInfo_Source_Type>(
    Resource_DiskInfo_Source_Type_descriptor(), name, value);
}
enum Offer_Operation_Type {
  Offer_Operation_Type_UNKNOWN = 0,
  Offer_Operation_Type_LAUNCH = 1,
  Offer_Operation_Type_LAUNCH_GROUP = 6,
  Offer_Operation_Type_RESERVE = 2,
  Offer_Operation_Type_UNRESERVE = 3,
  Offer_Operation_Type_CREATE = 4,
  Offer_Operation_Type_DESTROY = 5,
  Offer_Operation_Type_CREATE_VOLUME = 7,
  Offer_Operation_Type_DESTROY_VOLUME = 8,
  Offer_Operation_Type_CREATE_BLOCK = 9,
  Offer_Operation_Type_DESTROY_BLOCK = 10,
  Offer_Operation_Type_GROW_VOLUME = 11,
  Offer_Operation_Type_SHRINK_VOLUME = 12
};
bool Offer_Operation_Type_IsValid(int value);
const Offer_Operation_Type Offer_Operation_Type_Type_MIN = Offer_Operation_Type_UNKNOWN;
const Offer_Operation_Type Offer_Operation_Type_Type_MAX = Offer_Operation_Type_SHRINK_VOLUME;
const int Offer_Operation_Type_Type_ARRAYSIZE = Offer_Operation_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Offer_Operation_Type_descriptor();
inline const ::std::string& Offer_Operation_Type_Name(Offer_Operation_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Offer_Operation_Type_descriptor(), value);
}
inline bool Offer_Operation_Type_Parse(
    const ::std::string& name, Offer_Operation_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Offer_Operation_Type>(
    Offer_Operation_Type_descriptor(), name, value);
}
enum TaskStatus_Source {
  TaskStatus_Source_SOURCE_MASTER = 0,
  TaskStatus_Source_SOURCE_SLAVE = 1,
  TaskStatus_Source_SOURCE_EXECUTOR = 2
};
bool TaskStatus_Source_IsValid(int value);
const TaskStatus_Source TaskStatus_Source_Source_MIN = TaskStatus_Source_SOURCE_MASTER;
const TaskStatus_Source TaskStatus_Source_Source_MAX = TaskStatus_Source_SOURCE_EXECUTOR;
const int TaskStatus_Source_Source_ARRAYSIZE = TaskStatus_Source_Source_MAX + 1;

const ::google::protobuf::EnumDescriptor* TaskStatus_Source_descriptor();
inline const ::std::string& TaskStatus_Source_Name(TaskStatus_Source value) {
  return ::google::protobuf::internal::NameOfEnum(
    TaskStatus_Source_descriptor(), value);
}
inline bool TaskStatus_Source_Parse(
    const ::std::string& name, TaskStatus_Source* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TaskStatus_Source>(
    TaskStatus_Source_descriptor(), name, value);
}
enum TaskStatus_Reason {
  TaskStatus_Reason_REASON_COMMAND_EXECUTOR_FAILED = 0,
  TaskStatus_Reason_REASON_CONTAINER_LAUNCH_FAILED = 21,
  TaskStatus_Reason_REASON_CONTAINER_LIMITATION = 19,
  TaskStatus_Reason_REASON_CONTAINER_LIMITATION_DISK = 20,
  TaskStatus_Reason_REASON_CONTAINER_LIMITATION_MEMORY = 8,
  TaskStatus_Reason_REASON_CONTAINER_PREEMPTED = 17,
  TaskStatus_Reason_REASON_CONTAINER_UPDATE_FAILED = 22,
  TaskStatus_Reason_REASON_MAX_COMPLETION_TIME_REACHED = 33,
  TaskStatus_Reason_REASON_EXECUTOR_REGISTRATION_TIMEOUT = 23,
  TaskStatus_Reason_REASON_EXECUTOR_REREGISTRATION_TIMEOUT = 24,
  TaskStatus_Reason_REASON_EXECUTOR_TERMINATED = 1,
  TaskStatus_Reason_REASON_EXECUTOR_UNREGISTERED = 2,
  TaskStatus_Reason_REASON_FRAMEWORK_REMOVED = 3,
  TaskStatus_Reason_REASON_GC_ERROR = 4,
  TaskStatus_Reason_REASON_INVALID_FRAMEWORKID = 5,
  TaskStatus_Reason_REASON_INVALID_OFFERS = 6,
  TaskStatus_Reason_REASON_IO_SWITCHBOARD_EXITED = 27,
  TaskStatus_Reason_REASON_MASTER_DISCONNECTED = 7,
  TaskStatus_Reason_REASON_RECONCILIATION = 9,
  TaskStatus_Reason_REASON_RESOURCES_UNKNOWN = 18,
  TaskStatus_Reason_REASON_SLAVE_DISCONNECTED = 10,
  TaskStatus_Reason_REASON_SLAVE_REMOVED = 11,
  TaskStatus_Reason_REASON_SLAVE_REMOVED_BY_OPERATOR = 31,
  TaskStatus_Reason_REASON_SLAVE_REREGISTERED = 32,
  TaskStatus_Reason_REASON_SLAVE_RESTARTED = 12,
  TaskStatus_Reason_REASON_SLAVE_UNKNOWN = 13,
  TaskStatus_Reason_REASON_TASK_KILLED_DURING_LAUNCH = 30,
  TaskStatus_Reason_REASON_TASK_CHECK_STATUS_UPDATED = 28,
  TaskStatus_Reason_REASON_TASK_HEALTH_CHECK_STATUS_UPDATED = 29,
  TaskStatus_Reason_REASON_TASK_GROUP_INVALID = 25,
  TaskStatus_Reason_REASON_TASK_GROUP_UNAUTHORIZED = 26,
  TaskStatus_Reason_REASON_TASK_INVALID = 14,
  TaskStatus_Reason_REASON_TASK_UNAUTHORIZED = 15,
  TaskStatus_Reason_REASON_TASK_UNKNOWN = 16
};
bool TaskStatus_Reason_IsValid(int value);
const TaskStatus_Reason TaskStatus_Reason_Reason_MIN = TaskStatus_Reason_REASON_COMMAND_EXECUTOR_FAILED;
const TaskStatus_Reason TaskStatus_Reason_Reason_MAX = TaskStatus_Reason_REASON_MAX_COMPLETION_TIME_REACHED;
const int TaskStatus_Reason_Reason_ARRAYSIZE = TaskStatus_Reason_Reason_MAX + 1;

const ::google::protobuf::EnumDescriptor* TaskStatus_Reason_descriptor();
inline const ::std::string& TaskStatus_Reason_Name(TaskStatus_Reason value) {
  return ::google::protobuf::internal::NameOfEnum(
    TaskStatus_Reason_descriptor(), value);
}
inline bool TaskStatus_Reason_Parse(
    const ::std::string& name, TaskStatus_Reason* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TaskStatus_Reason>(
    TaskStatus_Reason_descriptor(), name, value);
}
enum Environment_Variable_Type {
  Environment_Variable_Type_UNKNOWN = 0,
  Environment_Variable_Type_VALUE = 1,
  Environment_Variable_Type_SECRET = 2
};
bool Environment_Variable_Type_IsValid(int value);
const Environment_Variable_Type Environment_Variable_Type_Type_MIN = Environment_Variable_Type_UNKNOWN;
const Environment_Variable_Type Environment_Variable_Type_Type_MAX = Environment_Variable_Type_SECRET;
const int Environment_Variable_Type_Type_ARRAYSIZE = Environment_Variable_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Environment_Variable_Type_descriptor();
inline const ::std::string& Environment_Variable_Type_Name(Environment_Variable_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Environment_Variable_Type_descriptor(), value);
}
inline bool Environment_Variable_Type_Parse(
    const ::std::string& name, Environment_Variable_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Environment_Variable_Type>(
    Environment_Variable_Type_descriptor(), name, value);
}
enum Secret_Type {
  Secret_Type_UNKNOWN = 0,
  Secret_Type_REFERENCE = 1,
  Secret_Type_VALUE = 2
};
bool Secret_Type_IsValid(int value);
const Secret_Type Secret_Type_Type_MIN = Secret_Type_UNKNOWN;
const Secret_Type Secret_Type_Type_MAX = Secret_Type_VALUE;
const int Secret_Type_Type_ARRAYSIZE = Secret_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Secret_Type_descriptor();
inline const ::std::string& Secret_Type_Name(Secret_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Secret_Type_descriptor(), value);
}
inline bool Secret_Type_Parse(
    const ::std::string& name, Secret_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Secret_Type>(
    Secret_Type_descriptor(), name, value);
}
enum Image_Type {
  Image_Type_APPC = 1,
  Image_Type_DOCKER = 2
};
bool Image_Type_IsValid(int value);
const Image_Type Image_Type_Type_MIN = Image_Type_APPC;
const Image_Type Image_Type_Type_MAX = Image_Type_DOCKER;
const int Image_Type_Type_ARRAYSIZE = Image_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Image_Type_descriptor();
inline const ::std::string& Image_Type_Name(Image_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Image_Type_descriptor(), value);
}
inline bool Image_Type_Parse(
    const ::std::string& name, Image_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Image_Type>(
    Image_Type_descriptor(), name, value);
}
enum MountPropagation_Mode {
  MountPropagation_Mode_UNKNOWN = 0,
  MountPropagation_Mode_HOST_TO_CONTAINER = 1,
  MountPropagation_Mode_BIDIRECTIONAL = 2
};
bool MountPropagation_Mode_IsValid(int value);
const MountPropagation_Mode MountPropagation_Mode_Mode_MIN = MountPropagation_Mode_UNKNOWN;
const MountPropagation_Mode MountPropagation_Mode_Mode_MAX = MountPropagation_Mode_BIDIRECTIONAL;
const int MountPropagation_Mode_Mode_ARRAYSIZE = MountPropagation_Mode_Mode_MAX + 1;

const ::google::protobuf::EnumDescriptor* MountPropagation_Mode_descriptor();
inline const ::std::string& MountPropagation_Mode_Name(MountPropagation_Mode value) {
  return ::google::protobuf::internal::NameOfEnum(
    MountPropagation_Mode_descriptor(), value);
}
inline bool MountPropagation_Mode_Parse(
    const ::std::string& name, MountPropagation_Mode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MountPropagation_Mode>(
    MountPropagation_Mode_descriptor(), name, value);
}
enum Volume_Source_SandboxPath_Type {
  Volume_Source_SandboxPath_Type_UNKNOWN = 0,
  Volume_Source_SandboxPath_Type_SELF = 1,
  Volume_Source_SandboxPath_Type_PARENT = 2
};
bool Volume_Source_SandboxPath_Type_IsValid(int value);
const Volume_Source_SandboxPath_Type Volume_Source_SandboxPath_Type_Type_MIN = Volume_Source_SandboxPath_Type_UNKNOWN;
const Volume_Source_SandboxPath_Type Volume_Source_SandboxPath_Type_Type_MAX = Volume_Source_SandboxPath_Type_PARENT;
const int Volume_Source_SandboxPath_Type_Type_ARRAYSIZE = Volume_Source_SandboxPath_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Volume_Source_SandboxPath_Type_descriptor();
inline const ::std::string& Volume_Source_SandboxPath_Type_Name(Volume_Source_SandboxPath_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Volume_Source_SandboxPath_Type_descriptor(), value);
}
inline bool Volume_Source_SandboxPath_Type_Parse(
    const ::std::string& name, Volume_Source_SandboxPath_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Volume_Source_SandboxPath_Type>(
    Volume_Source_SandboxPath_Type_descriptor(), name, value);
}
enum Volume_Source_Type {
  Volume_Source_Type_UNKNOWN = 0,
  Volume_Source_Type_DOCKER_VOLUME = 1,
  Volume_Source_Type_HOST_PATH = 4,
  Volume_Source_Type_SANDBOX_PATH = 2,
  Volume_Source_Type_SECRET = 3
};
bool Volume_Source_Type_IsValid(int value);
const Volume_Source_Type Volume_Source_Type_Type_MIN = Volume_Source_Type_UNKNOWN;
const Volume_Source_Type Volume_Source_Type_Type_MAX = Volume_Source_Type_HOST_PATH;
const int Volume_Source_Type_Type_ARRAYSIZE = Volume_Source_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Volume_Source_Type_descriptor();
inline const ::std::string& Volume_Source_Type_Name(Volume_Source_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Volume_Source_Type_descriptor(), value);
}
inline bool Volume_Source_Type_Parse(
    const ::std::string& name, Volume_Source_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Volume_Source_Type>(
    Volume_Source_Type_descriptor(), name, value);
}
enum Volume_Mode {
  Volume_Mode_RW = 1,
  Volume_Mode_RO = 2
};
bool Volume_Mode_IsValid(int value);
const Volume_Mode Volume_Mode_Mode_MIN = Volume_Mode_RW;
const Volume_Mode Volume_Mode_Mode_MAX = Volume_Mode_RO;
const int Volume_Mode_Mode_ARRAYSIZE = Volume_Mode_Mode_MAX + 1;

const ::google::protobuf::EnumDescriptor* Volume_Mode_descriptor();
inline const ::std::string& Volume_Mode_Name(Volume_Mode value) {
  return ::google::protobuf::internal::NameOfEnum(
    Volume_Mode_descriptor(), value);
}
inline bool Volume_Mode_Parse(
    const ::std::string& name, Volume_Mode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Volume_Mode>(
    Volume_Mode_descriptor(), name, value);
}
enum NetworkInfo_Protocol {
  NetworkInfo_Protocol_IPv4 = 1,
  NetworkInfo_Protocol_IPv6 = 2
};
bool NetworkInfo_Protocol_IsValid(int value);
const NetworkInfo_Protocol NetworkInfo_Protocol_Protocol_MIN = NetworkInfo_Protocol_IPv4;
const NetworkInfo_Protocol NetworkInfo_Protocol_Protocol_MAX = NetworkInfo_Protocol_IPv6;
const int NetworkInfo_Protocol_Protocol_ARRAYSIZE = NetworkInfo_Protocol_Protocol_MAX + 1;

const ::google::protobuf::EnumDescriptor* NetworkInfo_Protocol_descriptor();
inline const ::std::string& NetworkInfo_Protocol_Name(NetworkInfo_Protocol value) {
  return ::google::protobuf::internal::NameOfEnum(
    NetworkInfo_Protocol_descriptor(), value);
}
inline bool NetworkInfo_Protocol_Parse(
    const ::std::string& name, NetworkInfo_Protocol* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NetworkInfo_Protocol>(
    NetworkInfo_Protocol_descriptor(), name, value);
}
enum CapabilityInfo_Capability {
  CapabilityInfo_Capability_UNKNOWN = 0,
  CapabilityInfo_Capability_CHOWN = 1000,
  CapabilityInfo_Capability_DAC_OVERRIDE = 1001,
  CapabilityInfo_Capability_DAC_READ_SEARCH = 1002,
  CapabilityInfo_Capability_FOWNER = 1003,
  CapabilityInfo_Capability_FSETID = 1004,
  CapabilityInfo_Capability_KILL = 1005,
  CapabilityInfo_Capability_SETGID = 1006,
  CapabilityInfo_Capability_SETUID = 1007,
  CapabilityInfo_Capability_SETPCAP = 1008,
  CapabilityInfo_Capability_LINUX_IMMUTABLE = 1009,
  CapabilityInfo_Capability_NET_BIND_SERVICE = 1010,
  CapabilityInfo_Capability_NET_BROADCAST = 1011,
  CapabilityInfo_Capability_NET_ADMIN = 1012,
  CapabilityInfo_Capability_NET_RAW = 1013,
  CapabilityInfo_Capability_IPC_LOCK = 1014,
  CapabilityInfo_Capability_IPC_OWNER = 1015,
  CapabilityInfo_Capability_SYS_MODULE = 1016,
  CapabilityInfo_Capability_SYS_RAWIO = 1017,
  CapabilityInfo_Capability_SYS_CHROOT = 1018,
  CapabilityInfo_Capability_SYS_PTRACE = 1019,
  CapabilityInfo_Capability_SYS_PACCT = 1020,
  CapabilityInfo_Capability_SYS_ADMIN = 1021,
  CapabilityInfo_Capability_SYS_BOOT = 1022,
  CapabilityInfo_Capability_SYS_NICE = 1023,
  CapabilityInfo_Capability_SYS_RESOURCE = 1024,
  CapabilityInfo_Capability_SYS_TIME = 1025,
  CapabilityInfo_Capability_SYS_TTY_CONFIG = 1026,
  CapabilityInfo_Capability_MKNOD = 1027,
  CapabilityInfo_Capability_LEASE = 1028,
  CapabilityInfo_Capability_AUDIT_WRITE = 1029,
  CapabilityInfo_Capability_AUDIT_CONTROL = 1030,
  CapabilityInfo_Capability_SETFCAP = 1031,
  CapabilityInfo_Capability_MAC_OVERRIDE = 1032,
  CapabilityInfo_Capability_MAC_ADMIN = 1033,
  CapabilityInfo_Capability_SYSLOG = 1034,
  CapabilityInfo_Capability_WAKE_ALARM = 1035,
  CapabilityInfo_Capability_BLOCK_SUSPEND = 1036,
  CapabilityInfo_Capability_AUDIT_READ = 1037
};
bool CapabilityInfo_Capability_IsValid(int value);
const CapabilityInfo_Capability CapabilityInfo_Capability_Capability_MIN = CapabilityInfo_Capability_UNKNOWN;
const CapabilityInfo_Capability CapabilityInfo_Capability_Capability_MAX = CapabilityInfo_Capability_AUDIT_READ;
const int CapabilityInfo_Capability_Capability_ARRAYSIZE = CapabilityInfo_Capability_Capability_MAX + 1;

const ::google::protobuf::EnumDescriptor* CapabilityInfo_Capability_descriptor();
inline const ::std::string& CapabilityInfo_Capability_Name(CapabilityInfo_Capability value) {
  return ::google::protobuf::internal::NameOfEnum(
    CapabilityInfo_Capability_descriptor(), value);
}
inline bool CapabilityInfo_Capability_Parse(
    const ::std::string& name, CapabilityInfo_Capability* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CapabilityInfo_Capability>(
    CapabilityInfo_Capability_descriptor(), name, value);
}
enum RLimitInfo_RLimit_Type {
  RLimitInfo_RLimit_Type_UNKNOWN = 0,
  RLimitInfo_RLimit_Type_RLMT_AS = 1,
  RLimitInfo_RLimit_Type_RLMT_CORE = 2,
  RLimitInfo_RLimit_Type_RLMT_CPU = 3,
  RLimitInfo_RLimit_Type_RLMT_DATA = 4,
  RLimitInfo_RLimit_Type_RLMT_FSIZE = 5,
  RLimitInfo_RLimit_Type_RLMT_LOCKS = 6,
  RLimitInfo_RLimit_Type_RLMT_MEMLOCK = 7,
  RLimitInfo_RLimit_Type_RLMT_MSGQUEUE = 8,
  RLimitInfo_RLimit_Type_RLMT_NICE = 9,
  RLimitInfo_RLimit_Type_RLMT_NOFILE = 10,
  RLimitInfo_RLimit_Type_RLMT_NPROC = 11,
  RLimitInfo_RLimit_Type_RLMT_RSS = 12,
  RLimitInfo_RLimit_Type_RLMT_RTPRIO = 13,
  RLimitInfo_RLimit_Type_RLMT_RTTIME = 14,
  RLimitInfo_RLimit_Type_RLMT_SIGPENDING = 15,
  RLimitInfo_RLimit_Type_RLMT_STACK = 16
};
bool RLimitInfo_RLimit_Type_IsValid(int value);
const RLimitInfo_RLimit_Type RLimitInfo_RLimit_Type_Type_MIN = RLimitInfo_RLimit_Type_UNKNOWN;
const RLimitInfo_RLimit_Type RLimitInfo_RLimit_Type_Type_MAX = RLimitInfo_RLimit_Type_RLMT_STACK;
const int RLimitInfo_RLimit_Type_Type_ARRAYSIZE = RLimitInfo_RLimit_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* RLimitInfo_RLimit_Type_descriptor();
inline const ::std::string& RLimitInfo_RLimit_Type_Name(RLimitInfo_RLimit_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    RLimitInfo_RLimit_Type_descriptor(), value);
}
inline bool RLimitInfo_RLimit_Type_Parse(
    const ::std::string& name, RLimitInfo_RLimit_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RLimitInfo_RLimit_Type>(
    RLimitInfo_RLimit_Type_descriptor(), name, value);
}
enum ContainerInfo_DockerInfo_Network {
  ContainerInfo_DockerInfo_Network_HOST = 1,
  ContainerInfo_DockerInfo_Network_BRIDGE = 2,
  ContainerInfo_DockerInfo_Network_NONE = 3,
  ContainerInfo_DockerInfo_Network_USER = 4
};
bool ContainerInfo_DockerInfo_Network_IsValid(int value);
const ContainerInfo_DockerInfo_Network ContainerInfo_DockerInfo_Network_Network_MIN = ContainerInfo_DockerInfo_Network_HOST;
const ContainerInfo_DockerInfo_Network ContainerInfo_DockerInfo_Network_Network_MAX = ContainerInfo_DockerInfo_Network_USER;
const int ContainerInfo_DockerInfo_Network_Network_ARRAYSIZE = ContainerInfo_DockerInfo_Network_Network_MAX + 1;

const ::google::protobuf::EnumDescriptor* ContainerInfo_DockerInfo_Network_descriptor();
inline const ::std::string& ContainerInfo_DockerInfo_Network_Name(ContainerInfo_DockerInfo_Network value) {
  return ::google::protobuf::internal::NameOfEnum(
    ContainerInfo_DockerInfo_Network_descriptor(), value);
}
inline bool ContainerInfo_DockerInfo_Network_Parse(
    const ::std::string& name, ContainerInfo_DockerInfo_Network* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ContainerInfo_DockerInfo_Network>(
    ContainerInfo_DockerInfo_Network_descriptor(), name, value);
}
enum ContainerInfo_Type {
  ContainerInfo_Type_DOCKER = 1,
  ContainerInfo_Type_MESOS = 2
};
bool ContainerInfo_Type_IsValid(int value);
const ContainerInfo_Type ContainerInfo_Type_Type_MIN = ContainerInfo_Type_DOCKER;
const ContainerInfo_Type ContainerInfo_Type_Type_MAX = ContainerInfo_Type_MESOS;
const int ContainerInfo_Type_Type_ARRAYSIZE = ContainerInfo_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* ContainerInfo_Type_descriptor();
inline const ::std::string& ContainerInfo_Type_Name(ContainerInfo_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    ContainerInfo_Type_descriptor(), value);
}
inline bool ContainerInfo_Type_Parse(
    const ::std::string& name, ContainerInfo_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ContainerInfo_Type>(
    ContainerInfo_Type_descriptor(), name, value);
}
enum CgroupInfo_Blkio_Operation {
  CgroupInfo_Blkio_Operation_UNKNOWN = 0,
  CgroupInfo_Blkio_Operation_TOTAL = 1,
  CgroupInfo_Blkio_Operation_READ = 2,
  CgroupInfo_Blkio_Operation_WRITE = 3,
  CgroupInfo_Blkio_Operation_SYNC = 4,
  CgroupInfo_Blkio_Operation_ASYNC = 5
};
bool CgroupInfo_Blkio_Operation_IsValid(int value);
const CgroupInfo_Blkio_Operation CgroupInfo_Blkio_Operation_Operation_MIN = CgroupInfo_Blkio_Operation_UNKNOWN;
const CgroupInfo_Blkio_Operation CgroupInfo_Blkio_Operation_Operation_MAX = CgroupInfo_Blkio_Operation_ASYNC;
const int CgroupInfo_Blkio_Operation_Operation_ARRAYSIZE = CgroupInfo_Blkio_Operation_Operation_MAX + 1;

const ::google::protobuf::EnumDescriptor* CgroupInfo_Blkio_Operation_descriptor();
inline const ::std::string& CgroupInfo_Blkio_Operation_Name(CgroupInfo_Blkio_Operation value) {
  return ::google::protobuf::internal::NameOfEnum(
    CgroupInfo_Blkio_Operation_descriptor(), value);
}
inline bool CgroupInfo_Blkio_Operation_Parse(
    const ::std::string& name, CgroupInfo_Blkio_Operation* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CgroupInfo_Blkio_Operation>(
    CgroupInfo_Blkio_Operation_descriptor(), name, value);
}
enum DiscoveryInfo_Visibility {
  DiscoveryInfo_Visibility_FRAMEWORK = 0,
  DiscoveryInfo_Visibility_CLUSTER = 1,
  DiscoveryInfo_Visibility_EXTERNAL = 2
};
bool DiscoveryInfo_Visibility_IsValid(int value);
const DiscoveryInfo_Visibility DiscoveryInfo_Visibility_Visibility_MIN = DiscoveryInfo_Visibility_FRAMEWORK;
const DiscoveryInfo_Visibility DiscoveryInfo_Visibility_Visibility_MAX = DiscoveryInfo_Visibility_EXTERNAL;
const int DiscoveryInfo_Visibility_Visibility_ARRAYSIZE = DiscoveryInfo_Visibility_Visibility_MAX + 1;

const ::google::protobuf::EnumDescriptor* DiscoveryInfo_Visibility_descriptor();
inline const ::std::string& DiscoveryInfo_Visibility_Name(DiscoveryInfo_Visibility value) {
  return ::google::protobuf::internal::NameOfEnum(
    DiscoveryInfo_Visibility_descriptor(), value);
}
inline bool DiscoveryInfo_Visibility_Parse(
    const ::std::string& name, DiscoveryInfo_Visibility* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DiscoveryInfo_Visibility>(
    DiscoveryInfo_Visibility_descriptor(), name, value);
}
enum Status {
  DRIVER_NOT_STARTED = 1,
  DRIVER_RUNNING = 2,
  DRIVER_ABORTED = 3,
  DRIVER_STOPPED = 4
};
bool Status_IsValid(int value);
const Status Status_MIN = DRIVER_NOT_STARTED;
const Status Status_MAX = DRIVER_STOPPED;
const int Status_ARRAYSIZE = Status_MAX + 1;

const ::google::protobuf::EnumDescriptor* Status_descriptor();
inline const ::std::string& Status_Name(Status value) {
  return ::google::protobuf::internal::NameOfEnum(
    Status_descriptor(), value);
}
inline bool Status_Parse(
    const ::std::string& name, Status* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Status>(
    Status_descriptor(), name, value);
}
enum TaskState {
  TASK_STAGING = 6,
  TASK_STARTING = 0,
  TASK_RUNNING = 1,
  TASK_KILLING = 8,
  TASK_FINISHED = 2,
  TASK_FAILED = 3,
  TASK_KILLED = 4,
  TASK_ERROR = 7,
  TASK_LOST = 5,
  TASK_DROPPED = 9,
  TASK_UNREACHABLE = 10,
  TASK_GONE = 11,
  TASK_GONE_BY_OPERATOR = 12,
  TASK_UNKNOWN = 13
};
bool TaskState_IsValid(int value);
const TaskState TaskState_MIN = TASK_STARTING;
const TaskState TaskState_MAX = TASK_UNKNOWN;
const int TaskState_ARRAYSIZE = TaskState_MAX + 1;

const ::google::protobuf::EnumDescriptor* TaskState_descriptor();
inline const ::std::string& TaskState_Name(TaskState value) {
  return ::google::protobuf::internal::NameOfEnum(
    TaskState_descriptor(), value);
}
inline bool TaskState_Parse(
    const ::std::string& name, TaskState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TaskState>(
    TaskState_descriptor(), name, value);
}
enum OperationState {
  OPERATION_UNSUPPORTED = 0,
  OPERATION_PENDING = 1,
  OPERATION_FINISHED = 2,
  OPERATION_FAILED = 3,
  OPERATION_ERROR = 4,
  OPERATION_DROPPED = 5,
  OPERATION_UNREACHABLE = 6,
  OPERATION_GONE_BY_OPERATOR = 7,
  OPERATION_RECOVERING = 8,
  OPERATION_UNKNOWN = 9
};
bool OperationState_IsValid(int value);
const OperationState OperationState_MIN = OPERATION_UNSUPPORTED;
const OperationState OperationState_MAX = OPERATION_UNKNOWN;
const int OperationState_ARRAYSIZE = OperationState_MAX + 1;

const ::google::protobuf::EnumDescriptor* OperationState_descriptor();
inline const ::std::string& OperationState_Name(OperationState value) {
  return ::google::protobuf::internal::NameOfEnum(
    OperationState_descriptor(), value);
}
inline bool OperationState_Parse(
    const ::std::string& name, OperationState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<OperationState>(
    OperationState_descriptor(), name, value);
}
// ===================================================================

class FrameworkID : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.FrameworkID) */ {
 public:
  FrameworkID();
  virtual ~FrameworkID();

  FrameworkID(const FrameworkID& from);

  inline FrameworkID& operator=(const FrameworkID& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FrameworkID(FrameworkID&& from) noexcept
    : FrameworkID() {
    *this = ::std::move(from);
  }

  inline FrameworkID& operator=(FrameworkID&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const FrameworkID& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FrameworkID* internal_default_instance() {
    return reinterpret_cast<const FrameworkID*>(
               &_FrameworkID_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void UnsafeArenaSwap(FrameworkID* other);
  void Swap(FrameworkID* other);
  friend void swap(FrameworkID& a, FrameworkID& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FrameworkID* New() const PROTOBUF_FINAL { return New(NULL); }

  FrameworkID* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const FrameworkID& from);
  void MergeFrom(const FrameworkID& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(FrameworkID* other);
  protected:
  explicit FrameworkID(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string value = 1;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_value();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_value(
      ::std::string* value);

  // @@protoc_insertion_point(class_scope:mesos.FrameworkID)
 private:
  void set_has_value();
  void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsFrameworkIDImpl();
};
// -------------------------------------------------------------------

class OfferID : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.OfferID) */ {
 public:
  OfferID();
  virtual ~OfferID();

  OfferID(const OfferID& from);

  inline OfferID& operator=(const OfferID& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OfferID(OfferID&& from) noexcept
    : OfferID() {
    *this = ::std::move(from);
  }

  inline OfferID& operator=(OfferID&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const OfferID& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OfferID* internal_default_instance() {
    return reinterpret_cast<const OfferID*>(
               &_OfferID_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void UnsafeArenaSwap(OfferID* other);
  void Swap(OfferID* other);
  friend void swap(OfferID& a, OfferID& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OfferID* New() const PROTOBUF_FINAL { return New(NULL); }

  OfferID* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const OfferID& from);
  void MergeFrom(const OfferID& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(OfferID* other);
  protected:
  explicit OfferID(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string value = 1;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_value();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_value(
      ::std::string* value);

  // @@protoc_insertion_point(class_scope:mesos.OfferID)
 private:
  void set_has_value();
  void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsOfferIDImpl();
};
// -------------------------------------------------------------------

class SlaveID : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.SlaveID) */ {
 public:
  SlaveID();
  virtual ~SlaveID();

  SlaveID(const SlaveID& from);

  inline SlaveID& operator=(const SlaveID& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SlaveID(SlaveID&& from) noexcept
    : SlaveID() {
    *this = ::std::move(from);
  }

  inline SlaveID& operator=(SlaveID&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const SlaveID& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SlaveID* internal_default_instance() {
    return reinterpret_cast<const SlaveID*>(
               &_SlaveID_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void UnsafeArenaSwap(SlaveID* other);
  void Swap(SlaveID* other);
  friend void swap(SlaveID& a, SlaveID& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SlaveID* New() const PROTOBUF_FINAL { return New(NULL); }

  SlaveID* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SlaveID& from);
  void MergeFrom(const SlaveID& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SlaveID* other);
  protected:
  explicit SlaveID(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string value = 1;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_value();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_value(
      ::std::string* value);

  // @@protoc_insertion_point(class_scope:mesos.SlaveID)
 private:
  void set_has_value();
  void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsSlaveIDImpl();
};
// -------------------------------------------------------------------

class TaskID : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.TaskID) */ {
 public:
  TaskID();
  virtual ~TaskID();

  TaskID(const TaskID& from);

  inline TaskID& operator=(const TaskID& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TaskID(TaskID&& from) noexcept
    : TaskID() {
    *this = ::std::move(from);
  }

  inline TaskID& operator=(TaskID&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const TaskID& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TaskID* internal_default_instance() {
    return reinterpret_cast<const TaskID*>(
               &_TaskID_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void UnsafeArenaSwap(TaskID* other);
  void Swap(TaskID* other);
  friend void swap(TaskID& a, TaskID& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TaskID* New() const PROTOBUF_FINAL { return New(NULL); }

  TaskID* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TaskID& from);
  void MergeFrom(const TaskID& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TaskID* other);
  protected:
  explicit TaskID(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string value = 1;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_value();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_value(
      ::std::string* value);

  // @@protoc_insertion_point(class_scope:mesos.TaskID)
 private:
  void set_has_value();
  void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsTaskIDImpl();
};
// -------------------------------------------------------------------

class ExecutorID : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.ExecutorID) */ {
 public:
  ExecutorID();
  virtual ~ExecutorID();

  ExecutorID(const ExecutorID& from);

  inline ExecutorID& operator=(const ExecutorID& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ExecutorID(ExecutorID&& from) noexcept
    : ExecutorID() {
    *this = ::std::move(from);
  }

  inline ExecutorID& operator=(ExecutorID&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const ExecutorID& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ExecutorID* internal_default_instance() {
    return reinterpret_cast<const ExecutorID*>(
               &_ExecutorID_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void UnsafeArenaSwap(ExecutorID* other);
  void Swap(ExecutorID* other);
  friend void swap(ExecutorID& a, ExecutorID& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ExecutorID* New() const PROTOBUF_FINAL { return New(NULL); }

  ExecutorID* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ExecutorID& from);
  void MergeFrom(const ExecutorID& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ExecutorID* other);
  protected:
  explicit ExecutorID(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string value = 1;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_value();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_value(
      ::std::string* value);

  // @@protoc_insertion_point(class_scope:mesos.ExecutorID)
 private:
  void set_has_value();
  void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsExecutorIDImpl();
};
// -------------------------------------------------------------------

class ContainerID : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.ContainerID) */ {
 public:
  ContainerID();
  virtual ~ContainerID();

  ContainerID(const ContainerID& from);

  inline ContainerID& operator=(const ContainerID& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ContainerID(ContainerID&& from) noexcept
    : ContainerID() {
    *this = ::std::move(from);
  }

  inline ContainerID& operator=(ContainerID&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const ContainerID& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ContainerID* internal_default_instance() {
    return reinterpret_cast<const ContainerID*>(
               &_ContainerID_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void UnsafeArenaSwap(ContainerID* other);
  void Swap(ContainerID* other);
  friend void swap(ContainerID& a, ContainerID& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ContainerID* New() const PROTOBUF_FINAL { return New(NULL); }

  ContainerID* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ContainerID& from);
  void MergeFrom(const ContainerID& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ContainerID* other);
  protected:
  explicit ContainerID(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string value = 1;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_value();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_value(
      ::std::string* value);

  // optional .mesos.ContainerID parent = 2;
  bool has_parent() const;
  void clear_parent();
  static const int kParentFieldNumber = 2;
  private:
  void _slow_mutable_parent();
  public:
  const ::mesos::ContainerID& parent() const;
  ::mesos::ContainerID* release_parent();
  ::mesos::ContainerID* mutable_parent();
  void set_allocated_parent(::mesos::ContainerID* parent);
  void unsafe_arena_set_allocated_parent(
      ::mesos::ContainerID* parent);
  ::mesos::ContainerID* unsafe_arena_release_parent();

  // @@protoc_insertion_point(class_scope:mesos.ContainerID)
 private:
  void set_has_value();
  void clear_has_value();
  void set_has_parent();
  void clear_has_parent();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  ::mesos::ContainerID* parent_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsContainerIDImpl();
};
// -------------------------------------------------------------------

class ResourceProviderID : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.ResourceProviderID) */ {
 public:
  ResourceProviderID();
  virtual ~ResourceProviderID();

  ResourceProviderID(const ResourceProviderID& from);

  inline ResourceProviderID& operator=(const ResourceProviderID& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResourceProviderID(ResourceProviderID&& from) noexcept
    : ResourceProviderID() {
    *this = ::std::move(from);
  }

  inline ResourceProviderID& operator=(ResourceProviderID&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResourceProviderID& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResourceProviderID* internal_default_instance() {
    return reinterpret_cast<const ResourceProviderID*>(
               &_ResourceProviderID_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void UnsafeArenaSwap(ResourceProviderID* other);
  void Swap(ResourceProviderID* other);
  friend void swap(ResourceProviderID& a, ResourceProviderID& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResourceProviderID* New() const PROTOBUF_FINAL { return New(NULL); }

  ResourceProviderID* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ResourceProviderID& from);
  void MergeFrom(const ResourceProviderID& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ResourceProviderID* other);
  protected:
  explicit ResourceProviderID(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string value = 1;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_value();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_value(
      ::std::string* value);

  // @@protoc_insertion_point(class_scope:mesos.ResourceProviderID)
 private:
  void set_has_value();
  void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsResourceProviderIDImpl();
};
// -------------------------------------------------------------------

class OperationID : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.OperationID) */ {
 public:
  OperationID();
  virtual ~OperationID();

  OperationID(const OperationID& from);

  inline OperationID& operator=(const OperationID& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OperationID(OperationID&& from) noexcept
    : OperationID() {
    *this = ::std::move(from);
  }

  inline OperationID& operator=(OperationID&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const OperationID& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OperationID* internal_default_instance() {
    return reinterpret_cast<const OperationID*>(
               &_OperationID_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void UnsafeArenaSwap(OperationID* other);
  void Swap(OperationID* other);
  friend void swap(OperationID& a, OperationID& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OperationID* New() const PROTOBUF_FINAL { return New(NULL); }

  OperationID* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const OperationID& from);
  void MergeFrom(const OperationID& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(OperationID* other);
  protected:
  explicit OperationID(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string value = 1;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_value();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_value(
      ::std::string* value);

  // @@protoc_insertion_point(class_scope:mesos.OperationID)
 private:
  void set_has_value();
  void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsOperationIDImpl();
};
// -------------------------------------------------------------------

class TimeInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.TimeInfo) */ {
 public:
  TimeInfo();
  virtual ~TimeInfo();

  TimeInfo(const TimeInfo& from);

  inline TimeInfo& operator=(const TimeInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TimeInfo(TimeInfo&& from) noexcept
    : TimeInfo() {
    *this = ::std::move(from);
  }

  inline TimeInfo& operator=(TimeInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const TimeInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TimeInfo* internal_default_instance() {
    return reinterpret_cast<const TimeInfo*>(
               &_TimeInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void UnsafeArenaSwap(TimeInfo* other);
  void Swap(TimeInfo* other);
  friend void swap(TimeInfo& a, TimeInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TimeInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  TimeInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TimeInfo& from);
  void MergeFrom(const TimeInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TimeInfo* other);
  protected:
  explicit TimeInfo(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 nanoseconds = 1;
  bool has_nanoseconds() const;
  void clear_nanoseconds();
  static const int kNanosecondsFieldNumber = 1;
  ::google::protobuf::int64 nanoseconds() const;
  void set_nanoseconds(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:mesos.TimeInfo)
 private:
  void set_has_nanoseconds();
  void clear_has_nanoseconds();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int64 nanoseconds_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsTimeInfoImpl();
};
// -------------------------------------------------------------------

class DurationInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.DurationInfo) */ {
 public:
  DurationInfo();
  virtual ~DurationInfo();

  DurationInfo(const DurationInfo& from);

  inline DurationInfo& operator=(const DurationInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DurationInfo(DurationInfo&& from) noexcept
    : DurationInfo() {
    *this = ::std::move(from);
  }

  inline DurationInfo& operator=(DurationInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const DurationInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DurationInfo* internal_default_instance() {
    return reinterpret_cast<const DurationInfo*>(
               &_DurationInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void UnsafeArenaSwap(DurationInfo* other);
  void Swap(DurationInfo* other);
  friend void swap(DurationInfo& a, DurationInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DurationInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  DurationInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DurationInfo& from);
  void MergeFrom(const DurationInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DurationInfo* other);
  protected:
  explicit DurationInfo(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 nanoseconds = 1;
  bool has_nanoseconds() const;
  void clear_nanoseconds();
  static const int kNanosecondsFieldNumber = 1;
  ::google::protobuf::int64 nanoseconds() const;
  void set_nanoseconds(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:mesos.DurationInfo)
 private:
  void set_has_nanoseconds();
  void clear_has_nanoseconds();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int64 nanoseconds_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsDurationInfoImpl();
};
// -------------------------------------------------------------------

class Address : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.Address) */ {
 public:
  Address();
  virtual ~Address();

  Address(const Address& from);

  inline Address& operator=(const Address& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Address(Address&& from) noexcept
    : Address() {
    *this = ::std::move(from);
  }

  inline Address& operator=(Address&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Address& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Address* internal_default_instance() {
    return reinterpret_cast<const Address*>(
               &_Address_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void UnsafeArenaSwap(Address* other);
  void Swap(Address* other);
  friend void swap(Address& a, Address& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Address* New() const PROTOBUF_FINAL { return New(NULL); }

  Address* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Address& from);
  void MergeFrom(const Address& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Address* other);
  protected:
  explicit Address(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string hostname = 1;
  bool has_hostname() const;
  void clear_hostname();
  static const int kHostnameFieldNumber = 1;
  const ::std::string& hostname() const;
  void set_hostname(const ::std::string& value);
  #if LANG_CXX11
  void set_hostname(::std::string&& value);
  #endif
  void set_hostname(const char* value);
  void set_hostname(const char* value, size_t size);
  ::std::string* mutable_hostname();
  ::std::string* release_hostname();
  void set_allocated_hostname(::std::string* hostname);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_hostname();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_hostname(
      ::std::string* hostname);

  // optional string ip = 2;
  bool has_ip() const;
  void clear_ip();
  static const int kIpFieldNumber = 2;
  const ::std::string& ip() const;
  void set_ip(const ::std::string& value);
  #if LANG_CXX11
  void set_ip(::std::string&& value);
  #endif
  void set_ip(const char* value);
  void set_ip(const char* value, size_t size);
  ::std::string* mutable_ip();
  ::std::string* release_ip();
  void set_allocated_ip(::std::string* ip);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_ip();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_ip(
      ::std::string* ip);

  // required int32 port = 3;
  bool has_port() const;
  void clear_port();
  static const int kPortFieldNumber = 3;
  ::google::protobuf::int32 port() const;
  void set_port(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:mesos.Address)
 private:
  void set_has_hostname();
  void clear_has_hostname();
  void set_has_ip();
  void clear_has_ip();
  void set_has_port();
  void clear_has_port();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr hostname_;
  ::google::protobuf::internal::ArenaStringPtr ip_;
  ::google::protobuf::int32 port_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsAddressImpl();
};
// -------------------------------------------------------------------

class URL : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.URL) */ {
 public:
  URL();
  virtual ~URL();

  URL(const URL& from);

  inline URL& operator=(const URL& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  URL(URL&& from) noexcept
    : URL() {
    *this = ::std::move(from);
  }

  inline URL& operator=(URL&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const URL& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const URL* internal_default_instance() {
    return reinterpret_cast<const URL*>(
               &_URL_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void UnsafeArenaSwap(URL* other);
  void Swap(URL* other);
  friend void swap(URL& a, URL& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline URL* New() const PROTOBUF_FINAL { return New(NULL); }

  URL* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const URL& from);
  void MergeFrom(const URL& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(URL* other);
  protected:
  explicit URL(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.Parameter query = 4;
  int query_size() const;
  void clear_query();
  static const int kQueryFieldNumber = 4;
  const ::mesos::Parameter& query(int index) const;
  ::mesos::Parameter* mutable_query(int index);
  ::mesos::Parameter* add_query();
  ::google::protobuf::RepeatedPtrField< ::mesos::Parameter >*
      mutable_query();
  const ::google::protobuf::RepeatedPtrField< ::mesos::Parameter >&
      query() const;

  // required string scheme = 1;
  bool has_scheme() const;
  void clear_scheme();
  static const int kSchemeFieldNumber = 1;
  const ::std::string& scheme() const;
  void set_scheme(const ::std::string& value);
  #if LANG_CXX11
  void set_scheme(::std::string&& value);
  #endif
  void set_scheme(const char* value);
  void set_scheme(const char* value, size_t size);
  ::std::string* mutable_scheme();
  ::std::string* release_scheme();
  void set_allocated_scheme(::std::string* scheme);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_scheme();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_scheme(
      ::std::string* scheme);

  // optional string path = 3;
  bool has_path() const;
  void clear_path();
  static const int kPathFieldNumber = 3;
  const ::std::string& path() const;
  void set_path(const ::std::string& value);
  #if LANG_CXX11
  void set_path(::std::string&& value);
  #endif
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  ::std::string* mutable_path();
  ::std::string* release_path();
  void set_allocated_path(::std::string* path);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_path();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_path(
      ::std::string* path);

  // optional string fragment = 5;
  bool has_fragment() const;
  void clear_fragment();
  static const int kFragmentFieldNumber = 5;
  const ::std::string& fragment() const;
  void set_fragment(const ::std::string& value);
  #if LANG_CXX11
  void set_fragment(::std::string&& value);
  #endif
  void set_fragment(const char* value);
  void set_fragment(const char* value, size_t size);
  ::std::string* mutable_fragment();
  ::std::string* release_fragment();
  void set_allocated_fragment(::std::string* fragment);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_fragment();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_fragment(
      ::std::string* fragment);

  // required .mesos.Address address = 2;
  bool has_address() const;
  void clear_address();
  static const int kAddressFieldNumber = 2;
  private:
  void _slow_mutable_address();
  public:
  const ::mesos::Address& address() const;
  ::mesos::Address* release_address();
  ::mesos::Address* mutable_address();
  void set_allocated_address(::mesos::Address* address);
  void unsafe_arena_set_allocated_address(
      ::mesos::Address* address);
  ::mesos::Address* unsafe_arena_release_address();

  // @@protoc_insertion_point(class_scope:mesos.URL)
 private:
  void set_has_scheme();
  void clear_has_scheme();
  void set_has_address();
  void clear_has_address();
  void set_has_path();
  void clear_has_path();
  void set_has_fragment();
  void clear_has_fragment();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Parameter > query_;
  ::google::protobuf::internal::ArenaStringPtr scheme_;
  ::google::protobuf::internal::ArenaStringPtr path_;
  ::google::protobuf::internal::ArenaStringPtr fragment_;
  ::mesos::Address* address_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsURLImpl();
};
// -------------------------------------------------------------------

class Unavailability : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.Unavailability) */ {
 public:
  Unavailability();
  virtual ~Unavailability();

  Unavailability(const Unavailability& from);

  inline Unavailability& operator=(const Unavailability& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Unavailability(Unavailability&& from) noexcept
    : Unavailability() {
    *this = ::std::move(from);
  }

  inline Unavailability& operator=(Unavailability&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Unavailability& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Unavailability* internal_default_instance() {
    return reinterpret_cast<const Unavailability*>(
               &_Unavailability_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void UnsafeArenaSwap(Unavailability* other);
  void Swap(Unavailability* other);
  friend void swap(Unavailability& a, Unavailability& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Unavailability* New() const PROTOBUF_FINAL { return New(NULL); }

  Unavailability* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Unavailability& from);
  void MergeFrom(const Unavailability& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Unavailability* other);
  protected:
  explicit Unavailability(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.TimeInfo start = 1;
  bool has_start() const;
  void clear_start();
  static const int kStartFieldNumber = 1;
  private:
  void _slow_mutable_start();
  public:
  const ::mesos::TimeInfo& start() const;
  ::mesos::TimeInfo* release_start();
  ::mesos::TimeInfo* mutable_start();
  void set_allocated_start(::mesos::TimeInfo* start);
  void unsafe_arena_set_allocated_start(
      ::mesos::TimeInfo* start);
  ::mesos::TimeInfo* unsafe_arena_release_start();

  // optional .mesos.DurationInfo duration = 2;
  bool has_duration() const;
  void clear_duration();
  static const int kDurationFieldNumber = 2;
  private:
  void _slow_mutable_duration();
  public:
  const ::mesos::DurationInfo& duration() const;
  ::mesos::DurationInfo* release_duration();
  ::mesos::DurationInfo* mutable_duration();
  void set_allocated_duration(::mesos::DurationInfo* duration);
  void unsafe_arena_set_allocated_duration(
      ::mesos::DurationInfo* duration);
  ::mesos::DurationInfo* unsafe_arena_release_duration();

  // @@protoc_insertion_point(class_scope:mesos.Unavailability)
 private:
  void set_has_start();
  void clear_has_start();
  void set_has_duration();
  void clear_has_duration();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::TimeInfo* start_;
  ::mesos::DurationInfo* duration_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsUnavailabilityImpl();
};
// -------------------------------------------------------------------

class MachineID : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.MachineID) */ {
 public:
  MachineID();
  virtual ~MachineID();

  MachineID(const MachineID& from);

  inline MachineID& operator=(const MachineID& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MachineID(MachineID&& from) noexcept
    : MachineID() {
    *this = ::std::move(from);
  }

  inline MachineID& operator=(MachineID&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const MachineID& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MachineID* internal_default_instance() {
    return reinterpret_cast<const MachineID*>(
               &_MachineID_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void UnsafeArenaSwap(MachineID* other);
  void Swap(MachineID* other);
  friend void swap(MachineID& a, MachineID& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MachineID* New() const PROTOBUF_FINAL { return New(NULL); }

  MachineID* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MachineID& from);
  void MergeFrom(const MachineID& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MachineID* other);
  protected:
  explicit MachineID(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string hostname = 1;
  bool has_hostname() const;
  void clear_hostname();
  static const int kHostnameFieldNumber = 1;
  const ::std::string& hostname() const;
  void set_hostname(const ::std::string& value);
  #if LANG_CXX11
  void set_hostname(::std::string&& value);
  #endif
  void set_hostname(const char* value);
  void set_hostname(const char* value, size_t size);
  ::std::string* mutable_hostname();
  ::std::string* release_hostname();
  void set_allocated_hostname(::std::string* hostname);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_hostname();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_hostname(
      ::std::string* hostname);

  // optional string ip = 2;
  bool has_ip() const;
  void clear_ip();
  static const int kIpFieldNumber = 2;
  const ::std::string& ip() const;
  void set_ip(const ::std::string& value);
  #if LANG_CXX11
  void set_ip(::std::string&& value);
  #endif
  void set_ip(const char* value);
  void set_ip(const char* value, size_t size);
  ::std::string* mutable_ip();
  ::std::string* release_ip();
  void set_allocated_ip(::std::string* ip);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_ip();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_ip(
      ::std::string* ip);

  // @@protoc_insertion_point(class_scope:mesos.MachineID)
 private:
  void set_has_hostname();
  void clear_has_hostname();
  void set_has_ip();
  void clear_has_ip();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr hostname_;
  ::google::protobuf::internal::ArenaStringPtr ip_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsMachineIDImpl();
};
// -------------------------------------------------------------------

class MachineInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.MachineInfo) */ {
 public:
  MachineInfo();
  virtual ~MachineInfo();

  MachineInfo(const MachineInfo& from);

  inline MachineInfo& operator=(const MachineInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MachineInfo(MachineInfo&& from) noexcept
    : MachineInfo() {
    *this = ::std::move(from);
  }

  inline MachineInfo& operator=(MachineInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const MachineInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MachineInfo* internal_default_instance() {
    return reinterpret_cast<const MachineInfo*>(
               &_MachineInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    14;

  void UnsafeArenaSwap(MachineInfo* other);
  void Swap(MachineInfo* other);
  friend void swap(MachineInfo& a, MachineInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MachineInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  MachineInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MachineInfo& from);
  void MergeFrom(const MachineInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MachineInfo* other);
  protected:
  explicit MachineInfo(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef MachineInfo_Mode Mode;
  static const Mode UP =
    MachineInfo_Mode_UP;
  static const Mode DRAINING =
    MachineInfo_Mode_DRAINING;
  static const Mode DOWN =
    MachineInfo_Mode_DOWN;
  static inline bool Mode_IsValid(int value) {
    return MachineInfo_Mode_IsValid(value);
  }
  static const Mode Mode_MIN =
    MachineInfo_Mode_Mode_MIN;
  static const Mode Mode_MAX =
    MachineInfo_Mode_Mode_MAX;
  static const int Mode_ARRAYSIZE =
    MachineInfo_Mode_Mode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Mode_descriptor() {
    return MachineInfo_Mode_descriptor();
  }
  static inline const ::std::string& Mode_Name(Mode value) {
    return MachineInfo_Mode_Name(value);
  }
  static inline bool Mode_Parse(const ::std::string& name,
      Mode* value) {
    return MachineInfo_Mode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .mesos.MachineID id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  private:
  void _slow_mutable_id();
  public:
  const ::mesos::MachineID& id() const;
  ::mesos::MachineID* release_id();
  ::mesos::MachineID* mutable_id();
  void set_allocated_id(::mesos::MachineID* id);
  void unsafe_arena_set_allocated_id(
      ::mesos::MachineID* id);
  ::mesos::MachineID* unsafe_arena_release_id();

  // optional .mesos.Unavailability unavailability = 3;
  bool has_unavailability() const;
  void clear_unavailability();
  static const int kUnavailabilityFieldNumber = 3;
  private:
  void _slow_mutable_unavailability();
  public:
  const ::mesos::Unavailability& unavailability() const;
  ::mesos::Unavailability* release_unavailability();
  ::mesos::Unavailability* mutable_unavailability();
  void set_allocated_unavailability(::mesos::Unavailability* unavailability);
  void unsafe_arena_set_allocated_unavailability(
      ::mesos::Unavailability* unavailability);
  ::mesos::Unavailability* unsafe_arena_release_unavailability();

  // optional .mesos.MachineInfo.Mode mode = 2;
  bool has_mode() const;
  void clear_mode();
  static const int kModeFieldNumber = 2;
  ::mesos::MachineInfo_Mode mode() const;
  void set_mode(::mesos::MachineInfo_Mode value);

  // @@protoc_insertion_point(class_scope:mesos.MachineInfo)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_mode();
  void clear_has_mode();
  void set_has_unavailability();
  void clear_has_unavailability();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::MachineID* id_;
  ::mesos::Unavailability* unavailability_;
  int mode_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsMachineInfoImpl();
};
// -------------------------------------------------------------------

class FrameworkInfo_Capability : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.FrameworkInfo.Capability) */ {
 public:
  FrameworkInfo_Capability();
  virtual ~FrameworkInfo_Capability();

  FrameworkInfo_Capability(const FrameworkInfo_Capability& from);

  inline FrameworkInfo_Capability& operator=(const FrameworkInfo_Capability& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FrameworkInfo_Capability(FrameworkInfo_Capability&& from) noexcept
    : FrameworkInfo_Capability() {
    *this = ::std::move(from);
  }

  inline FrameworkInfo_Capability& operator=(FrameworkInfo_Capability&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const FrameworkInfo_Capability& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FrameworkInfo_Capability* internal_default_instance() {
    return reinterpret_cast<const FrameworkInfo_Capability*>(
               &_FrameworkInfo_Capability_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    15;

  void UnsafeArenaSwap(FrameworkInfo_Capability* other);
  void Swap(FrameworkInfo_Capability* other);
  friend void swap(FrameworkInfo_Capability& a, FrameworkInfo_Capability& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FrameworkInfo_Capability* New() const PROTOBUF_FINAL { return New(NULL); }

  FrameworkInfo_Capability* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const FrameworkInfo_Capability& from);
  void MergeFrom(const FrameworkInfo_Capability& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(FrameworkInfo_Capability* other);
  protected:
  explicit FrameworkInfo_Capability(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef FrameworkInfo_Capability_Type Type;
  static const Type UNKNOWN =
    FrameworkInfo_Capability_Type_UNKNOWN;
  static const Type REVOCABLE_RESOURCES =
    FrameworkInfo_Capability_Type_REVOCABLE_RESOURCES;
  static const Type TASK_KILLING_STATE =
    FrameworkInfo_Capability_Type_TASK_KILLING_STATE;
  static const Type GPU_RESOURCES =
    FrameworkInfo_Capability_Type_GPU_RESOURCES;
  static const Type SHARED_RESOURCES =
    FrameworkInfo_Capability_Type_SHARED_RESOURCES;
  static const Type PARTITION_AWARE =
    FrameworkInfo_Capability_Type_PARTITION_AWARE;
  static const Type MULTI_ROLE =
    FrameworkInfo_Capability_Type_MULTI_ROLE;
  static const Type RESERVATION_REFINEMENT =
    FrameworkInfo_Capability_Type_RESERVATION_REFINEMENT;
  static const Type REGION_AWARE =
    FrameworkInfo_Capability_Type_REGION_AWARE;
  static inline bool Type_IsValid(int value) {
    return FrameworkInfo_Capability_Type_IsValid(value);
  }
  static const Type Type_MIN =
    FrameworkInfo_Capability_Type_Type_MIN;
  static const Type Type_MAX =
    FrameworkInfo_Capability_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    FrameworkInfo_Capability_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return FrameworkInfo_Capability_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return FrameworkInfo_Capability_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return FrameworkInfo_Capability_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .mesos.FrameworkInfo.Capability.Type type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::mesos::FrameworkInfo_Capability_Type type() const;
  void set_type(::mesos::FrameworkInfo_Capability_Type value);

  // @@protoc_insertion_point(class_scope:mesos.FrameworkInfo.Capability)
 private:
  void set_has_type();
  void clear_has_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  int type_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsFrameworkInfo_CapabilityImpl();
};
// -------------------------------------------------------------------

class FrameworkInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.FrameworkInfo) */ {
 public:
  FrameworkInfo();
  virtual ~FrameworkInfo();

  FrameworkInfo(const FrameworkInfo& from);

  inline FrameworkInfo& operator=(const FrameworkInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FrameworkInfo(FrameworkInfo&& from) noexcept
    : FrameworkInfo() {
    *this = ::std::move(from);
  }

  inline FrameworkInfo& operator=(FrameworkInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const FrameworkInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FrameworkInfo* internal_default_instance() {
    return reinterpret_cast<const FrameworkInfo*>(
               &_FrameworkInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    16;

  void UnsafeArenaSwap(FrameworkInfo* other);
  void Swap(FrameworkInfo* other);
  friend void swap(FrameworkInfo& a, FrameworkInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FrameworkInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  FrameworkInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const FrameworkInfo& from);
  void MergeFrom(const FrameworkInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(FrameworkInfo* other);
  protected:
  explicit FrameworkInfo(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef FrameworkInfo_Capability Capability;

  // accessors -------------------------------------------------------

  // repeated .mesos.FrameworkInfo.Capability capabilities = 10;
  int capabilities_size() const;
  void clear_capabilities();
  static const int kCapabilitiesFieldNumber = 10;
  const ::mesos::FrameworkInfo_Capability& capabilities(int index) const;
  ::mesos::FrameworkInfo_Capability* mutable_capabilities(int index);
  ::mesos::FrameworkInfo_Capability* add_capabilities();
  ::google::protobuf::RepeatedPtrField< ::mesos::FrameworkInfo_Capability >*
      mutable_capabilities();
  const ::google::protobuf::RepeatedPtrField< ::mesos::FrameworkInfo_Capability >&
      capabilities() const;

  // repeated string roles = 12;
  int roles_size() const;
  void clear_roles();
  static const int kRolesFieldNumber = 12;
  const ::std::string& roles(int index) const;
  ::std::string* mutable_roles(int index);
  void set_roles(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_roles(int index, ::std::string&& value);
  #endif
  void set_roles(int index, const char* value);
  void set_roles(int index, const char* value, size_t size);
  ::std::string* add_roles();
  void add_roles(const ::std::string& value);
  #if LANG_CXX11
  void add_roles(::std::string&& value);
  #endif
  void add_roles(const char* value);
  void add_roles(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& roles() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_roles();

  // required string user = 1;
  bool has_user() const;
  void clear_user();
  static const int kUserFieldNumber = 1;
  const ::std::string& user() const;
  void set_user(const ::std::string& value);
  #if LANG_CXX11
  void set_user(::std::string&& value);
  #endif
  void set_user(const char* value);
  void set_user(const char* value, size_t size);
  ::std::string* mutable_user();
  ::std::string* release_user();
  void set_allocated_user(::std::string* user);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_user();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_user(
      ::std::string* user);

  // required string name = 2;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_name();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      ::std::string* name);

  // optional string role = 6 [default = "*", deprecated = true];
  GOOGLE_PROTOBUF_DEPRECATED_ATTR bool has_role() const;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void clear_role();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR static const int kRoleFieldNumber = 6;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR const ::std::string& role() const;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void set_role(const ::std::string& value);
  #if LANG_CXX11
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void set_role(::std::string&& value);
  #endif
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void set_role(const char* value);
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void set_role(const char* value, size_t size);
  GOOGLE_PROTOBUF_DEPRECATED_ATTR ::std::string* mutable_role();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR ::std::string* release_role();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void set_allocated_role(::std::string* role);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_role();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_role(
      ::std::string* role);

  // optional string hostname = 7;
  bool has_hostname() const;
  void clear_hostname();
  static const int kHostnameFieldNumber = 7;
  const ::std::string& hostname() const;
  void set_hostname(const ::std::string& value);
  #if LANG_CXX11
  void set_hostname(::std::string&& value);
  #endif
  void set_hostname(const char* value);
  void set_hostname(const char* value, size_t size);
  ::std::string* mutable_hostname();
  ::std::string* release_hostname();
  void set_allocated_hostname(::std::string* hostname);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_hostname();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_hostname(
      ::std::string* hostname);

  // optional string principal = 8;
  bool has_principal() const;
  void clear_principal();
  static const int kPrincipalFieldNumber = 8;
  const ::std::string& principal() const;
  void set_principal(const ::std::string& value);
  #if LANG_CXX11
  void set_principal(::std::string&& value);
  #endif
  void set_principal(const char* value);
  void set_principal(const char* value, size_t size);
  ::std::string* mutable_principal();
  ::std::string* release_principal();
  void set_allocated_principal(::std::string* principal);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_principal();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_principal(
      ::std::string* principal);

  // optional string webui_url = 9;
  bool has_webui_url() const;
  void clear_webui_url();
  static const int kWebuiUrlFieldNumber = 9;
  const ::std::string& webui_url() const;
  void set_webui_url(const ::std::string& value);
  #if LANG_CXX11
  void set_webui_url(::std::string&& value);
  #endif
  void set_webui_url(const char* value);
  void set_webui_url(const char* value, size_t size);
  ::std::string* mutable_webui_url();
  ::std::string* release_webui_url();
  void set_allocated_webui_url(::std::string* webui_url);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_webui_url();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_webui_url(
      ::std::string* webui_url);

  // optional .mesos.FrameworkID id = 3;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 3;
  private:
  void _slow_mutable_id();
  public:
  const ::mesos::FrameworkID& id() const;
  ::mesos::FrameworkID* release_id();
  ::mesos::FrameworkID* mutable_id();
  void set_allocated_id(::mesos::FrameworkID* id);
  void unsafe_arena_set_allocated_id(
      ::mesos::FrameworkID* id);
  ::mesos::FrameworkID* unsafe_arena_release_id();

  // optional .mesos.Labels labels = 11;
  bool has_labels() const;
  void clear_labels();
  static const int kLabelsFieldNumber = 11;
  private:
  void _slow_mutable_labels();
  public:
  const ::mesos::Labels& labels() const;
  ::mesos::Labels* release_labels();
  ::mesos::Labels* mutable_labels();
  void set_allocated_labels(::mesos::Labels* labels);
  void unsafe_arena_set_allocated_labels(
      ::mesos::Labels* labels);
  ::mesos::Labels* unsafe_arena_release_labels();

  // optional double failover_timeout = 4 [default = 0];
  bool has_failover_timeout() const;
  void clear_failover_timeout();
  static const int kFailoverTimeoutFieldNumber = 4;
  double failover_timeout() const;
  void set_failover_timeout(double value);

  // optional bool checkpoint = 5 [default = false];
  bool has_checkpoint() const;
  void clear_checkpoint();
  static const int kCheckpointFieldNumber = 5;
  bool checkpoint() const;
  void set_checkpoint(bool value);

  // @@protoc_insertion_point(class_scope:mesos.FrameworkInfo)
 private:
  void set_has_user();
  void clear_has_user();
  void set_has_name();
  void clear_has_name();
  void set_has_id();
  void clear_has_id();
  void set_has_failover_timeout();
  void clear_has_failover_timeout();
  void set_has_checkpoint();
  void clear_has_checkpoint();
  void set_has_role();
  void clear_has_role();
  void set_has_hostname();
  void clear_has_hostname();
  void set_has_principal();
  void clear_has_principal();
  void set_has_webui_url();
  void clear_has_webui_url();
  void set_has_labels();
  void clear_has_labels();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::FrameworkInfo_Capability > capabilities_;
  ::google::protobuf::RepeatedPtrField< ::std::string> roles_;
  ::google::protobuf::internal::ArenaStringPtr user_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  static ::google::protobuf::internal::ExplicitlyConstructed< ::std::string> _default_role_;
  ::google::protobuf::internal::ArenaStringPtr role_;
  ::google::protobuf::internal::ArenaStringPtr hostname_;
  ::google::protobuf::internal::ArenaStringPtr principal_;
  ::google::protobuf::internal::ArenaStringPtr webui_url_;
  ::mesos::FrameworkID* id_;
  ::mesos::Labels* labels_;
  double failover_timeout_;
  bool checkpoint_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsFrameworkInfoImpl();
};
// -------------------------------------------------------------------

class CheckInfo_Command : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.CheckInfo.Command) */ {
 public:
  CheckInfo_Command();
  virtual ~CheckInfo_Command();

  CheckInfo_Command(const CheckInfo_Command& from);

  inline CheckInfo_Command& operator=(const CheckInfo_Command& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CheckInfo_Command(CheckInfo_Command&& from) noexcept
    : CheckInfo_Command() {
    *this = ::std::move(from);
  }

  inline CheckInfo_Command& operator=(CheckInfo_Command&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const CheckInfo_Command& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CheckInfo_Command* internal_default_instance() {
    return reinterpret_cast<const CheckInfo_Command*>(
               &_CheckInfo_Command_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    17;

  void UnsafeArenaSwap(CheckInfo_Command* other);
  void Swap(CheckInfo_Command* other);
  friend void swap(CheckInfo_Command& a, CheckInfo_Command& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CheckInfo_Command* New() const PROTOBUF_FINAL { return New(NULL); }

  CheckInfo_Command* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CheckInfo_Command& from);
  void MergeFrom(const CheckInfo_Command& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CheckInfo_Command* other);
  protected:
  explicit CheckInfo_Command(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.CommandInfo command = 1;
  bool has_command() const;
  void clear_command();
  static const int kCommandFieldNumber = 1;
  private:
  void _slow_mutable_command();
  public:
  const ::mesos::CommandInfo& command() const;
  ::mesos::CommandInfo* release_command();
  ::mesos::CommandInfo* mutable_command();
  void set_allocated_command(::mesos::CommandInfo* command);
  void unsafe_arena_set_allocated_command(
      ::mesos::CommandInfo* command);
  ::mesos::CommandInfo* unsafe_arena_release_command();

  // @@protoc_insertion_point(class_scope:mesos.CheckInfo.Command)
 private:
  void set_has_command();
  void clear_has_command();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::CommandInfo* command_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsCheckInfo_CommandImpl();
};
// -------------------------------------------------------------------

class CheckInfo_Http : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.CheckInfo.Http) */ {
 public:
  CheckInfo_Http();
  virtual ~CheckInfo_Http();

  CheckInfo_Http(const CheckInfo_Http& from);

  inline CheckInfo_Http& operator=(const CheckInfo_Http& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CheckInfo_Http(CheckInfo_Http&& from) noexcept
    : CheckInfo_Http() {
    *this = ::std::move(from);
  }

  inline CheckInfo_Http& operator=(CheckInfo_Http&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const CheckInfo_Http& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CheckInfo_Http* internal_default_instance() {
    return reinterpret_cast<const CheckInfo_Http*>(
               &_CheckInfo_Http_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    18;

  void UnsafeArenaSwap(CheckInfo_Http* other);
  void Swap(CheckInfo_Http* other);
  friend void swap(CheckInfo_Http& a, CheckInfo_Http& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CheckInfo_Http* New() const PROTOBUF_FINAL { return New(NULL); }

  CheckInfo_Http* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CheckInfo_Http& from);
  void MergeFrom(const CheckInfo_Http& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CheckInfo_Http* other);
  protected:
  explicit CheckInfo_Http(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string path = 2;
  bool has_path() const;
  void clear_path();
  static const int kPathFieldNumber = 2;
  const ::std::string& path() const;
  void set_path(const ::std::string& value);
  #if LANG_CXX11
  void set_path(::std::string&& value);
  #endif
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  ::std::string* mutable_path();
  ::std::string* release_path();
  void set_allocated_path(::std::string* path);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_path();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_path(
      ::std::string* path);

  // required uint32 port = 1;
  bool has_port() const;
  void clear_port();
  static const int kPortFieldNumber = 1;
  ::google::protobuf::uint32 port() const;
  void set_port(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mesos.CheckInfo.Http)
 private:
  void set_has_port();
  void clear_has_port();
  void set_has_path();
  void clear_has_path();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr path_;
  ::google::protobuf::uint32 port_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsCheckInfo_HttpImpl();
};
// -------------------------------------------------------------------

class CheckInfo_Tcp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.CheckInfo.Tcp) */ {
 public:
  CheckInfo_Tcp();
  virtual ~CheckInfo_Tcp();

  CheckInfo_Tcp(const CheckInfo_Tcp& from);

  inline CheckInfo_Tcp& operator=(const CheckInfo_Tcp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CheckInfo_Tcp(CheckInfo_Tcp&& from) noexcept
    : CheckInfo_Tcp() {
    *this = ::std::move(from);
  }

  inline CheckInfo_Tcp& operator=(CheckInfo_Tcp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const CheckInfo_Tcp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CheckInfo_Tcp* internal_default_instance() {
    return reinterpret_cast<const CheckInfo_Tcp*>(
               &_CheckInfo_Tcp_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    19;

  void UnsafeArenaSwap(CheckInfo_Tcp* other);
  void Swap(CheckInfo_Tcp* other);
  friend void swap(CheckInfo_Tcp& a, CheckInfo_Tcp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CheckInfo_Tcp* New() const PROTOBUF_FINAL { return New(NULL); }

  CheckInfo_Tcp* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CheckInfo_Tcp& from);
  void MergeFrom(const CheckInfo_Tcp& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CheckInfo_Tcp* other);
  protected:
  explicit CheckInfo_Tcp(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 port = 1;
  bool has_port() const;
  void clear_port();
  static const int kPortFieldNumber = 1;
  ::google::protobuf::uint32 port() const;
  void set_port(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mesos.CheckInfo.Tcp)
 private:
  void set_has_port();
  void clear_has_port();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 port_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsCheckInfo_TcpImpl();
};
// -------------------------------------------------------------------

class CheckInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.CheckInfo) */ {
 public:
  CheckInfo();
  virtual ~CheckInfo();

  CheckInfo(const CheckInfo& from);

  inline CheckInfo& operator=(const CheckInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CheckInfo(CheckInfo&& from) noexcept
    : CheckInfo() {
    *this = ::std::move(from);
  }

  inline CheckInfo& operator=(CheckInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const CheckInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CheckInfo* internal_default_instance() {
    return reinterpret_cast<const CheckInfo*>(
               &_CheckInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    20;

  void UnsafeArenaSwap(CheckInfo* other);
  void Swap(CheckInfo* other);
  friend void swap(CheckInfo& a, CheckInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CheckInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  CheckInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CheckInfo& from);
  void MergeFrom(const CheckInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CheckInfo* other);
  protected:
  explicit CheckInfo(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef CheckInfo_Command Command;
  typedef CheckInfo_Http Http;
  typedef CheckInfo_Tcp Tcp;

  typedef CheckInfo_Type Type;
  static const Type UNKNOWN =
    CheckInfo_Type_UNKNOWN;
  static const Type COMMAND =
    CheckInfo_Type_COMMAND;
  static const Type HTTP =
    CheckInfo_Type_HTTP;
  static const Type TCP =
    CheckInfo_Type_TCP;
  static inline bool Type_IsValid(int value) {
    return CheckInfo_Type_IsValid(value);
  }
  static const Type Type_MIN =
    CheckInfo_Type_Type_MIN;
  static const Type Type_MAX =
    CheckInfo_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    CheckInfo_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return CheckInfo_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return CheckInfo_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return CheckInfo_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .mesos.CheckInfo.Command command = 2;
  bool has_command() const;
  void clear_command();
  static const int kCommandFieldNumber = 2;
  private:
  void _slow_mutable_command();
  public:
  const ::mesos::CheckInfo_Command& command() const;
  ::mesos::CheckInfo_Command* release_command();
  ::mesos::CheckInfo_Command* mutable_command();
  void set_allocated_command(::mesos::CheckInfo_Command* command);
  void unsafe_arena_set_allocated_command(
      ::mesos::CheckInfo_Command* command);
  ::mesos::CheckInfo_Command* unsafe_arena_release_command();

  // optional .mesos.CheckInfo.Http http = 3;
  bool has_http() const;
  void clear_http();
  static const int kHttpFieldNumber = 3;
  private:
  void _slow_mutable_http();
  public:
  const ::mesos::CheckInfo_Http& http() const;
  ::mesos::CheckInfo_Http* release_http();
  ::mesos::CheckInfo_Http* mutable_http();
  void set_allocated_http(::mesos::CheckInfo_Http* http);
  void unsafe_arena_set_allocated_http(
      ::mesos::CheckInfo_Http* http);
  ::mesos::CheckInfo_Http* unsafe_arena_release_http();

  // optional .mesos.CheckInfo.Tcp tcp = 7;
  bool has_tcp() const;
  void clear_tcp();
  static const int kTcpFieldNumber = 7;
  private:
  void _slow_mutable_tcp();
  public:
  const ::mesos::CheckInfo_Tcp& tcp() const;
  ::mesos::CheckInfo_Tcp* release_tcp();
  ::mesos::CheckInfo_Tcp* mutable_tcp();
  void set_allocated_tcp(::mesos::CheckInfo_Tcp* tcp);
  void unsafe_arena_set_allocated_tcp(
      ::mesos::CheckInfo_Tcp* tcp);
  ::mesos::CheckInfo_Tcp* unsafe_arena_release_tcp();

  // optional .mesos.CheckInfo.Type type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::mesos::CheckInfo_Type type() const;
  void set_type(::mesos::CheckInfo_Type value);

  // optional double delay_seconds = 4 [default = 15];
  bool has_delay_seconds() const;
  void clear_delay_seconds();
  static const int kDelaySecondsFieldNumber = 4;
  double delay_seconds() const;
  void set_delay_seconds(double value);

  // optional double interval_seconds = 5 [default = 10];
  bool has_interval_seconds() const;
  void clear_interval_seconds();
  static const int kIntervalSecondsFieldNumber = 5;
  double interval_seconds() const;
  void set_interval_seconds(double value);

  // optional double timeout_seconds = 6 [default = 20];
  bool has_timeout_seconds() const;
  void clear_timeout_seconds();
  static const int kTimeoutSecondsFieldNumber = 6;
  double timeout_seconds() const;
  void set_timeout_seconds(double value);

  // @@protoc_insertion_point(class_scope:mesos.CheckInfo)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_command();
  void clear_has_command();
  void set_has_http();
  void clear_has_http();
  void set_has_tcp();
  void clear_has_tcp();
  void set_has_delay_seconds();
  void clear_has_delay_seconds();
  void set_has_interval_seconds();
  void clear_has_interval_seconds();
  void set_has_timeout_seconds();
  void clear_has_timeout_seconds();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::CheckInfo_Command* command_;
  ::mesos::CheckInfo_Http* http_;
  ::mesos::CheckInfo_Tcp* tcp_;
  int type_;
  double delay_seconds_;
  double interval_seconds_;
  double timeout_seconds_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsCheckInfoImpl();
};
// -------------------------------------------------------------------

class HealthCheck_HTTPCheckInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.HealthCheck.HTTPCheckInfo) */ {
 public:
  HealthCheck_HTTPCheckInfo();
  virtual ~HealthCheck_HTTPCheckInfo();

  HealthCheck_HTTPCheckInfo(const HealthCheck_HTTPCheckInfo& from);

  inline HealthCheck_HTTPCheckInfo& operator=(const HealthCheck_HTTPCheckInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HealthCheck_HTTPCheckInfo(HealthCheck_HTTPCheckInfo&& from) noexcept
    : HealthCheck_HTTPCheckInfo() {
    *this = ::std::move(from);
  }

  inline HealthCheck_HTTPCheckInfo& operator=(HealthCheck_HTTPCheckInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const HealthCheck_HTTPCheckInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HealthCheck_HTTPCheckInfo* internal_default_instance() {
    return reinterpret_cast<const HealthCheck_HTTPCheckInfo*>(
               &_HealthCheck_HTTPCheckInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    21;

  void UnsafeArenaSwap(HealthCheck_HTTPCheckInfo* other);
  void Swap(HealthCheck_HTTPCheckInfo* other);
  friend void swap(HealthCheck_HTTPCheckInfo& a, HealthCheck_HTTPCheckInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HealthCheck_HTTPCheckInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  HealthCheck_HTTPCheckInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const HealthCheck_HTTPCheckInfo& from);
  void MergeFrom(const HealthCheck_HTTPCheckInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(HealthCheck_HTTPCheckInfo* other);
  protected:
  explicit HealthCheck_HTTPCheckInfo(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 statuses = 4;
  int statuses_size() const;
  void clear_statuses();
  static const int kStatusesFieldNumber = 4;
  ::google::protobuf::uint32 statuses(int index) const;
  void set_statuses(int index, ::google::protobuf::uint32 value);
  void add_statuses(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      statuses() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_statuses();

  // optional string path = 2;
  bool has_path() const;
  void clear_path();
  static const int kPathFieldNumber = 2;
  const ::std::string& path() const;
  void set_path(const ::std::string& value);
  #if LANG_CXX11
  void set_path(::std::string&& value);
  #endif
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  ::std::string* mutable_path();
  ::std::string* release_path();
  void set_allocated_path(::std::string* path);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_path();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_path(
      ::std::string* path);

  // optional string scheme = 3;
  bool has_scheme() const;
  void clear_scheme();
  static const int kSchemeFieldNumber = 3;
  const ::std::string& scheme() const;
  void set_scheme(const ::std::string& value);
  #if LANG_CXX11
  void set_scheme(::std::string&& value);
  #endif
  void set_scheme(const char* value);
  void set_scheme(const char* value, size_t size);
  ::std::string* mutable_scheme();
  ::std::string* release_scheme();
  void set_allocated_scheme(::std::string* scheme);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_scheme();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_scheme(
      ::std::string* scheme);

  // required uint32 port = 1;
  bool has_port() const;
  void clear_port();
  static const int kPortFieldNumber = 1;
  ::google::protobuf::uint32 port() const;
  void set_port(::google::protobuf::uint32 value);

  // optional .mesos.NetworkInfo.Protocol protocol = 5 [default = IPv4];
  bool has_protocol() const;
  void clear_protocol();
  static const int kProtocolFieldNumber = 5;
  ::mesos::NetworkInfo_Protocol protocol() const;
  void set_protocol(::mesos::NetworkInfo_Protocol value);

  // @@protoc_insertion_point(class_scope:mesos.HealthCheck.HTTPCheckInfo)
 private:
  void set_has_protocol();
  void clear_has_protocol();
  void set_has_scheme();
  void clear_has_scheme();
  void set_has_port();
  void clear_has_port();
  void set_has_path();
  void clear_has_path();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > statuses_;
  ::google::protobuf::internal::ArenaStringPtr path_;
  ::google::protobuf::internal::ArenaStringPtr scheme_;
  ::google::protobuf::uint32 port_;
  int protocol_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsHealthCheck_HTTPCheckInfoImpl();
};
// -------------------------------------------------------------------

class HealthCheck_TCPCheckInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.HealthCheck.TCPCheckInfo) */ {
 public:
  HealthCheck_TCPCheckInfo();
  virtual ~HealthCheck_TCPCheckInfo();

  HealthCheck_TCPCheckInfo(const HealthCheck_TCPCheckInfo& from);

  inline HealthCheck_TCPCheckInfo& operator=(const HealthCheck_TCPCheckInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HealthCheck_TCPCheckInfo(HealthCheck_TCPCheckInfo&& from) noexcept
    : HealthCheck_TCPCheckInfo() {
    *this = ::std::move(from);
  }

  inline HealthCheck_TCPCheckInfo& operator=(HealthCheck_TCPCheckInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const HealthCheck_TCPCheckInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HealthCheck_TCPCheckInfo* internal_default_instance() {
    return reinterpret_cast<const HealthCheck_TCPCheckInfo*>(
               &_HealthCheck_TCPCheckInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    22;

  void UnsafeArenaSwap(HealthCheck_TCPCheckInfo* other);
  void Swap(HealthCheck_TCPCheckInfo* other);
  friend void swap(HealthCheck_TCPCheckInfo& a, HealthCheck_TCPCheckInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HealthCheck_TCPCheckInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  HealthCheck_TCPCheckInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const HealthCheck_TCPCheckInfo& from);
  void MergeFrom(const HealthCheck_TCPCheckInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(HealthCheck_TCPCheckInfo* other);
  protected:
  explicit HealthCheck_TCPCheckInfo(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 port = 1;
  bool has_port() const;
  void clear_port();
  static const int kPortFieldNumber = 1;
  ::google::protobuf::uint32 port() const;
  void set_port(::google::protobuf::uint32 value);

  // optional .mesos.NetworkInfo.Protocol protocol = 2 [default = IPv4];
  bool has_protocol() const;
  void clear_protocol();
  static const int kProtocolFieldNumber = 2;
  ::mesos::NetworkInfo_Protocol protocol() const;
  void set_protocol(::mesos::NetworkInfo_Protocol value);

  // @@protoc_insertion_point(class_scope:mesos.HealthCheck.TCPCheckInfo)
 private:
  void set_has_protocol();
  void clear_has_protocol();
  void set_has_port();
  void clear_has_port();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 port_;
  int protocol_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsHealthCheck_TCPCheckInfoImpl();
};
// -------------------------------------------------------------------

class HealthCheck : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.HealthCheck) */ {
 public:
  HealthCheck();
  virtual ~HealthCheck();

  HealthCheck(const HealthCheck& from);

  inline HealthCheck& operator=(const HealthCheck& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HealthCheck(HealthCheck&& from) noexcept
    : HealthCheck() {
    *this = ::std::move(from);
  }

  inline HealthCheck& operator=(HealthCheck&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const HealthCheck& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HealthCheck* internal_default_instance() {
    return reinterpret_cast<const HealthCheck*>(
               &_HealthCheck_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    23;

  void UnsafeArenaSwap(HealthCheck* other);
  void Swap(HealthCheck* other);
  friend void swap(HealthCheck& a, HealthCheck& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HealthCheck* New() const PROTOBUF_FINAL { return New(NULL); }

  HealthCheck* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const HealthCheck& from);
  void MergeFrom(const HealthCheck& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(HealthCheck* other);
  protected:
  explicit HealthCheck(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef HealthCheck_HTTPCheckInfo HTTPCheckInfo;
  typedef HealthCheck_TCPCheckInfo TCPCheckInfo;

  typedef HealthCheck_Type Type;
  static const Type UNKNOWN =
    HealthCheck_Type_UNKNOWN;
  static const Type COMMAND =
    HealthCheck_Type_COMMAND;
  static const Type HTTP =
    HealthCheck_Type_HTTP;
  static const Type TCP =
    HealthCheck_Type_TCP;
  static inline bool Type_IsValid(int value) {
    return HealthCheck_Type_IsValid(value);
  }
  static const Type Type_MIN =
    HealthCheck_Type_Type_MIN;
  static const Type Type_MAX =
    HealthCheck_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    HealthCheck_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return HealthCheck_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return HealthCheck_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return HealthCheck_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .mesos.HealthCheck.HTTPCheckInfo http = 1;
  bool has_http() const;
  void clear_http();
  static const int kHttpFieldNumber = 1;
  private:
  void _slow_mutable_http();
  public:
  const ::mesos::HealthCheck_HTTPCheckInfo& http() const;
  ::mesos::HealthCheck_HTTPCheckInfo* release_http();
  ::mesos::HealthCheck_HTTPCheckInfo* mutable_http();
  void set_allocated_http(::mesos::HealthCheck_HTTPCheckInfo* http);
  void unsafe_arena_set_allocated_http(
      ::mesos::HealthCheck_HTTPCheckInfo* http);
  ::mesos::HealthCheck_HTTPCheckInfo* unsafe_arena_release_http();

  // optional .mesos.CommandInfo command = 7;
  bool has_command() const;
  void clear_command();
  static const int kCommandFieldNumber = 7;
  private:
  void _slow_mutable_command();
  public:
  const ::mesos::CommandInfo& command() const;
  ::mesos::CommandInfo* release_command();
  ::mesos::CommandInfo* mutable_command();
  void set_allocated_command(::mesos::CommandInfo* command);
  void unsafe_arena_set_allocated_command(
      ::mesos::CommandInfo* command);
  ::mesos::CommandInfo* unsafe_arena_release_command();

  // optional .mesos.HealthCheck.TCPCheckInfo tcp = 9;
  bool has_tcp() const;
  void clear_tcp();
  static const int kTcpFieldNumber = 9;
  private:
  void _slow_mutable_tcp();
  public:
  const ::mesos::HealthCheck_TCPCheckInfo& tcp() const;
  ::mesos::HealthCheck_TCPCheckInfo* release_tcp();
  ::mesos::HealthCheck_TCPCheckInfo* mutable_tcp();
  void set_allocated_tcp(::mesos::HealthCheck_TCPCheckInfo* tcp);
  void unsafe_arena_set_allocated_tcp(
      ::mesos::HealthCheck_TCPCheckInfo* tcp);
  ::mesos::HealthCheck_TCPCheckInfo* unsafe_arena_release_tcp();

  // optional .mesos.HealthCheck.Type type = 8;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 8;
  ::mesos::HealthCheck_Type type() const;
  void set_type(::mesos::HealthCheck_Type value);

  // optional uint32 consecutive_failures = 5 [default = 3];
  bool has_consecutive_failures() const;
  void clear_consecutive_failures();
  static const int kConsecutiveFailuresFieldNumber = 5;
  ::google::protobuf::uint32 consecutive_failures() const;
  void set_consecutive_failures(::google::protobuf::uint32 value);

  // optional double delay_seconds = 2 [default = 15];
  bool has_delay_seconds() const;
  void clear_delay_seconds();
  static const int kDelaySecondsFieldNumber = 2;
  double delay_seconds() const;
  void set_delay_seconds(double value);

  // optional double interval_seconds = 3 [default = 10];
  bool has_interval_seconds() const;
  void clear_interval_seconds();
  static const int kIntervalSecondsFieldNumber = 3;
  double interval_seconds() const;
  void set_interval_seconds(double value);

  // optional double timeout_seconds = 4 [default = 20];
  bool has_timeout_seconds() const;
  void clear_timeout_seconds();
  static const int kTimeoutSecondsFieldNumber = 4;
  double timeout_seconds() const;
  void set_timeout_seconds(double value);

  // optional double grace_period_seconds = 6 [default = 10];
  bool has_grace_period_seconds() const;
  void clear_grace_period_seconds();
  static const int kGracePeriodSecondsFieldNumber = 6;
  double grace_period_seconds() const;
  void set_grace_period_seconds(double value);

  // @@protoc_insertion_point(class_scope:mesos.HealthCheck)
 private:
  void set_has_delay_seconds();
  void clear_has_delay_seconds();
  void set_has_interval_seconds();
  void clear_has_interval_seconds();
  void set_has_timeout_seconds();
  void clear_has_timeout_seconds();
  void set_has_consecutive_failures();
  void clear_has_consecutive_failures();
  void set_has_grace_period_seconds();
  void clear_has_grace_period_seconds();
  void set_has_type();
  void clear_has_type();
  void set_has_command();
  void clear_has_command();
  void set_has_http();
  void clear_has_http();
  void set_has_tcp();
  void clear_has_tcp();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::HealthCheck_HTTPCheckInfo* http_;
  ::mesos::CommandInfo* command_;
  ::mesos::HealthCheck_TCPCheckInfo* tcp_;
  int type_;
  ::google::protobuf::uint32 consecutive_failures_;
  double delay_seconds_;
  double interval_seconds_;
  double timeout_seconds_;
  double grace_period_seconds_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsHealthCheckImpl();
};
// -------------------------------------------------------------------

class KillPolicy : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.KillPolicy) */ {
 public:
  KillPolicy();
  virtual ~KillPolicy();

  KillPolicy(const KillPolicy& from);

  inline KillPolicy& operator=(const KillPolicy& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  KillPolicy(KillPolicy&& from) noexcept
    : KillPolicy() {
    *this = ::std::move(from);
  }

  inline KillPolicy& operator=(KillPolicy&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const KillPolicy& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const KillPolicy* internal_default_instance() {
    return reinterpret_cast<const KillPolicy*>(
               &_KillPolicy_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    24;

  void UnsafeArenaSwap(KillPolicy* other);
  void Swap(KillPolicy* other);
  friend void swap(KillPolicy& a, KillPolicy& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KillPolicy* New() const PROTOBUF_FINAL { return New(NULL); }

  KillPolicy* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const KillPolicy& from);
  void MergeFrom(const KillPolicy& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(KillPolicy* other);
  protected:
  explicit KillPolicy(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mesos.DurationInfo grace_period = 1;
  bool has_grace_period() const;
  void clear_grace_period();
  static const int kGracePeriodFieldNumber = 1;
  private:
  void _slow_mutable_grace_period();
  public:
  const ::mesos::DurationInfo& grace_period() const;
  ::mesos::DurationInfo* release_grace_period();
  ::mesos::DurationInfo* mutable_grace_period();
  void set_allocated_grace_period(::mesos::DurationInfo* grace_period);
  void unsafe_arena_set_allocated_grace_period(
      ::mesos::DurationInfo* grace_period);
  ::mesos::DurationInfo* unsafe_arena_release_grace_period();

  // @@protoc_insertion_point(class_scope:mesos.KillPolicy)
 private:
  void set_has_grace_period();
  void clear_has_grace_period();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::DurationInfo* grace_period_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsKillPolicyImpl();
};
// -------------------------------------------------------------------

class CommandInfo_URI : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.CommandInfo.URI) */ {
 public:
  CommandInfo_URI();
  virtual ~CommandInfo_URI();

  CommandInfo_URI(const CommandInfo_URI& from);

  inline CommandInfo_URI& operator=(const CommandInfo_URI& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CommandInfo_URI(CommandInfo_URI&& from) noexcept
    : CommandInfo_URI() {
    *this = ::std::move(from);
  }

  inline CommandInfo_URI& operator=(CommandInfo_URI&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandInfo_URI& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CommandInfo_URI* internal_default_instance() {
    return reinterpret_cast<const CommandInfo_URI*>(
               &_CommandInfo_URI_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    25;

  void UnsafeArenaSwap(CommandInfo_URI* other);
  void Swap(CommandInfo_URI* other);
  friend void swap(CommandInfo_URI& a, CommandInfo_URI& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CommandInfo_URI* New() const PROTOBUF_FINAL { return New(NULL); }

  CommandInfo_URI* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CommandInfo_URI& from);
  void MergeFrom(const CommandInfo_URI& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CommandInfo_URI* other);
  protected:
  explicit CommandInfo_URI(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string value = 1;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_value();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_value(
      ::std::string* value);

  // optional string output_file = 5;
  bool has_output_file() const;
  void clear_output_file();
  static const int kOutputFileFieldNumber = 5;
  const ::std::string& output_file() const;
  void set_output_file(const ::std::string& value);
  #if LANG_CXX11
  void set_output_file(::std::string&& value);
  #endif
  void set_output_file(const char* value);
  void set_output_file(const char* value, size_t size);
  ::std::string* mutable_output_file();
  ::std::string* release_output_file();
  void set_allocated_output_file(::std::string* output_file);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_output_file();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_output_file(
      ::std::string* output_file);

  // optional bool executable = 2;
  bool has_executable() const;
  void clear_executable();
  static const int kExecutableFieldNumber = 2;
  bool executable() const;
  void set_executable(bool value);

  // optional bool cache = 4;
  bool has_cache() const;
  void clear_cache();
  static const int kCacheFieldNumber = 4;
  bool cache() const;
  void set_cache(bool value);

  // optional bool extract = 3 [default = true];
  bool has_extract() const;
  void clear_extract();
  static const int kExtractFieldNumber = 3;
  bool extract() const;
  void set_extract(bool value);

  // @@protoc_insertion_point(class_scope:mesos.CommandInfo.URI)
 private:
  void set_has_value();
  void clear_has_value();
  void set_has_executable();
  void clear_has_executable();
  void set_has_extract();
  void clear_has_extract();
  void set_has_cache();
  void clear_has_cache();
  void set_has_output_file();
  void clear_has_output_file();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  ::google::protobuf::internal::ArenaStringPtr output_file_;
  bool executable_;
  bool cache_;
  bool extract_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsCommandInfo_URIImpl();
};
// -------------------------------------------------------------------

class CommandInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.CommandInfo) */ {
 public:
  CommandInfo();
  virtual ~CommandInfo();

  CommandInfo(const CommandInfo& from);

  inline CommandInfo& operator=(const CommandInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CommandInfo(CommandInfo&& from) noexcept
    : CommandInfo() {
    *this = ::std::move(from);
  }

  inline CommandInfo& operator=(CommandInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CommandInfo* internal_default_instance() {
    return reinterpret_cast<const CommandInfo*>(
               &_CommandInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    26;

  void UnsafeArenaSwap(CommandInfo* other);
  void Swap(CommandInfo* other);
  friend void swap(CommandInfo& a, CommandInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CommandInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  CommandInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CommandInfo& from);
  void MergeFrom(const CommandInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CommandInfo* other);
  protected:
  explicit CommandInfo(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef CommandInfo_URI URI;

  // accessors -------------------------------------------------------

  // repeated .mesos.CommandInfo.URI uris = 1;
  int uris_size() const;
  void clear_uris();
  static const int kUrisFieldNumber = 1;
  const ::mesos::CommandInfo_URI& uris(int index) const;
  ::mesos::CommandInfo_URI* mutable_uris(int index);
  ::mesos::CommandInfo_URI* add_uris();
  ::google::protobuf::RepeatedPtrField< ::mesos::CommandInfo_URI >*
      mutable_uris();
  const ::google::protobuf::RepeatedPtrField< ::mesos::CommandInfo_URI >&
      uris() const;

  // repeated string arguments = 7;
  int arguments_size() const;
  void clear_arguments();
  static const int kArgumentsFieldNumber = 7;
  const ::std::string& arguments(int index) const;
  ::std::string* mutable_arguments(int index);
  void set_arguments(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_arguments(int index, ::std::string&& value);
  #endif
  void set_arguments(int index, const char* value);
  void set_arguments(int index, const char* value, size_t size);
  ::std::string* add_arguments();
  void add_arguments(const ::std::string& value);
  #if LANG_CXX11
  void add_arguments(::std::string&& value);
  #endif
  void add_arguments(const char* value);
  void add_arguments(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& arguments() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_arguments();

  // optional string value = 3;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 3;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_value();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_value(
      ::std::string* value);

  // optional string user = 5;
  bool has_user() const;
  void clear_user();
  static const int kUserFieldNumber = 5;
  const ::std::string& user() const;
  void set_user(const ::std::string& value);
  #if LANG_CXX11
  void set_user(::std::string&& value);
  #endif
  void set_user(const char* value);
  void set_user(const char* value, size_t size);
  ::std::string* mutable_user();
  ::std::string* release_user();
  void set_allocated_user(::std::string* user);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_user();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_user(
      ::std::string* user);

  // optional .mesos.Environment environment = 2;
  bool has_environment() const;
  void clear_environment();
  static const int kEnvironmentFieldNumber = 2;
  private:
  void _slow_mutable_environment();
  public:
  const ::mesos::Environment& environment() const;
  ::mesos::Environment* release_environment();
  ::mesos::Environment* mutable_environment();
  void set_allocated_environment(::mesos::Environment* environment);
  void unsafe_arena_set_allocated_environment(
      ::mesos::Environment* environment);
  ::mesos::Environment* unsafe_arena_release_environment();

  // optional bool shell = 6 [default = true];
  bool has_shell() const;
  void clear_shell();
  static const int kShellFieldNumber = 6;
  bool shell() const;
  void set_shell(bool value);

  // @@protoc_insertion_point(class_scope:mesos.CommandInfo)
 private:
  void set_has_environment();
  void clear_has_environment();
  void set_has_shell();
  void clear_has_shell();
  void set_has_value();
  void clear_has_value();
  void set_has_user();
  void clear_has_user();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::CommandInfo_URI > uris_;
  ::google::protobuf::RepeatedPtrField< ::std::string> arguments_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  ::google::protobuf::internal::ArenaStringPtr user_;
  ::mesos::Environment* environment_;
  bool shell_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsCommandInfoImpl();
};
// -------------------------------------------------------------------

class ExecutorInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.ExecutorInfo) */ {
 public:
  ExecutorInfo();
  virtual ~ExecutorInfo();

  ExecutorInfo(const ExecutorInfo& from);

  inline ExecutorInfo& operator=(const ExecutorInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ExecutorInfo(ExecutorInfo&& from) noexcept
    : ExecutorInfo() {
    *this = ::std::move(from);
  }

  inline ExecutorInfo& operator=(ExecutorInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const ExecutorInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ExecutorInfo* internal_default_instance() {
    return reinterpret_cast<const ExecutorInfo*>(
               &_ExecutorInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    27;

  void UnsafeArenaSwap(ExecutorInfo* other);
  void Swap(ExecutorInfo* other);
  friend void swap(ExecutorInfo& a, ExecutorInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ExecutorInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  ExecutorInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ExecutorInfo& from);
  void MergeFrom(const ExecutorInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ExecutorInfo* other);
  protected:
  explicit ExecutorInfo(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef ExecutorInfo_Type Type;
  static const Type UNKNOWN =
    ExecutorInfo_Type_UNKNOWN;
  static const Type DEFAULT =
    ExecutorInfo_Type_DEFAULT;
  static const Type CUSTOM =
    ExecutorInfo_Type_CUSTOM;
  static inline bool Type_IsValid(int value) {
    return ExecutorInfo_Type_IsValid(value);
  }
  static const Type Type_MIN =
    ExecutorInfo_Type_Type_MIN;
  static const Type Type_MAX =
    ExecutorInfo_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    ExecutorInfo_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return ExecutorInfo_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return ExecutorInfo_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return ExecutorInfo_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .mesos.Resource resources = 5;
  int resources_size() const;
  void clear_resources();
  static const int kResourcesFieldNumber = 5;
  const ::mesos::Resource& resources(int index) const;
  ::mesos::Resource* mutable_resources(int index);
  ::mesos::Resource* add_resources();
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
      mutable_resources();
  const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
      resources() const;

  // optional bytes data = 4;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 4;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_data();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_data(
      ::std::string* data);

  // optional string name = 9;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 9;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_name();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      ::std::string* name);

  // optional string source = 10 [deprecated = true];
  GOOGLE_PROTOBUF_DEPRECATED_ATTR bool has_source() const;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void clear_source();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR static const int kSourceFieldNumber = 10;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR const ::std::string& source() const;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void set_source(const ::std::string& value);
  #if LANG_CXX11
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void set_source(::std::string&& value);
  #endif
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void set_source(const char* value);
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void set_source(const char* value, size_t size);
  GOOGLE_PROTOBUF_DEPRECATED_ATTR ::std::string* mutable_source();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR ::std::string* release_source();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void set_allocated_source(::std::string* source);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_source();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_source(
      ::std::string* source);

  // required .mesos.ExecutorID executor_id = 1;
  bool has_executor_id() const;
  void clear_executor_id();
  static const int kExecutorIdFieldNumber = 1;
  private:
  void _slow_mutable_executor_id();
  public:
  const ::mesos::ExecutorID& executor_id() const;
  ::mesos::ExecutorID* release_executor_id();
  ::mesos::ExecutorID* mutable_executor_id();
  void set_allocated_executor_id(::mesos::ExecutorID* executor_id);
  void unsafe_arena_set_allocated_executor_id(
      ::mesos::ExecutorID* executor_id);
  ::mesos::ExecutorID* unsafe_arena_release_executor_id();

  // optional .mesos.CommandInfo command = 7;
  bool has_command() const;
  void clear_command();
  static const int kCommandFieldNumber = 7;
  private:
  void _slow_mutable_command();
  public:
  const ::mesos::CommandInfo& command() const;
  ::mesos::CommandInfo* release_command();
  ::mesos::CommandInfo* mutable_command();
  void set_allocated_command(::mesos::CommandInfo* command);
  void unsafe_arena_set_allocated_command(
      ::mesos::CommandInfo* command);
  ::mesos::CommandInfo* unsafe_arena_release_command();

  // optional .mesos.FrameworkID framework_id = 8;
  bool has_framework_id() const;
  void clear_framework_id();
  static const int kFrameworkIdFieldNumber = 8;
  private:
  void _slow_mutable_framework_id();
  public:
  const ::mesos::FrameworkID& framework_id() const;
  ::mesos::FrameworkID* release_framework_id();
  ::mesos::FrameworkID* mutable_framework_id();
  void set_allocated_framework_id(::mesos::FrameworkID* framework_id);
  void unsafe_arena_set_allocated_framework_id(
      ::mesos::FrameworkID* framework_id);
  ::mesos::FrameworkID* unsafe_arena_release_framework_id();

  // optional .mesos.ContainerInfo container = 11;
  bool has_container() const;
  void clear_container();
  static const int kContainerFieldNumber = 11;
  private:
  void _slow_mutable_container();
  public:
  const ::mesos::ContainerInfo& container() const;
  ::mesos::ContainerInfo* release_container();
  ::mesos::ContainerInfo* mutable_container();
  void set_allocated_container(::mesos::ContainerInfo* container);
  void unsafe_arena_set_allocated_container(
      ::mesos::ContainerInfo* container);
  ::mesos::ContainerInfo* unsafe_arena_release_container();

  // optional .mesos.DiscoveryInfo discovery = 12;
  bool has_discovery() const;
  void clear_discovery();
  static const int kDiscoveryFieldNumber = 12;
  private:
  void _slow_mutable_discovery();
  public:
  const ::mesos::DiscoveryInfo& discovery() const;
  ::mesos::DiscoveryInfo* release_discovery();
  ::mesos::DiscoveryInfo* mutable_discovery();
  void set_allocated_discovery(::mesos::DiscoveryInfo* discovery);
  void unsafe_arena_set_allocated_discovery(
      ::mesos::DiscoveryInfo* discovery);
  ::mesos::DiscoveryInfo* unsafe_arena_release_discovery();

  // optional .mesos.DurationInfo shutdown_grace_period = 13;
  bool has_shutdown_grace_period() const;
  void clear_shutdown_grace_period();
  static const int kShutdownGracePeriodFieldNumber = 13;
  private:
  void _slow_mutable_shutdown_grace_period();
  public:
  const ::mesos::DurationInfo& shutdown_grace_period() const;
  ::mesos::DurationInfo* release_shutdown_grace_period();
  ::mesos::DurationInfo* mutable_shutdown_grace_period();
  void set_allocated_shutdown_grace_period(::mesos::DurationInfo* shutdown_grace_period);
  void unsafe_arena_set_allocated_shutdown_grace_period(
      ::mesos::DurationInfo* shutdown_grace_period);
  ::mesos::DurationInfo* unsafe_arena_release_shutdown_grace_period();

  // optional .mesos.Labels labels = 14;
  bool has_labels() const;
  void clear_labels();
  static const int kLabelsFieldNumber = 14;
  private:
  void _slow_mutable_labels();
  public:
  const ::mesos::Labels& labels() const;
  ::mesos::Labels* release_labels();
  ::mesos::Labels* mutable_labels();
  void set_allocated_labels(::mesos::Labels* labels);
  void unsafe_arena_set_allocated_labels(
      ::mesos::Labels* labels);
  ::mesos::Labels* unsafe_arena_release_labels();

  // optional .mesos.ExecutorInfo.Type type = 15;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 15;
  ::mesos::ExecutorInfo_Type type() const;
  void set_type(::mesos::ExecutorInfo_Type value);

  // @@protoc_insertion_point(class_scope:mesos.ExecutorInfo)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_executor_id();
  void clear_has_executor_id();
  void set_has_framework_id();
  void clear_has_framework_id();
  void set_has_command();
  void clear_has_command();
  void set_has_container();
  void clear_has_container();
  void set_has_name();
  void clear_has_name();
  void set_has_source();
  void clear_has_source();
  void set_has_data();
  void clear_has_data();
  void set_has_discovery();
  void clear_has_discovery();
  void set_has_shutdown_grace_period();
  void clear_has_shutdown_grace_period();
  void set_has_labels();
  void clear_has_labels();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource > resources_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr source_;
  ::mesos::ExecutorID* executor_id_;
  ::mesos::CommandInfo* command_;
  ::mesos::FrameworkID* framework_id_;
  ::mesos::ContainerInfo* container_;
  ::mesos::DiscoveryInfo* discovery_;
  ::mesos::DurationInfo* shutdown_grace_period_;
  ::mesos::Labels* labels_;
  int type_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsExecutorInfoImpl();
};
// -------------------------------------------------------------------

class DomainInfo_FaultDomain_RegionInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.DomainInfo.FaultDomain.RegionInfo) */ {
 public:
  DomainInfo_FaultDomain_RegionInfo();
  virtual ~DomainInfo_FaultDomain_RegionInfo();

  DomainInfo_FaultDomain_RegionInfo(const DomainInfo_FaultDomain_RegionInfo& from);

  inline DomainInfo_FaultDomain_RegionInfo& operator=(const DomainInfo_FaultDomain_RegionInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DomainInfo_FaultDomain_RegionInfo(DomainInfo_FaultDomain_RegionInfo&& from) noexcept
    : DomainInfo_FaultDomain_RegionInfo() {
    *this = ::std::move(from);
  }

  inline DomainInfo_FaultDomain_RegionInfo& operator=(DomainInfo_FaultDomain_RegionInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const DomainInfo_FaultDomain_RegionInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DomainInfo_FaultDomain_RegionInfo* internal_default_instance() {
    return reinterpret_cast<const DomainInfo_FaultDomain_RegionInfo*>(
               &_DomainInfo_FaultDomain_RegionInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    28;

  void UnsafeArenaSwap(DomainInfo_FaultDomain_RegionInfo* other);
  void Swap(DomainInfo_FaultDomain_RegionInfo* other);
  friend void swap(DomainInfo_FaultDomain_RegionInfo& a, DomainInfo_FaultDomain_RegionInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DomainInfo_FaultDomain_RegionInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  DomainInfo_FaultDomain_RegionInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DomainInfo_FaultDomain_RegionInfo& from);
  void MergeFrom(const DomainInfo_FaultDomain_RegionInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DomainInfo_FaultDomain_RegionInfo* other);
  protected:
  explicit DomainInfo_FaultDomain_RegionInfo(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_name();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      ::std::string* name);

  // @@protoc_insertion_point(class_scope:mesos.DomainInfo.FaultDomain.RegionInfo)
 private:
  void set_has_name();
  void clear_has_name();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsDomainInfo_FaultDomain_RegionInfoImpl();
};
// -------------------------------------------------------------------

class DomainInfo_FaultDomain_ZoneInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.DomainInfo.FaultDomain.ZoneInfo) */ {
 public:
  DomainInfo_FaultDomain_ZoneInfo();
  virtual ~DomainInfo_FaultDomain_ZoneInfo();

  DomainInfo_FaultDomain_ZoneInfo(const DomainInfo_FaultDomain_ZoneInfo& from);

  inline DomainInfo_FaultDomain_ZoneInfo& operator=(const DomainInfo_FaultDomain_ZoneInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DomainInfo_FaultDomain_ZoneInfo(DomainInfo_FaultDomain_ZoneInfo&& from) noexcept
    : DomainInfo_FaultDomain_ZoneInfo() {
    *this = ::std::move(from);
  }

  inline DomainInfo_FaultDomain_ZoneInfo& operator=(DomainInfo_FaultDomain_ZoneInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const DomainInfo_FaultDomain_ZoneInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DomainInfo_FaultDomain_ZoneInfo* internal_default_instance() {
    return reinterpret_cast<const DomainInfo_FaultDomain_ZoneInfo*>(
               &_DomainInfo_FaultDomain_ZoneInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    29;

  void UnsafeArenaSwap(DomainInfo_FaultDomain_ZoneInfo* other);
  void Swap(DomainInfo_FaultDomain_ZoneInfo* other);
  friend void swap(DomainInfo_FaultDomain_ZoneInfo& a, DomainInfo_FaultDomain_ZoneInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DomainInfo_FaultDomain_ZoneInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  DomainInfo_FaultDomain_ZoneInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DomainInfo_FaultDomain_ZoneInfo& from);
  void MergeFrom(const DomainInfo_FaultDomain_ZoneInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DomainInfo_FaultDomain_ZoneInfo* other);
  protected:
  explicit DomainInfo_FaultDomain_ZoneInfo(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_name();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      ::std::string* name);

  // @@protoc_insertion_point(class_scope:mesos.DomainInfo.FaultDomain.ZoneInfo)
 private:
  void set_has_name();
  void clear_has_name();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsDomainInfo_FaultDomain_ZoneInfoImpl();
};
// -------------------------------------------------------------------

class DomainInfo_FaultDomain : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.DomainInfo.FaultDomain) */ {
 public:
  DomainInfo_FaultDomain();
  virtual ~DomainInfo_FaultDomain();

  DomainInfo_FaultDomain(const DomainInfo_FaultDomain& from);

  inline DomainInfo_FaultDomain& operator=(const DomainInfo_FaultDomain& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DomainInfo_FaultDomain(DomainInfo_FaultDomain&& from) noexcept
    : DomainInfo_FaultDomain() {
    *this = ::std::move(from);
  }

  inline DomainInfo_FaultDomain& operator=(DomainInfo_FaultDomain&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const DomainInfo_FaultDomain& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DomainInfo_FaultDomain* internal_default_instance() {
    return reinterpret_cast<const DomainInfo_FaultDomain*>(
               &_DomainInfo_FaultDomain_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    30;

  void UnsafeArenaSwap(DomainInfo_FaultDomain* other);
  void Swap(DomainInfo_FaultDomain* other);
  friend void swap(DomainInfo_FaultDomain& a, DomainInfo_FaultDomain& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DomainInfo_FaultDomain* New() const PROTOBUF_FINAL { return New(NULL); }

  DomainInfo_FaultDomain* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DomainInfo_FaultDomain& from);
  void MergeFrom(const DomainInfo_FaultDomain& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DomainInfo_FaultDomain* other);
  protected:
  explicit DomainInfo_FaultDomain(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef DomainInfo_FaultDomain_RegionInfo RegionInfo;
  typedef DomainInfo_FaultDomain_ZoneInfo ZoneInfo;

  // accessors -------------------------------------------------------

  // required .mesos.DomainInfo.FaultDomain.RegionInfo region = 1;
  bool has_region() const;
  void clear_region();
  static const int kRegionFieldNumber = 1;
  private:
  void _slow_mutable_region();
  public:
  const ::mesos::DomainInfo_FaultDomain_RegionInfo& region() const;
  ::mesos::DomainInfo_FaultDomain_RegionInfo* release_region();
  ::mesos::DomainInfo_FaultDomain_RegionInfo* mutable_region();
  void set_allocated_region(::mesos::DomainInfo_FaultDomain_RegionInfo* region);
  void unsafe_arena_set_allocated_region(
      ::mesos::DomainInfo_FaultDomain_RegionInfo* region);
  ::mesos::DomainInfo_FaultDomain_RegionInfo* unsafe_arena_release_region();

  // required .mesos.DomainInfo.FaultDomain.ZoneInfo zone = 2;
  bool has_zone() const;
  void clear_zone();
  static const int kZoneFieldNumber = 2;
  private:
  void _slow_mutable_zone();
  public:
  const ::mesos::DomainInfo_FaultDomain_ZoneInfo& zone() const;
  ::mesos::DomainInfo_FaultDomain_ZoneInfo* release_zone();
  ::mesos::DomainInfo_FaultDomain_ZoneInfo* mutable_zone();
  void set_allocated_zone(::mesos::DomainInfo_FaultDomain_ZoneInfo* zone);
  void unsafe_arena_set_allocated_zone(
      ::mesos::DomainInfo_FaultDomain_ZoneInfo* zone);
  ::mesos::DomainInfo_FaultDomain_ZoneInfo* unsafe_arena_release_zone();

  // @@protoc_insertion_point(class_scope:mesos.DomainInfo.FaultDomain)
 private:
  void set_has_region();
  void clear_has_region();
  void set_has_zone();
  void clear_has_zone();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::DomainInfo_FaultDomain_RegionInfo* region_;
  ::mesos::DomainInfo_FaultDomain_ZoneInfo* zone_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsDomainInfo_FaultDomainImpl();
};
// -------------------------------------------------------------------

class DomainInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.DomainInfo) */ {
 public:
  DomainInfo();
  virtual ~DomainInfo();

  DomainInfo(const DomainInfo& from);

  inline DomainInfo& operator=(const DomainInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DomainInfo(DomainInfo&& from) noexcept
    : DomainInfo() {
    *this = ::std::move(from);
  }

  inline DomainInfo& operator=(DomainInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const DomainInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DomainInfo* internal_default_instance() {
    return reinterpret_cast<const DomainInfo*>(
               &_DomainInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    31;

  void UnsafeArenaSwap(DomainInfo* other);
  void Swap(DomainInfo* other);
  friend void swap(DomainInfo& a, DomainInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DomainInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  DomainInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DomainInfo& from);
  void MergeFrom(const DomainInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DomainInfo* other);
  protected:
  explicit DomainInfo(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef DomainInfo_FaultDomain FaultDomain;

  // accessors -------------------------------------------------------

  // optional .mesos.DomainInfo.FaultDomain fault_domain = 1;
  bool has_fault_domain() const;
  void clear_fault_domain();
  static const int kFaultDomainFieldNumber = 1;
  private:
  void _slow_mutable_fault_domain();
  public:
  const ::mesos::DomainInfo_FaultDomain& fault_domain() const;
  ::mesos::DomainInfo_FaultDomain* release_fault_domain();
  ::mesos::DomainInfo_FaultDomain* mutable_fault_domain();
  void set_allocated_fault_domain(::mesos::DomainInfo_FaultDomain* fault_domain);
  void unsafe_arena_set_allocated_fault_domain(
      ::mesos::DomainInfo_FaultDomain* fault_domain);
  ::mesos::DomainInfo_FaultDomain* unsafe_arena_release_fault_domain();

  // @@protoc_insertion_point(class_scope:mesos.DomainInfo)
 private:
  void set_has_fault_domain();
  void clear_has_fault_domain();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::DomainInfo_FaultDomain* fault_domain_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsDomainInfoImpl();
};
// -------------------------------------------------------------------

class MasterInfo_Capability : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.MasterInfo.Capability) */ {
 public:
  MasterInfo_Capability();
  virtual ~MasterInfo_Capability();

  MasterInfo_Capability(const MasterInfo_Capability& from);

  inline MasterInfo_Capability& operator=(const MasterInfo_Capability& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MasterInfo_Capability(MasterInfo_Capability&& from) noexcept
    : MasterInfo_Capability() {
    *this = ::std::move(from);
  }

  inline MasterInfo_Capability& operator=(MasterInfo_Capability&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const MasterInfo_Capability& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MasterInfo_Capability* internal_default_instance() {
    return reinterpret_cast<const MasterInfo_Capability*>(
               &_MasterInfo_Capability_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    32;

  void UnsafeArenaSwap(MasterInfo_Capability* other);
  void Swap(MasterInfo_Capability* other);
  friend void swap(MasterInfo_Capability& a, MasterInfo_Capability& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MasterInfo_Capability* New() const PROTOBUF_FINAL { return New(NULL); }

  MasterInfo_Capability* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MasterInfo_Capability& from);
  void MergeFrom(const MasterInfo_Capability& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MasterInfo_Capability* other);
  protected:
  explicit MasterInfo_Capability(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef MasterInfo_Capability_Type Type;
  static const Type UNKNOWN =
    MasterInfo_Capability_Type_UNKNOWN;
  static const Type AGENT_UPDATE =
    MasterInfo_Capability_Type_AGENT_UPDATE;
  static inline bool Type_IsValid(int value) {
    return MasterInfo_Capability_Type_IsValid(value);
  }
  static const Type Type_MIN =
    MasterInfo_Capability_Type_Type_MIN;
  static const Type Type_MAX =
    MasterInfo_Capability_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    MasterInfo_Capability_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return MasterInfo_Capability_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return MasterInfo_Capability_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return MasterInfo_Capability_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .mesos.MasterInfo.Capability.Type type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::mesos::MasterInfo_Capability_Type type() const;
  void set_type(::mesos::MasterInfo_Capability_Type value);

  // @@protoc_insertion_point(class_scope:mesos.MasterInfo.Capability)
 private:
  void set_has_type();
  void clear_has_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  int type_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsMasterInfo_CapabilityImpl();
};
// -------------------------------------------------------------------

class MasterInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.MasterInfo) */ {
 public:
  MasterInfo();
  virtual ~MasterInfo();

  MasterInfo(const MasterInfo& from);

  inline MasterInfo& operator=(const MasterInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MasterInfo(MasterInfo&& from) noexcept
    : MasterInfo() {
    *this = ::std::move(from);
  }

  inline MasterInfo& operator=(MasterInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const MasterInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MasterInfo* internal_default_instance() {
    return reinterpret_cast<const MasterInfo*>(
               &_MasterInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    33;

  void UnsafeArenaSwap(MasterInfo* other);
  void Swap(MasterInfo* other);
  friend void swap(MasterInfo& a, MasterInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MasterInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  MasterInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MasterInfo& from);
  void MergeFrom(const MasterInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MasterInfo* other);
  protected:
  explicit MasterInfo(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef MasterInfo_Capability Capability;

  // accessors -------------------------------------------------------

  // repeated .mesos.MasterInfo.Capability capabilities = 9;
  int capabilities_size() const;
  void clear_capabilities();
  static const int kCapabilitiesFieldNumber = 9;
  const ::mesos::MasterInfo_Capability& capabilities(int index) const;
  ::mesos::MasterInfo_Capability* mutable_capabilities(int index);
  ::mesos::MasterInfo_Capability* add_capabilities();
  ::google::protobuf::RepeatedPtrField< ::mesos::MasterInfo_Capability >*
      mutable_capabilities();
  const ::google::protobuf::RepeatedPtrField< ::mesos::MasterInfo_Capability >&
      capabilities() const;

  // required string id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_id();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_id(
      ::std::string* id);

  // optional string pid = 4;
  bool has_pid() const;
  void clear_pid();
  static const int kPidFieldNumber = 4;
  const ::std::string& pid() const;
  void set_pid(const ::std::string& value);
  #if LANG_CXX11
  void set_pid(::std::string&& value);
  #endif
  void set_pid(const char* value);
  void set_pid(const char* value, size_t size);
  ::std::string* mutable_pid();
  ::std::string* release_pid();
  void set_allocated_pid(::std::string* pid);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_pid();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_pid(
      ::std::string* pid);

  // optional string hostname = 5;
  bool has_hostname() const;
  void clear_hostname();
  static const int kHostnameFieldNumber = 5;
  const ::std::string& hostname() const;
  void set_hostname(const ::std::string& value);
  #if LANG_CXX11
  void set_hostname(::std::string&& value);
  #endif
  void set_hostname(const char* value);
  void set_hostname(const char* value, size_t size);
  ::std::string* mutable_hostname();
  ::std::string* release_hostname();
  void set_allocated_hostname(::std::string* hostname);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_hostname();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_hostname(
      ::std::string* hostname);

  // optional string version = 6;
  bool has_version() const;
  void clear_version();
  static const int kVersionFieldNumber = 6;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_version();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_version(
      ::std::string* version);

  // optional .mesos.Address address = 7;
  bool has_address() const;
  void clear_address();
  static const int kAddressFieldNumber = 7;
  private:
  void _slow_mutable_address();
  public:
  const ::mesos::Address& address() const;
  ::mesos::Address* release_address();
  ::mesos::Address* mutable_address();
  void set_allocated_address(::mesos::Address* address);
  void unsafe_arena_set_allocated_address(
      ::mesos::Address* address);
  ::mesos::Address* unsafe_arena_release_address();

  // optional .mesos.DomainInfo domain = 8;
  bool has_domain() const;
  void clear_domain();
  static const int kDomainFieldNumber = 8;
  private:
  void _slow_mutable_domain();
  public:
  const ::mesos::DomainInfo& domain() const;
  ::mesos::DomainInfo* release_domain();
  ::mesos::DomainInfo* mutable_domain();
  void set_allocated_domain(::mesos::DomainInfo* domain);
  void unsafe_arena_set_allocated_domain(
      ::mesos::DomainInfo* domain);
  ::mesos::DomainInfo* unsafe_arena_release_domain();

  // required uint32 ip = 2;
  bool has_ip() const;
  void clear_ip();
  static const int kIpFieldNumber = 2;
  ::google::protobuf::uint32 ip() const;
  void set_ip(::google::protobuf::uint32 value);

  // required uint32 port = 3 [default = 5050];
  bool has_port() const;
  void clear_port();
  static const int kPortFieldNumber = 3;
  ::google::protobuf::uint32 port() const;
  void set_port(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mesos.MasterInfo)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_ip();
  void clear_has_ip();
  void set_has_port();
  void clear_has_port();
  void set_has_pid();
  void clear_has_pid();
  void set_has_hostname();
  void clear_has_hostname();
  void set_has_version();
  void clear_has_version();
  void set_has_address();
  void clear_has_address();
  void set_has_domain();
  void clear_has_domain();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::MasterInfo_Capability > capabilities_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr pid_;
  ::google::protobuf::internal::ArenaStringPtr hostname_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  ::mesos::Address* address_;
  ::mesos::DomainInfo* domain_;
  ::google::protobuf::uint32 ip_;
  ::google::protobuf::uint32 port_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsMasterInfoImpl();
};
// -------------------------------------------------------------------

class SlaveInfo_Capability : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.SlaveInfo.Capability) */ {
 public:
  SlaveInfo_Capability();
  virtual ~SlaveInfo_Capability();

  SlaveInfo_Capability(const SlaveInfo_Capability& from);

  inline SlaveInfo_Capability& operator=(const SlaveInfo_Capability& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SlaveInfo_Capability(SlaveInfo_Capability&& from) noexcept
    : SlaveInfo_Capability() {
    *this = ::std::move(from);
  }

  inline SlaveInfo_Capability& operator=(SlaveInfo_Capability&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const SlaveInfo_Capability& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SlaveInfo_Capability* internal_default_instance() {
    return reinterpret_cast<const SlaveInfo_Capability*>(
               &_SlaveInfo_Capability_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    34;

  void UnsafeArenaSwap(SlaveInfo_Capability* other);
  void Swap(SlaveInfo_Capability* other);
  friend void swap(SlaveInfo_Capability& a, SlaveInfo_Capability& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SlaveInfo_Capability* New() const PROTOBUF_FINAL { return New(NULL); }

  SlaveInfo_Capability* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SlaveInfo_Capability& from);
  void MergeFrom(const SlaveInfo_Capability& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SlaveInfo_Capability* other);
  protected:
  explicit SlaveInfo_Capability(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef SlaveInfo_Capability_Type Type;
  static const Type UNKNOWN =
    SlaveInfo_Capability_Type_UNKNOWN;
  static const Type MULTI_ROLE =
    SlaveInfo_Capability_Type_MULTI_ROLE;
  static const Type HIERARCHICAL_ROLE =
    SlaveInfo_Capability_Type_HIERARCHICAL_ROLE;
  static const Type RESERVATION_REFINEMENT =
    SlaveInfo_Capability_Type_RESERVATION_REFINEMENT;
  static const Type RESOURCE_PROVIDER =
    SlaveInfo_Capability_Type_RESOURCE_PROVIDER;
  static const Type RESIZE_VOLUME =
    SlaveInfo_Capability_Type_RESIZE_VOLUME;
  static inline bool Type_IsValid(int value) {
    return SlaveInfo_Capability_Type_IsValid(value);
  }
  static const Type Type_MIN =
    SlaveInfo_Capability_Type_Type_MIN;
  static const Type Type_MAX =
    SlaveInfo_Capability_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    SlaveInfo_Capability_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return SlaveInfo_Capability_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return SlaveInfo_Capability_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return SlaveInfo_Capability_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .mesos.SlaveInfo.Capability.Type type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::mesos::SlaveInfo_Capability_Type type() const;
  void set_type(::mesos::SlaveInfo_Capability_Type value);

  // @@protoc_insertion_point(class_scope:mesos.SlaveInfo.Capability)
 private:
  void set_has_type();
  void clear_has_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  int type_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsSlaveInfo_CapabilityImpl();
};
// -------------------------------------------------------------------

class SlaveInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.SlaveInfo) */ {
 public:
  SlaveInfo();
  virtual ~SlaveInfo();

  SlaveInfo(const SlaveInfo& from);

  inline SlaveInfo& operator=(const SlaveInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SlaveInfo(SlaveInfo&& from) noexcept
    : SlaveInfo() {
    *this = ::std::move(from);
  }

  inline SlaveInfo& operator=(SlaveInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const SlaveInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SlaveInfo* internal_default_instance() {
    return reinterpret_cast<const SlaveInfo*>(
               &_SlaveInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    35;

  void UnsafeArenaSwap(SlaveInfo* other);
  void Swap(SlaveInfo* other);
  friend void swap(SlaveInfo& a, SlaveInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SlaveInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  SlaveInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SlaveInfo& from);
  void MergeFrom(const SlaveInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SlaveInfo* other);
  protected:
  explicit SlaveInfo(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef SlaveInfo_Capability Capability;

  // accessors -------------------------------------------------------

  // repeated .mesos.Resource resources = 3;
  int resources_size() const;
  void clear_resources();
  static const int kResourcesFieldNumber = 3;
  const ::mesos::Resource& resources(int index) const;
  ::mesos::Resource* mutable_resources(int index);
  ::mesos::Resource* add_resources();
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
      mutable_resources();
  const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
      resources() const;

  // repeated .mesos.Attribute attributes = 5;
  int attributes_size() const;
  void clear_attributes();
  static const int kAttributesFieldNumber = 5;
  const ::mesos::Attribute& attributes(int index) const;
  ::mesos::Attribute* mutable_attributes(int index);
  ::mesos::Attribute* add_attributes();
  ::google::protobuf::RepeatedPtrField< ::mesos::Attribute >*
      mutable_attributes();
  const ::google::protobuf::RepeatedPtrField< ::mesos::Attribute >&
      attributes() const;

  // required string hostname = 1;
  bool has_hostname() const;
  void clear_hostname();
  static const int kHostnameFieldNumber = 1;
  const ::std::string& hostname() const;
  void set_hostname(const ::std::string& value);
  #if LANG_CXX11
  void set_hostname(::std::string&& value);
  #endif
  void set_hostname(const char* value);
  void set_hostname(const char* value, size_t size);
  ::std::string* mutable_hostname();
  ::std::string* release_hostname();
  void set_allocated_hostname(::std::string* hostname);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_hostname();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_hostname(
      ::std::string* hostname);

  // optional .mesos.SlaveID id = 6;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 6;
  private:
  void _slow_mutable_id();
  public:
  const ::mesos::SlaveID& id() const;
  ::mesos::SlaveID* release_id();
  ::mesos::SlaveID* mutable_id();
  void set_allocated_id(::mesos::SlaveID* id);
  void unsafe_arena_set_allocated_id(
      ::mesos::SlaveID* id);
  ::mesos::SlaveID* unsafe_arena_release_id();

  // optional .mesos.DomainInfo domain = 10;
  bool has_domain() const;
  void clear_domain();
  static const int kDomainFieldNumber = 10;
  private:
  void _slow_mutable_domain();
  public:
  const ::mesos::DomainInfo& domain() const;
  ::mesos::DomainInfo* release_domain();
  ::mesos::DomainInfo* mutable_domain();
  void set_allocated_domain(::mesos::DomainInfo* domain);
  void unsafe_arena_set_allocated_domain(
      ::mesos::DomainInfo* domain);
  ::mesos::DomainInfo* unsafe_arena_release_domain();

  // optional bool checkpoint = 7 [default = false];
  bool has_checkpoint() const;
  void clear_checkpoint();
  static const int kCheckpointFieldNumber = 7;
  bool checkpoint() const;
  void set_checkpoint(bool value);

  // optional int32 port = 8 [default = 5051];
  bool has_port() const;
  void clear_port();
  static const int kPortFieldNumber = 8;
  ::google::protobuf::int32 port() const;
  void set_port(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:mesos.SlaveInfo)
 private:
  void set_has_hostname();
  void clear_has_hostname();
  void set_has_port();
  void clear_has_port();
  void set_has_id();
  void clear_has_id();
  void set_has_domain();
  void clear_has_domain();
  void set_has_checkpoint();
  void clear_has_checkpoint();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource > resources_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Attribute > attributes_;
  ::google::protobuf::internal::ArenaStringPtr hostname_;
  ::mesos::SlaveID* id_;
  ::mesos::DomainInfo* domain_;
  bool checkpoint_;
  ::google::protobuf::int32 port_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsSlaveInfoImpl();
};
// -------------------------------------------------------------------

class CSIPluginContainerInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.CSIPluginContainerInfo) */ {
 public:
  CSIPluginContainerInfo();
  virtual ~CSIPluginContainerInfo();

  CSIPluginContainerInfo(const CSIPluginContainerInfo& from);

  inline CSIPluginContainerInfo& operator=(const CSIPluginContainerInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CSIPluginContainerInfo(CSIPluginContainerInfo&& from) noexcept
    : CSIPluginContainerInfo() {
    *this = ::std::move(from);
  }

  inline CSIPluginContainerInfo& operator=(CSIPluginContainerInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const CSIPluginContainerInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CSIPluginContainerInfo* internal_default_instance() {
    return reinterpret_cast<const CSIPluginContainerInfo*>(
               &_CSIPluginContainerInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    36;

  void UnsafeArenaSwap(CSIPluginContainerInfo* other);
  void Swap(CSIPluginContainerInfo* other);
  friend void swap(CSIPluginContainerInfo& a, CSIPluginContainerInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CSIPluginContainerInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  CSIPluginContainerInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CSIPluginContainerInfo& from);
  void MergeFrom(const CSIPluginContainerInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CSIPluginContainerInfo* other);
  protected:
  explicit CSIPluginContainerInfo(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef CSIPluginContainerInfo_Service Service;
  static const Service UNKNOWN =
    CSIPluginContainerInfo_Service_UNKNOWN;
  static const Service CONTROLLER_SERVICE =
    CSIPluginContainerInfo_Service_CONTROLLER_SERVICE;
  static const Service NODE_SERVICE =
    CSIPluginContainerInfo_Service_NODE_SERVICE;
  static inline bool Service_IsValid(int value) {
    return CSIPluginContainerInfo_Service_IsValid(value);
  }
  static const Service Service_MIN =
    CSIPluginContainerInfo_Service_Service_MIN;
  static const Service Service_MAX =
    CSIPluginContainerInfo_Service_Service_MAX;
  static const int Service_ARRAYSIZE =
    CSIPluginContainerInfo_Service_Service_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Service_descriptor() {
    return CSIPluginContainerInfo_Service_descriptor();
  }
  static inline const ::std::string& Service_Name(Service value) {
    return CSIPluginContainerInfo_Service_Name(value);
  }
  static inline bool Service_Parse(const ::std::string& name,
      Service* value) {
    return CSIPluginContainerInfo_Service_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .mesos.CSIPluginContainerInfo.Service services = 1;
  int services_size() const;
  void clear_services();
  static const int kServicesFieldNumber = 1;
  ::mesos::CSIPluginContainerInfo_Service services(int index) const;
  void set_services(int index, ::mesos::CSIPluginContainerInfo_Service value);
  void add_services(::mesos::CSIPluginContainerInfo_Service value);
  const ::google::protobuf::RepeatedField<int>& services() const;
  ::google::protobuf::RepeatedField<int>* mutable_services();

  // repeated .mesos.Resource resources = 3;
  int resources_size() const;
  void clear_resources();
  static const int kResourcesFieldNumber = 3;
  const ::mesos::Resource& resources(int index) const;
  ::mesos::Resource* mutable_resources(int index);
  ::mesos::Resource* add_resources();
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
      mutable_resources();
  const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
      resources() const;

  // optional .mesos.CommandInfo command = 2;
  bool has_command() const;
  void clear_command();
  static const int kCommandFieldNumber = 2;
  private:
  void _slow_mutable_command();
  public:
  const ::mesos::CommandInfo& command() const;
  ::mesos::CommandInfo* release_command();
  ::mesos::CommandInfo* mutable_command();
  void set_allocated_command(::mesos::CommandInfo* command);
  void unsafe_arena_set_allocated_command(
      ::mesos::CommandInfo* command);
  ::mesos::CommandInfo* unsafe_arena_release_command();

  // optional .mesos.ContainerInfo container = 4;
  bool has_container() const;
  void clear_container();
  static const int kContainerFieldNumber = 4;
  private:
  void _slow_mutable_container();
  public:
  const ::mesos::ContainerInfo& container() const;
  ::mesos::ContainerInfo* release_container();
  ::mesos::ContainerInfo* mutable_container();
  void set_allocated_container(::mesos::ContainerInfo* container);
  void unsafe_arena_set_allocated_container(
      ::mesos::ContainerInfo* container);
  ::mesos::ContainerInfo* unsafe_arena_release_container();

  // @@protoc_insertion_point(class_scope:mesos.CSIPluginContainerInfo)
 private:
  void set_has_command();
  void clear_has_command();
  void set_has_container();
  void clear_has_container();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField<int> services_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource > resources_;
  ::mesos::CommandInfo* command_;
  ::mesos::ContainerInfo* container_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsCSIPluginContainerInfoImpl();
};
// -------------------------------------------------------------------

class CSIPluginInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.CSIPluginInfo) */ {
 public:
  CSIPluginInfo();
  virtual ~CSIPluginInfo();

  CSIPluginInfo(const CSIPluginInfo& from);

  inline CSIPluginInfo& operator=(const CSIPluginInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CSIPluginInfo(CSIPluginInfo&& from) noexcept
    : CSIPluginInfo() {
    *this = ::std::move(from);
  }

  inline CSIPluginInfo& operator=(CSIPluginInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const CSIPluginInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CSIPluginInfo* internal_default_instance() {
    return reinterpret_cast<const CSIPluginInfo*>(
               &_CSIPluginInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    37;

  void UnsafeArenaSwap(CSIPluginInfo* other);
  void Swap(CSIPluginInfo* other);
  friend void swap(CSIPluginInfo& a, CSIPluginInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CSIPluginInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  CSIPluginInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CSIPluginInfo& from);
  void MergeFrom(const CSIPluginInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CSIPluginInfo* other);
  protected:
  explicit CSIPluginInfo(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.CSIPluginContainerInfo containers = 3;
  int containers_size() const;
  void clear_containers();
  static const int kContainersFieldNumber = 3;
  const ::mesos::CSIPluginContainerInfo& containers(int index) const;
  ::mesos::CSIPluginContainerInfo* mutable_containers(int index);
  ::mesos::CSIPluginContainerInfo* add_containers();
  ::google::protobuf::RepeatedPtrField< ::mesos::CSIPluginContainerInfo >*
      mutable_containers();
  const ::google::protobuf::RepeatedPtrField< ::mesos::CSIPluginContainerInfo >&
      containers() const;

  // required string type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_type();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_type(
      ::std::string* type);

  // required string name = 2;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_name();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      ::std::string* name);

  // @@protoc_insertion_point(class_scope:mesos.CSIPluginInfo)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_name();
  void clear_has_name();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::CSIPluginContainerInfo > containers_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsCSIPluginInfoImpl();
};
// -------------------------------------------------------------------

class ResourceProviderInfo_Storage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.ResourceProviderInfo.Storage) */ {
 public:
  ResourceProviderInfo_Storage();
  virtual ~ResourceProviderInfo_Storage();

  ResourceProviderInfo_Storage(const ResourceProviderInfo_Storage& from);

  inline ResourceProviderInfo_Storage& operator=(const ResourceProviderInfo_Storage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResourceProviderInfo_Storage(ResourceProviderInfo_Storage&& from) noexcept
    : ResourceProviderInfo_Storage() {
    *this = ::std::move(from);
  }

  inline ResourceProviderInfo_Storage& operator=(ResourceProviderInfo_Storage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResourceProviderInfo_Storage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResourceProviderInfo_Storage* internal_default_instance() {
    return reinterpret_cast<const ResourceProviderInfo_Storage*>(
               &_ResourceProviderInfo_Storage_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    38;

  void UnsafeArenaSwap(ResourceProviderInfo_Storage* other);
  void Swap(ResourceProviderInfo_Storage* other);
  friend void swap(ResourceProviderInfo_Storage& a, ResourceProviderInfo_Storage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResourceProviderInfo_Storage* New() const PROTOBUF_FINAL { return New(NULL); }

  ResourceProviderInfo_Storage* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ResourceProviderInfo_Storage& from);
  void MergeFrom(const ResourceProviderInfo_Storage& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ResourceProviderInfo_Storage* other);
  protected:
  explicit ResourceProviderInfo_Storage(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.CSIPluginInfo plugin = 1;
  bool has_plugin() const;
  void clear_plugin();
  static const int kPluginFieldNumber = 1;
  private:
  void _slow_mutable_plugin();
  public:
  const ::mesos::CSIPluginInfo& plugin() const;
  ::mesos::CSIPluginInfo* release_plugin();
  ::mesos::CSIPluginInfo* mutable_plugin();
  void set_allocated_plugin(::mesos::CSIPluginInfo* plugin);
  void unsafe_arena_set_allocated_plugin(
      ::mesos::CSIPluginInfo* plugin);
  ::mesos::CSIPluginInfo* unsafe_arena_release_plugin();

  // @@protoc_insertion_point(class_scope:mesos.ResourceProviderInfo.Storage)
 private:
  void set_has_plugin();
  void clear_has_plugin();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::CSIPluginInfo* plugin_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsResourceProviderInfo_StorageImpl();
};
// -------------------------------------------------------------------

class ResourceProviderInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.ResourceProviderInfo) */ {
 public:
  ResourceProviderInfo();
  virtual ~ResourceProviderInfo();

  ResourceProviderInfo(const ResourceProviderInfo& from);

  inline ResourceProviderInfo& operator=(const ResourceProviderInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResourceProviderInfo(ResourceProviderInfo&& from) noexcept
    : ResourceProviderInfo() {
    *this = ::std::move(from);
  }

  inline ResourceProviderInfo& operator=(ResourceProviderInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResourceProviderInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResourceProviderInfo* internal_default_instance() {
    return reinterpret_cast<const ResourceProviderInfo*>(
               &_ResourceProviderInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    39;

  void UnsafeArenaSwap(ResourceProviderInfo* other);
  void Swap(ResourceProviderInfo* other);
  friend void swap(ResourceProviderInfo& a, ResourceProviderInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResourceProviderInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  ResourceProviderInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ResourceProviderInfo& from);
  void MergeFrom(const ResourceProviderInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ResourceProviderInfo* other);
  protected:
  explicit ResourceProviderInfo(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef ResourceProviderInfo_Storage Storage;

  // accessors -------------------------------------------------------

  // repeated .mesos.Attribute attributes = 2;
  int attributes_size() const;
  void clear_attributes();
  static const int kAttributesFieldNumber = 2;
  const ::mesos::Attribute& attributes(int index) const;
  ::mesos::Attribute* mutable_attributes(int index);
  ::mesos::Attribute* add_attributes();
  ::google::protobuf::RepeatedPtrField< ::mesos::Attribute >*
      mutable_attributes();
  const ::google::protobuf::RepeatedPtrField< ::mesos::Attribute >&
      attributes() const;

  // repeated .mesos.Resource.ReservationInfo default_reservations = 5;
  int default_reservations_size() const;
  void clear_default_reservations();
  static const int kDefaultReservationsFieldNumber = 5;
  const ::mesos::Resource_ReservationInfo& default_reservations(int index) const;
  ::mesos::Resource_ReservationInfo* mutable_default_reservations(int index);
  ::mesos::Resource_ReservationInfo* add_default_reservations();
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource_ReservationInfo >*
      mutable_default_reservations();
  const ::google::protobuf::RepeatedPtrField< ::mesos::Resource_ReservationInfo >&
      default_reservations() const;

  // required string type = 3;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 3;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_type();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_type(
      ::std::string* type);

  // required string name = 4;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 4;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_name();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      ::std::string* name);

  // optional .mesos.ResourceProviderID id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  private:
  void _slow_mutable_id();
  public:
  const ::mesos::ResourceProviderID& id() const;
  ::mesos::ResourceProviderID* release_id();
  ::mesos::ResourceProviderID* mutable_id();
  void set_allocated_id(::mesos::ResourceProviderID* id);
  void unsafe_arena_set_allocated_id(
      ::mesos::ResourceProviderID* id);
  ::mesos::ResourceProviderID* unsafe_arena_release_id();

  // optional .mesos.ResourceProviderInfo.Storage storage = 6;
  bool has_storage() const;
  void clear_storage();
  static const int kStorageFieldNumber = 6;
  private:
  void _slow_mutable_storage();
  public:
  const ::mesos::ResourceProviderInfo_Storage& storage() const;
  ::mesos::ResourceProviderInfo_Storage* release_storage();
  ::mesos::ResourceProviderInfo_Storage* mutable_storage();
  void set_allocated_storage(::mesos::ResourceProviderInfo_Storage* storage);
  void unsafe_arena_set_allocated_storage(
      ::mesos::ResourceProviderInfo_Storage* storage);
  ::mesos::ResourceProviderInfo_Storage* unsafe_arena_release_storage();

  // @@protoc_insertion_point(class_scope:mesos.ResourceProviderInfo)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_type();
  void clear_has_type();
  void set_has_name();
  void clear_has_name();
  void set_has_storage();
  void clear_has_storage();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Attribute > attributes_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource_ReservationInfo > default_reservations_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::mesos::ResourceProviderID* id_;
  ::mesos::ResourceProviderInfo_Storage* storage_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsResourceProviderInfoImpl();
};
// -------------------------------------------------------------------

class Value_Scalar : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.Value.Scalar) */ {
 public:
  Value_Scalar();
  virtual ~Value_Scalar();

  Value_Scalar(const Value_Scalar& from);

  inline Value_Scalar& operator=(const Value_Scalar& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Value_Scalar(Value_Scalar&& from) noexcept
    : Value_Scalar() {
    *this = ::std::move(from);
  }

  inline Value_Scalar& operator=(Value_Scalar&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Value_Scalar& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Value_Scalar* internal_default_instance() {
    return reinterpret_cast<const Value_Scalar*>(
               &_Value_Scalar_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    40;

  void UnsafeArenaSwap(Value_Scalar* other);
  void Swap(Value_Scalar* other);
  friend void swap(Value_Scalar& a, Value_Scalar& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Value_Scalar* New() const PROTOBUF_FINAL { return New(NULL); }

  Value_Scalar* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Value_Scalar& from);
  void MergeFrom(const Value_Scalar& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Value_Scalar* other);
  protected:
  explicit Value_Scalar(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double value = 1;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  double value() const;
  void set_value(double value);

  // @@protoc_insertion_point(class_scope:mesos.Value.Scalar)
 private:
  void set_has_value();
  void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  double value_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsValue_ScalarImpl();
};
// -------------------------------------------------------------------

class Value_Range : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.Value.Range) */ {
 public:
  Value_Range();
  virtual ~Value_Range();

  Value_Range(const Value_Range& from);

  inline Value_Range& operator=(const Value_Range& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Value_Range(Value_Range&& from) noexcept
    : Value_Range() {
    *this = ::std::move(from);
  }

  inline Value_Range& operator=(Value_Range&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Value_Range& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Value_Range* internal_default_instance() {
    return reinterpret_cast<const Value_Range*>(
               &_Value_Range_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    41;

  void UnsafeArenaSwap(Value_Range* other);
  void Swap(Value_Range* other);
  friend void swap(Value_Range& a, Value_Range& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Value_Range* New() const PROTOBUF_FINAL { return New(NULL); }

  Value_Range* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Value_Range& from);
  void MergeFrom(const Value_Range& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Value_Range* other);
  protected:
  explicit Value_Range(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 begin = 1;
  bool has_begin() const;
  void clear_begin();
  static const int kBeginFieldNumber = 1;
  ::google::protobuf::uint64 begin() const;
  void set_begin(::google::protobuf::uint64 value);

  // required uint64 end = 2;
  bool has_end() const;
  void clear_end();
  static const int kEndFieldNumber = 2;
  ::google::protobuf::uint64 end() const;
  void set_end(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:mesos.Value.Range)
 private:
  void set_has_begin();
  void clear_has_begin();
  void set_has_end();
  void clear_has_end();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint64 begin_;
  ::google::protobuf::uint64 end_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsValue_RangeImpl();
};
// -------------------------------------------------------------------

class Value_Ranges : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.Value.Ranges) */ {
 public:
  Value_Ranges();
  virtual ~Value_Ranges();

  Value_Ranges(const Value_Ranges& from);

  inline Value_Ranges& operator=(const Value_Ranges& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Value_Ranges(Value_Ranges&& from) noexcept
    : Value_Ranges() {
    *this = ::std::move(from);
  }

  inline Value_Ranges& operator=(Value_Ranges&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Value_Ranges& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Value_Ranges* internal_default_instance() {
    return reinterpret_cast<const Value_Ranges*>(
               &_Value_Ranges_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    42;

  void UnsafeArenaSwap(Value_Ranges* other);
  void Swap(Value_Ranges* other);
  friend void swap(Value_Ranges& a, Value_Ranges& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Value_Ranges* New() const PROTOBUF_FINAL { return New(NULL); }

  Value_Ranges* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Value_Ranges& from);
  void MergeFrom(const Value_Ranges& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Value_Ranges* other);
  protected:
  explicit Value_Ranges(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.Value.Range range = 1;
  int range_size() const;
  void clear_range();
  static const int kRangeFieldNumber = 1;
  const ::mesos::Value_Range& range(int index) const;
  ::mesos::Value_Range* mutable_range(int index);
  ::mesos::Value_Range* add_range();
  ::google::protobuf::RepeatedPtrField< ::mesos::Value_Range >*
      mutable_range();
  const ::google::protobuf::RepeatedPtrField< ::mesos::Value_Range >&
      range() const;

  // @@protoc_insertion_point(class_scope:mesos.Value.Ranges)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Value_Range > range_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsValue_RangesImpl();
};
// -------------------------------------------------------------------

class Value_Set : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.Value.Set) */ {
 public:
  Value_Set();
  virtual ~Value_Set();

  Value_Set(const Value_Set& from);

  inline Value_Set& operator=(const Value_Set& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Value_Set(Value_Set&& from) noexcept
    : Value_Set() {
    *this = ::std::move(from);
  }

  inline Value_Set& operator=(Value_Set&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Value_Set& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Value_Set* internal_default_instance() {
    return reinterpret_cast<const Value_Set*>(
               &_Value_Set_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    43;

  void UnsafeArenaSwap(Value_Set* other);
  void Swap(Value_Set* other);
  friend void swap(Value_Set& a, Value_Set& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Value_Set* New() const PROTOBUF_FINAL { return New(NULL); }

  Value_Set* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Value_Set& from);
  void MergeFrom(const Value_Set& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Value_Set* other);
  protected:
  explicit Value_Set(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string item = 1;
  int item_size() const;
  void clear_item();
  static const int kItemFieldNumber = 1;
  const ::std::string& item(int index) const;
  ::std::string* mutable_item(int index);
  void set_item(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_item(int index, ::std::string&& value);
  #endif
  void set_item(int index, const char* value);
  void set_item(int index, const char* value, size_t size);
  ::std::string* add_item();
  void add_item(const ::std::string& value);
  #if LANG_CXX11
  void add_item(::std::string&& value);
  #endif
  void add_item(const char* value);
  void add_item(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& item() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_item();

  // @@protoc_insertion_point(class_scope:mesos.Value.Set)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> item_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsValue_SetImpl();
};
// -------------------------------------------------------------------

class Value_Text : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.Value.Text) */ {
 public:
  Value_Text();
  virtual ~Value_Text();

  Value_Text(const Value_Text& from);

  inline Value_Text& operator=(const Value_Text& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Value_Text(Value_Text&& from) noexcept
    : Value_Text() {
    *this = ::std::move(from);
  }

  inline Value_Text& operator=(Value_Text&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Value_Text& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Value_Text* internal_default_instance() {
    return reinterpret_cast<const Value_Text*>(
               &_Value_Text_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    44;

  void UnsafeArenaSwap(Value_Text* other);
  void Swap(Value_Text* other);
  friend void swap(Value_Text& a, Value_Text& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Value_Text* New() const PROTOBUF_FINAL { return New(NULL); }

  Value_Text* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Value_Text& from);
  void MergeFrom(const Value_Text& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Value_Text* other);
  protected:
  explicit Value_Text(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string value = 1;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_value();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_value(
      ::std::string* value);

  // @@protoc_insertion_point(class_scope:mesos.Value.Text)
 private:
  void set_has_value();
  void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsValue_TextImpl();
};
// -------------------------------------------------------------------

class Value : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.Value) */ {
 public:
  Value();
  virtual ~Value();

  Value(const Value& from);

  inline Value& operator=(const Value& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Value(Value&& from) noexcept
    : Value() {
    *this = ::std::move(from);
  }

  inline Value& operator=(Value&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Value& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Value* internal_default_instance() {
    return reinterpret_cast<const Value*>(
               &_Value_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    45;

  void UnsafeArenaSwap(Value* other);
  void Swap(Value* other);
  friend void swap(Value& a, Value& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Value* New() const PROTOBUF_FINAL { return New(NULL); }

  Value* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Value& from);
  void MergeFrom(const Value& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Value* other);
  protected:
  explicit Value(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Value_Scalar Scalar;
  typedef Value_Range Range;
  typedef Value_Ranges Ranges;
  typedef Value_Set Set;
  typedef Value_Text Text;

  typedef Value_Type Type;
  static const Type SCALAR =
    Value_Type_SCALAR;
  static const Type RANGES =
    Value_Type_RANGES;
  static const Type SET =
    Value_Type_SET;
  static const Type TEXT =
    Value_Type_TEXT;
  static inline bool Type_IsValid(int value) {
    return Value_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Value_Type_Type_MIN;
  static const Type Type_MAX =
    Value_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Value_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Value_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Value_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Value_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .mesos.Value.Scalar scalar = 2;
  bool has_scalar() const;
  void clear_scalar();
  static const int kScalarFieldNumber = 2;
  private:
  void _slow_mutable_scalar();
  public:
  const ::mesos::Value_Scalar& scalar() const;
  ::mesos::Value_Scalar* release_scalar();
  ::mesos::Value_Scalar* mutable_scalar();
  void set_allocated_scalar(::mesos::Value_Scalar* scalar);
  void unsafe_arena_set_allocated_scalar(
      ::mesos::Value_Scalar* scalar);
  ::mesos::Value_Scalar* unsafe_arena_release_scalar();

  // optional .mesos.Value.Ranges ranges = 3;
  bool has_ranges() const;
  void clear_ranges();
  static const int kRangesFieldNumber = 3;
  private:
  void _slow_mutable_ranges();
  public:
  const ::mesos::Value_Ranges& ranges() const;
  ::mesos::Value_Ranges* release_ranges();
  ::mesos::Value_Ranges* mutable_ranges();
  void set_allocated_ranges(::mesos::Value_Ranges* ranges);
  void unsafe_arena_set_allocated_ranges(
      ::mesos::Value_Ranges* ranges);
  ::mesos::Value_Ranges* unsafe_arena_release_ranges();

  // optional .mesos.Value.Set set = 4;
  bool has_set() const;
  void clear_set();
  static const int kSetFieldNumber = 4;
  private:
  void _slow_mutable_set();
  public:
  const ::mesos::Value_Set& set() const;
  ::mesos::Value_Set* release_set();
  ::mesos::Value_Set* mutable_set();
  void set_allocated_set(::mesos::Value_Set* set);
  void unsafe_arena_set_allocated_set(
      ::mesos::Value_Set* set);
  ::mesos::Value_Set* unsafe_arena_release_set();

  // optional .mesos.Value.Text text = 5;
  bool has_text() const;
  void clear_text();
  static const int kTextFieldNumber = 5;
  private:
  void _slow_mutable_text();
  public:
  const ::mesos::Value_Text& text() const;
  ::mesos::Value_Text* release_text();
  ::mesos::Value_Text* mutable_text();
  void set_allocated_text(::mesos::Value_Text* text);
  void unsafe_arena_set_allocated_text(
      ::mesos::Value_Text* text);
  ::mesos::Value_Text* unsafe_arena_release_text();

  // required .mesos.Value.Type type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::mesos::Value_Type type() const;
  void set_type(::mesos::Value_Type value);

  // @@protoc_insertion_point(class_scope:mesos.Value)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_scalar();
  void clear_has_scalar();
  void set_has_ranges();
  void clear_has_ranges();
  void set_has_set();
  void clear_has_set();
  void set_has_text();
  void clear_has_text();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::Value_Scalar* scalar_;
  ::mesos::Value_Ranges* ranges_;
  ::mesos::Value_Set* set_;
  ::mesos::Value_Text* text_;
  int type_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsValueImpl();
};
// -------------------------------------------------------------------

class Attribute : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.Attribute) */ {
 public:
  Attribute();
  virtual ~Attribute();

  Attribute(const Attribute& from);

  inline Attribute& operator=(const Attribute& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Attribute(Attribute&& from) noexcept
    : Attribute() {
    *this = ::std::move(from);
  }

  inline Attribute& operator=(Attribute&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Attribute& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Attribute* internal_default_instance() {
    return reinterpret_cast<const Attribute*>(
               &_Attribute_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    46;

  void UnsafeArenaSwap(Attribute* other);
  void Swap(Attribute* other);
  friend void swap(Attribute& a, Attribute& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Attribute* New() const PROTOBUF_FINAL { return New(NULL); }

  Attribute* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Attribute& from);
  void MergeFrom(const Attribute& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Attribute* other);
  protected:
  explicit Attribute(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_name();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      ::std::string* name);

  // optional .mesos.Value.Scalar scalar = 3;
  bool has_scalar() const;
  void clear_scalar();
  static const int kScalarFieldNumber = 3;
  private:
  void _slow_mutable_scalar();
  public:
  const ::mesos::Value_Scalar& scalar() const;
  ::mesos::Value_Scalar* release_scalar();
  ::mesos::Value_Scalar* mutable_scalar();
  void set_allocated_scalar(::mesos::Value_Scalar* scalar);
  void unsafe_arena_set_allocated_scalar(
      ::mesos::Value_Scalar* scalar);
  ::mesos::Value_Scalar* unsafe_arena_release_scalar();

  // optional .mesos.Value.Ranges ranges = 4;
  bool has_ranges() const;
  void clear_ranges();
  static const int kRangesFieldNumber = 4;
  private:
  void _slow_mutable_ranges();
  public:
  const ::mesos::Value_Ranges& ranges() const;
  ::mesos::Value_Ranges* release_ranges();
  ::mesos::Value_Ranges* mutable_ranges();
  void set_allocated_ranges(::mesos::Value_Ranges* ranges);
  void unsafe_arena_set_allocated_ranges(
      ::mesos::Value_Ranges* ranges);
  ::mesos::Value_Ranges* unsafe_arena_release_ranges();

  // optional .mesos.Value.Text text = 5;
  bool has_text() const;
  void clear_text();
  static const int kTextFieldNumber = 5;
  private:
  void _slow_mutable_text();
  public:
  const ::mesos::Value_Text& text() const;
  ::mesos::Value_Text* release_text();
  ::mesos::Value_Text* mutable_text();
  void set_allocated_text(::mesos::Value_Text* text);
  void unsafe_arena_set_allocated_text(
      ::mesos::Value_Text* text);
  ::mesos::Value_Text* unsafe_arena_release_text();

  // optional .mesos.Value.Set set = 6;
  bool has_set() const;
  void clear_set();
  static const int kSetFieldNumber = 6;
  private:
  void _slow_mutable_set();
  public:
  const ::mesos::Value_Set& set() const;
  ::mesos::Value_Set* release_set();
  ::mesos::Value_Set* mutable_set();
  void set_allocated_set(::mesos::Value_Set* set);
  void unsafe_arena_set_allocated_set(
      ::mesos::Value_Set* set);
  ::mesos::Value_Set* unsafe_arena_release_set();

  // required .mesos.Value.Type type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::mesos::Value_Type type() const;
  void set_type(::mesos::Value_Type value);

  // @@protoc_insertion_point(class_scope:mesos.Attribute)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_type();
  void clear_has_type();
  void set_has_scalar();
  void clear_has_scalar();
  void set_has_ranges();
  void clear_has_ranges();
  void set_has_set();
  void clear_has_set();
  void set_has_text();
  void clear_has_text();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::mesos::Value_Scalar* scalar_;
  ::mesos::Value_Ranges* ranges_;
  ::mesos::Value_Text* text_;
  ::mesos::Value_Set* set_;
  int type_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsAttributeImpl();
};
// -------------------------------------------------------------------

class Resource_AllocationInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.Resource.AllocationInfo) */ {
 public:
  Resource_AllocationInfo();
  virtual ~Resource_AllocationInfo();

  Resource_AllocationInfo(const Resource_AllocationInfo& from);

  inline Resource_AllocationInfo& operator=(const Resource_AllocationInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Resource_AllocationInfo(Resource_AllocationInfo&& from) noexcept
    : Resource_AllocationInfo() {
    *this = ::std::move(from);
  }

  inline Resource_AllocationInfo& operator=(Resource_AllocationInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Resource_AllocationInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Resource_AllocationInfo* internal_default_instance() {
    return reinterpret_cast<const Resource_AllocationInfo*>(
               &_Resource_AllocationInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    47;

  void UnsafeArenaSwap(Resource_AllocationInfo* other);
  void Swap(Resource_AllocationInfo* other);
  friend void swap(Resource_AllocationInfo& a, Resource_AllocationInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Resource_AllocationInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  Resource_AllocationInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Resource_AllocationInfo& from);
  void MergeFrom(const Resource_AllocationInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Resource_AllocationInfo* other);
  protected:
  explicit Resource_AllocationInfo(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string role = 1;
  bool has_role() const;
  void clear_role();
  static const int kRoleFieldNumber = 1;
  const ::std::string& role() const;
  void set_role(const ::std::string& value);
  #if LANG_CXX11
  void set_role(::std::string&& value);
  #endif
  void set_role(const char* value);
  void set_role(const char* value, size_t size);
  ::std::string* mutable_role();
  ::std::string* release_role();
  void set_allocated_role(::std::string* role);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_role();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_role(
      ::std::string* role);

  // @@protoc_insertion_point(class_scope:mesos.Resource.AllocationInfo)
 private:
  void set_has_role();
  void clear_has_role();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr role_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsResource_AllocationInfoImpl();
};
// -------------------------------------------------------------------

class Resource_ReservationInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.Resource.ReservationInfo) */ {
 public:
  Resource_ReservationInfo();
  virtual ~Resource_ReservationInfo();

  Resource_ReservationInfo(const Resource_ReservationInfo& from);

  inline Resource_ReservationInfo& operator=(const Resource_ReservationInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Resource_ReservationInfo(Resource_ReservationInfo&& from) noexcept
    : Resource_ReservationInfo() {
    *this = ::std::move(from);
  }

  inline Resource_ReservationInfo& operator=(Resource_ReservationInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Resource_ReservationInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Resource_ReservationInfo* internal_default_instance() {
    return reinterpret_cast<const Resource_ReservationInfo*>(
               &_Resource_ReservationInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    48;

  void UnsafeArenaSwap(Resource_ReservationInfo* other);
  void Swap(Resource_ReservationInfo* other);
  friend void swap(Resource_ReservationInfo& a, Resource_ReservationInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Resource_ReservationInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  Resource_ReservationInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Resource_ReservationInfo& from);
  void MergeFrom(const Resource_ReservationInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Resource_ReservationInfo* other);
  protected:
  explicit Resource_ReservationInfo(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Resource_ReservationInfo_Type Type;
  static const Type UNKNOWN =
    Resource_ReservationInfo_Type_UNKNOWN;
  static const Type STATIC =
    Resource_ReservationInfo_Type_STATIC;
  static const Type DYNAMIC =
    Resource_ReservationInfo_Type_DYNAMIC;
  static inline bool Type_IsValid(int value) {
    return Resource_ReservationInfo_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Resource_ReservationInfo_Type_Type_MIN;
  static const Type Type_MAX =
    Resource_ReservationInfo_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Resource_ReservationInfo_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Resource_ReservationInfo_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Resource_ReservationInfo_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Resource_ReservationInfo_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string principal = 1;
  bool has_principal() const;
  void clear_principal();
  static const int kPrincipalFieldNumber = 1;
  const ::std::string& principal() const;
  void set_principal(const ::std::string& value);
  #if LANG_CXX11
  void set_principal(::std::string&& value);
  #endif
  void set_principal(const char* value);
  void set_principal(const char* value, size_t size);
  ::std::string* mutable_principal();
  ::std::string* release_principal();
  void set_allocated_principal(::std::string* principal);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_principal();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_principal(
      ::std::string* principal);

  // optional string role = 3;
  bool has_role() const;
  void clear_role();
  static const int kRoleFieldNumber = 3;
  const ::std::string& role() const;
  void set_role(const ::std::string& value);
  #if LANG_CXX11
  void set_role(::std::string&& value);
  #endif
  void set_role(const char* value);
  void set_role(const char* value, size_t size);
  ::std::string* mutable_role();
  ::std::string* release_role();
  void set_allocated_role(::std::string* role);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_role();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_role(
      ::std::string* role);

  // optional .mesos.Labels labels = 2;
  bool has_labels() const;
  void clear_labels();
  static const int kLabelsFieldNumber = 2;
  private:
  void _slow_mutable_labels();
  public:
  const ::mesos::Labels& labels() const;
  ::mesos::Labels* release_labels();
  ::mesos::Labels* mutable_labels();
  void set_allocated_labels(::mesos::Labels* labels);
  void unsafe_arena_set_allocated_labels(
      ::mesos::Labels* labels);
  ::mesos::Labels* unsafe_arena_release_labels();

  // optional .mesos.Resource.ReservationInfo.Type type = 4;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 4;
  ::mesos::Resource_ReservationInfo_Type type() const;
  void set_type(::mesos::Resource_ReservationInfo_Type value);

  // @@protoc_insertion_point(class_scope:mesos.Resource.ReservationInfo)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_role();
  void clear_has_role();
  void set_has_principal();
  void clear_has_principal();
  void set_has_labels();
  void clear_has_labels();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr principal_;
  ::google::protobuf::internal::ArenaStringPtr role_;
  ::mesos::Labels* labels_;
  int type_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsResource_ReservationInfoImpl();
};
// -------------------------------------------------------------------

class Resource_DiskInfo_Persistence : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.Resource.DiskInfo.Persistence) */ {
 public:
  Resource_DiskInfo_Persistence();
  virtual ~Resource_DiskInfo_Persistence();

  Resource_DiskInfo_Persistence(const Resource_DiskInfo_Persistence& from);

  inline Resource_DiskInfo_Persistence& operator=(const Resource_DiskInfo_Persistence& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Resource_DiskInfo_Persistence(Resource_DiskInfo_Persistence&& from) noexcept
    : Resource_DiskInfo_Persistence() {
    *this = ::std::move(from);
  }

  inline Resource_DiskInfo_Persistence& operator=(Resource_DiskInfo_Persistence&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Resource_DiskInfo_Persistence& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Resource_DiskInfo_Persistence* internal_default_instance() {
    return reinterpret_cast<const Resource_DiskInfo_Persistence*>(
               &_Resource_DiskInfo_Persistence_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    49;

  void UnsafeArenaSwap(Resource_DiskInfo_Persistence* other);
  void Swap(Resource_DiskInfo_Persistence* other);
  friend void swap(Resource_DiskInfo_Persistence& a, Resource_DiskInfo_Persistence& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Resource_DiskInfo_Persistence* New() const PROTOBUF_FINAL { return New(NULL); }

  Resource_DiskInfo_Persistence* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Resource_DiskInfo_Persistence& from);
  void MergeFrom(const Resource_DiskInfo_Persistence& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Resource_DiskInfo_Persistence* other);
  protected:
  explicit Resource_DiskInfo_Persistence(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_id();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_id(
      ::std::string* id);

  // optional string principal = 2;
  bool has_principal() const;
  void clear_principal();
  static const int kPrincipalFieldNumber = 2;
  const ::std::string& principal() const;
  void set_principal(const ::std::string& value);
  #if LANG_CXX11
  void set_principal(::std::string&& value);
  #endif
  void set_principal(const char* value);
  void set_principal(const char* value, size_t size);
  ::std::string* mutable_principal();
  ::std::string* release_principal();
  void set_allocated_principal(::std::string* principal);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_principal();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_principal(
      ::std::string* principal);

  // @@protoc_insertion_point(class_scope:mesos.Resource.DiskInfo.Persistence)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_principal();
  void clear_has_principal();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr principal_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsResource_DiskInfo_PersistenceImpl();
};
// -------------------------------------------------------------------

class Resource_DiskInfo_Source_Path : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.Resource.DiskInfo.Source.Path) */ {
 public:
  Resource_DiskInfo_Source_Path();
  virtual ~Resource_DiskInfo_Source_Path();

  Resource_DiskInfo_Source_Path(const Resource_DiskInfo_Source_Path& from);

  inline Resource_DiskInfo_Source_Path& operator=(const Resource_DiskInfo_Source_Path& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Resource_DiskInfo_Source_Path(Resource_DiskInfo_Source_Path&& from) noexcept
    : Resource_DiskInfo_Source_Path() {
    *this = ::std::move(from);
  }

  inline Resource_DiskInfo_Source_Path& operator=(Resource_DiskInfo_Source_Path&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Resource_DiskInfo_Source_Path& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Resource_DiskInfo_Source_Path* internal_default_instance() {
    return reinterpret_cast<const Resource_DiskInfo_Source_Path*>(
               &_Resource_DiskInfo_Source_Path_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    50;

  void UnsafeArenaSwap(Resource_DiskInfo_Source_Path* other);
  void Swap(Resource_DiskInfo_Source_Path* other);
  friend void swap(Resource_DiskInfo_Source_Path& a, Resource_DiskInfo_Source_Path& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Resource_DiskInfo_Source_Path* New() const PROTOBUF_FINAL { return New(NULL); }

  Resource_DiskInfo_Source_Path* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Resource_DiskInfo_Source_Path& from);
  void MergeFrom(const Resource_DiskInfo_Source_Path& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Resource_DiskInfo_Source_Path* other);
  protected:
  explicit Resource_DiskInfo_Source_Path(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string root = 1;
  bool has_root() const;
  void clear_root();
  static const int kRootFieldNumber = 1;
  const ::std::string& root() const;
  void set_root(const ::std::string& value);
  #if LANG_CXX11
  void set_root(::std::string&& value);
  #endif
  void set_root(const char* value);
  void set_root(const char* value, size_t size);
  ::std::string* mutable_root();
  ::std::string* release_root();
  void set_allocated_root(::std::string* root);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_root();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_root(
      ::std::string* root);

  // @@protoc_insertion_point(class_scope:mesos.Resource.DiskInfo.Source.Path)
 private:
  void set_has_root();
  void clear_has_root();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr root_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsResource_DiskInfo_Source_PathImpl();
};
// -------------------------------------------------------------------

class Resource_DiskInfo_Source_Mount : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.Resource.DiskInfo.Source.Mount) */ {
 public:
  Resource_DiskInfo_Source_Mount();
  virtual ~Resource_DiskInfo_Source_Mount();

  Resource_DiskInfo_Source_Mount(const Resource_DiskInfo_Source_Mount& from);

  inline Resource_DiskInfo_Source_Mount& operator=(const Resource_DiskInfo_Source_Mount& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Resource_DiskInfo_Source_Mount(Resource_DiskInfo_Source_Mount&& from) noexcept
    : Resource_DiskInfo_Source_Mount() {
    *this = ::std::move(from);
  }

  inline Resource_DiskInfo_Source_Mount& operator=(Resource_DiskInfo_Source_Mount&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Resource_DiskInfo_Source_Mount& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Resource_DiskInfo_Source_Mount* internal_default_instance() {
    return reinterpret_cast<const Resource_DiskInfo_Source_Mount*>(
               &_Resource_DiskInfo_Source_Mount_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    51;

  void UnsafeArenaSwap(Resource_DiskInfo_Source_Mount* other);
  void Swap(Resource_DiskInfo_Source_Mount* other);
  friend void swap(Resource_DiskInfo_Source_Mount& a, Resource_DiskInfo_Source_Mount& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Resource_DiskInfo_Source_Mount* New() const PROTOBUF_FINAL { return New(NULL); }

  Resource_DiskInfo_Source_Mount* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Resource_DiskInfo_Source_Mount& from);
  void MergeFrom(const Resource_DiskInfo_Source_Mount& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Resource_DiskInfo_Source_Mount* other);
  protected:
  explicit Resource_DiskInfo_Source_Mount(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string root = 1;
  bool has_root() const;
  void clear_root();
  static const int kRootFieldNumber = 1;
  const ::std::string& root() const;
  void set_root(const ::std::string& value);
  #if LANG_CXX11
  void set_root(::std::string&& value);
  #endif
  void set_root(const char* value);
  void set_root(const char* value, size_t size);
  ::std::string* mutable_root();
  ::std::string* release_root();
  void set_allocated_root(::std::string* root);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_root();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_root(
      ::std::string* root);

  // @@protoc_insertion_point(class_scope:mesos.Resource.DiskInfo.Source.Mount)
 private:
  void set_has_root();
  void clear_has_root();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr root_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsResource_DiskInfo_Source_MountImpl();
};
// -------------------------------------------------------------------

class Resource_DiskInfo_Source : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.Resource.DiskInfo.Source) */ {
 public:
  Resource_DiskInfo_Source();
  virtual ~Resource_DiskInfo_Source();

  Resource_DiskInfo_Source(const Resource_DiskInfo_Source& from);

  inline Resource_DiskInfo_Source& operator=(const Resource_DiskInfo_Source& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Resource_DiskInfo_Source(Resource_DiskInfo_Source&& from) noexcept
    : Resource_DiskInfo_Source() {
    *this = ::std::move(from);
  }

  inline Resource_DiskInfo_Source& operator=(Resource_DiskInfo_Source&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Resource_DiskInfo_Source& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Resource_DiskInfo_Source* internal_default_instance() {
    return reinterpret_cast<const Resource_DiskInfo_Source*>(
               &_Resource_DiskInfo_Source_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    52;

  void UnsafeArenaSwap(Resource_DiskInfo_Source* other);
  void Swap(Resource_DiskInfo_Source* other);
  friend void swap(Resource_DiskInfo_Source& a, Resource_DiskInfo_Source& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Resource_DiskInfo_Source* New() const PROTOBUF_FINAL { return New(NULL); }

  Resource_DiskInfo_Source* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Resource_DiskInfo_Source& from);
  void MergeFrom(const Resource_DiskInfo_Source& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Resource_DiskInfo_Source* other);
  protected:
  explicit Resource_DiskInfo_Source(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Resource_DiskInfo_Source_Path Path;
  typedef Resource_DiskInfo_Source_Mount Mount;

  typedef Resource_DiskInfo_Source_Type Type;
  static const Type UNKNOWN =
    Resource_DiskInfo_Source_Type_UNKNOWN;
  static const Type PATH =
    Resource_DiskInfo_Source_Type_PATH;
  static const Type MOUNT =
    Resource_DiskInfo_Source_Type_MOUNT;
  static const Type BLOCK =
    Resource_DiskInfo_Source_Type_BLOCK;
  static const Type RAW =
    Resource_DiskInfo_Source_Type_RAW;
  static inline bool Type_IsValid(int value) {
    return Resource_DiskInfo_Source_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Resource_DiskInfo_Source_Type_Type_MIN;
  static const Type Type_MAX =
    Resource_DiskInfo_Source_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Resource_DiskInfo_Source_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Resource_DiskInfo_Source_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Resource_DiskInfo_Source_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Resource_DiskInfo_Source_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string id = 4;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 4;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_id();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_id(
      ::std::string* id);

  // optional string profile = 6;
  bool has_profile() const;
  void clear_profile();
  static const int kProfileFieldNumber = 6;
  const ::std::string& profile() const;
  void set_profile(const ::std::string& value);
  #if LANG_CXX11
  void set_profile(::std::string&& value);
  #endif
  void set_profile(const char* value);
  void set_profile(const char* value, size_t size);
  ::std::string* mutable_profile();
  ::std::string* release_profile();
  void set_allocated_profile(::std::string* profile);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_profile();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_profile(
      ::std::string* profile);

  // optional .mesos.Resource.DiskInfo.Source.Path path = 2;
  bool has_path() const;
  void clear_path();
  static const int kPathFieldNumber = 2;
  private:
  void _slow_mutable_path();
  public:
  const ::mesos::Resource_DiskInfo_Source_Path& path() const;
  ::mesos::Resource_DiskInfo_Source_Path* release_path();
  ::mesos::Resource_DiskInfo_Source_Path* mutable_path();
  void set_allocated_path(::mesos::Resource_DiskInfo_Source_Path* path);
  void unsafe_arena_set_allocated_path(
      ::mesos::Resource_DiskInfo_Source_Path* path);
  ::mesos::Resource_DiskInfo_Source_Path* unsafe_arena_release_path();

  // optional .mesos.Resource.DiskInfo.Source.Mount mount = 3;
  bool has_mount() const;
  void clear_mount();
  static const int kMountFieldNumber = 3;
  private:
  void _slow_mutable_mount();
  public:
  const ::mesos::Resource_DiskInfo_Source_Mount& mount() const;
  ::mesos::Resource_DiskInfo_Source_Mount* release_mount();
  ::mesos::Resource_DiskInfo_Source_Mount* mutable_mount();
  void set_allocated_mount(::mesos::Resource_DiskInfo_Source_Mount* mount);
  void unsafe_arena_set_allocated_mount(
      ::mesos::Resource_DiskInfo_Source_Mount* mount);
  ::mesos::Resource_DiskInfo_Source_Mount* unsafe_arena_release_mount();

  // optional .mesos.Labels metadata = 5;
  bool has_metadata() const;
  void clear_metadata();
  static const int kMetadataFieldNumber = 5;
  private:
  void _slow_mutable_metadata();
  public:
  const ::mesos::Labels& metadata() const;
  ::mesos::Labels* release_metadata();
  ::mesos::Labels* mutable_metadata();
  void set_allocated_metadata(::mesos::Labels* metadata);
  void unsafe_arena_set_allocated_metadata(
      ::mesos::Labels* metadata);
  ::mesos::Labels* unsafe_arena_release_metadata();

  // required .mesos.Resource.DiskInfo.Source.Type type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::mesos::Resource_DiskInfo_Source_Type type() const;
  void set_type(::mesos::Resource_DiskInfo_Source_Type value);

  // @@protoc_insertion_point(class_scope:mesos.Resource.DiskInfo.Source)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_path();
  void clear_has_path();
  void set_has_mount();
  void clear_has_mount();
  void set_has_id();
  void clear_has_id();
  void set_has_metadata();
  void clear_has_metadata();
  void set_has_profile();
  void clear_has_profile();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr profile_;
  ::mesos::Resource_DiskInfo_Source_Path* path_;
  ::mesos::Resource_DiskInfo_Source_Mount* mount_;
  ::mesos::Labels* metadata_;
  int type_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsResource_DiskInfo_SourceImpl();
};
// -------------------------------------------------------------------

class Resource_DiskInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.Resource.DiskInfo) */ {
 public:
  Resource_DiskInfo();
  virtual ~Resource_DiskInfo();

  Resource_DiskInfo(const Resource_DiskInfo& from);

  inline Resource_DiskInfo& operator=(const Resource_DiskInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Resource_DiskInfo(Resource_DiskInfo&& from) noexcept
    : Resource_DiskInfo() {
    *this = ::std::move(from);
  }

  inline Resource_DiskInfo& operator=(Resource_DiskInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Resource_DiskInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Resource_DiskInfo* internal_default_instance() {
    return reinterpret_cast<const Resource_DiskInfo*>(
               &_Resource_DiskInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    53;

  void UnsafeArenaSwap(Resource_DiskInfo* other);
  void Swap(Resource_DiskInfo* other);
  friend void swap(Resource_DiskInfo& a, Resource_DiskInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Resource_DiskInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  Resource_DiskInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Resource_DiskInfo& from);
  void MergeFrom(const Resource_DiskInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Resource_DiskInfo* other);
  protected:
  explicit Resource_DiskInfo(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Resource_DiskInfo_Persistence Persistence;
  typedef Resource_DiskInfo_Source Source;

  // accessors -------------------------------------------------------

  // optional .mesos.Resource.DiskInfo.Persistence persistence = 1;
  bool has_persistence() const;
  void clear_persistence();
  static const int kPersistenceFieldNumber = 1;
  private:
  void _slow_mutable_persistence();
  public:
  const ::mesos::Resource_DiskInfo_Persistence& persistence() const;
  ::mesos::Resource_DiskInfo_Persistence* release_persistence();
  ::mesos::Resource_DiskInfo_Persistence* mutable_persistence();
  void set_allocated_persistence(::mesos::Resource_DiskInfo_Persistence* persistence);
  void unsafe_arena_set_allocated_persistence(
      ::mesos::Resource_DiskInfo_Persistence* persistence);
  ::mesos::Resource_DiskInfo_Persistence* unsafe_arena_release_persistence();

  // optional .mesos.Volume volume = 2;
  bool has_volume() const;
  void clear_volume();
  static const int kVolumeFieldNumber = 2;
  private:
  void _slow_mutable_volume();
  public:
  const ::mesos::Volume& volume() const;
  ::mesos::Volume* release_volume();
  ::mesos::Volume* mutable_volume();
  void set_allocated_volume(::mesos::Volume* volume);
  void unsafe_arena_set_allocated_volume(
      ::mesos::Volume* volume);
  ::mesos::Volume* unsafe_arena_release_volume();

  // optional .mesos.Resource.DiskInfo.Source source = 3;
  bool has_source() const;
  void clear_source();
  static const int kSourceFieldNumber = 3;
  private:
  void _slow_mutable_source();
  public:
  const ::mesos::Resource_DiskInfo_Source& source() const;
  ::mesos::Resource_DiskInfo_Source* release_source();
  ::mesos::Resource_DiskInfo_Source* mutable_source();
  void set_allocated_source(::mesos::Resource_DiskInfo_Source* source);
  void unsafe_arena_set_allocated_source(
      ::mesos::Resource_DiskInfo_Source* source);
  ::mesos::Resource_DiskInfo_Source* unsafe_arena_release_source();

  // @@protoc_insertion_point(class_scope:mesos.Resource.DiskInfo)
 private:
  void set_has_persistence();
  void clear_has_persistence();
  void set_has_volume();
  void clear_has_volume();
  void set_has_source();
  void clear_has_source();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::Resource_DiskInfo_Persistence* persistence_;
  ::mesos::Volume* volume_;
  ::mesos::Resource_DiskInfo_Source* source_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsResource_DiskInfoImpl();
};
// -------------------------------------------------------------------

class Resource_RevocableInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.Resource.RevocableInfo) */ {
 public:
  Resource_RevocableInfo();
  virtual ~Resource_RevocableInfo();

  Resource_RevocableInfo(const Resource_RevocableInfo& from);

  inline Resource_RevocableInfo& operator=(const Resource_RevocableInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Resource_RevocableInfo(Resource_RevocableInfo&& from) noexcept
    : Resource_RevocableInfo() {
    *this = ::std::move(from);
  }

  inline Resource_RevocableInfo& operator=(Resource_RevocableInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Resource_RevocableInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Resource_RevocableInfo* internal_default_instance() {
    return reinterpret_cast<const Resource_RevocableInfo*>(
               &_Resource_RevocableInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    54;

  void UnsafeArenaSwap(Resource_RevocableInfo* other);
  void Swap(Resource_RevocableInfo* other);
  friend void swap(Resource_RevocableInfo& a, Resource_RevocableInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Resource_RevocableInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  Resource_RevocableInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Resource_RevocableInfo& from);
  void MergeFrom(const Resource_RevocableInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Resource_RevocableInfo* other);
  protected:
  explicit Resource_RevocableInfo(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:mesos.Resource.RevocableInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsResource_RevocableInfoImpl();
};
// -------------------------------------------------------------------

class Resource_SharedInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.Resource.SharedInfo) */ {
 public:
  Resource_SharedInfo();
  virtual ~Resource_SharedInfo();

  Resource_SharedInfo(const Resource_SharedInfo& from);

  inline Resource_SharedInfo& operator=(const Resource_SharedInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Resource_SharedInfo(Resource_SharedInfo&& from) noexcept
    : Resource_SharedInfo() {
    *this = ::std::move(from);
  }

  inline Resource_SharedInfo& operator=(Resource_SharedInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Resource_SharedInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Resource_SharedInfo* internal_default_instance() {
    return reinterpret_cast<const Resource_SharedInfo*>(
               &_Resource_SharedInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    55;

  void UnsafeArenaSwap(Resource_SharedInfo* other);
  void Swap(Resource_SharedInfo* other);
  friend void swap(Resource_SharedInfo& a, Resource_SharedInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Resource_SharedInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  Resource_SharedInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Resource_SharedInfo& from);
  void MergeFrom(const Resource_SharedInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Resource_SharedInfo* other);
  protected:
  explicit Resource_SharedInfo(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:mesos.Resource.SharedInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsResource_SharedInfoImpl();
};
// -------------------------------------------------------------------

class Resource : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.Resource) */ {
 public:
  Resource();
  virtual ~Resource();

  Resource(const Resource& from);

  inline Resource& operator=(const Resource& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Resource(Resource&& from) noexcept
    : Resource() {
    *this = ::std::move(from);
  }

  inline Resource& operator=(Resource&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Resource& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Resource* internal_default_instance() {
    return reinterpret_cast<const Resource*>(
               &_Resource_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    56;

  void UnsafeArenaSwap(Resource* other);
  void Swap(Resource* other);
  friend void swap(Resource& a, Resource& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Resource* New() const PROTOBUF_FINAL { return New(NULL); }

  Resource* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Resource& from);
  void MergeFrom(const Resource& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Resource* other);
  protected:
  explicit Resource(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Resource_AllocationInfo AllocationInfo;
  typedef Resource_ReservationInfo ReservationInfo;
  typedef Resource_DiskInfo DiskInfo;
  typedef Resource_RevocableInfo RevocableInfo;
  typedef Resource_SharedInfo SharedInfo;

  // accessors -------------------------------------------------------

  // repeated .mesos.Resource.ReservationInfo reservations = 13;
  int reservations_size() const;
  void clear_reservations();
  static const int kReservationsFieldNumber = 13;
  const ::mesos::Resource_ReservationInfo& reservations(int index) const;
  ::mesos::Resource_ReservationInfo* mutable_reservations(int index);
  ::mesos::Resource_ReservationInfo* add_reservations();
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource_ReservationInfo >*
      mutable_reservations();
  const ::google::protobuf::RepeatedPtrField< ::mesos::Resource_ReservationInfo >&
      reservations() const;

  // required string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_name();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      ::std::string* name);

  // optional string role = 6 [default = "*", deprecated = true];
  GOOGLE_PROTOBUF_DEPRECATED_ATTR bool has_role() const;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void clear_role();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR static const int kRoleFieldNumber = 6;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR const ::std::string& role() const;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void set_role(const ::std::string& value);
  #if LANG_CXX11
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void set_role(::std::string&& value);
  #endif
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void set_role(const char* value);
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void set_role(const char* value, size_t size);
  GOOGLE_PROTOBUF_DEPRECATED_ATTR ::std::string* mutable_role();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR ::std::string* release_role();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void set_allocated_role(::std::string* role);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_role();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_role(
      ::std::string* role);

  // optional .mesos.Value.Scalar scalar = 3;
  bool has_scalar() const;
  void clear_scalar();
  static const int kScalarFieldNumber = 3;
  private:
  void _slow_mutable_scalar();
  public:
  const ::mesos::Value_Scalar& scalar() const;
  ::mesos::Value_Scalar* release_scalar();
  ::mesos::Value_Scalar* mutable_scalar();
  void set_allocated_scalar(::mesos::Value_Scalar* scalar);
  void unsafe_arena_set_allocated_scalar(
      ::mesos::Value_Scalar* scalar);
  ::mesos::Value_Scalar* unsafe_arena_release_scalar();

  // optional .mesos.Value.Ranges ranges = 4;
  bool has_ranges() const;
  void clear_ranges();
  static const int kRangesFieldNumber = 4;
  private:
  void _slow_mutable_ranges();
  public:
  const ::mesos::Value_Ranges& ranges() const;
  ::mesos::Value_Ranges* release_ranges();
  ::mesos::Value_Ranges* mutable_ranges();
  void set_allocated_ranges(::mesos::Value_Ranges* ranges);
  void unsafe_arena_set_allocated_ranges(
      ::mesos::Value_Ranges* ranges);
  ::mesos::Value_Ranges* unsafe_arena_release_ranges();

  // optional .mesos.Value.Set set = 5;
  bool has_set() const;
  void clear_set();
  static const int kSetFieldNumber = 5;
  private:
  void _slow_mutable_set();
  public:
  const ::mesos::Value_Set& set() const;
  ::mesos::Value_Set* release_set();
  ::mesos::Value_Set* mutable_set();
  void set_allocated_set(::mesos::Value_Set* set);
  void unsafe_arena_set_allocated_set(
      ::mesos::Value_Set* set);
  ::mesos::Value_Set* unsafe_arena_release_set();

  // optional .mesos.Resource.DiskInfo disk = 7;
  bool has_disk() const;
  void clear_disk();
  static const int kDiskFieldNumber = 7;
  private:
  void _slow_mutable_disk();
  public:
  const ::mesos::Resource_DiskInfo& disk() const;
  ::mesos::Resource_DiskInfo* release_disk();
  ::mesos::Resource_DiskInfo* mutable_disk();
  void set_allocated_disk(::mesos::Resource_DiskInfo* disk);
  void unsafe_arena_set_allocated_disk(
      ::mesos::Resource_DiskInfo* disk);
  ::mesos::Resource_DiskInfo* unsafe_arena_release_disk();

  // optional .mesos.Resource.ReservationInfo reservation = 8;
  bool has_reservation() const;
  void clear_reservation();
  static const int kReservationFieldNumber = 8;
  private:
  void _slow_mutable_reservation();
  public:
  const ::mesos::Resource_ReservationInfo& reservation() const;
  ::mesos::Resource_ReservationInfo* release_reservation();
  ::mesos::Resource_ReservationInfo* mutable_reservation();
  void set_allocated_reservation(::mesos::Resource_ReservationInfo* reservation);
  void unsafe_arena_set_allocated_reservation(
      ::mesos::Resource_ReservationInfo* reservation);
  ::mesos::Resource_ReservationInfo* unsafe_arena_release_reservation();

  // optional .mesos.Resource.RevocableInfo revocable = 9;
  bool has_revocable() const;
  void clear_revocable();
  static const int kRevocableFieldNumber = 9;
  private:
  void _slow_mutable_revocable();
  public:
  const ::mesos::Resource_RevocableInfo& revocable() const;
  ::mesos::Resource_RevocableInfo* release_revocable();
  ::mesos::Resource_RevocableInfo* mutable_revocable();
  void set_allocated_revocable(::mesos::Resource_RevocableInfo* revocable);
  void unsafe_arena_set_allocated_revocable(
      ::mesos::Resource_RevocableInfo* revocable);
  ::mesos::Resource_RevocableInfo* unsafe_arena_release_revocable();

  // optional .mesos.Resource.SharedInfo shared = 10;
  bool has_shared() const;
  void clear_shared();
  static const int kSharedFieldNumber = 10;
  private:
  void _slow_mutable_shared();
  public:
  const ::mesos::Resource_SharedInfo& shared() const;
  ::mesos::Resource_SharedInfo* release_shared();
  ::mesos::Resource_SharedInfo* mutable_shared();
  void set_allocated_shared(::mesos::Resource_SharedInfo* shared);
  void unsafe_arena_set_allocated_shared(
      ::mesos::Resource_SharedInfo* shared);
  ::mesos::Resource_SharedInfo* unsafe_arena_release_shared();

  // optional .mesos.Resource.AllocationInfo allocation_info = 11;
  bool has_allocation_info() const;
  void clear_allocation_info();
  static const int kAllocationInfoFieldNumber = 11;
  private:
  void _slow_mutable_allocation_info();
  public:
  const ::mesos::Resource_AllocationInfo& allocation_info() const;
  ::mesos::Resource_AllocationInfo* release_allocation_info();
  ::mesos::Resource_AllocationInfo* mutable_allocation_info();
  void set_allocated_allocation_info(::mesos::Resource_AllocationInfo* allocation_info);
  void unsafe_arena_set_allocated_allocation_info(
      ::mesos::Resource_AllocationInfo* allocation_info);
  ::mesos::Resource_AllocationInfo* unsafe_arena_release_allocation_info();

  // optional .mesos.ResourceProviderID provider_id = 12;
  bool has_provider_id() const;
  void clear_provider_id();
  static const int kProviderIdFieldNumber = 12;
  private:
  void _slow_mutable_provider_id();
  public:
  const ::mesos::ResourceProviderID& provider_id() const;
  ::mesos::ResourceProviderID* release_provider_id();
  ::mesos::ResourceProviderID* mutable_provider_id();
  void set_allocated_provider_id(::mesos::ResourceProviderID* provider_id);
  void unsafe_arena_set_allocated_provider_id(
      ::mesos::ResourceProviderID* provider_id);
  ::mesos::ResourceProviderID* unsafe_arena_release_provider_id();

  // required .mesos.Value.Type type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::mesos::Value_Type type() const;
  void set_type(::mesos::Value_Type value);

  // @@protoc_insertion_point(class_scope:mesos.Resource)
 private:
  void set_has_provider_id();
  void clear_has_provider_id();
  void set_has_name();
  void clear_has_name();
  void set_has_type();
  void clear_has_type();
  void set_has_scalar();
  void clear_has_scalar();
  void set_has_ranges();
  void clear_has_ranges();
  void set_has_set();
  void clear_has_set();
  void set_has_role();
  void clear_has_role();
  void set_has_allocation_info();
  void clear_has_allocation_info();
  void set_has_reservation();
  void clear_has_reservation();
  void set_has_disk();
  void clear_has_disk();
  void set_has_revocable();
  void clear_has_revocable();
  void set_has_shared();
  void clear_has_shared();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource_ReservationInfo > reservations_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  static ::google::protobuf::internal::ExplicitlyConstructed< ::std::string> _default_role_;
  ::google::protobuf::internal::ArenaStringPtr role_;
  ::mesos::Value_Scalar* scalar_;
  ::mesos::Value_Ranges* ranges_;
  ::mesos::Value_Set* set_;
  ::mesos::Resource_DiskInfo* disk_;
  ::mesos::Resource_ReservationInfo* reservation_;
  ::mesos::Resource_RevocableInfo* revocable_;
  ::mesos::Resource_SharedInfo* shared_;
  ::mesos::Resource_AllocationInfo* allocation_info_;
  ::mesos::ResourceProviderID* provider_id_;
  int type_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsResourceImpl();
};
// -------------------------------------------------------------------

class TrafficControlStatistics : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.TrafficControlStatistics) */ {
 public:
  TrafficControlStatistics();
  virtual ~TrafficControlStatistics();

  TrafficControlStatistics(const TrafficControlStatistics& from);

  inline TrafficControlStatistics& operator=(const TrafficControlStatistics& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TrafficControlStatistics(TrafficControlStatistics&& from) noexcept
    : TrafficControlStatistics() {
    *this = ::std::move(from);
  }

  inline TrafficControlStatistics& operator=(TrafficControlStatistics&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const TrafficControlStatistics& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TrafficControlStatistics* internal_default_instance() {
    return reinterpret_cast<const TrafficControlStatistics*>(
               &_TrafficControlStatistics_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    57;

  void UnsafeArenaSwap(TrafficControlStatistics* other);
  void Swap(TrafficControlStatistics* other);
  friend void swap(TrafficControlStatistics& a, TrafficControlStatistics& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TrafficControlStatistics* New() const PROTOBUF_FINAL { return New(NULL); }

  TrafficControlStatistics* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TrafficControlStatistics& from);
  void MergeFrom(const TrafficControlStatistics& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TrafficControlStatistics* other);
  protected:
  explicit TrafficControlStatistics(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_id();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_id(
      ::std::string* id);

  // optional uint64 backlog = 2;
  bool has_backlog() const;
  void clear_backlog();
  static const int kBacklogFieldNumber = 2;
  ::google::protobuf::uint64 backlog() const;
  void set_backlog(::google::protobuf::uint64 value);

  // optional uint64 bytes = 3;
  bool has_bytes() const;
  void clear_bytes();
  static const int kBytesFieldNumber = 3;
  ::google::protobuf::uint64 bytes() const;
  void set_bytes(::google::protobuf::uint64 value);

  // optional uint64 drops = 4;
  bool has_drops() const;
  void clear_drops();
  static const int kDropsFieldNumber = 4;
  ::google::protobuf::uint64 drops() const;
  void set_drops(::google::protobuf::uint64 value);

  // optional uint64 overlimits = 5;
  bool has_overlimits() const;
  void clear_overlimits();
  static const int kOverlimitsFieldNumber = 5;
  ::google::protobuf::uint64 overlimits() const;
  void set_overlimits(::google::protobuf::uint64 value);

  // optional uint64 packets = 6;
  bool has_packets() const;
  void clear_packets();
  static const int kPacketsFieldNumber = 6;
  ::google::protobuf::uint64 packets() const;
  void set_packets(::google::protobuf::uint64 value);

  // optional uint64 qlen = 7;
  bool has_qlen() const;
  void clear_qlen();
  static const int kQlenFieldNumber = 7;
  ::google::protobuf::uint64 qlen() const;
  void set_qlen(::google::protobuf::uint64 value);

  // optional uint64 ratebps = 8;
  bool has_ratebps() const;
  void clear_ratebps();
  static const int kRatebpsFieldNumber = 8;
  ::google::protobuf::uint64 ratebps() const;
  void set_ratebps(::google::protobuf::uint64 value);

  // optional uint64 ratepps = 9;
  bool has_ratepps() const;
  void clear_ratepps();
  static const int kRateppsFieldNumber = 9;
  ::google::protobuf::uint64 ratepps() const;
  void set_ratepps(::google::protobuf::uint64 value);

  // optional uint64 requeues = 10;
  bool has_requeues() const;
  void clear_requeues();
  static const int kRequeuesFieldNumber = 10;
  ::google::protobuf::uint64 requeues() const;
  void set_requeues(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:mesos.TrafficControlStatistics)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_backlog();
  void clear_has_backlog();
  void set_has_bytes();
  void clear_has_bytes();
  void set_has_drops();
  void clear_has_drops();
  void set_has_overlimits();
  void clear_has_overlimits();
  void set_has_packets();
  void clear_has_packets();
  void set_has_qlen();
  void clear_has_qlen();
  void set_has_ratebps();
  void clear_has_ratebps();
  void set_has_ratepps();
  void clear_has_ratepps();
  void set_has_requeues();
  void clear_has_requeues();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::uint64 backlog_;
  ::google::protobuf::uint64 bytes_;
  ::google::protobuf::uint64 drops_;
  ::google::protobuf::uint64 overlimits_;
  ::google::protobuf::uint64 packets_;
  ::google::protobuf::uint64 qlen_;
  ::google::protobuf::uint64 ratebps_;
  ::google::protobuf::uint64 ratepps_;
  ::google::protobuf::uint64 requeues_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsTrafficControlStatisticsImpl();
};
// -------------------------------------------------------------------

class IpStatistics : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.IpStatistics) */ {
 public:
  IpStatistics();
  virtual ~IpStatistics();

  IpStatistics(const IpStatistics& from);

  inline IpStatistics& operator=(const IpStatistics& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IpStatistics(IpStatistics&& from) noexcept
    : IpStatistics() {
    *this = ::std::move(from);
  }

  inline IpStatistics& operator=(IpStatistics&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const IpStatistics& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IpStatistics* internal_default_instance() {
    return reinterpret_cast<const IpStatistics*>(
               &_IpStatistics_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    58;

  void UnsafeArenaSwap(IpStatistics* other);
  void Swap(IpStatistics* other);
  friend void swap(IpStatistics& a, IpStatistics& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IpStatistics* New() const PROTOBUF_FINAL { return New(NULL); }

  IpStatistics* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const IpStatistics& from);
  void MergeFrom(const IpStatistics& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(IpStatistics* other);
  protected:
  explicit IpStatistics(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 Forwarding = 1;
  bool has_forwarding() const;
  void clear_forwarding();
  static const int kForwardingFieldNumber = 1;
  ::google::protobuf::int64 forwarding() const;
  void set_forwarding(::google::protobuf::int64 value);

  // optional int64 DefaultTTL = 2;
  bool has_defaultttl() const;
  void clear_defaultttl();
  static const int kDefaultTTLFieldNumber = 2;
  ::google::protobuf::int64 defaultttl() const;
  void set_defaultttl(::google::protobuf::int64 value);

  // optional int64 InReceives = 3;
  bool has_inreceives() const;
  void clear_inreceives();
  static const int kInReceivesFieldNumber = 3;
  ::google::protobuf::int64 inreceives() const;
  void set_inreceives(::google::protobuf::int64 value);

  // optional int64 InHdrErrors = 4;
  bool has_inhdrerrors() const;
  void clear_inhdrerrors();
  static const int kInHdrErrorsFieldNumber = 4;
  ::google::protobuf::int64 inhdrerrors() const;
  void set_inhdrerrors(::google::protobuf::int64 value);

  // optional int64 InAddrErrors = 5;
  bool has_inaddrerrors() const;
  void clear_inaddrerrors();
  static const int kInAddrErrorsFieldNumber = 5;
  ::google::protobuf::int64 inaddrerrors() const;
  void set_inaddrerrors(::google::protobuf::int64 value);

  // optional int64 ForwDatagrams = 6;
  bool has_forwdatagrams() const;
  void clear_forwdatagrams();
  static const int kForwDatagramsFieldNumber = 6;
  ::google::protobuf::int64 forwdatagrams() const;
  void set_forwdatagrams(::google::protobuf::int64 value);

  // optional int64 InUnknownProtos = 7;
  bool has_inunknownprotos() const;
  void clear_inunknownprotos();
  static const int kInUnknownProtosFieldNumber = 7;
  ::google::protobuf::int64 inunknownprotos() const;
  void set_inunknownprotos(::google::protobuf::int64 value);

  // optional int64 InDiscards = 8;
  bool has_indiscards() const;
  void clear_indiscards();
  static const int kInDiscardsFieldNumber = 8;
  ::google::protobuf::int64 indiscards() const;
  void set_indiscards(::google::protobuf::int64 value);

  // optional int64 InDelivers = 9;
  bool has_indelivers() const;
  void clear_indelivers();
  static const int kInDeliversFieldNumber = 9;
  ::google::protobuf::int64 indelivers() const;
  void set_indelivers(::google::protobuf::int64 value);

  // optional int64 OutRequests = 10;
  bool has_outrequests() const;
  void clear_outrequests();
  static const int kOutRequestsFieldNumber = 10;
  ::google::protobuf::int64 outrequests() const;
  void set_outrequests(::google::protobuf::int64 value);

  // optional int64 OutDiscards = 11;
  bool has_outdiscards() const;
  void clear_outdiscards();
  static const int kOutDiscardsFieldNumber = 11;
  ::google::protobuf::int64 outdiscards() const;
  void set_outdiscards(::google::protobuf::int64 value);

  // optional int64 OutNoRoutes = 12;
  bool has_outnoroutes() const;
  void clear_outnoroutes();
  static const int kOutNoRoutesFieldNumber = 12;
  ::google::protobuf::int64 outnoroutes() const;
  void set_outnoroutes(::google::protobuf::int64 value);

  // optional int64 ReasmTimeout = 13;
  bool has_reasmtimeout() const;
  void clear_reasmtimeout();
  static const int kReasmTimeoutFieldNumber = 13;
  ::google::protobuf::int64 reasmtimeout() const;
  void set_reasmtimeout(::google::protobuf::int64 value);

  // optional int64 ReasmReqds = 14;
  bool has_reasmreqds() const;
  void clear_reasmreqds();
  static const int kReasmReqdsFieldNumber = 14;
  ::google::protobuf::int64 reasmreqds() const;
  void set_reasmreqds(::google::protobuf::int64 value);

  // optional int64 ReasmOKs = 15;
  bool has_reasmoks() const;
  void clear_reasmoks();
  static const int kReasmOKsFieldNumber = 15;
  ::google::protobuf::int64 reasmoks() const;
  void set_reasmoks(::google::protobuf::int64 value);

  // optional int64 ReasmFails = 16;
  bool has_reasmfails() const;
  void clear_reasmfails();
  static const int kReasmFailsFieldNumber = 16;
  ::google::protobuf::int64 reasmfails() const;
  void set_reasmfails(::google::protobuf::int64 value);

  // optional int64 FragOKs = 17;
  bool has_fragoks() const;
  void clear_fragoks();
  static const int kFragOKsFieldNumber = 17;
  ::google::protobuf::int64 fragoks() const;
  void set_fragoks(::google::protobuf::int64 value);

  // optional int64 FragFails = 18;
  bool has_fragfails() const;
  void clear_fragfails();
  static const int kFragFailsFieldNumber = 18;
  ::google::protobuf::int64 fragfails() const;
  void set_fragfails(::google::protobuf::int64 value);

  // optional int64 FragCreates = 19;
  bool has_fragcreates() const;
  void clear_fragcreates();
  static const int kFragCreatesFieldNumber = 19;
  ::google::protobuf::int64 fragcreates() const;
  void set_fragcreates(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:mesos.IpStatistics)
 private:
  void set_has_forwarding();
  void clear_has_forwarding();
  void set_has_defaultttl();
  void clear_has_defaultttl();
  void set_has_inreceives();
  void clear_has_inreceives();
  void set_has_inhdrerrors();
  void clear_has_inhdrerrors();
  void set_has_inaddrerrors();
  void clear_has_inaddrerrors();
  void set_has_forwdatagrams();
  void clear_has_forwdatagrams();
  void set_has_inunknownprotos();
  void clear_has_inunknownprotos();
  void set_has_indiscards();
  void clear_has_indiscards();
  void set_has_indelivers();
  void clear_has_indelivers();
  void set_has_outrequests();
  void clear_has_outrequests();
  void set_has_outdiscards();
  void clear_has_outdiscards();
  void set_has_outnoroutes();
  void clear_has_outnoroutes();
  void set_has_reasmtimeout();
  void clear_has_reasmtimeout();
  void set_has_reasmreqds();
  void clear_has_reasmreqds();
  void set_has_reasmoks();
  void clear_has_reasmoks();
  void set_has_reasmfails();
  void clear_has_reasmfails();
  void set_has_fragoks();
  void clear_has_fragoks();
  void set_has_fragfails();
  void clear_has_fragfails();
  void set_has_fragcreates();
  void clear_has_fragcreates();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int64 forwarding_;
  ::google::protobuf::int64 defaultttl_;
  ::google::protobuf::int64 inreceives_;
  ::google::protobuf::int64 inhdrerrors_;
  ::google::protobuf::int64 inaddrerrors_;
  ::google::protobuf::int64 forwdatagrams_;
  ::google::protobuf::int64 inunknownprotos_;
  ::google::protobuf::int64 indiscards_;
  ::google::protobuf::int64 indelivers_;
  ::google::protobuf::int64 outrequests_;
  ::google::protobuf::int64 outdiscards_;
  ::google::protobuf::int64 outnoroutes_;
  ::google::protobuf::int64 reasmtimeout_;
  ::google::protobuf::int64 reasmreqds_;
  ::google::protobuf::int64 reasmoks_;
  ::google::protobuf::int64 reasmfails_;
  ::google::protobuf::int64 fragoks_;
  ::google::protobuf::int64 fragfails_;
  ::google::protobuf::int64 fragcreates_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsIpStatisticsImpl();
};
// -------------------------------------------------------------------

class IcmpStatistics : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.IcmpStatistics) */ {
 public:
  IcmpStatistics();
  virtual ~IcmpStatistics();

  IcmpStatistics(const IcmpStatistics& from);

  inline IcmpStatistics& operator=(const IcmpStatistics& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IcmpStatistics(IcmpStatistics&& from) noexcept
    : IcmpStatistics() {
    *this = ::std::move(from);
  }

  inline IcmpStatistics& operator=(IcmpStatistics&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const IcmpStatistics& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IcmpStatistics* internal_default_instance() {
    return reinterpret_cast<const IcmpStatistics*>(
               &_IcmpStatistics_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    59;

  void UnsafeArenaSwap(IcmpStatistics* other);
  void Swap(IcmpStatistics* other);
  friend void swap(IcmpStatistics& a, IcmpStatistics& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IcmpStatistics* New() const PROTOBUF_FINAL { return New(NULL); }

  IcmpStatistics* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const IcmpStatistics& from);
  void MergeFrom(const IcmpStatistics& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(IcmpStatistics* other);
  protected:
  explicit IcmpStatistics(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 InMsgs = 1;
  bool has_inmsgs() const;
  void clear_inmsgs();
  static const int kInMsgsFieldNumber = 1;
  ::google::protobuf::int64 inmsgs() const;
  void set_inmsgs(::google::protobuf::int64 value);

  // optional int64 InErrors = 2;
  bool has_inerrors() const;
  void clear_inerrors();
  static const int kInErrorsFieldNumber = 2;
  ::google::protobuf::int64 inerrors() const;
  void set_inerrors(::google::protobuf::int64 value);

  // optional int64 InCsumErrors = 3;
  bool has_incsumerrors() const;
  void clear_incsumerrors();
  static const int kInCsumErrorsFieldNumber = 3;
  ::google::protobuf::int64 incsumerrors() const;
  void set_incsumerrors(::google::protobuf::int64 value);

  // optional int64 InDestUnreachs = 4;
  bool has_indestunreachs() const;
  void clear_indestunreachs();
  static const int kInDestUnreachsFieldNumber = 4;
  ::google::protobuf::int64 indestunreachs() const;
  void set_indestunreachs(::google::protobuf::int64 value);

  // optional int64 InTimeExcds = 5;
  bool has_intimeexcds() const;
  void clear_intimeexcds();
  static const int kInTimeExcdsFieldNumber = 5;
  ::google::protobuf::int64 intimeexcds() const;
  void set_intimeexcds(::google::protobuf::int64 value);

  // optional int64 InParmProbs = 6;
  bool has_inparmprobs() const;
  void clear_inparmprobs();
  static const int kInParmProbsFieldNumber = 6;
  ::google::protobuf::int64 inparmprobs() const;
  void set_inparmprobs(::google::protobuf::int64 value);

  // optional int64 InSrcQuenchs = 7;
  bool has_insrcquenchs() const;
  void clear_insrcquenchs();
  static const int kInSrcQuenchsFieldNumber = 7;
  ::google::protobuf::int64 insrcquenchs() const;
  void set_insrcquenchs(::google::protobuf::int64 value);

  // optional int64 InRedirects = 8;
  bool has_inredirects() const;
  void clear_inredirects();
  static const int kInRedirectsFieldNumber = 8;
  ::google::protobuf::int64 inredirects() const;
  void set_inredirects(::google::protobuf::int64 value);

  // optional int64 InEchos = 9;
  bool has_inechos() const;
  void clear_inechos();
  static const int kInEchosFieldNumber = 9;
  ::google::protobuf::int64 inechos() const;
  void set_inechos(::google::protobuf::int64 value);

  // optional int64 InEchoReps = 10;
  bool has_inechoreps() const;
  void clear_inechoreps();
  static const int kInEchoRepsFieldNumber = 10;
  ::google::protobuf::int64 inechoreps() const;
  void set_inechoreps(::google::protobuf::int64 value);

  // optional int64 InTimestamps = 11;
  bool has_intimestamps() const;
  void clear_intimestamps();
  static const int kInTimestampsFieldNumber = 11;
  ::google::protobuf::int64 intimestamps() const;
  void set_intimestamps(::google::protobuf::int64 value);

  // optional int64 InTimestampReps = 12;
  bool has_intimestampreps() const;
  void clear_intimestampreps();
  static const int kInTimestampRepsFieldNumber = 12;
  ::google::protobuf::int64 intimestampreps() const;
  void set_intimestampreps(::google::protobuf::int64 value);

  // optional int64 InAddrMasks = 13;
  bool has_inaddrmasks() const;
  void clear_inaddrmasks();
  static const int kInAddrMasksFieldNumber = 13;
  ::google::protobuf::int64 inaddrmasks() const;
  void set_inaddrmasks(::google::protobuf::int64 value);

  // optional int64 InAddrMaskReps = 14;
  bool has_inaddrmaskreps() const;
  void clear_inaddrmaskreps();
  static const int kInAddrMaskRepsFieldNumber = 14;
  ::google::protobuf::int64 inaddrmaskreps() const;
  void set_inaddrmaskreps(::google::protobuf::int64 value);

  // optional int64 OutMsgs = 15;
  bool has_outmsgs() const;
  void clear_outmsgs();
  static const int kOutMsgsFieldNumber = 15;
  ::google::protobuf::int64 outmsgs() const;
  void set_outmsgs(::google::protobuf::int64 value);

  // optional int64 OutErrors = 16;
  bool has_outerrors() const;
  void clear_outerrors();
  static const int kOutErrorsFieldNumber = 16;
  ::google::protobuf::int64 outerrors() const;
  void set_outerrors(::google::protobuf::int64 value);

  // optional int64 OutDestUnreachs = 17;
  bool has_outdestunreachs() const;
  void clear_outdestunreachs();
  static const int kOutDestUnreachsFieldNumber = 17;
  ::google::protobuf::int64 outdestunreachs() const;
  void set_outdestunreachs(::google::protobuf::int64 value);

  // optional int64 OutTimeExcds = 18;
  bool has_outtimeexcds() const;
  void clear_outtimeexcds();
  static const int kOutTimeExcdsFieldNumber = 18;
  ::google::protobuf::int64 outtimeexcds() const;
  void set_outtimeexcds(::google::protobuf::int64 value);

  // optional int64 OutParmProbs = 19;
  bool has_outparmprobs() const;
  void clear_outparmprobs();
  static const int kOutParmProbsFieldNumber = 19;
  ::google::protobuf::int64 outparmprobs() const;
  void set_outparmprobs(::google::protobuf::int64 value);

  // optional int64 OutSrcQuenchs = 20;
  bool has_outsrcquenchs() const;
  void clear_outsrcquenchs();
  static const int kOutSrcQuenchsFieldNumber = 20;
  ::google::protobuf::int64 outsrcquenchs() const;
  void set_outsrcquenchs(::google::protobuf::int64 value);

  // optional int64 OutRedirects = 21;
  bool has_outredirects() const;
  void clear_outredirects();
  static const int kOutRedirectsFieldNumber = 21;
  ::google::protobuf::int64 outredirects() const;
  void set_outredirects(::google::protobuf::int64 value);

  // optional int64 OutEchos = 22;
  bool has_outechos() const;
  void clear_outechos();
  static const int kOutEchosFieldNumber = 22;
  ::google::protobuf::int64 outechos() const;
  void set_outechos(::google::protobuf::int64 value);

  // optional int64 OutEchoReps = 23;
  bool has_outechoreps() const;
  void clear_outechoreps();
  static const int kOutEchoRepsFieldNumber = 23;
  ::google::protobuf::int64 outechoreps() const;
  void set_outechoreps(::google::protobuf::int64 value);

  // optional int64 OutTimestamps = 24;
  bool has_outtimestamps() const;
  void clear_outtimestamps();
  static const int kOutTimestampsFieldNumber = 24;
  ::google::protobuf::int64 outtimestamps() const;
  void set_outtimestamps(::google::protobuf::int64 value);

  // optional int64 OutTimestampReps = 25;
  bool has_outtimestampreps() const;
  void clear_outtimestampreps();
  static const int kOutTimestampRepsFieldNumber = 25;
  ::google::protobuf::int64 outtimestampreps() const;
  void set_outtimestampreps(::google::protobuf::int64 value);

  // optional int64 OutAddrMasks = 26;
  bool has_outaddrmasks() const;
  void clear_outaddrmasks();
  static const int kOutAddrMasksFieldNumber = 26;
  ::google::protobuf::int64 outaddrmasks() const;
  void set_outaddrmasks(::google::protobuf::int64 value);

  // optional int64 OutAddrMaskReps = 27;
  bool has_outaddrmaskreps() const;
  void clear_outaddrmaskreps();
  static const int kOutAddrMaskRepsFieldNumber = 27;
  ::google::protobuf::int64 outaddrmaskreps() const;
  void set_outaddrmaskreps(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:mesos.IcmpStatistics)
 private:
  void set_has_inmsgs();
  void clear_has_inmsgs();
  void set_has_inerrors();
  void clear_has_inerrors();
  void set_has_incsumerrors();
  void clear_has_incsumerrors();
  void set_has_indestunreachs();
  void clear_has_indestunreachs();
  void set_has_intimeexcds();
  void clear_has_intimeexcds();
  void set_has_inparmprobs();
  void clear_has_inparmprobs();
  void set_has_insrcquenchs();
  void clear_has_insrcquenchs();
  void set_has_inredirects();
  void clear_has_inredirects();
  void set_has_inechos();
  void clear_has_inechos();
  void set_has_inechoreps();
  void clear_has_inechoreps();
  void set_has_intimestamps();
  void clear_has_intimestamps();
  void set_has_intimestampreps();
  void clear_has_intimestampreps();
  void set_has_inaddrmasks();
  void clear_has_inaddrmasks();
  void set_has_inaddrmaskreps();
  void clear_has_inaddrmaskreps();
  void set_has_outmsgs();
  void clear_has_outmsgs();
  void set_has_outerrors();
  void clear_has_outerrors();
  void set_has_outdestunreachs();
  void clear_has_outdestunreachs();
  void set_has_outtimeexcds();
  void clear_has_outtimeexcds();
  void set_has_outparmprobs();
  void clear_has_outparmprobs();
  void set_has_outsrcquenchs();
  void clear_has_outsrcquenchs();
  void set_has_outredirects();
  void clear_has_outredirects();
  void set_has_outechos();
  void clear_has_outechos();
  void set_has_outechoreps();
  void clear_has_outechoreps();
  void set_has_outtimestamps();
  void clear_has_outtimestamps();
  void set_has_outtimestampreps();
  void clear_has_outtimestampreps();
  void set_has_outaddrmasks();
  void clear_has_outaddrmasks();
  void set_has_outaddrmaskreps();
  void clear_has_outaddrmaskreps();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int64 inmsgs_;
  ::google::protobuf::int64 inerrors_;
  ::google::protobuf::int64 incsumerrors_;
  ::google::protobuf::int64 indestunreachs_;
  ::google::protobuf::int64 intimeexcds_;
  ::google::protobuf::int64 inparmprobs_;
  ::google::protobuf::int64 insrcquenchs_;
  ::google::protobuf::int64 inredirects_;
  ::google::protobuf::int64 inechos_;
  ::google::protobuf::int64 inechoreps_;
  ::google::protobuf::int64 intimestamps_;
  ::google::protobuf::int64 intimestampreps_;
  ::google::protobuf::int64 inaddrmasks_;
  ::google::protobuf::int64 inaddrmaskreps_;
  ::google::protobuf::int64 outmsgs_;
  ::google::protobuf::int64 outerrors_;
  ::google::protobuf::int64 outdestunreachs_;
  ::google::protobuf::int64 outtimeexcds_;
  ::google::protobuf::int64 outparmprobs_;
  ::google::protobuf::int64 outsrcquenchs_;
  ::google::protobuf::int64 outredirects_;
  ::google::protobuf::int64 outechos_;
  ::google::protobuf::int64 outechoreps_;
  ::google::protobuf::int64 outtimestamps_;
  ::google::protobuf::int64 outtimestampreps_;
  ::google::protobuf::int64 outaddrmasks_;
  ::google::protobuf::int64 outaddrmaskreps_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsIcmpStatisticsImpl();
};
// -------------------------------------------------------------------

class TcpStatistics : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.TcpStatistics) */ {
 public:
  TcpStatistics();
  virtual ~TcpStatistics();

  TcpStatistics(const TcpStatistics& from);

  inline TcpStatistics& operator=(const TcpStatistics& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TcpStatistics(TcpStatistics&& from) noexcept
    : TcpStatistics() {
    *this = ::std::move(from);
  }

  inline TcpStatistics& operator=(TcpStatistics&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const TcpStatistics& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TcpStatistics* internal_default_instance() {
    return reinterpret_cast<const TcpStatistics*>(
               &_TcpStatistics_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    60;

  void UnsafeArenaSwap(TcpStatistics* other);
  void Swap(TcpStatistics* other);
  friend void swap(TcpStatistics& a, TcpStatistics& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TcpStatistics* New() const PROTOBUF_FINAL { return New(NULL); }

  TcpStatistics* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TcpStatistics& from);
  void MergeFrom(const TcpStatistics& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TcpStatistics* other);
  protected:
  explicit TcpStatistics(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 RtoAlgorithm = 1;
  bool has_rtoalgorithm() const;
  void clear_rtoalgorithm();
  static const int kRtoAlgorithmFieldNumber = 1;
  ::google::protobuf::int64 rtoalgorithm() const;
  void set_rtoalgorithm(::google::protobuf::int64 value);

  // optional int64 RtoMin = 2;
  bool has_rtomin() const;
  void clear_rtomin();
  static const int kRtoMinFieldNumber = 2;
  ::google::protobuf::int64 rtomin() const;
  void set_rtomin(::google::protobuf::int64 value);

  // optional int64 RtoMax = 3;
  bool has_rtomax() const;
  void clear_rtomax();
  static const int kRtoMaxFieldNumber = 3;
  ::google::protobuf::int64 rtomax() const;
  void set_rtomax(::google::protobuf::int64 value);

  // optional int64 MaxConn = 4;
  bool has_maxconn() const;
  void clear_maxconn();
  static const int kMaxConnFieldNumber = 4;
  ::google::protobuf::int64 maxconn() const;
  void set_maxconn(::google::protobuf::int64 value);

  // optional int64 ActiveOpens = 5;
  bool has_activeopens() const;
  void clear_activeopens();
  static const int kActiveOpensFieldNumber = 5;
  ::google::protobuf::int64 activeopens() const;
  void set_activeopens(::google::protobuf::int64 value);

  // optional int64 PassiveOpens = 6;
  bool has_passiveopens() const;
  void clear_passiveopens();
  static const int kPassiveOpensFieldNumber = 6;
  ::google::protobuf::int64 passiveopens() const;
  void set_passiveopens(::google::protobuf::int64 value);

  // optional int64 AttemptFails = 7;
  bool has_attemptfails() const;
  void clear_attemptfails();
  static const int kAttemptFailsFieldNumber = 7;
  ::google::protobuf::int64 attemptfails() const;
  void set_attemptfails(::google::protobuf::int64 value);

  // optional int64 EstabResets = 8;
  bool has_estabresets() const;
  void clear_estabresets();
  static const int kEstabResetsFieldNumber = 8;
  ::google::protobuf::int64 estabresets() const;
  void set_estabresets(::google::protobuf::int64 value);

  // optional int64 CurrEstab = 9;
  bool has_currestab() const;
  void clear_currestab();
  static const int kCurrEstabFieldNumber = 9;
  ::google::protobuf::int64 currestab() const;
  void set_currestab(::google::protobuf::int64 value);

  // optional int64 InSegs = 10;
  bool has_insegs() const;
  void clear_insegs();
  static const int kInSegsFieldNumber = 10;
  ::google::protobuf::int64 insegs() const;
  void set_insegs(::google::protobuf::int64 value);

  // optional int64 OutSegs = 11;
  bool has_outsegs() const;
  void clear_outsegs();
  static const int kOutSegsFieldNumber = 11;
  ::google::protobuf::int64 outsegs() const;
  void set_outsegs(::google::protobuf::int64 value);

  // optional int64 RetransSegs = 12;
  bool has_retranssegs() const;
  void clear_retranssegs();
  static const int kRetransSegsFieldNumber = 12;
  ::google::protobuf::int64 retranssegs() const;
  void set_retranssegs(::google::protobuf::int64 value);

  // optional int64 InErrs = 13;
  bool has_inerrs() const;
  void clear_inerrs();
  static const int kInErrsFieldNumber = 13;
  ::google::protobuf::int64 inerrs() const;
  void set_inerrs(::google::protobuf::int64 value);

  // optional int64 OutRsts = 14;
  bool has_outrsts() const;
  void clear_outrsts();
  static const int kOutRstsFieldNumber = 14;
  ::google::protobuf::int64 outrsts() const;
  void set_outrsts(::google::protobuf::int64 value);

  // optional int64 InCsumErrors = 15;
  bool has_incsumerrors() const;
  void clear_incsumerrors();
  static const int kInCsumErrorsFieldNumber = 15;
  ::google::protobuf::int64 incsumerrors() const;
  void set_incsumerrors(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:mesos.TcpStatistics)
 private:
  void set_has_rtoalgorithm();
  void clear_has_rtoalgorithm();
  void set_has_rtomin();
  void clear_has_rtomin();
  void set_has_rtomax();
  void clear_has_rtomax();
  void set_has_maxconn();
  void clear_has_maxconn();
  void set_has_activeopens();
  void clear_has_activeopens();
  void set_has_passiveopens();
  void clear_has_passiveopens();
  void set_has_attemptfails();
  void clear_has_attemptfails();
  void set_has_estabresets();
  void clear_has_estabresets();
  void set_has_currestab();
  void clear_has_currestab();
  void set_has_insegs();
  void clear_has_insegs();
  void set_has_outsegs();
  void clear_has_outsegs();
  void set_has_retranssegs();
  void clear_has_retranssegs();
  void set_has_inerrs();
  void clear_has_inerrs();
  void set_has_outrsts();
  void clear_has_outrsts();
  void set_has_incsumerrors();
  void clear_has_incsumerrors();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int64 rtoalgorithm_;
  ::google::protobuf::int64 rtomin_;
  ::google::protobuf::int64 rtomax_;
  ::google::protobuf::int64 maxconn_;
  ::google::protobuf::int64 activeopens_;
  ::google::protobuf::int64 passiveopens_;
  ::google::protobuf::int64 attemptfails_;
  ::google::protobuf::int64 estabresets_;
  ::google::protobuf::int64 currestab_;
  ::google::protobuf::int64 insegs_;
  ::google::protobuf::int64 outsegs_;
  ::google::protobuf::int64 retranssegs_;
  ::google::protobuf::int64 inerrs_;
  ::google::protobuf::int64 outrsts_;
  ::google::protobuf::int64 incsumerrors_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsTcpStatisticsImpl();
};
// -------------------------------------------------------------------

class UdpStatistics : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.UdpStatistics) */ {
 public:
  UdpStatistics();
  virtual ~UdpStatistics();

  UdpStatistics(const UdpStatistics& from);

  inline UdpStatistics& operator=(const UdpStatistics& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UdpStatistics(UdpStatistics&& from) noexcept
    : UdpStatistics() {
    *this = ::std::move(from);
  }

  inline UdpStatistics& operator=(UdpStatistics&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const UdpStatistics& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UdpStatistics* internal_default_instance() {
    return reinterpret_cast<const UdpStatistics*>(
               &_UdpStatistics_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    61;

  void UnsafeArenaSwap(UdpStatistics* other);
  void Swap(UdpStatistics* other);
  friend void swap(UdpStatistics& a, UdpStatistics& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UdpStatistics* New() const PROTOBUF_FINAL { return New(NULL); }

  UdpStatistics* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const UdpStatistics& from);
  void MergeFrom(const UdpStatistics& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(UdpStatistics* other);
  protected:
  explicit UdpStatistics(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 InDatagrams = 1;
  bool has_indatagrams() const;
  void clear_indatagrams();
  static const int kInDatagramsFieldNumber = 1;
  ::google::protobuf::int64 indatagrams() const;
  void set_indatagrams(::google::protobuf::int64 value);

  // optional int64 NoPorts = 2;
  bool has_noports() const;
  void clear_noports();
  static const int kNoPortsFieldNumber = 2;
  ::google::protobuf::int64 noports() const;
  void set_noports(::google::protobuf::int64 value);

  // optional int64 InErrors = 3;
  bool has_inerrors() const;
  void clear_inerrors();
  static const int kInErrorsFieldNumber = 3;
  ::google::protobuf::int64 inerrors() const;
  void set_inerrors(::google::protobuf::int64 value);

  // optional int64 OutDatagrams = 4;
  bool has_outdatagrams() const;
  void clear_outdatagrams();
  static const int kOutDatagramsFieldNumber = 4;
  ::google::protobuf::int64 outdatagrams() const;
  void set_outdatagrams(::google::protobuf::int64 value);

  // optional int64 RcvbufErrors = 5;
  bool has_rcvbuferrors() const;
  void clear_rcvbuferrors();
  static const int kRcvbufErrorsFieldNumber = 5;
  ::google::protobuf::int64 rcvbuferrors() const;
  void set_rcvbuferrors(::google::protobuf::int64 value);

  // optional int64 SndbufErrors = 6;
  bool has_sndbuferrors() const;
  void clear_sndbuferrors();
  static const int kSndbufErrorsFieldNumber = 6;
  ::google::protobuf::int64 sndbuferrors() const;
  void set_sndbuferrors(::google::protobuf::int64 value);

  // optional int64 InCsumErrors = 7;
  bool has_incsumerrors() const;
  void clear_incsumerrors();
  static const int kInCsumErrorsFieldNumber = 7;
  ::google::protobuf::int64 incsumerrors() const;
  void set_incsumerrors(::google::protobuf::int64 value);

  // optional int64 IgnoredMulti = 8;
  bool has_ignoredmulti() const;
  void clear_ignoredmulti();
  static const int kIgnoredMultiFieldNumber = 8;
  ::google::protobuf::int64 ignoredmulti() const;
  void set_ignoredmulti(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:mesos.UdpStatistics)
 private:
  void set_has_indatagrams();
  void clear_has_indatagrams();
  void set_has_noports();
  void clear_has_noports();
  void set_has_inerrors();
  void clear_has_inerrors();
  void set_has_outdatagrams();
  void clear_has_outdatagrams();
  void set_has_rcvbuferrors();
  void clear_has_rcvbuferrors();
  void set_has_sndbuferrors();
  void clear_has_sndbuferrors();
  void set_has_incsumerrors();
  void clear_has_incsumerrors();
  void set_has_ignoredmulti();
  void clear_has_ignoredmulti();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int64 indatagrams_;
  ::google::protobuf::int64 noports_;
  ::google::protobuf::int64 inerrors_;
  ::google::protobuf::int64 outdatagrams_;
  ::google::protobuf::int64 rcvbuferrors_;
  ::google::protobuf::int64 sndbuferrors_;
  ::google::protobuf::int64 incsumerrors_;
  ::google::protobuf::int64 ignoredmulti_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsUdpStatisticsImpl();
};
// -------------------------------------------------------------------

class SNMPStatistics : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.SNMPStatistics) */ {
 public:
  SNMPStatistics();
  virtual ~SNMPStatistics();

  SNMPStatistics(const SNMPStatistics& from);

  inline SNMPStatistics& operator=(const SNMPStatistics& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SNMPStatistics(SNMPStatistics&& from) noexcept
    : SNMPStatistics() {
    *this = ::std::move(from);
  }

  inline SNMPStatistics& operator=(SNMPStatistics&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const SNMPStatistics& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SNMPStatistics* internal_default_instance() {
    return reinterpret_cast<const SNMPStatistics*>(
               &_SNMPStatistics_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    62;

  void UnsafeArenaSwap(SNMPStatistics* other);
  void Swap(SNMPStatistics* other);
  friend void swap(SNMPStatistics& a, SNMPStatistics& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SNMPStatistics* New() const PROTOBUF_FINAL { return New(NULL); }

  SNMPStatistics* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SNMPStatistics& from);
  void MergeFrom(const SNMPStatistics& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SNMPStatistics* other);
  protected:
  explicit SNMPStatistics(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mesos.IpStatistics ip_stats = 1;
  bool has_ip_stats() const;
  void clear_ip_stats();
  static const int kIpStatsFieldNumber = 1;
  private:
  void _slow_mutable_ip_stats();
  public:
  const ::mesos::IpStatistics& ip_stats() const;
  ::mesos::IpStatistics* release_ip_stats();
  ::mesos::IpStatistics* mutable_ip_stats();
  void set_allocated_ip_stats(::mesos::IpStatistics* ip_stats);
  void unsafe_arena_set_allocated_ip_stats(
      ::mesos::IpStatistics* ip_stats);
  ::mesos::IpStatistics* unsafe_arena_release_ip_stats();

  // optional .mesos.IcmpStatistics icmp_stats = 2;
  bool has_icmp_stats() const;
  void clear_icmp_stats();
  static const int kIcmpStatsFieldNumber = 2;
  private:
  void _slow_mutable_icmp_stats();
  public:
  const ::mesos::IcmpStatistics& icmp_stats() const;
  ::mesos::IcmpStatistics* release_icmp_stats();
  ::mesos::IcmpStatistics* mutable_icmp_stats();
  void set_allocated_icmp_stats(::mesos::IcmpStatistics* icmp_stats);
  void unsafe_arena_set_allocated_icmp_stats(
      ::mesos::IcmpStatistics* icmp_stats);
  ::mesos::IcmpStatistics* unsafe_arena_release_icmp_stats();

  // optional .mesos.TcpStatistics tcp_stats = 3;
  bool has_tcp_stats() const;
  void clear_tcp_stats();
  static const int kTcpStatsFieldNumber = 3;
  private:
  void _slow_mutable_tcp_stats();
  public:
  const ::mesos::TcpStatistics& tcp_stats() const;
  ::mesos::TcpStatistics* release_tcp_stats();
  ::mesos::TcpStatistics* mutable_tcp_stats();
  void set_allocated_tcp_stats(::mesos::TcpStatistics* tcp_stats);
  void unsafe_arena_set_allocated_tcp_stats(
      ::mesos::TcpStatistics* tcp_stats);
  ::mesos::TcpStatistics* unsafe_arena_release_tcp_stats();

  // optional .mesos.UdpStatistics udp_stats = 4;
  bool has_udp_stats() const;
  void clear_udp_stats();
  static const int kUdpStatsFieldNumber = 4;
  private:
  void _slow_mutable_udp_stats();
  public:
  const ::mesos::UdpStatistics& udp_stats() const;
  ::mesos::UdpStatistics* release_udp_stats();
  ::mesos::UdpStatistics* mutable_udp_stats();
  void set_allocated_udp_stats(::mesos::UdpStatistics* udp_stats);
  void unsafe_arena_set_allocated_udp_stats(
      ::mesos::UdpStatistics* udp_stats);
  ::mesos::UdpStatistics* unsafe_arena_release_udp_stats();

  // @@protoc_insertion_point(class_scope:mesos.SNMPStatistics)
 private:
  void set_has_ip_stats();
  void clear_has_ip_stats();
  void set_has_icmp_stats();
  void clear_has_icmp_stats();
  void set_has_tcp_stats();
  void clear_has_tcp_stats();
  void set_has_udp_stats();
  void clear_has_udp_stats();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::IpStatistics* ip_stats_;
  ::mesos::IcmpStatistics* icmp_stats_;
  ::mesos::TcpStatistics* tcp_stats_;
  ::mesos::UdpStatistics* udp_stats_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsSNMPStatisticsImpl();
};
// -------------------------------------------------------------------

class DiskStatistics : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.DiskStatistics) */ {
 public:
  DiskStatistics();
  virtual ~DiskStatistics();

  DiskStatistics(const DiskStatistics& from);

  inline DiskStatistics& operator=(const DiskStatistics& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DiskStatistics(DiskStatistics&& from) noexcept
    : DiskStatistics() {
    *this = ::std::move(from);
  }

  inline DiskStatistics& operator=(DiskStatistics&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const DiskStatistics& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DiskStatistics* internal_default_instance() {
    return reinterpret_cast<const DiskStatistics*>(
               &_DiskStatistics_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    63;

  void UnsafeArenaSwap(DiskStatistics* other);
  void Swap(DiskStatistics* other);
  friend void swap(DiskStatistics& a, DiskStatistics& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DiskStatistics* New() const PROTOBUF_FINAL { return New(NULL); }

  DiskStatistics* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DiskStatistics& from);
  void MergeFrom(const DiskStatistics& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DiskStatistics* other);
  protected:
  explicit DiskStatistics(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mesos.Resource.DiskInfo.Source source = 1;
  bool has_source() const;
  void clear_source();
  static const int kSourceFieldNumber = 1;
  private:
  void _slow_mutable_source();
  public:
  const ::mesos::Resource_DiskInfo_Source& source() const;
  ::mesos::Resource_DiskInfo_Source* release_source();
  ::mesos::Resource_DiskInfo_Source* mutable_source();
  void set_allocated_source(::mesos::Resource_DiskInfo_Source* source);
  void unsafe_arena_set_allocated_source(
      ::mesos::Resource_DiskInfo_Source* source);
  ::mesos::Resource_DiskInfo_Source* unsafe_arena_release_source();

  // optional .mesos.Resource.DiskInfo.Persistence persistence = 2;
  bool has_persistence() const;
  void clear_persistence();
  static const int kPersistenceFieldNumber = 2;
  private:
  void _slow_mutable_persistence();
  public:
  const ::mesos::Resource_DiskInfo_Persistence& persistence() const;
  ::mesos::Resource_DiskInfo_Persistence* release_persistence();
  ::mesos::Resource_DiskInfo_Persistence* mutable_persistence();
  void set_allocated_persistence(::mesos::Resource_DiskInfo_Persistence* persistence);
  void unsafe_arena_set_allocated_persistence(
      ::mesos::Resource_DiskInfo_Persistence* persistence);
  ::mesos::Resource_DiskInfo_Persistence* unsafe_arena_release_persistence();

  // optional uint64 limit_bytes = 3;
  bool has_limit_bytes() const;
  void clear_limit_bytes();
  static const int kLimitBytesFieldNumber = 3;
  ::google::protobuf::uint64 limit_bytes() const;
  void set_limit_bytes(::google::protobuf::uint64 value);

  // optional uint64 used_bytes = 4;
  bool has_used_bytes() const;
  void clear_used_bytes();
  static const int kUsedBytesFieldNumber = 4;
  ::google::protobuf::uint64 used_bytes() const;
  void set_used_bytes(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:mesos.DiskStatistics)
 private:
  void set_has_source();
  void clear_has_source();
  void set_has_persistence();
  void clear_has_persistence();
  void set_has_limit_bytes();
  void clear_has_limit_bytes();
  void set_has_used_bytes();
  void clear_has_used_bytes();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::Resource_DiskInfo_Source* source_;
  ::mesos::Resource_DiskInfo_Persistence* persistence_;
  ::google::protobuf::uint64 limit_bytes_;
  ::google::protobuf::uint64 used_bytes_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsDiskStatisticsImpl();
};
// -------------------------------------------------------------------

class ResourceStatistics : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.ResourceStatistics) */ {
 public:
  ResourceStatistics();
  virtual ~ResourceStatistics();

  ResourceStatistics(const ResourceStatistics& from);

  inline ResourceStatistics& operator=(const ResourceStatistics& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResourceStatistics(ResourceStatistics&& from) noexcept
    : ResourceStatistics() {
    *this = ::std::move(from);
  }

  inline ResourceStatistics& operator=(ResourceStatistics&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResourceStatistics& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResourceStatistics* internal_default_instance() {
    return reinterpret_cast<const ResourceStatistics*>(
               &_ResourceStatistics_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    64;

  void UnsafeArenaSwap(ResourceStatistics* other);
  void Swap(ResourceStatistics* other);
  friend void swap(ResourceStatistics& a, ResourceStatistics& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResourceStatistics* New() const PROTOBUF_FINAL { return New(NULL); }

  ResourceStatistics* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ResourceStatistics& from);
  void MergeFrom(const ResourceStatistics& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ResourceStatistics* other);
  protected:
  explicit ResourceStatistics(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.TrafficControlStatistics net_traffic_control_statistics = 35;
  int net_traffic_control_statistics_size() const;
  void clear_net_traffic_control_statistics();
  static const int kNetTrafficControlStatisticsFieldNumber = 35;
  const ::mesos::TrafficControlStatistics& net_traffic_control_statistics(int index) const;
  ::mesos::TrafficControlStatistics* mutable_net_traffic_control_statistics(int index);
  ::mesos::TrafficControlStatistics* add_net_traffic_control_statistics();
  ::google::protobuf::RepeatedPtrField< ::mesos::TrafficControlStatistics >*
      mutable_net_traffic_control_statistics();
  const ::google::protobuf::RepeatedPtrField< ::mesos::TrafficControlStatistics >&
      net_traffic_control_statistics() const;

  // repeated .mesos.DiskStatistics disk_statistics = 43;
  int disk_statistics_size() const;
  void clear_disk_statistics();
  static const int kDiskStatisticsFieldNumber = 43;
  const ::mesos::DiskStatistics& disk_statistics(int index) const;
  ::mesos::DiskStatistics* mutable_disk_statistics(int index);
  ::mesos::DiskStatistics* add_disk_statistics();
  ::google::protobuf::RepeatedPtrField< ::mesos::DiskStatistics >*
      mutable_disk_statistics();
  const ::google::protobuf::RepeatedPtrField< ::mesos::DiskStatistics >&
      disk_statistics() const;

  // optional .mesos.PerfStatistics perf = 13;
  bool has_perf() const;
  void clear_perf();
  static const int kPerfFieldNumber = 13;
  private:
  void _slow_mutable_perf();
  public:
  const ::mesos::PerfStatistics& perf() const;
  ::mesos::PerfStatistics* release_perf();
  ::mesos::PerfStatistics* mutable_perf();
  void set_allocated_perf(::mesos::PerfStatistics* perf);
  void unsafe_arena_set_allocated_perf(
      ::mesos::PerfStatistics* perf);
  ::mesos::PerfStatistics* unsafe_arena_release_perf();

  // optional .mesos.SNMPStatistics net_snmp_statistics = 42;
  bool has_net_snmp_statistics() const;
  void clear_net_snmp_statistics();
  static const int kNetSnmpStatisticsFieldNumber = 42;
  private:
  void _slow_mutable_net_snmp_statistics();
  public:
  const ::mesos::SNMPStatistics& net_snmp_statistics() const;
  ::mesos::SNMPStatistics* release_net_snmp_statistics();
  ::mesos::SNMPStatistics* mutable_net_snmp_statistics();
  void set_allocated_net_snmp_statistics(::mesos::SNMPStatistics* net_snmp_statistics);
  void unsafe_arena_set_allocated_net_snmp_statistics(
      ::mesos::SNMPStatistics* net_snmp_statistics);
  ::mesos::SNMPStatistics* unsafe_arena_release_net_snmp_statistics();

  // optional .mesos.CgroupInfo.Blkio.Statistics blkio_statistics = 44;
  bool has_blkio_statistics() const;
  void clear_blkio_statistics();
  static const int kBlkioStatisticsFieldNumber = 44;
  private:
  void _slow_mutable_blkio_statistics();
  public:
  const ::mesos::CgroupInfo_Blkio_Statistics& blkio_statistics() const;
  ::mesos::CgroupInfo_Blkio_Statistics* release_blkio_statistics();
  ::mesos::CgroupInfo_Blkio_Statistics* mutable_blkio_statistics();
  void set_allocated_blkio_statistics(::mesos::CgroupInfo_Blkio_Statistics* blkio_statistics);
  void unsafe_arena_set_allocated_blkio_statistics(
      ::mesos::CgroupInfo_Blkio_Statistics* blkio_statistics);
  ::mesos::CgroupInfo_Blkio_Statistics* unsafe_arena_release_blkio_statistics();

  // required double timestamp = 1;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  double timestamp() const;
  void set_timestamp(double value);

  // optional double cpus_user_time_secs = 2;
  bool has_cpus_user_time_secs() const;
  void clear_cpus_user_time_secs();
  static const int kCpusUserTimeSecsFieldNumber = 2;
  double cpus_user_time_secs() const;
  void set_cpus_user_time_secs(double value);

  // optional double cpus_system_time_secs = 3;
  bool has_cpus_system_time_secs() const;
  void clear_cpus_system_time_secs();
  static const int kCpusSystemTimeSecsFieldNumber = 3;
  double cpus_system_time_secs() const;
  void set_cpus_system_time_secs(double value);

  // optional double cpus_limit = 4;
  bool has_cpus_limit() const;
  void clear_cpus_limit();
  static const int kCpusLimitFieldNumber = 4;
  double cpus_limit() const;
  void set_cpus_limit(double value);

  // optional uint64 mem_rss_bytes = 5;
  bool has_mem_rss_bytes() const;
  void clear_mem_rss_bytes();
  static const int kMemRssBytesFieldNumber = 5;
  ::google::protobuf::uint64 mem_rss_bytes() const;
  void set_mem_rss_bytes(::google::protobuf::uint64 value);

  // optional uint64 mem_limit_bytes = 6;
  bool has_mem_limit_bytes() const;
  void clear_mem_limit_bytes();
  static const int kMemLimitBytesFieldNumber = 6;
  ::google::protobuf::uint64 mem_limit_bytes() const;
  void set_mem_limit_bytes(::google::protobuf::uint64 value);

  // optional uint32 cpus_nr_periods = 7;
  bool has_cpus_nr_periods() const;
  void clear_cpus_nr_periods();
  static const int kCpusNrPeriodsFieldNumber = 7;
  ::google::protobuf::uint32 cpus_nr_periods() const;
  void set_cpus_nr_periods(::google::protobuf::uint32 value);

  // optional uint32 cpus_nr_throttled = 8;
  bool has_cpus_nr_throttled() const;
  void clear_cpus_nr_throttled();
  static const int kCpusNrThrottledFieldNumber = 8;
  ::google::protobuf::uint32 cpus_nr_throttled() const;
  void set_cpus_nr_throttled(::google::protobuf::uint32 value);

  // optional double cpus_throttled_time_secs = 9;
  bool has_cpus_throttled_time_secs() const;
  void clear_cpus_throttled_time_secs();
  static const int kCpusThrottledTimeSecsFieldNumber = 9;
  double cpus_throttled_time_secs() const;
  void set_cpus_throttled_time_secs(double value);

  // optional uint64 mem_file_bytes = 10;
  bool has_mem_file_bytes() const;
  void clear_mem_file_bytes();
  static const int kMemFileBytesFieldNumber = 10;
  ::google::protobuf::uint64 mem_file_bytes() const;
  void set_mem_file_bytes(::google::protobuf::uint64 value);

  // optional uint64 mem_anon_bytes = 11;
  bool has_mem_anon_bytes() const;
  void clear_mem_anon_bytes();
  static const int kMemAnonBytesFieldNumber = 11;
  ::google::protobuf::uint64 mem_anon_bytes() const;
  void set_mem_anon_bytes(::google::protobuf::uint64 value);

  // optional uint64 mem_mapped_file_bytes = 12;
  bool has_mem_mapped_file_bytes() const;
  void clear_mem_mapped_file_bytes();
  static const int kMemMappedFileBytesFieldNumber = 12;
  ::google::protobuf::uint64 mem_mapped_file_bytes() const;
  void set_mem_mapped_file_bytes(::google::protobuf::uint64 value);

  // optional uint64 net_rx_packets = 14;
  bool has_net_rx_packets() const;
  void clear_net_rx_packets();
  static const int kNetRxPacketsFieldNumber = 14;
  ::google::protobuf::uint64 net_rx_packets() const;
  void set_net_rx_packets(::google::protobuf::uint64 value);

  // optional uint64 net_rx_bytes = 15;
  bool has_net_rx_bytes() const;
  void clear_net_rx_bytes();
  static const int kNetRxBytesFieldNumber = 15;
  ::google::protobuf::uint64 net_rx_bytes() const;
  void set_net_rx_bytes(::google::protobuf::uint64 value);

  // optional uint64 net_rx_errors = 16;
  bool has_net_rx_errors() const;
  void clear_net_rx_errors();
  static const int kNetRxErrorsFieldNumber = 16;
  ::google::protobuf::uint64 net_rx_errors() const;
  void set_net_rx_errors(::google::protobuf::uint64 value);

  // optional uint64 net_rx_dropped = 17;
  bool has_net_rx_dropped() const;
  void clear_net_rx_dropped();
  static const int kNetRxDroppedFieldNumber = 17;
  ::google::protobuf::uint64 net_rx_dropped() const;
  void set_net_rx_dropped(::google::protobuf::uint64 value);

  // optional uint64 net_tx_packets = 18;
  bool has_net_tx_packets() const;
  void clear_net_tx_packets();
  static const int kNetTxPacketsFieldNumber = 18;
  ::google::protobuf::uint64 net_tx_packets() const;
  void set_net_tx_packets(::google::protobuf::uint64 value);

  // optional uint64 net_tx_bytes = 19;
  bool has_net_tx_bytes() const;
  void clear_net_tx_bytes();
  static const int kNetTxBytesFieldNumber = 19;
  ::google::protobuf::uint64 net_tx_bytes() const;
  void set_net_tx_bytes(::google::protobuf::uint64 value);

  // optional uint64 net_tx_errors = 20;
  bool has_net_tx_errors() const;
  void clear_net_tx_errors();
  static const int kNetTxErrorsFieldNumber = 20;
  ::google::protobuf::uint64 net_tx_errors() const;
  void set_net_tx_errors(::google::protobuf::uint64 value);

  // optional uint64 net_tx_dropped = 21;
  bool has_net_tx_dropped() const;
  void clear_net_tx_dropped();
  static const int kNetTxDroppedFieldNumber = 21;
  ::google::protobuf::uint64 net_tx_dropped() const;
  void set_net_tx_dropped(::google::protobuf::uint64 value);

  // optional double net_tcp_rtt_microsecs_p50 = 22;
  bool has_net_tcp_rtt_microsecs_p50() const;
  void clear_net_tcp_rtt_microsecs_p50();
  static const int kNetTcpRttMicrosecsP50FieldNumber = 22;
  double net_tcp_rtt_microsecs_p50() const;
  void set_net_tcp_rtt_microsecs_p50(double value);

  // optional double net_tcp_rtt_microsecs_p90 = 23;
  bool has_net_tcp_rtt_microsecs_p90() const;
  void clear_net_tcp_rtt_microsecs_p90();
  static const int kNetTcpRttMicrosecsP90FieldNumber = 23;
  double net_tcp_rtt_microsecs_p90() const;
  void set_net_tcp_rtt_microsecs_p90(double value);

  // optional double net_tcp_rtt_microsecs_p95 = 24;
  bool has_net_tcp_rtt_microsecs_p95() const;
  void clear_net_tcp_rtt_microsecs_p95();
  static const int kNetTcpRttMicrosecsP95FieldNumber = 24;
  double net_tcp_rtt_microsecs_p95() const;
  void set_net_tcp_rtt_microsecs_p95(double value);

  // optional double net_tcp_rtt_microsecs_p99 = 25;
  bool has_net_tcp_rtt_microsecs_p99() const;
  void clear_net_tcp_rtt_microsecs_p99();
  static const int kNetTcpRttMicrosecsP99FieldNumber = 25;
  double net_tcp_rtt_microsecs_p99() const;
  void set_net_tcp_rtt_microsecs_p99(double value);

  // optional uint64 disk_limit_bytes = 26;
  bool has_disk_limit_bytes() const;
  void clear_disk_limit_bytes();
  static const int kDiskLimitBytesFieldNumber = 26;
  ::google::protobuf::uint64 disk_limit_bytes() const;
  void set_disk_limit_bytes(::google::protobuf::uint64 value);

  // optional uint64 disk_used_bytes = 27;
  bool has_disk_used_bytes() const;
  void clear_disk_used_bytes();
  static const int kDiskUsedBytesFieldNumber = 27;
  ::google::protobuf::uint64 disk_used_bytes() const;
  void set_disk_used_bytes(::google::protobuf::uint64 value);

  // optional double net_tcp_active_connections = 28;
  bool has_net_tcp_active_connections() const;
  void clear_net_tcp_active_connections();
  static const int kNetTcpActiveConnectionsFieldNumber = 28;
  double net_tcp_active_connections() const;
  void set_net_tcp_active_connections(double value);

  // optional double net_tcp_time_wait_connections = 29;
  bool has_net_tcp_time_wait_connections() const;
  void clear_net_tcp_time_wait_connections();
  static const int kNetTcpTimeWaitConnectionsFieldNumber = 29;
  double net_tcp_time_wait_connections() const;
  void set_net_tcp_time_wait_connections(double value);

  // optional uint32 processes = 30;
  bool has_processes() const;
  void clear_processes();
  static const int kProcessesFieldNumber = 30;
  ::google::protobuf::uint32 processes() const;
  void set_processes(::google::protobuf::uint32 value);

  // optional uint32 threads = 31;
  bool has_threads() const;
  void clear_threads();
  static const int kThreadsFieldNumber = 31;
  ::google::protobuf::uint32 threads() const;
  void set_threads(::google::protobuf::uint32 value);

  // optional uint64 mem_low_pressure_counter = 32;
  bool has_mem_low_pressure_counter() const;
  void clear_mem_low_pressure_counter();
  static const int kMemLowPressureCounterFieldNumber = 32;
  ::google::protobuf::uint64 mem_low_pressure_counter() const;
  void set_mem_low_pressure_counter(::google::protobuf::uint64 value);

  // optional uint64 mem_medium_pressure_counter = 33;
  bool has_mem_medium_pressure_counter() const;
  void clear_mem_medium_pressure_counter();
  static const int kMemMediumPressureCounterFieldNumber = 33;
  ::google::protobuf::uint64 mem_medium_pressure_counter() const;
  void set_mem_medium_pressure_counter(::google::protobuf::uint64 value);

  // optional uint64 mem_critical_pressure_counter = 34;
  bool has_mem_critical_pressure_counter() const;
  void clear_mem_critical_pressure_counter();
  static const int kMemCriticalPressureCounterFieldNumber = 34;
  ::google::protobuf::uint64 mem_critical_pressure_counter() const;
  void set_mem_critical_pressure_counter(::google::protobuf::uint64 value);

  // optional uint64 mem_total_bytes = 36;
  bool has_mem_total_bytes() const;
  void clear_mem_total_bytes();
  static const int kMemTotalBytesFieldNumber = 36;
  ::google::protobuf::uint64 mem_total_bytes() const;
  void set_mem_total_bytes(::google::protobuf::uint64 value);

  // optional uint64 mem_total_memsw_bytes = 37;
  bool has_mem_total_memsw_bytes() const;
  void clear_mem_total_memsw_bytes();
  static const int kMemTotalMemswBytesFieldNumber = 37;
  ::google::protobuf::uint64 mem_total_memsw_bytes() const;
  void set_mem_total_memsw_bytes(::google::protobuf::uint64 value);

  // optional uint64 mem_soft_limit_bytes = 38;
  bool has_mem_soft_limit_bytes() const;
  void clear_mem_soft_limit_bytes();
  static const int kMemSoftLimitBytesFieldNumber = 38;
  ::google::protobuf::uint64 mem_soft_limit_bytes() const;
  void set_mem_soft_limit_bytes(::google::protobuf::uint64 value);

  // optional uint64 mem_cache_bytes = 39;
  bool has_mem_cache_bytes() const;
  void clear_mem_cache_bytes();
  static const int kMemCacheBytesFieldNumber = 39;
  ::google::protobuf::uint64 mem_cache_bytes() const;
  void set_mem_cache_bytes(::google::protobuf::uint64 value);

  // optional uint64 mem_swap_bytes = 40;
  bool has_mem_swap_bytes() const;
  void clear_mem_swap_bytes();
  static const int kMemSwapBytesFieldNumber = 40;
  ::google::protobuf::uint64 mem_swap_bytes() const;
  void set_mem_swap_bytes(::google::protobuf::uint64 value);

  // optional uint64 mem_unevictable_bytes = 41;
  bool has_mem_unevictable_bytes() const;
  void clear_mem_unevictable_bytes();
  static const int kMemUnevictableBytesFieldNumber = 41;
  ::google::protobuf::uint64 mem_unevictable_bytes() const;
  void set_mem_unevictable_bytes(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:mesos.ResourceStatistics)
 private:
  void set_has_timestamp();
  void clear_has_timestamp();
  void set_has_processes();
  void clear_has_processes();
  void set_has_threads();
  void clear_has_threads();
  void set_has_cpus_user_time_secs();
  void clear_has_cpus_user_time_secs();
  void set_has_cpus_system_time_secs();
  void clear_has_cpus_system_time_secs();
  void set_has_cpus_limit();
  void clear_has_cpus_limit();
  void set_has_cpus_nr_periods();
  void clear_has_cpus_nr_periods();
  void set_has_cpus_nr_throttled();
  void clear_has_cpus_nr_throttled();
  void set_has_cpus_throttled_time_secs();
  void clear_has_cpus_throttled_time_secs();
  void set_has_mem_total_bytes();
  void clear_has_mem_total_bytes();
  void set_has_mem_total_memsw_bytes();
  void clear_has_mem_total_memsw_bytes();
  void set_has_mem_limit_bytes();
  void clear_has_mem_limit_bytes();
  void set_has_mem_soft_limit_bytes();
  void clear_has_mem_soft_limit_bytes();
  void set_has_mem_file_bytes();
  void clear_has_mem_file_bytes();
  void set_has_mem_anon_bytes();
  void clear_has_mem_anon_bytes();
  void set_has_mem_cache_bytes();
  void clear_has_mem_cache_bytes();
  void set_has_mem_rss_bytes();
  void clear_has_mem_rss_bytes();
  void set_has_mem_mapped_file_bytes();
  void clear_has_mem_mapped_file_bytes();
  void set_has_mem_swap_bytes();
  void clear_has_mem_swap_bytes();
  void set_has_mem_unevictable_bytes();
  void clear_has_mem_unevictable_bytes();
  void set_has_mem_low_pressure_counter();
  void clear_has_mem_low_pressure_counter();
  void set_has_mem_medium_pressure_counter();
  void clear_has_mem_medium_pressure_counter();
  void set_has_mem_critical_pressure_counter();
  void clear_has_mem_critical_pressure_counter();
  void set_has_disk_limit_bytes();
  void clear_has_disk_limit_bytes();
  void set_has_disk_used_bytes();
  void clear_has_disk_used_bytes();
  void set_has_blkio_statistics();
  void clear_has_blkio_statistics();
  void set_has_perf();
  void clear_has_perf();
  void set_has_net_rx_packets();
  void clear_has_net_rx_packets();
  void set_has_net_rx_bytes();
  void clear_has_net_rx_bytes();
  void set_has_net_rx_errors();
  void clear_has_net_rx_errors();
  void set_has_net_rx_dropped();
  void clear_has_net_rx_dropped();
  void set_has_net_tx_packets();
  void clear_has_net_tx_packets();
  void set_has_net_tx_bytes();
  void clear_has_net_tx_bytes();
  void set_has_net_tx_errors();
  void clear_has_net_tx_errors();
  void set_has_net_tx_dropped();
  void clear_has_net_tx_dropped();
  void set_has_net_tcp_rtt_microsecs_p50();
  void clear_has_net_tcp_rtt_microsecs_p50();
  void set_has_net_tcp_rtt_microsecs_p90();
  void clear_has_net_tcp_rtt_microsecs_p90();
  void set_has_net_tcp_rtt_microsecs_p95();
  void clear_has_net_tcp_rtt_microsecs_p95();
  void set_has_net_tcp_rtt_microsecs_p99();
  void clear_has_net_tcp_rtt_microsecs_p99();
  void set_has_net_tcp_active_connections();
  void clear_has_net_tcp_active_connections();
  void set_has_net_tcp_time_wait_connections();
  void clear_has_net_tcp_time_wait_connections();
  void set_has_net_snmp_statistics();
  void clear_has_net_snmp_statistics();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<2> _has_bits_;
  ::google::protobuf::RepeatedPtrField< ::mesos::TrafficControlStatistics > net_traffic_control_statistics_;
  ::google::protobuf::RepeatedPtrField< ::mesos::DiskStatistics > disk_statistics_;
  ::mesos::PerfStatistics* perf_;
  ::mesos::SNMPStatistics* net_snmp_statistics_;
  ::mesos::CgroupInfo_Blkio_Statistics* blkio_statistics_;
  double timestamp_;
  double cpus_user_time_secs_;
  double cpus_system_time_secs_;
  double cpus_limit_;
  ::google::protobuf::uint64 mem_rss_bytes_;
  ::google::protobuf::uint64 mem_limit_bytes_;
  ::google::protobuf::uint32 cpus_nr_periods_;
  ::google::protobuf::uint32 cpus_nr_throttled_;
  double cpus_throttled_time_secs_;
  ::google::protobuf::uint64 mem_file_bytes_;
  ::google::protobuf::uint64 mem_anon_bytes_;
  ::google::protobuf::uint64 mem_mapped_file_bytes_;
  ::google::protobuf::uint64 net_rx_packets_;
  ::google::protobuf::uint64 net_rx_bytes_;
  ::google::protobuf::uint64 net_rx_errors_;
  ::google::protobuf::uint64 net_rx_dropped_;
  ::google::protobuf::uint64 net_tx_packets_;
  ::google::protobuf::uint64 net_tx_bytes_;
  ::google::protobuf::uint64 net_tx_errors_;
  ::google::protobuf::uint64 net_tx_dropped_;
  double net_tcp_rtt_microsecs_p50_;
  double net_tcp_rtt_microsecs_p90_;
  double net_tcp_rtt_microsecs_p95_;
  double net_tcp_rtt_microsecs_p99_;
  ::google::protobuf::uint64 disk_limit_bytes_;
  ::google::protobuf::uint64 disk_used_bytes_;
  double net_tcp_active_connections_;
  double net_tcp_time_wait_connections_;
  ::google::protobuf::uint32 processes_;
  ::google::protobuf::uint32 threads_;
  ::google::protobuf::uint64 mem_low_pressure_counter_;
  ::google::protobuf::uint64 mem_medium_pressure_counter_;
  ::google::protobuf::uint64 mem_critical_pressure_counter_;
  ::google::protobuf::uint64 mem_total_bytes_;
  ::google::protobuf::uint64 mem_total_memsw_bytes_;
  ::google::protobuf::uint64 mem_soft_limit_bytes_;
  ::google::protobuf::uint64 mem_cache_bytes_;
  ::google::protobuf::uint64 mem_swap_bytes_;
  ::google::protobuf::uint64 mem_unevictable_bytes_;
  mutable int _cached_size_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsResourceStatisticsImpl();
};
// -------------------------------------------------------------------

class ResourceUsage_Executor_Task : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.ResourceUsage.Executor.Task) */ {
 public:
  ResourceUsage_Executor_Task();
  virtual ~ResourceUsage_Executor_Task();

  ResourceUsage_Executor_Task(const ResourceUsage_Executor_Task& from);

  inline ResourceUsage_Executor_Task& operator=(const ResourceUsage_Executor_Task& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResourceUsage_Executor_Task(ResourceUsage_Executor_Task&& from) noexcept
    : ResourceUsage_Executor_Task() {
    *this = ::std::move(from);
  }

  inline ResourceUsage_Executor_Task& operator=(ResourceUsage_Executor_Task&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResourceUsage_Executor_Task& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResourceUsage_Executor_Task* internal_default_instance() {
    return reinterpret_cast<const ResourceUsage_Executor_Task*>(
               &_ResourceUsage_Executor_Task_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    65;

  void UnsafeArenaSwap(ResourceUsage_Executor_Task* other);
  void Swap(ResourceUsage_Executor_Task* other);
  friend void swap(ResourceUsage_Executor_Task& a, ResourceUsage_Executor_Task& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResourceUsage_Executor_Task* New() const PROTOBUF_FINAL { return New(NULL); }

  ResourceUsage_Executor_Task* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ResourceUsage_Executor_Task& from);
  void MergeFrom(const ResourceUsage_Executor_Task& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ResourceUsage_Executor_Task* other);
  protected:
  explicit ResourceUsage_Executor_Task(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.Resource resources = 3;
  int resources_size() const;
  void clear_resources();
  static const int kResourcesFieldNumber = 3;
  const ::mesos::Resource& resources(int index) const;
  ::mesos::Resource* mutable_resources(int index);
  ::mesos::Resource* add_resources();
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
      mutable_resources();
  const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
      resources() const;

  // required string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_name();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      ::std::string* name);

  // required .mesos.TaskID id = 2;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 2;
  private:
  void _slow_mutable_id();
  public:
  const ::mesos::TaskID& id() const;
  ::mesos::TaskID* release_id();
  ::mesos::TaskID* mutable_id();
  void set_allocated_id(::mesos::TaskID* id);
  void unsafe_arena_set_allocated_id(
      ::mesos::TaskID* id);
  ::mesos::TaskID* unsafe_arena_release_id();

  // optional .mesos.Labels labels = 4;
  bool has_labels() const;
  void clear_labels();
  static const int kLabelsFieldNumber = 4;
  private:
  void _slow_mutable_labels();
  public:
  const ::mesos::Labels& labels() const;
  ::mesos::Labels* release_labels();
  ::mesos::Labels* mutable_labels();
  void set_allocated_labels(::mesos::Labels* labels);
  void unsafe_arena_set_allocated_labels(
      ::mesos::Labels* labels);
  ::mesos::Labels* unsafe_arena_release_labels();

  // @@protoc_insertion_point(class_scope:mesos.ResourceUsage.Executor.Task)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_id();
  void clear_has_id();
  void set_has_labels();
  void clear_has_labels();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource > resources_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::mesos::TaskID* id_;
  ::mesos::Labels* labels_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsResourceUsage_Executor_TaskImpl();
};
// -------------------------------------------------------------------

class ResourceUsage_Executor : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.ResourceUsage.Executor) */ {
 public:
  ResourceUsage_Executor();
  virtual ~ResourceUsage_Executor();

  ResourceUsage_Executor(const ResourceUsage_Executor& from);

  inline ResourceUsage_Executor& operator=(const ResourceUsage_Executor& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResourceUsage_Executor(ResourceUsage_Executor&& from) noexcept
    : ResourceUsage_Executor() {
    *this = ::std::move(from);
  }

  inline ResourceUsage_Executor& operator=(ResourceUsage_Executor&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResourceUsage_Executor& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResourceUsage_Executor* internal_default_instance() {
    return reinterpret_cast<const ResourceUsage_Executor*>(
               &_ResourceUsage_Executor_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    66;

  void UnsafeArenaSwap(ResourceUsage_Executor* other);
  void Swap(ResourceUsage_Executor* other);
  friend void swap(ResourceUsage_Executor& a, ResourceUsage_Executor& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResourceUsage_Executor* New() const PROTOBUF_FINAL { return New(NULL); }

  ResourceUsage_Executor* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ResourceUsage_Executor& from);
  void MergeFrom(const ResourceUsage_Executor& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ResourceUsage_Executor* other);
  protected:
  explicit ResourceUsage_Executor(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef ResourceUsage_Executor_Task Task;

  // accessors -------------------------------------------------------

  // repeated .mesos.Resource allocated = 2;
  int allocated_size() const;
  void clear_allocated();
  static const int kAllocatedFieldNumber = 2;
  const ::mesos::Resource& allocated(int index) const;
  ::mesos::Resource* mutable_allocated(int index);
  ::mesos::Resource* add_allocated();
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
      mutable_allocated();
  const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
      allocated() const;

  // repeated .mesos.ResourceUsage.Executor.Task tasks = 5;
  int tasks_size() const;
  void clear_tasks();
  static const int kTasksFieldNumber = 5;
  const ::mesos::ResourceUsage_Executor_Task& tasks(int index) const;
  ::mesos::ResourceUsage_Executor_Task* mutable_tasks(int index);
  ::mesos::ResourceUsage_Executor_Task* add_tasks();
  ::google::protobuf::RepeatedPtrField< ::mesos::ResourceUsage_Executor_Task >*
      mutable_tasks();
  const ::google::protobuf::RepeatedPtrField< ::mesos::ResourceUsage_Executor_Task >&
      tasks() const;

  // required .mesos.ExecutorInfo executor_info = 1;
  bool has_executor_info() const;
  void clear_executor_info();
  static const int kExecutorInfoFieldNumber = 1;
  private:
  void _slow_mutable_executor_info();
  public:
  const ::mesos::ExecutorInfo& executor_info() const;
  ::mesos::ExecutorInfo* release_executor_info();
  ::mesos::ExecutorInfo* mutable_executor_info();
  void set_allocated_executor_info(::mesos::ExecutorInfo* executor_info);
  void unsafe_arena_set_allocated_executor_info(
      ::mesos::ExecutorInfo* executor_info);
  ::mesos::ExecutorInfo* unsafe_arena_release_executor_info();

  // optional .mesos.ResourceStatistics statistics = 3;
  bool has_statistics() const;
  void clear_statistics();
  static const int kStatisticsFieldNumber = 3;
  private:
  void _slow_mutable_statistics();
  public:
  const ::mesos::ResourceStatistics& statistics() const;
  ::mesos::ResourceStatistics* release_statistics();
  ::mesos::ResourceStatistics* mutable_statistics();
  void set_allocated_statistics(::mesos::ResourceStatistics* statistics);
  void unsafe_arena_set_allocated_statistics(
      ::mesos::ResourceStatistics* statistics);
  ::mesos::ResourceStatistics* unsafe_arena_release_statistics();

  // required .mesos.ContainerID container_id = 4;
  bool has_container_id() const;
  void clear_container_id();
  static const int kContainerIdFieldNumber = 4;
  private:
  void _slow_mutable_container_id();
  public:
  const ::mesos::ContainerID& container_id() const;
  ::mesos::ContainerID* release_container_id();
  ::mesos::ContainerID* mutable_container_id();
  void set_allocated_container_id(::mesos::ContainerID* container_id);
  void unsafe_arena_set_allocated_container_id(
      ::mesos::ContainerID* container_id);
  ::mesos::ContainerID* unsafe_arena_release_container_id();

  // @@protoc_insertion_point(class_scope:mesos.ResourceUsage.Executor)
 private:
  void set_has_executor_info();
  void clear_has_executor_info();
  void set_has_statistics();
  void clear_has_statistics();
  void set_has_container_id();
  void clear_has_container_id();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource > allocated_;
  ::google::protobuf::RepeatedPtrField< ::mesos::ResourceUsage_Executor_Task > tasks_;
  ::mesos::ExecutorInfo* executor_info_;
  ::mesos::ResourceStatistics* statistics_;
  ::mesos::ContainerID* container_id_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsResourceUsage_ExecutorImpl();
};
// -------------------------------------------------------------------

class ResourceUsage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.ResourceUsage) */ {
 public:
  ResourceUsage();
  virtual ~ResourceUsage();

  ResourceUsage(const ResourceUsage& from);

  inline ResourceUsage& operator=(const ResourceUsage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResourceUsage(ResourceUsage&& from) noexcept
    : ResourceUsage() {
    *this = ::std::move(from);
  }

  inline ResourceUsage& operator=(ResourceUsage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResourceUsage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResourceUsage* internal_default_instance() {
    return reinterpret_cast<const ResourceUsage*>(
               &_ResourceUsage_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    67;

  void UnsafeArenaSwap(ResourceUsage* other);
  void Swap(ResourceUsage* other);
  friend void swap(ResourceUsage& a, ResourceUsage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResourceUsage* New() const PROTOBUF_FINAL { return New(NULL); }

  ResourceUsage* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ResourceUsage& from);
  void MergeFrom(const ResourceUsage& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ResourceUsage* other);
  protected:
  explicit ResourceUsage(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef ResourceUsage_Executor Executor;

  // accessors -------------------------------------------------------

  // repeated .mesos.ResourceUsage.Executor executors = 1;
  int executors_size() const;
  void clear_executors();
  static const int kExecutorsFieldNumber = 1;
  const ::mesos::ResourceUsage_Executor& executors(int index) const;
  ::mesos::ResourceUsage_Executor* mutable_executors(int index);
  ::mesos::ResourceUsage_Executor* add_executors();
  ::google::protobuf::RepeatedPtrField< ::mesos::ResourceUsage_Executor >*
      mutable_executors();
  const ::google::protobuf::RepeatedPtrField< ::mesos::ResourceUsage_Executor >&
      executors() const;

  // repeated .mesos.Resource total = 2;
  int total_size() const;
  void clear_total();
  static const int kTotalFieldNumber = 2;
  const ::mesos::Resource& total(int index) const;
  ::mesos::Resource* mutable_total(int index);
  ::mesos::Resource* add_total();
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
      mutable_total();
  const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
      total() const;

  // @@protoc_insertion_point(class_scope:mesos.ResourceUsage)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::ResourceUsage_Executor > executors_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource > total_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsResourceUsageImpl();
};
// -------------------------------------------------------------------

class PerfStatistics : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.PerfStatistics) */ {
 public:
  PerfStatistics();
  virtual ~PerfStatistics();

  PerfStatistics(const PerfStatistics& from);

  inline PerfStatistics& operator=(const PerfStatistics& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PerfStatistics(PerfStatistics&& from) noexcept
    : PerfStatistics() {
    *this = ::std::move(from);
  }

  inline PerfStatistics& operator=(PerfStatistics&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const PerfStatistics& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PerfStatistics* internal_default_instance() {
    return reinterpret_cast<const PerfStatistics*>(
               &_PerfStatistics_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    68;

  void UnsafeArenaSwap(PerfStatistics* other);
  void Swap(PerfStatistics* other);
  friend void swap(PerfStatistics& a, PerfStatistics& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PerfStatistics* New() const PROTOBUF_FINAL { return New(NULL); }

  PerfStatistics* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PerfStatistics& from);
  void MergeFrom(const PerfStatistics& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PerfStatistics* other);
  protected:
  explicit PerfStatistics(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double timestamp = 1;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  double timestamp() const;
  void set_timestamp(double value);

  // required double duration = 2;
  bool has_duration() const;
  void clear_duration();
  static const int kDurationFieldNumber = 2;
  double duration() const;
  void set_duration(double value);

  // optional uint64 cycles = 3;
  bool has_cycles() const;
  void clear_cycles();
  static const int kCyclesFieldNumber = 3;
  ::google::protobuf::uint64 cycles() const;
  void set_cycles(::google::protobuf::uint64 value);

  // optional uint64 stalled_cycles_frontend = 4;
  bool has_stalled_cycles_frontend() const;
  void clear_stalled_cycles_frontend();
  static const int kStalledCyclesFrontendFieldNumber = 4;
  ::google::protobuf::uint64 stalled_cycles_frontend() const;
  void set_stalled_cycles_frontend(::google::protobuf::uint64 value);

  // optional uint64 stalled_cycles_backend = 5;
  bool has_stalled_cycles_backend() const;
  void clear_stalled_cycles_backend();
  static const int kStalledCyclesBackendFieldNumber = 5;
  ::google::protobuf::uint64 stalled_cycles_backend() const;
  void set_stalled_cycles_backend(::google::protobuf::uint64 value);

  // optional uint64 instructions = 6;
  bool has_instructions() const;
  void clear_instructions();
  static const int kInstructionsFieldNumber = 6;
  ::google::protobuf::uint64 instructions() const;
  void set_instructions(::google::protobuf::uint64 value);

  // optional uint64 cache_references = 7;
  bool has_cache_references() const;
  void clear_cache_references();
  static const int kCacheReferencesFieldNumber = 7;
  ::google::protobuf::uint64 cache_references() const;
  void set_cache_references(::google::protobuf::uint64 value);

  // optional uint64 cache_misses = 8;
  bool has_cache_misses() const;
  void clear_cache_misses();
  static const int kCacheMissesFieldNumber = 8;
  ::google::protobuf::uint64 cache_misses() const;
  void set_cache_misses(::google::protobuf::uint64 value);

  // optional uint64 branches = 9;
  bool has_branches() const;
  void clear_branches();
  static const int kBranchesFieldNumber = 9;
  ::google::protobuf::uint64 branches() const;
  void set_branches(::google::protobuf::uint64 value);

  // optional uint64 branch_misses = 10;
  bool has_branch_misses() const;
  void clear_branch_misses();
  static const int kBranchMissesFieldNumber = 10;
  ::google::protobuf::uint64 branch_misses() const;
  void set_branch_misses(::google::protobuf::uint64 value);

  // optional uint64 bus_cycles = 11;
  bool has_bus_cycles() const;
  void clear_bus_cycles();
  static const int kBusCyclesFieldNumber = 11;
  ::google::protobuf::uint64 bus_cycles() const;
  void set_bus_cycles(::google::protobuf::uint64 value);

  // optional uint64 ref_cycles = 12;
  bool has_ref_cycles() const;
  void clear_ref_cycles();
  static const int kRefCyclesFieldNumber = 12;
  ::google::protobuf::uint64 ref_cycles() const;
  void set_ref_cycles(::google::protobuf::uint64 value);

  // optional double cpu_clock = 13;
  bool has_cpu_clock() const;
  void clear_cpu_clock();
  static const int kCpuClockFieldNumber = 13;
  double cpu_clock() const;
  void set_cpu_clock(double value);

  // optional double task_clock = 14;
  bool has_task_clock() const;
  void clear_task_clock();
  static const int kTaskClockFieldNumber = 14;
  double task_clock() const;
  void set_task_clock(double value);

  // optional uint64 page_faults = 15;
  bool has_page_faults() const;
  void clear_page_faults();
  static const int kPageFaultsFieldNumber = 15;
  ::google::protobuf::uint64 page_faults() const;
  void set_page_faults(::google::protobuf::uint64 value);

  // optional uint64 minor_faults = 16;
  bool has_minor_faults() const;
  void clear_minor_faults();
  static const int kMinorFaultsFieldNumber = 16;
  ::google::protobuf::uint64 minor_faults() const;
  void set_minor_faults(::google::protobuf::uint64 value);

  // optional uint64 major_faults = 17;
  bool has_major_faults() const;
  void clear_major_faults();
  static const int kMajorFaultsFieldNumber = 17;
  ::google::protobuf::uint64 major_faults() const;
  void set_major_faults(::google::protobuf::uint64 value);

  // optional uint64 context_switches = 18;
  bool has_context_switches() const;
  void clear_context_switches();
  static const int kContextSwitchesFieldNumber = 18;
  ::google::protobuf::uint64 context_switches() const;
  void set_context_switches(::google::protobuf::uint64 value);

  // optional uint64 cpu_migrations = 19;
  bool has_cpu_migrations() const;
  void clear_cpu_migrations();
  static const int kCpuMigrationsFieldNumber = 19;
  ::google::protobuf::uint64 cpu_migrations() const;
  void set_cpu_migrations(::google::protobuf::uint64 value);

  // optional uint64 alignment_faults = 20;
  bool has_alignment_faults() const;
  void clear_alignment_faults();
  static const int kAlignmentFaultsFieldNumber = 20;
  ::google::protobuf::uint64 alignment_faults() const;
  void set_alignment_faults(::google::protobuf::uint64 value);

  // optional uint64 emulation_faults = 21;
  bool has_emulation_faults() const;
  void clear_emulation_faults();
  static const int kEmulationFaultsFieldNumber = 21;
  ::google::protobuf::uint64 emulation_faults() const;
  void set_emulation_faults(::google::protobuf::uint64 value);

  // optional uint64 l1_dcache_loads = 22;
  bool has_l1_dcache_loads() const;
  void clear_l1_dcache_loads();
  static const int kL1DcacheLoadsFieldNumber = 22;
  ::google::protobuf::uint64 l1_dcache_loads() const;
  void set_l1_dcache_loads(::google::protobuf::uint64 value);

  // optional uint64 l1_dcache_load_misses = 23;
  bool has_l1_dcache_load_misses() const;
  void clear_l1_dcache_load_misses();
  static const int kL1DcacheLoadMissesFieldNumber = 23;
  ::google::protobuf::uint64 l1_dcache_load_misses() const;
  void set_l1_dcache_load_misses(::google::protobuf::uint64 value);

  // optional uint64 l1_dcache_stores = 24;
  bool has_l1_dcache_stores() const;
  void clear_l1_dcache_stores();
  static const int kL1DcacheStoresFieldNumber = 24;
  ::google::protobuf::uint64 l1_dcache_stores() const;
  void set_l1_dcache_stores(::google::protobuf::uint64 value);

  // optional uint64 l1_dcache_store_misses = 25;
  bool has_l1_dcache_store_misses() const;
  void clear_l1_dcache_store_misses();
  static const int kL1DcacheStoreMissesFieldNumber = 25;
  ::google::protobuf::uint64 l1_dcache_store_misses() const;
  void set_l1_dcache_store_misses(::google::protobuf::uint64 value);

  // optional uint64 l1_dcache_prefetches = 26;
  bool has_l1_dcache_prefetches() const;
  void clear_l1_dcache_prefetches();
  static const int kL1DcachePrefetchesFieldNumber = 26;
  ::google::protobuf::uint64 l1_dcache_prefetches() const;
  void set_l1_dcache_prefetches(::google::protobuf::uint64 value);

  // optional uint64 l1_dcache_prefetch_misses = 27;
  bool has_l1_dcache_prefetch_misses() const;
  void clear_l1_dcache_prefetch_misses();
  static const int kL1DcachePrefetchMissesFieldNumber = 27;
  ::google::protobuf::uint64 l1_dcache_prefetch_misses() const;
  void set_l1_dcache_prefetch_misses(::google::protobuf::uint64 value);

  // optional uint64 l1_icache_loads = 28;
  bool has_l1_icache_loads() const;
  void clear_l1_icache_loads();
  static const int kL1IcacheLoadsFieldNumber = 28;
  ::google::protobuf::uint64 l1_icache_loads() const;
  void set_l1_icache_loads(::google::protobuf::uint64 value);

  // optional uint64 l1_icache_load_misses = 29;
  bool has_l1_icache_load_misses() const;
  void clear_l1_icache_load_misses();
  static const int kL1IcacheLoadMissesFieldNumber = 29;
  ::google::protobuf::uint64 l1_icache_load_misses() const;
  void set_l1_icache_load_misses(::google::protobuf::uint64 value);

  // optional uint64 l1_icache_prefetches = 30;
  bool has_l1_icache_prefetches() const;
  void clear_l1_icache_prefetches();
  static const int kL1IcachePrefetchesFieldNumber = 30;
  ::google::protobuf::uint64 l1_icache_prefetches() const;
  void set_l1_icache_prefetches(::google::protobuf::uint64 value);

  // optional uint64 l1_icache_prefetch_misses = 31;
  bool has_l1_icache_prefetch_misses() const;
  void clear_l1_icache_prefetch_misses();
  static const int kL1IcachePrefetchMissesFieldNumber = 31;
  ::google::protobuf::uint64 l1_icache_prefetch_misses() const;
  void set_l1_icache_prefetch_misses(::google::protobuf::uint64 value);

  // optional uint64 llc_loads = 32;
  bool has_llc_loads() const;
  void clear_llc_loads();
  static const int kLlcLoadsFieldNumber = 32;
  ::google::protobuf::uint64 llc_loads() const;
  void set_llc_loads(::google::protobuf::uint64 value);

  // optional uint64 llc_load_misses = 33;
  bool has_llc_load_misses() const;
  void clear_llc_load_misses();
  static const int kLlcLoadMissesFieldNumber = 33;
  ::google::protobuf::uint64 llc_load_misses() const;
  void set_llc_load_misses(::google::protobuf::uint64 value);

  // optional uint64 llc_stores = 34;
  bool has_llc_stores() const;
  void clear_llc_stores();
  static const int kLlcStoresFieldNumber = 34;
  ::google::protobuf::uint64 llc_stores() const;
  void set_llc_stores(::google::protobuf::uint64 value);

  // optional uint64 llc_store_misses = 35;
  bool has_llc_store_misses() const;
  void clear_llc_store_misses();
  static const int kLlcStoreMissesFieldNumber = 35;
  ::google::protobuf::uint64 llc_store_misses() const;
  void set_llc_store_misses(::google::protobuf::uint64 value);

  // optional uint64 llc_prefetches = 36;
  bool has_llc_prefetches() const;
  void clear_llc_prefetches();
  static const int kLlcPrefetchesFieldNumber = 36;
  ::google::protobuf::uint64 llc_prefetches() const;
  void set_llc_prefetches(::google::protobuf::uint64 value);

  // optional uint64 llc_prefetch_misses = 37;
  bool has_llc_prefetch_misses() const;
  void clear_llc_prefetch_misses();
  static const int kLlcPrefetchMissesFieldNumber = 37;
  ::google::protobuf::uint64 llc_prefetch_misses() const;
  void set_llc_prefetch_misses(::google::protobuf::uint64 value);

  // optional uint64 dtlb_loads = 38;
  bool has_dtlb_loads() const;
  void clear_dtlb_loads();
  static const int kDtlbLoadsFieldNumber = 38;
  ::google::protobuf::uint64 dtlb_loads() const;
  void set_dtlb_loads(::google::protobuf::uint64 value);

  // optional uint64 dtlb_load_misses = 39;
  bool has_dtlb_load_misses() const;
  void clear_dtlb_load_misses();
  static const int kDtlbLoadMissesFieldNumber = 39;
  ::google::protobuf::uint64 dtlb_load_misses() const;
  void set_dtlb_load_misses(::google::protobuf::uint64 value);

  // optional uint64 dtlb_stores = 40;
  bool has_dtlb_stores() const;
  void clear_dtlb_stores();
  static const int kDtlbStoresFieldNumber = 40;
  ::google::protobuf::uint64 dtlb_stores() const;
  void set_dtlb_stores(::google::protobuf::uint64 value);

  // optional uint64 dtlb_store_misses = 41;
  bool has_dtlb_store_misses() const;
  void clear_dtlb_store_misses();
  static const int kDtlbStoreMissesFieldNumber = 41;
  ::google::protobuf::uint64 dtlb_store_misses() const;
  void set_dtlb_store_misses(::google::protobuf::uint64 value);

  // optional uint64 dtlb_prefetches = 42;
  bool has_dtlb_prefetches() const;
  void clear_dtlb_prefetches();
  static const int kDtlbPrefetchesFieldNumber = 42;
  ::google::protobuf::uint64 dtlb_prefetches() const;
  void set_dtlb_prefetches(::google::protobuf::uint64 value);

  // optional uint64 dtlb_prefetch_misses = 43;
  bool has_dtlb_prefetch_misses() const;
  void clear_dtlb_prefetch_misses();
  static const int kDtlbPrefetchMissesFieldNumber = 43;
  ::google::protobuf::uint64 dtlb_prefetch_misses() const;
  void set_dtlb_prefetch_misses(::google::protobuf::uint64 value);

  // optional uint64 itlb_loads = 44;
  bool has_itlb_loads() const;
  void clear_itlb_loads();
  static const int kItlbLoadsFieldNumber = 44;
  ::google::protobuf::uint64 itlb_loads() const;
  void set_itlb_loads(::google::protobuf::uint64 value);

  // optional uint64 itlb_load_misses = 45;
  bool has_itlb_load_misses() const;
  void clear_itlb_load_misses();
  static const int kItlbLoadMissesFieldNumber = 45;
  ::google::protobuf::uint64 itlb_load_misses() const;
  void set_itlb_load_misses(::google::protobuf::uint64 value);

  // optional uint64 branch_loads = 46;
  bool has_branch_loads() const;
  void clear_branch_loads();
  static const int kBranchLoadsFieldNumber = 46;
  ::google::protobuf::uint64 branch_loads() const;
  void set_branch_loads(::google::protobuf::uint64 value);

  // optional uint64 branch_load_misses = 47;
  bool has_branch_load_misses() const;
  void clear_branch_load_misses();
  static const int kBranchLoadMissesFieldNumber = 47;
  ::google::protobuf::uint64 branch_load_misses() const;
  void set_branch_load_misses(::google::protobuf::uint64 value);

  // optional uint64 node_loads = 48;
  bool has_node_loads() const;
  void clear_node_loads();
  static const int kNodeLoadsFieldNumber = 48;
  ::google::protobuf::uint64 node_loads() const;
  void set_node_loads(::google::protobuf::uint64 value);

  // optional uint64 node_load_misses = 49;
  bool has_node_load_misses() const;
  void clear_node_load_misses();
  static const int kNodeLoadMissesFieldNumber = 49;
  ::google::protobuf::uint64 node_load_misses() const;
  void set_node_load_misses(::google::protobuf::uint64 value);

  // optional uint64 node_stores = 50;
  bool has_node_stores() const;
  void clear_node_stores();
  static const int kNodeStoresFieldNumber = 50;
  ::google::protobuf::uint64 node_stores() const;
  void set_node_stores(::google::protobuf::uint64 value);

  // optional uint64 node_store_misses = 51;
  bool has_node_store_misses() const;
  void clear_node_store_misses();
  static const int kNodeStoreMissesFieldNumber = 51;
  ::google::protobuf::uint64 node_store_misses() const;
  void set_node_store_misses(::google::protobuf::uint64 value);

  // optional uint64 node_prefetches = 52;
  bool has_node_prefetches() const;
  void clear_node_prefetches();
  static const int kNodePrefetchesFieldNumber = 52;
  ::google::protobuf::uint64 node_prefetches() const;
  void set_node_prefetches(::google::protobuf::uint64 value);

  // optional uint64 node_prefetch_misses = 53;
  bool has_node_prefetch_misses() const;
  void clear_node_prefetch_misses();
  static const int kNodePrefetchMissesFieldNumber = 53;
  ::google::protobuf::uint64 node_prefetch_misses() const;
  void set_node_prefetch_misses(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:mesos.PerfStatistics)
 private:
  void set_has_timestamp();
  void clear_has_timestamp();
  void set_has_duration();
  void clear_has_duration();
  void set_has_cycles();
  void clear_has_cycles();
  void set_has_stalled_cycles_frontend();
  void clear_has_stalled_cycles_frontend();
  void set_has_stalled_cycles_backend();
  void clear_has_stalled_cycles_backend();
  void set_has_instructions();
  void clear_has_instructions();
  void set_has_cache_references();
  void clear_has_cache_references();
  void set_has_cache_misses();
  void clear_has_cache_misses();
  void set_has_branches();
  void clear_has_branches();
  void set_has_branch_misses();
  void clear_has_branch_misses();
  void set_has_bus_cycles();
  void clear_has_bus_cycles();
  void set_has_ref_cycles();
  void clear_has_ref_cycles();
  void set_has_cpu_clock();
  void clear_has_cpu_clock();
  void set_has_task_clock();
  void clear_has_task_clock();
  void set_has_page_faults();
  void clear_has_page_faults();
  void set_has_minor_faults();
  void clear_has_minor_faults();
  void set_has_major_faults();
  void clear_has_major_faults();
  void set_has_context_switches();
  void clear_has_context_switches();
  void set_has_cpu_migrations();
  void clear_has_cpu_migrations();
  void set_has_alignment_faults();
  void clear_has_alignment_faults();
  void set_has_emulation_faults();
  void clear_has_emulation_faults();
  void set_has_l1_dcache_loads();
  void clear_has_l1_dcache_loads();
  void set_has_l1_dcache_load_misses();
  void clear_has_l1_dcache_load_misses();
  void set_has_l1_dcache_stores();
  void clear_has_l1_dcache_stores();
  void set_has_l1_dcache_store_misses();
  void clear_has_l1_dcache_store_misses();
  void set_has_l1_dcache_prefetches();
  void clear_has_l1_dcache_prefetches();
  void set_has_l1_dcache_prefetch_misses();
  void clear_has_l1_dcache_prefetch_misses();
  void set_has_l1_icache_loads();
  void clear_has_l1_icache_loads();
  void set_has_l1_icache_load_misses();
  void clear_has_l1_icache_load_misses();
  void set_has_l1_icache_prefetches();
  void clear_has_l1_icache_prefetches();
  void set_has_l1_icache_prefetch_misses();
  void clear_has_l1_icache_prefetch_misses();
  void set_has_llc_loads();
  void clear_has_llc_loads();
  void set_has_llc_load_misses();
  void clear_has_llc_load_misses();
  void set_has_llc_stores();
  void clear_has_llc_stores();
  void set_has_llc_store_misses();
  void clear_has_llc_store_misses();
  void set_has_llc_prefetches();
  void clear_has_llc_prefetches();
  void set_has_llc_prefetch_misses();
  void clear_has_llc_prefetch_misses();
  void set_has_dtlb_loads();
  void clear_has_dtlb_loads();
  void set_has_dtlb_load_misses();
  void clear_has_dtlb_load_misses();
  void set_has_dtlb_stores();
  void clear_has_dtlb_stores();
  void set_has_dtlb_store_misses();
  void clear_has_dtlb_store_misses();
  void set_has_dtlb_prefetches();
  void clear_has_dtlb_prefetches();
  void set_has_dtlb_prefetch_misses();
  void clear_has_dtlb_prefetch_misses();
  void set_has_itlb_loads();
  void clear_has_itlb_loads();
  void set_has_itlb_load_misses();
  void clear_has_itlb_load_misses();
  void set_has_branch_loads();
  void clear_has_branch_loads();
  void set_has_branch_load_misses();
  void clear_has_branch_load_misses();
  void set_has_node_loads();
  void clear_has_node_loads();
  void set_has_node_load_misses();
  void clear_has_node_load_misses();
  void set_has_node_stores();
  void clear_has_node_stores();
  void set_has_node_store_misses();
  void clear_has_node_store_misses();
  void set_has_node_prefetches();
  void clear_has_node_prefetches();
  void set_has_node_prefetch_misses();
  void clear_has_node_prefetch_misses();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<2> _has_bits_;
  double timestamp_;
  double duration_;
  ::google::protobuf::uint64 cycles_;
  ::google::protobuf::uint64 stalled_cycles_frontend_;
  ::google::protobuf::uint64 stalled_cycles_backend_;
  ::google::protobuf::uint64 instructions_;
  ::google::protobuf::uint64 cache_references_;
  ::google::protobuf::uint64 cache_misses_;
  ::google::protobuf::uint64 branches_;
  ::google::protobuf::uint64 branch_misses_;
  ::google::protobuf::uint64 bus_cycles_;
  ::google::protobuf::uint64 ref_cycles_;
  double cpu_clock_;
  double task_clock_;
  ::google::protobuf::uint64 page_faults_;
  ::google::protobuf::uint64 minor_faults_;
  ::google::protobuf::uint64 major_faults_;
  ::google::protobuf::uint64 context_switches_;
  ::google::protobuf::uint64 cpu_migrations_;
  ::google::protobuf::uint64 alignment_faults_;
  ::google::protobuf::uint64 emulation_faults_;
  ::google::protobuf::uint64 l1_dcache_loads_;
  ::google::protobuf::uint64 l1_dcache_load_misses_;
  ::google::protobuf::uint64 l1_dcache_stores_;
  ::google::protobuf::uint64 l1_dcache_store_misses_;
  ::google::protobuf::uint64 l1_dcache_prefetches_;
  ::google::protobuf::uint64 l1_dcache_prefetch_misses_;
  ::google::protobuf::uint64 l1_icache_loads_;
  ::google::protobuf::uint64 l1_icache_load_misses_;
  ::google::protobuf::uint64 l1_icache_prefetches_;
  ::google::protobuf::uint64 l1_icache_prefetch_misses_;
  ::google::protobuf::uint64 llc_loads_;
  ::google::protobuf::uint64 llc_load_misses_;
  ::google::protobuf::uint64 llc_stores_;
  ::google::protobuf::uint64 llc_store_misses_;
  ::google::protobuf::uint64 llc_prefetches_;
  ::google::protobuf::uint64 llc_prefetch_misses_;
  ::google::protobuf::uint64 dtlb_loads_;
  ::google::protobuf::uint64 dtlb_load_misses_;
  ::google::protobuf::uint64 dtlb_stores_;
  ::google::protobuf::uint64 dtlb_store_misses_;
  ::google::protobuf::uint64 dtlb_prefetches_;
  ::google::protobuf::uint64 dtlb_prefetch_misses_;
  ::google::protobuf::uint64 itlb_loads_;
  ::google::protobuf::uint64 itlb_load_misses_;
  ::google::protobuf::uint64 branch_loads_;
  ::google::protobuf::uint64 branch_load_misses_;
  ::google::protobuf::uint64 node_loads_;
  ::google::protobuf::uint64 node_load_misses_;
  ::google::protobuf::uint64 node_stores_;
  ::google::protobuf::uint64 node_store_misses_;
  ::google::protobuf::uint64 node_prefetches_;
  ::google::protobuf::uint64 node_prefetch_misses_;
  mutable int _cached_size_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsPerfStatisticsImpl();
};
// -------------------------------------------------------------------

class Request : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.Request) */ {
 public:
  Request();
  virtual ~Request();

  Request(const Request& from);

  inline Request& operator=(const Request& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Request(Request&& from) noexcept
    : Request() {
    *this = ::std::move(from);
  }

  inline Request& operator=(Request&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Request& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Request* internal_default_instance() {
    return reinterpret_cast<const Request*>(
               &_Request_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    69;

  void UnsafeArenaSwap(Request* other);
  void Swap(Request* other);
  friend void swap(Request& a, Request& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Request* New() const PROTOBUF_FINAL { return New(NULL); }

  Request* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Request& from);
  void MergeFrom(const Request& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Request* other);
  protected:
  explicit Request(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.Resource resources = 2;
  int resources_size() const;
  void clear_resources();
  static const int kResourcesFieldNumber = 2;
  const ::mesos::Resource& resources(int index) const;
  ::mesos::Resource* mutable_resources(int index);
  ::mesos::Resource* add_resources();
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
      mutable_resources();
  const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
      resources() const;

  // optional .mesos.SlaveID slave_id = 1;
  bool has_slave_id() const;
  void clear_slave_id();
  static const int kSlaveIdFieldNumber = 1;
  private:
  void _slow_mutable_slave_id();
  public:
  const ::mesos::SlaveID& slave_id() const;
  ::mesos::SlaveID* release_slave_id();
  ::mesos::SlaveID* mutable_slave_id();
  void set_allocated_slave_id(::mesos::SlaveID* slave_id);
  void unsafe_arena_set_allocated_slave_id(
      ::mesos::SlaveID* slave_id);
  ::mesos::SlaveID* unsafe_arena_release_slave_id();

  // @@protoc_insertion_point(class_scope:mesos.Request)
 private:
  void set_has_slave_id();
  void clear_has_slave_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource > resources_;
  ::mesos::SlaveID* slave_id_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsRequestImpl();
};
// -------------------------------------------------------------------

class Offer_Operation_Launch : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.Offer.Operation.Launch) */ {
 public:
  Offer_Operation_Launch();
  virtual ~Offer_Operation_Launch();

  Offer_Operation_Launch(const Offer_Operation_Launch& from);

  inline Offer_Operation_Launch& operator=(const Offer_Operation_Launch& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Offer_Operation_Launch(Offer_Operation_Launch&& from) noexcept
    : Offer_Operation_Launch() {
    *this = ::std::move(from);
  }

  inline Offer_Operation_Launch& operator=(Offer_Operation_Launch&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Offer_Operation_Launch& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Offer_Operation_Launch* internal_default_instance() {
    return reinterpret_cast<const Offer_Operation_Launch*>(
               &_Offer_Operation_Launch_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    70;

  void UnsafeArenaSwap(Offer_Operation_Launch* other);
  void Swap(Offer_Operation_Launch* other);
  friend void swap(Offer_Operation_Launch& a, Offer_Operation_Launch& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Offer_Operation_Launch* New() const PROTOBUF_FINAL { return New(NULL); }

  Offer_Operation_Launch* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Offer_Operation_Launch& from);
  void MergeFrom(const Offer_Operation_Launch& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Offer_Operation_Launch* other);
  protected:
  explicit Offer_Operation_Launch(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.TaskInfo task_infos = 1;
  int task_infos_size() const;
  void clear_task_infos();
  static const int kTaskInfosFieldNumber = 1;
  const ::mesos::TaskInfo& task_infos(int index) const;
  ::mesos::TaskInfo* mutable_task_infos(int index);
  ::mesos::TaskInfo* add_task_infos();
  ::google::protobuf::RepeatedPtrField< ::mesos::TaskInfo >*
      mutable_task_infos();
  const ::google::protobuf::RepeatedPtrField< ::mesos::TaskInfo >&
      task_infos() const;

  // @@protoc_insertion_point(class_scope:mesos.Offer.Operation.Launch)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::TaskInfo > task_infos_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsOffer_Operation_LaunchImpl();
};
// -------------------------------------------------------------------

class Offer_Operation_LaunchGroup : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.Offer.Operation.LaunchGroup) */ {
 public:
  Offer_Operation_LaunchGroup();
  virtual ~Offer_Operation_LaunchGroup();

  Offer_Operation_LaunchGroup(const Offer_Operation_LaunchGroup& from);

  inline Offer_Operation_LaunchGroup& operator=(const Offer_Operation_LaunchGroup& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Offer_Operation_LaunchGroup(Offer_Operation_LaunchGroup&& from) noexcept
    : Offer_Operation_LaunchGroup() {
    *this = ::std::move(from);
  }

  inline Offer_Operation_LaunchGroup& operator=(Offer_Operation_LaunchGroup&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Offer_Operation_LaunchGroup& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Offer_Operation_LaunchGroup* internal_default_instance() {
    return reinterpret_cast<const Offer_Operation_LaunchGroup*>(
               &_Offer_Operation_LaunchGroup_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    71;

  void UnsafeArenaSwap(Offer_Operation_LaunchGroup* other);
  void Swap(Offer_Operation_LaunchGroup* other);
  friend void swap(Offer_Operation_LaunchGroup& a, Offer_Operation_LaunchGroup& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Offer_Operation_LaunchGroup* New() const PROTOBUF_FINAL { return New(NULL); }

  Offer_Operation_LaunchGroup* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Offer_Operation_LaunchGroup& from);
  void MergeFrom(const Offer_Operation_LaunchGroup& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Offer_Operation_LaunchGroup* other);
  protected:
  explicit Offer_Operation_LaunchGroup(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.ExecutorInfo executor = 1;
  bool has_executor() const;
  void clear_executor();
  static const int kExecutorFieldNumber = 1;
  private:
  void _slow_mutable_executor();
  public:
  const ::mesos::ExecutorInfo& executor() const;
  ::mesos::ExecutorInfo* release_executor();
  ::mesos::ExecutorInfo* mutable_executor();
  void set_allocated_executor(::mesos::ExecutorInfo* executor);
  void unsafe_arena_set_allocated_executor(
      ::mesos::ExecutorInfo* executor);
  ::mesos::ExecutorInfo* unsafe_arena_release_executor();

  // required .mesos.TaskGroupInfo task_group = 2;
  bool has_task_group() const;
  void clear_task_group();
  static const int kTaskGroupFieldNumber = 2;
  private:
  void _slow_mutable_task_group();
  public:
  const ::mesos::TaskGroupInfo& task_group() const;
  ::mesos::TaskGroupInfo* release_task_group();
  ::mesos::TaskGroupInfo* mutable_task_group();
  void set_allocated_task_group(::mesos::TaskGroupInfo* task_group);
  void unsafe_arena_set_allocated_task_group(
      ::mesos::TaskGroupInfo* task_group);
  ::mesos::TaskGroupInfo* unsafe_arena_release_task_group();

  // @@protoc_insertion_point(class_scope:mesos.Offer.Operation.LaunchGroup)
 private:
  void set_has_executor();
  void clear_has_executor();
  void set_has_task_group();
  void clear_has_task_group();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::ExecutorInfo* executor_;
  ::mesos::TaskGroupInfo* task_group_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsOffer_Operation_LaunchGroupImpl();
};
// -------------------------------------------------------------------

class Offer_Operation_Reserve : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.Offer.Operation.Reserve) */ {
 public:
  Offer_Operation_Reserve();
  virtual ~Offer_Operation_Reserve();

  Offer_Operation_Reserve(const Offer_Operation_Reserve& from);

  inline Offer_Operation_Reserve& operator=(const Offer_Operation_Reserve& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Offer_Operation_Reserve(Offer_Operation_Reserve&& from) noexcept
    : Offer_Operation_Reserve() {
    *this = ::std::move(from);
  }

  inline Offer_Operation_Reserve& operator=(Offer_Operation_Reserve&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Offer_Operation_Reserve& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Offer_Operation_Reserve* internal_default_instance() {
    return reinterpret_cast<const Offer_Operation_Reserve*>(
               &_Offer_Operation_Reserve_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    72;

  void UnsafeArenaSwap(Offer_Operation_Reserve* other);
  void Swap(Offer_Operation_Reserve* other);
  friend void swap(Offer_Operation_Reserve& a, Offer_Operation_Reserve& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Offer_Operation_Reserve* New() const PROTOBUF_FINAL { return New(NULL); }

  Offer_Operation_Reserve* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Offer_Operation_Reserve& from);
  void MergeFrom(const Offer_Operation_Reserve& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Offer_Operation_Reserve* other);
  protected:
  explicit Offer_Operation_Reserve(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.Resource resources = 1;
  int resources_size() const;
  void clear_resources();
  static const int kResourcesFieldNumber = 1;
  const ::mesos::Resource& resources(int index) const;
  ::mesos::Resource* mutable_resources(int index);
  ::mesos::Resource* add_resources();
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
      mutable_resources();
  const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
      resources() const;

  // @@protoc_insertion_point(class_scope:mesos.Offer.Operation.Reserve)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource > resources_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsOffer_Operation_ReserveImpl();
};
// -------------------------------------------------------------------

class Offer_Operation_Unreserve : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.Offer.Operation.Unreserve) */ {
 public:
  Offer_Operation_Unreserve();
  virtual ~Offer_Operation_Unreserve();

  Offer_Operation_Unreserve(const Offer_Operation_Unreserve& from);

  inline Offer_Operation_Unreserve& operator=(const Offer_Operation_Unreserve& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Offer_Operation_Unreserve(Offer_Operation_Unreserve&& from) noexcept
    : Offer_Operation_Unreserve() {
    *this = ::std::move(from);
  }

  inline Offer_Operation_Unreserve& operator=(Offer_Operation_Unreserve&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Offer_Operation_Unreserve& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Offer_Operation_Unreserve* internal_default_instance() {
    return reinterpret_cast<const Offer_Operation_Unreserve*>(
               &_Offer_Operation_Unreserve_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    73;

  void UnsafeArenaSwap(Offer_Operation_Unreserve* other);
  void Swap(Offer_Operation_Unreserve* other);
  friend void swap(Offer_Operation_Unreserve& a, Offer_Operation_Unreserve& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Offer_Operation_Unreserve* New() const PROTOBUF_FINAL { return New(NULL); }

  Offer_Operation_Unreserve* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Offer_Operation_Unreserve& from);
  void MergeFrom(const Offer_Operation_Unreserve& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Offer_Operation_Unreserve* other);
  protected:
  explicit Offer_Operation_Unreserve(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.Resource resources = 1;
  int resources_size() const;
  void clear_resources();
  static const int kResourcesFieldNumber = 1;
  const ::mesos::Resource& resources(int index) const;
  ::mesos::Resource* mutable_resources(int index);
  ::mesos::Resource* add_resources();
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
      mutable_resources();
  const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
      resources() const;

  // @@protoc_insertion_point(class_scope:mesos.Offer.Operation.Unreserve)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource > resources_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsOffer_Operation_UnreserveImpl();
};
// -------------------------------------------------------------------

class Offer_Operation_Create : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.Offer.Operation.Create) */ {
 public:
  Offer_Operation_Create();
  virtual ~Offer_Operation_Create();

  Offer_Operation_Create(const Offer_Operation_Create& from);

  inline Offer_Operation_Create& operator=(const Offer_Operation_Create& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Offer_Operation_Create(Offer_Operation_Create&& from) noexcept
    : Offer_Operation_Create() {
    *this = ::std::move(from);
  }

  inline Offer_Operation_Create& operator=(Offer_Operation_Create&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Offer_Operation_Create& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Offer_Operation_Create* internal_default_instance() {
    return reinterpret_cast<const Offer_Operation_Create*>(
               &_Offer_Operation_Create_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    74;

  void UnsafeArenaSwap(Offer_Operation_Create* other);
  void Swap(Offer_Operation_Create* other);
  friend void swap(Offer_Operation_Create& a, Offer_Operation_Create& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Offer_Operation_Create* New() const PROTOBUF_FINAL { return New(NULL); }

  Offer_Operation_Create* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Offer_Operation_Create& from);
  void MergeFrom(const Offer_Operation_Create& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Offer_Operation_Create* other);
  protected:
  explicit Offer_Operation_Create(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.Resource volumes = 1;
  int volumes_size() const;
  void clear_volumes();
  static const int kVolumesFieldNumber = 1;
  const ::mesos::Resource& volumes(int index) const;
  ::mesos::Resource* mutable_volumes(int index);
  ::mesos::Resource* add_volumes();
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
      mutable_volumes();
  const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
      volumes() const;

  // @@protoc_insertion_point(class_scope:mesos.Offer.Operation.Create)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource > volumes_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsOffer_Operation_CreateImpl();
};
// -------------------------------------------------------------------

class Offer_Operation_Destroy : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.Offer.Operation.Destroy) */ {
 public:
  Offer_Operation_Destroy();
  virtual ~Offer_Operation_Destroy();

  Offer_Operation_Destroy(const Offer_Operation_Destroy& from);

  inline Offer_Operation_Destroy& operator=(const Offer_Operation_Destroy& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Offer_Operation_Destroy(Offer_Operation_Destroy&& from) noexcept
    : Offer_Operation_Destroy() {
    *this = ::std::move(from);
  }

  inline Offer_Operation_Destroy& operator=(Offer_Operation_Destroy&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Offer_Operation_Destroy& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Offer_Operation_Destroy* internal_default_instance() {
    return reinterpret_cast<const Offer_Operation_Destroy*>(
               &_Offer_Operation_Destroy_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    75;

  void UnsafeArenaSwap(Offer_Operation_Destroy* other);
  void Swap(Offer_Operation_Destroy* other);
  friend void swap(Offer_Operation_Destroy& a, Offer_Operation_Destroy& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Offer_Operation_Destroy* New() const PROTOBUF_FINAL { return New(NULL); }

  Offer_Operation_Destroy* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Offer_Operation_Destroy& from);
  void MergeFrom(const Offer_Operation_Destroy& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Offer_Operation_Destroy* other);
  protected:
  explicit Offer_Operation_Destroy(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.Resource volumes = 1;
  int volumes_size() const;
  void clear_volumes();
  static const int kVolumesFieldNumber = 1;
  const ::mesos::Resource& volumes(int index) const;
  ::mesos::Resource* mutable_volumes(int index);
  ::mesos::Resource* add_volumes();
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
      mutable_volumes();
  const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
      volumes() const;

  // @@protoc_insertion_point(class_scope:mesos.Offer.Operation.Destroy)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource > volumes_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsOffer_Operation_DestroyImpl();
};
// -------------------------------------------------------------------

class Offer_Operation_GrowVolume : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.Offer.Operation.GrowVolume) */ {
 public:
  Offer_Operation_GrowVolume();
  virtual ~Offer_Operation_GrowVolume();

  Offer_Operation_GrowVolume(const Offer_Operation_GrowVolume& from);

  inline Offer_Operation_GrowVolume& operator=(const Offer_Operation_GrowVolume& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Offer_Operation_GrowVolume(Offer_Operation_GrowVolume&& from) noexcept
    : Offer_Operation_GrowVolume() {
    *this = ::std::move(from);
  }

  inline Offer_Operation_GrowVolume& operator=(Offer_Operation_GrowVolume&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Offer_Operation_GrowVolume& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Offer_Operation_GrowVolume* internal_default_instance() {
    return reinterpret_cast<const Offer_Operation_GrowVolume*>(
               &_Offer_Operation_GrowVolume_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    76;

  void UnsafeArenaSwap(Offer_Operation_GrowVolume* other);
  void Swap(Offer_Operation_GrowVolume* other);
  friend void swap(Offer_Operation_GrowVolume& a, Offer_Operation_GrowVolume& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Offer_Operation_GrowVolume* New() const PROTOBUF_FINAL { return New(NULL); }

  Offer_Operation_GrowVolume* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Offer_Operation_GrowVolume& from);
  void MergeFrom(const Offer_Operation_GrowVolume& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Offer_Operation_GrowVolume* other);
  protected:
  explicit Offer_Operation_GrowVolume(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.Resource volume = 1;
  bool has_volume() const;
  void clear_volume();
  static const int kVolumeFieldNumber = 1;
  private:
  void _slow_mutable_volume();
  public:
  const ::mesos::Resource& volume() const;
  ::mesos::Resource* release_volume();
  ::mesos::Resource* mutable_volume();
  void set_allocated_volume(::mesos::Resource* volume);
  void unsafe_arena_set_allocated_volume(
      ::mesos::Resource* volume);
  ::mesos::Resource* unsafe_arena_release_volume();

  // required .mesos.Resource addition = 2;
  bool has_addition() const;
  void clear_addition();
  static const int kAdditionFieldNumber = 2;
  private:
  void _slow_mutable_addition();
  public:
  const ::mesos::Resource& addition() const;
  ::mesos::Resource* release_addition();
  ::mesos::Resource* mutable_addition();
  void set_allocated_addition(::mesos::Resource* addition);
  void unsafe_arena_set_allocated_addition(
      ::mesos::Resource* addition);
  ::mesos::Resource* unsafe_arena_release_addition();

  // @@protoc_insertion_point(class_scope:mesos.Offer.Operation.GrowVolume)
 private:
  void set_has_volume();
  void clear_has_volume();
  void set_has_addition();
  void clear_has_addition();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::Resource* volume_;
  ::mesos::Resource* addition_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsOffer_Operation_GrowVolumeImpl();
};
// -------------------------------------------------------------------

class Offer_Operation_ShrinkVolume : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.Offer.Operation.ShrinkVolume) */ {
 public:
  Offer_Operation_ShrinkVolume();
  virtual ~Offer_Operation_ShrinkVolume();

  Offer_Operation_ShrinkVolume(const Offer_Operation_ShrinkVolume& from);

  inline Offer_Operation_ShrinkVolume& operator=(const Offer_Operation_ShrinkVolume& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Offer_Operation_ShrinkVolume(Offer_Operation_ShrinkVolume&& from) noexcept
    : Offer_Operation_ShrinkVolume() {
    *this = ::std::move(from);
  }

  inline Offer_Operation_ShrinkVolume& operator=(Offer_Operation_ShrinkVolume&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Offer_Operation_ShrinkVolume& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Offer_Operation_ShrinkVolume* internal_default_instance() {
    return reinterpret_cast<const Offer_Operation_ShrinkVolume*>(
               &_Offer_Operation_ShrinkVolume_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    77;

  void UnsafeArenaSwap(Offer_Operation_ShrinkVolume* other);
  void Swap(Offer_Operation_ShrinkVolume* other);
  friend void swap(Offer_Operation_ShrinkVolume& a, Offer_Operation_ShrinkVolume& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Offer_Operation_ShrinkVolume* New() const PROTOBUF_FINAL { return New(NULL); }

  Offer_Operation_ShrinkVolume* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Offer_Operation_ShrinkVolume& from);
  void MergeFrom(const Offer_Operation_ShrinkVolume& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Offer_Operation_ShrinkVolume* other);
  protected:
  explicit Offer_Operation_ShrinkVolume(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.Resource volume = 1;
  bool has_volume() const;
  void clear_volume();
  static const int kVolumeFieldNumber = 1;
  private:
  void _slow_mutable_volume();
  public:
  const ::mesos::Resource& volume() const;
  ::mesos::Resource* release_volume();
  ::mesos::Resource* mutable_volume();
  void set_allocated_volume(::mesos::Resource* volume);
  void unsafe_arena_set_allocated_volume(
      ::mesos::Resource* volume);
  ::mesos::Resource* unsafe_arena_release_volume();

  // required .mesos.Value.Scalar subtract = 2;
  bool has_subtract() const;
  void clear_subtract();
  static const int kSubtractFieldNumber = 2;
  private:
  void _slow_mutable_subtract();
  public:
  const ::mesos::Value_Scalar& subtract() const;
  ::mesos::Value_Scalar* release_subtract();
  ::mesos::Value_Scalar* mutable_subtract();
  void set_allocated_subtract(::mesos::Value_Scalar* subtract);
  void unsafe_arena_set_allocated_subtract(
      ::mesos::Value_Scalar* subtract);
  ::mesos::Value_Scalar* unsafe_arena_release_subtract();

  // @@protoc_insertion_point(class_scope:mesos.Offer.Operation.ShrinkVolume)
 private:
  void set_has_volume();
  void clear_has_volume();
  void set_has_subtract();
  void clear_has_subtract();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::Resource* volume_;
  ::mesos::Value_Scalar* subtract_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsOffer_Operation_ShrinkVolumeImpl();
};
// -------------------------------------------------------------------

class Offer_Operation_CreateVolume : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.Offer.Operation.CreateVolume) */ {
 public:
  Offer_Operation_CreateVolume();
  virtual ~Offer_Operation_CreateVolume();

  Offer_Operation_CreateVolume(const Offer_Operation_CreateVolume& from);

  inline Offer_Operation_CreateVolume& operator=(const Offer_Operation_CreateVolume& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Offer_Operation_CreateVolume(Offer_Operation_CreateVolume&& from) noexcept
    : Offer_Operation_CreateVolume() {
    *this = ::std::move(from);
  }

  inline Offer_Operation_CreateVolume& operator=(Offer_Operation_CreateVolume&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Offer_Operation_CreateVolume& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Offer_Operation_CreateVolume* internal_default_instance() {
    return reinterpret_cast<const Offer_Operation_CreateVolume*>(
               &_Offer_Operation_CreateVolume_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    78;

  void UnsafeArenaSwap(Offer_Operation_CreateVolume* other);
  void Swap(Offer_Operation_CreateVolume* other);
  friend void swap(Offer_Operation_CreateVolume& a, Offer_Operation_CreateVolume& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Offer_Operation_CreateVolume* New() const PROTOBUF_FINAL { return New(NULL); }

  Offer_Operation_CreateVolume* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Offer_Operation_CreateVolume& from);
  void MergeFrom(const Offer_Operation_CreateVolume& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Offer_Operation_CreateVolume* other);
  protected:
  explicit Offer_Operation_CreateVolume(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.Resource source = 1;
  bool has_source() const;
  void clear_source();
  static const int kSourceFieldNumber = 1;
  private:
  void _slow_mutable_source();
  public:
  const ::mesos::Resource& source() const;
  ::mesos::Resource* release_source();
  ::mesos::Resource* mutable_source();
  void set_allocated_source(::mesos::Resource* source);
  void unsafe_arena_set_allocated_source(
      ::mesos::Resource* source);
  ::mesos::Resource* unsafe_arena_release_source();

  // required .mesos.Resource.DiskInfo.Source.Type target_type = 2;
  bool has_target_type() const;
  void clear_target_type();
  static const int kTargetTypeFieldNumber = 2;
  ::mesos::Resource_DiskInfo_Source_Type target_type() const;
  void set_target_type(::mesos::Resource_DiskInfo_Source_Type value);

  // @@protoc_insertion_point(class_scope:mesos.Offer.Operation.CreateVolume)
 private:
  void set_has_source();
  void clear_has_source();
  void set_has_target_type();
  void clear_has_target_type();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::Resource* source_;
  int target_type_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsOffer_Operation_CreateVolumeImpl();
};
// -------------------------------------------------------------------

class Offer_Operation_DestroyVolume : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.Offer.Operation.DestroyVolume) */ {
 public:
  Offer_Operation_DestroyVolume();
  virtual ~Offer_Operation_DestroyVolume();

  Offer_Operation_DestroyVolume(const Offer_Operation_DestroyVolume& from);

  inline Offer_Operation_DestroyVolume& operator=(const Offer_Operation_DestroyVolume& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Offer_Operation_DestroyVolume(Offer_Operation_DestroyVolume&& from) noexcept
    : Offer_Operation_DestroyVolume() {
    *this = ::std::move(from);
  }

  inline Offer_Operation_DestroyVolume& operator=(Offer_Operation_DestroyVolume&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Offer_Operation_DestroyVolume& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Offer_Operation_DestroyVolume* internal_default_instance() {
    return reinterpret_cast<const Offer_Operation_DestroyVolume*>(
               &_Offer_Operation_DestroyVolume_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    79;

  void UnsafeArenaSwap(Offer_Operation_DestroyVolume* other);
  void Swap(Offer_Operation_DestroyVolume* other);
  friend void swap(Offer_Operation_DestroyVolume& a, Offer_Operation_DestroyVolume& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Offer_Operation_DestroyVolume* New() const PROTOBUF_FINAL { return New(NULL); }

  Offer_Operation_DestroyVolume* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Offer_Operation_DestroyVolume& from);
  void MergeFrom(const Offer_Operation_DestroyVolume& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Offer_Operation_DestroyVolume* other);
  protected:
  explicit Offer_Operation_DestroyVolume(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.Resource volume = 1;
  bool has_volume() const;
  void clear_volume();
  static const int kVolumeFieldNumber = 1;
  private:
  void _slow_mutable_volume();
  public:
  const ::mesos::Resource& volume() const;
  ::mesos::Resource* release_volume();
  ::mesos::Resource* mutable_volume();
  void set_allocated_volume(::mesos::Resource* volume);
  void unsafe_arena_set_allocated_volume(
      ::mesos::Resource* volume);
  ::mesos::Resource* unsafe_arena_release_volume();

  // @@protoc_insertion_point(class_scope:mesos.Offer.Operation.DestroyVolume)
 private:
  void set_has_volume();
  void clear_has_volume();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::Resource* volume_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsOffer_Operation_DestroyVolumeImpl();
};
// -------------------------------------------------------------------

class Offer_Operation_CreateBlock : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.Offer.Operation.CreateBlock) */ {
 public:
  Offer_Operation_CreateBlock();
  virtual ~Offer_Operation_CreateBlock();

  Offer_Operation_CreateBlock(const Offer_Operation_CreateBlock& from);

  inline Offer_Operation_CreateBlock& operator=(const Offer_Operation_CreateBlock& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Offer_Operation_CreateBlock(Offer_Operation_CreateBlock&& from) noexcept
    : Offer_Operation_CreateBlock() {
    *this = ::std::move(from);
  }

  inline Offer_Operation_CreateBlock& operator=(Offer_Operation_CreateBlock&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Offer_Operation_CreateBlock& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Offer_Operation_CreateBlock* internal_default_instance() {
    return reinterpret_cast<const Offer_Operation_CreateBlock*>(
               &_Offer_Operation_CreateBlock_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    80;

  void UnsafeArenaSwap(Offer_Operation_CreateBlock* other);
  void Swap(Offer_Operation_CreateBlock* other);
  friend void swap(Offer_Operation_CreateBlock& a, Offer_Operation_CreateBlock& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Offer_Operation_CreateBlock* New() const PROTOBUF_FINAL { return New(NULL); }

  Offer_Operation_CreateBlock* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Offer_Operation_CreateBlock& from);
  void MergeFrom(const Offer_Operation_CreateBlock& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Offer_Operation_CreateBlock* other);
  protected:
  explicit Offer_Operation_CreateBlock(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.Resource source = 1;
  bool has_source() const;
  void clear_source();
  static const int kSourceFieldNumber = 1;
  private:
  void _slow_mutable_source();
  public:
  const ::mesos::Resource& source() const;
  ::mesos::Resource* release_source();
  ::mesos::Resource* mutable_source();
  void set_allocated_source(::mesos::Resource* source);
  void unsafe_arena_set_allocated_source(
      ::mesos::Resource* source);
  ::mesos::Resource* unsafe_arena_release_source();

  // @@protoc_insertion_point(class_scope:mesos.Offer.Operation.CreateBlock)
 private:
  void set_has_source();
  void clear_has_source();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::Resource* source_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsOffer_Operation_CreateBlockImpl();
};
// -------------------------------------------------------------------

class Offer_Operation_DestroyBlock : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.Offer.Operation.DestroyBlock) */ {
 public:
  Offer_Operation_DestroyBlock();
  virtual ~Offer_Operation_DestroyBlock();

  Offer_Operation_DestroyBlock(const Offer_Operation_DestroyBlock& from);

  inline Offer_Operation_DestroyBlock& operator=(const Offer_Operation_DestroyBlock& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Offer_Operation_DestroyBlock(Offer_Operation_DestroyBlock&& from) noexcept
    : Offer_Operation_DestroyBlock() {
    *this = ::std::move(from);
  }

  inline Offer_Operation_DestroyBlock& operator=(Offer_Operation_DestroyBlock&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Offer_Operation_DestroyBlock& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Offer_Operation_DestroyBlock* internal_default_instance() {
    return reinterpret_cast<const Offer_Operation_DestroyBlock*>(
               &_Offer_Operation_DestroyBlock_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    81;

  void UnsafeArenaSwap(Offer_Operation_DestroyBlock* other);
  void Swap(Offer_Operation_DestroyBlock* other);
  friend void swap(Offer_Operation_DestroyBlock& a, Offer_Operation_DestroyBlock& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Offer_Operation_DestroyBlock* New() const PROTOBUF_FINAL { return New(NULL); }

  Offer_Operation_DestroyBlock* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Offer_Operation_DestroyBlock& from);
  void MergeFrom(const Offer_Operation_DestroyBlock& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Offer_Operation_DestroyBlock* other);
  protected:
  explicit Offer_Operation_DestroyBlock(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.Resource block = 1;
  bool has_block() const;
  void clear_block();
  static const int kBlockFieldNumber = 1;
  private:
  void _slow_mutable_block();
  public:
  const ::mesos::Resource& block() const;
  ::mesos::Resource* release_block();
  ::mesos::Resource* mutable_block();
  void set_allocated_block(::mesos::Resource* block);
  void unsafe_arena_set_allocated_block(
      ::mesos::Resource* block);
  ::mesos::Resource* unsafe_arena_release_block();

  // @@protoc_insertion_point(class_scope:mesos.Offer.Operation.DestroyBlock)
 private:
  void set_has_block();
  void clear_has_block();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::Resource* block_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsOffer_Operation_DestroyBlockImpl();
};
// -------------------------------------------------------------------

class Offer_Operation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.Offer.Operation) */ {
 public:
  Offer_Operation();
  virtual ~Offer_Operation();

  Offer_Operation(const Offer_Operation& from);

  inline Offer_Operation& operator=(const Offer_Operation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Offer_Operation(Offer_Operation&& from) noexcept
    : Offer_Operation() {
    *this = ::std::move(from);
  }

  inline Offer_Operation& operator=(Offer_Operation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Offer_Operation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Offer_Operation* internal_default_instance() {
    return reinterpret_cast<const Offer_Operation*>(
               &_Offer_Operation_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    82;

  void UnsafeArenaSwap(Offer_Operation* other);
  void Swap(Offer_Operation* other);
  friend void swap(Offer_Operation& a, Offer_Operation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Offer_Operation* New() const PROTOBUF_FINAL { return New(NULL); }

  Offer_Operation* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Offer_Operation& from);
  void MergeFrom(const Offer_Operation& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Offer_Operation* other);
  protected:
  explicit Offer_Operation(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Offer_Operation_Launch Launch;
  typedef Offer_Operation_LaunchGroup LaunchGroup;
  typedef Offer_Operation_Reserve Reserve;
  typedef Offer_Operation_Unreserve Unreserve;
  typedef Offer_Operation_Create Create;
  typedef Offer_Operation_Destroy Destroy;
  typedef Offer_Operation_GrowVolume GrowVolume;
  typedef Offer_Operation_ShrinkVolume ShrinkVolume;
  typedef Offer_Operation_CreateVolume CreateVolume;
  typedef Offer_Operation_DestroyVolume DestroyVolume;
  typedef Offer_Operation_CreateBlock CreateBlock;
  typedef Offer_Operation_DestroyBlock DestroyBlock;

  typedef Offer_Operation_Type Type;
  static const Type UNKNOWN =
    Offer_Operation_Type_UNKNOWN;
  static const Type LAUNCH =
    Offer_Operation_Type_LAUNCH;
  static const Type LAUNCH_GROUP =
    Offer_Operation_Type_LAUNCH_GROUP;
  static const Type RESERVE =
    Offer_Operation_Type_RESERVE;
  static const Type UNRESERVE =
    Offer_Operation_Type_UNRESERVE;
  static const Type CREATE =
    Offer_Operation_Type_CREATE;
  static const Type DESTROY =
    Offer_Operation_Type_DESTROY;
  static const Type CREATE_VOLUME =
    Offer_Operation_Type_CREATE_VOLUME;
  static const Type DESTROY_VOLUME =
    Offer_Operation_Type_DESTROY_VOLUME;
  static const Type CREATE_BLOCK =
    Offer_Operation_Type_CREATE_BLOCK;
  static const Type DESTROY_BLOCK =
    Offer_Operation_Type_DESTROY_BLOCK;
  static const Type GROW_VOLUME =
    Offer_Operation_Type_GROW_VOLUME;
  static const Type SHRINK_VOLUME =
    Offer_Operation_Type_SHRINK_VOLUME;
  static inline bool Type_IsValid(int value) {
    return Offer_Operation_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Offer_Operation_Type_Type_MIN;
  static const Type Type_MAX =
    Offer_Operation_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Offer_Operation_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Offer_Operation_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Offer_Operation_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Offer_Operation_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .mesos.Offer.Operation.Launch launch = 2;
  bool has_launch() const;
  void clear_launch();
  static const int kLaunchFieldNumber = 2;
  private:
  void _slow_mutable_launch();
  public:
  const ::mesos::Offer_Operation_Launch& launch() const;
  ::mesos::Offer_Operation_Launch* release_launch();
  ::mesos::Offer_Operation_Launch* mutable_launch();
  void set_allocated_launch(::mesos::Offer_Operation_Launch* launch);
  void unsafe_arena_set_allocated_launch(
      ::mesos::Offer_Operation_Launch* launch);
  ::mesos::Offer_Operation_Launch* unsafe_arena_release_launch();

  // optional .mesos.Offer.Operation.Reserve reserve = 3;
  bool has_reserve() const;
  void clear_reserve();
  static const int kReserveFieldNumber = 3;
  private:
  void _slow_mutable_reserve();
  public:
  const ::mesos::Offer_Operation_Reserve& reserve() const;
  ::mesos::Offer_Operation_Reserve* release_reserve();
  ::mesos::Offer_Operation_Reserve* mutable_reserve();
  void set_allocated_reserve(::mesos::Offer_Operation_Reserve* reserve);
  void unsafe_arena_set_allocated_reserve(
      ::mesos::Offer_Operation_Reserve* reserve);
  ::mesos::Offer_Operation_Reserve* unsafe_arena_release_reserve();

  // optional .mesos.Offer.Operation.Unreserve unreserve = 4;
  bool has_unreserve() const;
  void clear_unreserve();
  static const int kUnreserveFieldNumber = 4;
  private:
  void _slow_mutable_unreserve();
  public:
  const ::mesos::Offer_Operation_Unreserve& unreserve() const;
  ::mesos::Offer_Operation_Unreserve* release_unreserve();
  ::mesos::Offer_Operation_Unreserve* mutable_unreserve();
  void set_allocated_unreserve(::mesos::Offer_Operation_Unreserve* unreserve);
  void unsafe_arena_set_allocated_unreserve(
      ::mesos::Offer_Operation_Unreserve* unreserve);
  ::mesos::Offer_Operation_Unreserve* unsafe_arena_release_unreserve();

  // optional .mesos.Offer.Operation.Create create = 5;
  bool has_create() const;
  void clear_create();
  static const int kCreateFieldNumber = 5;
  private:
  void _slow_mutable_create();
  public:
  const ::mesos::Offer_Operation_Create& create() const;
  ::mesos::Offer_Operation_Create* release_create();
  ::mesos::Offer_Operation_Create* mutable_create();
  void set_allocated_create(::mesos::Offer_Operation_Create* create);
  void unsafe_arena_set_allocated_create(
      ::mesos::Offer_Operation_Create* create);
  ::mesos::Offer_Operation_Create* unsafe_arena_release_create();

  // optional .mesos.Offer.Operation.Destroy destroy = 6;
  bool has_destroy() const;
  void clear_destroy();
  static const int kDestroyFieldNumber = 6;
  private:
  void _slow_mutable_destroy();
  public:
  const ::mesos::Offer_Operation_Destroy& destroy() const;
  ::mesos::Offer_Operation_Destroy* release_destroy();
  ::mesos::Offer_Operation_Destroy* mutable_destroy();
  void set_allocated_destroy(::mesos::Offer_Operation_Destroy* destroy);
  void unsafe_arena_set_allocated_destroy(
      ::mesos::Offer_Operation_Destroy* destroy);
  ::mesos::Offer_Operation_Destroy* unsafe_arena_release_destroy();

  // optional .mesos.Offer.Operation.LaunchGroup launch_group = 7;
  bool has_launch_group() const;
  void clear_launch_group();
  static const int kLaunchGroupFieldNumber = 7;
  private:
  void _slow_mutable_launch_group();
  public:
  const ::mesos::Offer_Operation_LaunchGroup& launch_group() const;
  ::mesos::Offer_Operation_LaunchGroup* release_launch_group();
  ::mesos::Offer_Operation_LaunchGroup* mutable_launch_group();
  void set_allocated_launch_group(::mesos::Offer_Operation_LaunchGroup* launch_group);
  void unsafe_arena_set_allocated_launch_group(
      ::mesos::Offer_Operation_LaunchGroup* launch_group);
  ::mesos::Offer_Operation_LaunchGroup* unsafe_arena_release_launch_group();

  // optional .mesos.Offer.Operation.CreateVolume create_volume = 8;
  bool has_create_volume() const;
  void clear_create_volume();
  static const int kCreateVolumeFieldNumber = 8;
  private:
  void _slow_mutable_create_volume();
  public:
  const ::mesos::Offer_Operation_CreateVolume& create_volume() const;
  ::mesos::Offer_Operation_CreateVolume* release_create_volume();
  ::mesos::Offer_Operation_CreateVolume* mutable_create_volume();
  void set_allocated_create_volume(::mesos::Offer_Operation_CreateVolume* create_volume);
  void unsafe_arena_set_allocated_create_volume(
      ::mesos::Offer_Operation_CreateVolume* create_volume);
  ::mesos::Offer_Operation_CreateVolume* unsafe_arena_release_create_volume();

  // optional .mesos.Offer.Operation.DestroyVolume destroy_volume = 9;
  bool has_destroy_volume() const;
  void clear_destroy_volume();
  static const int kDestroyVolumeFieldNumber = 9;
  private:
  void _slow_mutable_destroy_volume();
  public:
  const ::mesos::Offer_Operation_DestroyVolume& destroy_volume() const;
  ::mesos::Offer_Operation_DestroyVolume* release_destroy_volume();
  ::mesos::Offer_Operation_DestroyVolume* mutable_destroy_volume();
  void set_allocated_destroy_volume(::mesos::Offer_Operation_DestroyVolume* destroy_volume);
  void unsafe_arena_set_allocated_destroy_volume(
      ::mesos::Offer_Operation_DestroyVolume* destroy_volume);
  ::mesos::Offer_Operation_DestroyVolume* unsafe_arena_release_destroy_volume();

  // optional .mesos.Offer.Operation.CreateBlock create_block = 10;
  bool has_create_block() const;
  void clear_create_block();
  static const int kCreateBlockFieldNumber = 10;
  private:
  void _slow_mutable_create_block();
  public:
  const ::mesos::Offer_Operation_CreateBlock& create_block() const;
  ::mesos::Offer_Operation_CreateBlock* release_create_block();
  ::mesos::Offer_Operation_CreateBlock* mutable_create_block();
  void set_allocated_create_block(::mesos::Offer_Operation_CreateBlock* create_block);
  void unsafe_arena_set_allocated_create_block(
      ::mesos::Offer_Operation_CreateBlock* create_block);
  ::mesos::Offer_Operation_CreateBlock* unsafe_arena_release_create_block();

  // optional .mesos.Offer.Operation.DestroyBlock destroy_block = 11;
  bool has_destroy_block() const;
  void clear_destroy_block();
  static const int kDestroyBlockFieldNumber = 11;
  private:
  void _slow_mutable_destroy_block();
  public:
  const ::mesos::Offer_Operation_DestroyBlock& destroy_block() const;
  ::mesos::Offer_Operation_DestroyBlock* release_destroy_block();
  ::mesos::Offer_Operation_DestroyBlock* mutable_destroy_block();
  void set_allocated_destroy_block(::mesos::Offer_Operation_DestroyBlock* destroy_block);
  void unsafe_arena_set_allocated_destroy_block(
      ::mesos::Offer_Operation_DestroyBlock* destroy_block);
  ::mesos::Offer_Operation_DestroyBlock* unsafe_arena_release_destroy_block();

  // optional .mesos.OperationID id = 12;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 12;
  private:
  void _slow_mutable_id();
  public:
  const ::mesos::OperationID& id() const;
  ::mesos::OperationID* release_id();
  ::mesos::OperationID* mutable_id();
  void set_allocated_id(::mesos::OperationID* id);
  void unsafe_arena_set_allocated_id(
      ::mesos::OperationID* id);
  ::mesos::OperationID* unsafe_arena_release_id();

  // optional .mesos.Offer.Operation.GrowVolume grow_volume = 13;
  bool has_grow_volume() const;
  void clear_grow_volume();
  static const int kGrowVolumeFieldNumber = 13;
  private:
  void _slow_mutable_grow_volume();
  public:
  const ::mesos::Offer_Operation_GrowVolume& grow_volume() const;
  ::mesos::Offer_Operation_GrowVolume* release_grow_volume();
  ::mesos::Offer_Operation_GrowVolume* mutable_grow_volume();
  void set_allocated_grow_volume(::mesos::Offer_Operation_GrowVolume* grow_volume);
  void unsafe_arena_set_allocated_grow_volume(
      ::mesos::Offer_Operation_GrowVolume* grow_volume);
  ::mesos::Offer_Operation_GrowVolume* unsafe_arena_release_grow_volume();

  // optional .mesos.Offer.Operation.ShrinkVolume shrink_volume = 14;
  bool has_shrink_volume() const;
  void clear_shrink_volume();
  static const int kShrinkVolumeFieldNumber = 14;
  private:
  void _slow_mutable_shrink_volume();
  public:
  const ::mesos::Offer_Operation_ShrinkVolume& shrink_volume() const;
  ::mesos::Offer_Operation_ShrinkVolume* release_shrink_volume();
  ::mesos::Offer_Operation_ShrinkVolume* mutable_shrink_volume();
  void set_allocated_shrink_volume(::mesos::Offer_Operation_ShrinkVolume* shrink_volume);
  void unsafe_arena_set_allocated_shrink_volume(
      ::mesos::Offer_Operation_ShrinkVolume* shrink_volume);
  ::mesos::Offer_Operation_ShrinkVolume* unsafe_arena_release_shrink_volume();

  // optional .mesos.Offer.Operation.Type type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::mesos::Offer_Operation_Type type() const;
  void set_type(::mesos::Offer_Operation_Type value);

  // @@protoc_insertion_point(class_scope:mesos.Offer.Operation)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_id();
  void clear_has_id();
  void set_has_launch();
  void clear_has_launch();
  void set_has_launch_group();
  void clear_has_launch_group();
  void set_has_reserve();
  void clear_has_reserve();
  void set_has_unreserve();
  void clear_has_unreserve();
  void set_has_create();
  void clear_has_create();
  void set_has_destroy();
  void clear_has_destroy();
  void set_has_grow_volume();
  void clear_has_grow_volume();
  void set_has_shrink_volume();
  void clear_has_shrink_volume();
  void set_has_create_volume();
  void clear_has_create_volume();
  void set_has_destroy_volume();
  void clear_has_destroy_volume();
  void set_has_create_block();
  void clear_has_create_block();
  void set_has_destroy_block();
  void clear_has_destroy_block();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::Offer_Operation_Launch* launch_;
  ::mesos::Offer_Operation_Reserve* reserve_;
  ::mesos::Offer_Operation_Unreserve* unreserve_;
  ::mesos::Offer_Operation_Create* create_;
  ::mesos::Offer_Operation_Destroy* destroy_;
  ::mesos::Offer_Operation_LaunchGroup* launch_group_;
  ::mesos::Offer_Operation_CreateVolume* create_volume_;
  ::mesos::Offer_Operation_DestroyVolume* destroy_volume_;
  ::mesos::Offer_Operation_CreateBlock* create_block_;
  ::mesos::Offer_Operation_DestroyBlock* destroy_block_;
  ::mesos::OperationID* id_;
  ::mesos::Offer_Operation_GrowVolume* grow_volume_;
  ::mesos::Offer_Operation_ShrinkVolume* shrink_volume_;
  int type_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsOffer_OperationImpl();
};
// -------------------------------------------------------------------

class Offer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.Offer) */ {
 public:
  Offer();
  virtual ~Offer();

  Offer(const Offer& from);

  inline Offer& operator=(const Offer& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Offer(Offer&& from) noexcept
    : Offer() {
    *this = ::std::move(from);
  }

  inline Offer& operator=(Offer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Offer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Offer* internal_default_instance() {
    return reinterpret_cast<const Offer*>(
               &_Offer_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    83;

  void UnsafeArenaSwap(Offer* other);
  void Swap(Offer* other);
  friend void swap(Offer& a, Offer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Offer* New() const PROTOBUF_FINAL { return New(NULL); }

  Offer* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Offer& from);
  void MergeFrom(const Offer& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Offer* other);
  protected:
  explicit Offer(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Offer_Operation Operation;

  // accessors -------------------------------------------------------

  // repeated .mesos.Resource resources = 5;
  int resources_size() const;
  void clear_resources();
  static const int kResourcesFieldNumber = 5;
  const ::mesos::Resource& resources(int index) const;
  ::mesos::Resource* mutable_resources(int index);
  ::mesos::Resource* add_resources();
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
      mutable_resources();
  const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
      resources() const;

  // repeated .mesos.ExecutorID executor_ids = 6;
  int executor_ids_size() const;
  void clear_executor_ids();
  static const int kExecutorIdsFieldNumber = 6;
  const ::mesos::ExecutorID& executor_ids(int index) const;
  ::mesos::ExecutorID* mutable_executor_ids(int index);
  ::mesos::ExecutorID* add_executor_ids();
  ::google::protobuf::RepeatedPtrField< ::mesos::ExecutorID >*
      mutable_executor_ids();
  const ::google::protobuf::RepeatedPtrField< ::mesos::ExecutorID >&
      executor_ids() const;

  // repeated .mesos.Attribute attributes = 7;
  int attributes_size() const;
  void clear_attributes();
  static const int kAttributesFieldNumber = 7;
  const ::mesos::Attribute& attributes(int index) const;
  ::mesos::Attribute* mutable_attributes(int index);
  ::mesos::Attribute* add_attributes();
  ::google::protobuf::RepeatedPtrField< ::mesos::Attribute >*
      mutable_attributes();
  const ::google::protobuf::RepeatedPtrField< ::mesos::Attribute >&
      attributes() const;

  // required string hostname = 4;
  bool has_hostname() const;
  void clear_hostname();
  static const int kHostnameFieldNumber = 4;
  const ::std::string& hostname() const;
  void set_hostname(const ::std::string& value);
  #if LANG_CXX11
  void set_hostname(::std::string&& value);
  #endif
  void set_hostname(const char* value);
  void set_hostname(const char* value, size_t size);
  ::std::string* mutable_hostname();
  ::std::string* release_hostname();
  void set_allocated_hostname(::std::string* hostname);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_hostname();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_hostname(
      ::std::string* hostname);

  // required .mesos.OfferID id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  private:
  void _slow_mutable_id();
  public:
  const ::mesos::OfferID& id() const;
  ::mesos::OfferID* release_id();
  ::mesos::OfferID* mutable_id();
  void set_allocated_id(::mesos::OfferID* id);
  void unsafe_arena_set_allocated_id(
      ::mesos::OfferID* id);
  ::mesos::OfferID* unsafe_arena_release_id();

  // required .mesos.FrameworkID framework_id = 2;
  bool has_framework_id() const;
  void clear_framework_id();
  static const int kFrameworkIdFieldNumber = 2;
  private:
  void _slow_mutable_framework_id();
  public:
  const ::mesos::FrameworkID& framework_id() const;
  ::mesos::FrameworkID* release_framework_id();
  ::mesos::FrameworkID* mutable_framework_id();
  void set_allocated_framework_id(::mesos::FrameworkID* framework_id);
  void unsafe_arena_set_allocated_framework_id(
      ::mesos::FrameworkID* framework_id);
  ::mesos::FrameworkID* unsafe_arena_release_framework_id();

  // required .mesos.SlaveID slave_id = 3;
  bool has_slave_id() const;
  void clear_slave_id();
  static const int kSlaveIdFieldNumber = 3;
  private:
  void _slow_mutable_slave_id();
  public:
  const ::mesos::SlaveID& slave_id() const;
  ::mesos::SlaveID* release_slave_id();
  ::mesos::SlaveID* mutable_slave_id();
  void set_allocated_slave_id(::mesos::SlaveID* slave_id);
  void unsafe_arena_set_allocated_slave_id(
      ::mesos::SlaveID* slave_id);
  ::mesos::SlaveID* unsafe_arena_release_slave_id();

  // optional .mesos.URL url = 8;
  bool has_url() const;
  void clear_url();
  static const int kUrlFieldNumber = 8;
  private:
  void _slow_mutable_url();
  public:
  const ::mesos::URL& url() const;
  ::mesos::URL* release_url();
  ::mesos::URL* mutable_url();
  void set_allocated_url(::mesos::URL* url);
  void unsafe_arena_set_allocated_url(
      ::mesos::URL* url);
  ::mesos::URL* unsafe_arena_release_url();

  // optional .mesos.Unavailability unavailability = 9;
  bool has_unavailability() const;
  void clear_unavailability();
  static const int kUnavailabilityFieldNumber = 9;
  private:
  void _slow_mutable_unavailability();
  public:
  const ::mesos::Unavailability& unavailability() const;
  ::mesos::Unavailability* release_unavailability();
  ::mesos::Unavailability* mutable_unavailability();
  void set_allocated_unavailability(::mesos::Unavailability* unavailability);
  void unsafe_arena_set_allocated_unavailability(
      ::mesos::Unavailability* unavailability);
  ::mesos::Unavailability* unsafe_arena_release_unavailability();

  // optional .mesos.Resource.AllocationInfo allocation_info = 10;
  bool has_allocation_info() const;
  void clear_allocation_info();
  static const int kAllocationInfoFieldNumber = 10;
  private:
  void _slow_mutable_allocation_info();
  public:
  const ::mesos::Resource_AllocationInfo& allocation_info() const;
  ::mesos::Resource_AllocationInfo* release_allocation_info();
  ::mesos::Resource_AllocationInfo* mutable_allocation_info();
  void set_allocated_allocation_info(::mesos::Resource_AllocationInfo* allocation_info);
  void unsafe_arena_set_allocated_allocation_info(
      ::mesos::Resource_AllocationInfo* allocation_info);
  ::mesos::Resource_AllocationInfo* unsafe_arena_release_allocation_info();

  // optional .mesos.DomainInfo domain = 11;
  bool has_domain() const;
  void clear_domain();
  static const int kDomainFieldNumber = 11;
  private:
  void _slow_mutable_domain();
  public:
  const ::mesos::DomainInfo& domain() const;
  ::mesos::DomainInfo* release_domain();
  ::mesos::DomainInfo* mutable_domain();
  void set_allocated_domain(::mesos::DomainInfo* domain);
  void unsafe_arena_set_allocated_domain(
      ::mesos::DomainInfo* domain);
  ::mesos::DomainInfo* unsafe_arena_release_domain();

  // @@protoc_insertion_point(class_scope:mesos.Offer)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_framework_id();
  void clear_has_framework_id();
  void set_has_slave_id();
  void clear_has_slave_id();
  void set_has_hostname();
  void clear_has_hostname();
  void set_has_url();
  void clear_has_url();
  void set_has_domain();
  void clear_has_domain();
  void set_has_unavailability();
  void clear_has_unavailability();
  void set_has_allocation_info();
  void clear_has_allocation_info();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource > resources_;
  ::google::protobuf::RepeatedPtrField< ::mesos::ExecutorID > executor_ids_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Attribute > attributes_;
  ::google::protobuf::internal::ArenaStringPtr hostname_;
  ::mesos::OfferID* id_;
  ::mesos::FrameworkID* framework_id_;
  ::mesos::SlaveID* slave_id_;
  ::mesos::URL* url_;
  ::mesos::Unavailability* unavailability_;
  ::mesos::Resource_AllocationInfo* allocation_info_;
  ::mesos::DomainInfo* domain_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsOfferImpl();
};
// -------------------------------------------------------------------

class InverseOffer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.InverseOffer) */ {
 public:
  InverseOffer();
  virtual ~InverseOffer();

  InverseOffer(const InverseOffer& from);

  inline InverseOffer& operator=(const InverseOffer& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  InverseOffer(InverseOffer&& from) noexcept
    : InverseOffer() {
    *this = ::std::move(from);
  }

  inline InverseOffer& operator=(InverseOffer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const InverseOffer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InverseOffer* internal_default_instance() {
    return reinterpret_cast<const InverseOffer*>(
               &_InverseOffer_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    84;

  void UnsafeArenaSwap(InverseOffer* other);
  void Swap(InverseOffer* other);
  friend void swap(InverseOffer& a, InverseOffer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline InverseOffer* New() const PROTOBUF_FINAL { return New(NULL); }

  InverseOffer* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const InverseOffer& from);
  void MergeFrom(const InverseOffer& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(InverseOffer* other);
  protected:
  explicit InverseOffer(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.Resource resources = 6;
  int resources_size() const;
  void clear_resources();
  static const int kResourcesFieldNumber = 6;
  const ::mesos::Resource& resources(int index) const;
  ::mesos::Resource* mutable_resources(int index);
  ::mesos::Resource* add_resources();
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
      mutable_resources();
  const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
      resources() const;

  // required .mesos.OfferID id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  private:
  void _slow_mutable_id();
  public:
  const ::mesos::OfferID& id() const;
  ::mesos::OfferID* release_id();
  ::mesos::OfferID* mutable_id();
  void set_allocated_id(::mesos::OfferID* id);
  void unsafe_arena_set_allocated_id(
      ::mesos::OfferID* id);
  ::mesos::OfferID* unsafe_arena_release_id();

  // optional .mesos.URL url = 2;
  bool has_url() const;
  void clear_url();
  static const int kUrlFieldNumber = 2;
  private:
  void _slow_mutable_url();
  public:
  const ::mesos::URL& url() const;
  ::mesos::URL* release_url();
  ::mesos::URL* mutable_url();
  void set_allocated_url(::mesos::URL* url);
  void unsafe_arena_set_allocated_url(
      ::mesos::URL* url);
  ::mesos::URL* unsafe_arena_release_url();

  // required .mesos.FrameworkID framework_id = 3;
  bool has_framework_id() const;
  void clear_framework_id();
  static const int kFrameworkIdFieldNumber = 3;
  private:
  void _slow_mutable_framework_id();
  public:
  const ::mesos::FrameworkID& framework_id() const;
  ::mesos::FrameworkID* release_framework_id();
  ::mesos::FrameworkID* mutable_framework_id();
  void set_allocated_framework_id(::mesos::FrameworkID* framework_id);
  void unsafe_arena_set_allocated_framework_id(
      ::mesos::FrameworkID* framework_id);
  ::mesos::FrameworkID* unsafe_arena_release_framework_id();

  // optional .mesos.SlaveID slave_id = 4;
  bool has_slave_id() const;
  void clear_slave_id();
  static const int kSlaveIdFieldNumber = 4;
  private:
  void _slow_mutable_slave_id();
  public:
  const ::mesos::SlaveID& slave_id() const;
  ::mesos::SlaveID* release_slave_id();
  ::mesos::SlaveID* mutable_slave_id();
  void set_allocated_slave_id(::mesos::SlaveID* slave_id);
  void unsafe_arena_set_allocated_slave_id(
      ::mesos::SlaveID* slave_id);
  ::mesos::SlaveID* unsafe_arena_release_slave_id();

  // required .mesos.Unavailability unavailability = 5;
  bool has_unavailability() const;
  void clear_unavailability();
  static const int kUnavailabilityFieldNumber = 5;
  private:
  void _slow_mutable_unavailability();
  public:
  const ::mesos::Unavailability& unavailability() const;
  ::mesos::Unavailability* release_unavailability();
  ::mesos::Unavailability* mutable_unavailability();
  void set_allocated_unavailability(::mesos::Unavailability* unavailability);
  void unsafe_arena_set_allocated_unavailability(
      ::mesos::Unavailability* unavailability);
  ::mesos::Unavailability* unsafe_arena_release_unavailability();

  // @@protoc_insertion_point(class_scope:mesos.InverseOffer)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_url();
  void clear_has_url();
  void set_has_framework_id();
  void clear_has_framework_id();
  void set_has_slave_id();
  void clear_has_slave_id();
  void set_has_unavailability();
  void clear_has_unavailability();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource > resources_;
  ::mesos::OfferID* id_;
  ::mesos::URL* url_;
  ::mesos::FrameworkID* framework_id_;
  ::mesos::SlaveID* slave_id_;
  ::mesos::Unavailability* unavailability_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsInverseOfferImpl();
};
// -------------------------------------------------------------------

class TaskInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.TaskInfo) */ {
 public:
  TaskInfo();
  virtual ~TaskInfo();

  TaskInfo(const TaskInfo& from);

  inline TaskInfo& operator=(const TaskInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TaskInfo(TaskInfo&& from) noexcept
    : TaskInfo() {
    *this = ::std::move(from);
  }

  inline TaskInfo& operator=(TaskInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const TaskInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TaskInfo* internal_default_instance() {
    return reinterpret_cast<const TaskInfo*>(
               &_TaskInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    85;

  void UnsafeArenaSwap(TaskInfo* other);
  void Swap(TaskInfo* other);
  friend void swap(TaskInfo& a, TaskInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TaskInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  TaskInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TaskInfo& from);
  void MergeFrom(const TaskInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TaskInfo* other);
  protected:
  explicit TaskInfo(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.Resource resources = 4;
  int resources_size() const;
  void clear_resources();
  static const int kResourcesFieldNumber = 4;
  const ::mesos::Resource& resources(int index) const;
  ::mesos::Resource* mutable_resources(int index);
  ::mesos::Resource* add_resources();
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
      mutable_resources();
  const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
      resources() const;

  // required string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_name();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      ::std::string* name);

  // optional bytes data = 6;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 6;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_data();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_data(
      ::std::string* data);

  // required .mesos.TaskID task_id = 2;
  bool has_task_id() const;
  void clear_task_id();
  static const int kTaskIdFieldNumber = 2;
  private:
  void _slow_mutable_task_id();
  public:
  const ::mesos::TaskID& task_id() const;
  ::mesos::TaskID* release_task_id();
  ::mesos::TaskID* mutable_task_id();
  void set_allocated_task_id(::mesos::TaskID* task_id);
  void unsafe_arena_set_allocated_task_id(
      ::mesos::TaskID* task_id);
  ::mesos::TaskID* unsafe_arena_release_task_id();

  // required .mesos.SlaveID slave_id = 3;
  bool has_slave_id() const;
  void clear_slave_id();
  static const int kSlaveIdFieldNumber = 3;
  private:
  void _slow_mutable_slave_id();
  public:
  const ::mesos::SlaveID& slave_id() const;
  ::mesos::SlaveID* release_slave_id();
  ::mesos::SlaveID* mutable_slave_id();
  void set_allocated_slave_id(::mesos::SlaveID* slave_id);
  void unsafe_arena_set_allocated_slave_id(
      ::mesos::SlaveID* slave_id);
  ::mesos::SlaveID* unsafe_arena_release_slave_id();

  // optional .mesos.ExecutorInfo executor = 5;
  bool has_executor() const;
  void clear_executor();
  static const int kExecutorFieldNumber = 5;
  private:
  void _slow_mutable_executor();
  public:
  const ::mesos::ExecutorInfo& executor() const;
  ::mesos::ExecutorInfo* release_executor();
  ::mesos::ExecutorInfo* mutable_executor();
  void set_allocated_executor(::mesos::ExecutorInfo* executor);
  void unsafe_arena_set_allocated_executor(
      ::mesos::ExecutorInfo* executor);
  ::mesos::ExecutorInfo* unsafe_arena_release_executor();

  // optional .mesos.CommandInfo command = 7;
  bool has_command() const;
  void clear_command();
  static const int kCommandFieldNumber = 7;
  private:
  void _slow_mutable_command();
  public:
  const ::mesos::CommandInfo& command() const;
  ::mesos::CommandInfo* release_command();
  ::mesos::CommandInfo* mutable_command();
  void set_allocated_command(::mesos::CommandInfo* command);
  void unsafe_arena_set_allocated_command(
      ::mesos::CommandInfo* command);
  ::mesos::CommandInfo* unsafe_arena_release_command();

  // optional .mesos.HealthCheck health_check = 8;
  bool has_health_check() const;
  void clear_health_check();
  static const int kHealthCheckFieldNumber = 8;
  private:
  void _slow_mutable_health_check();
  public:
  const ::mesos::HealthCheck& health_check() const;
  ::mesos::HealthCheck* release_health_check();
  ::mesos::HealthCheck* mutable_health_check();
  void set_allocated_health_check(::mesos::HealthCheck* health_check);
  void unsafe_arena_set_allocated_health_check(
      ::mesos::HealthCheck* health_check);
  ::mesos::HealthCheck* unsafe_arena_release_health_check();

  // optional .mesos.ContainerInfo container = 9;
  bool has_container() const;
  void clear_container();
  static const int kContainerFieldNumber = 9;
  private:
  void _slow_mutable_container();
  public:
  const ::mesos::ContainerInfo& container() const;
  ::mesos::ContainerInfo* release_container();
  ::mesos::ContainerInfo* mutable_container();
  void set_allocated_container(::mesos::ContainerInfo* container);
  void unsafe_arena_set_allocated_container(
      ::mesos::ContainerInfo* container);
  ::mesos::ContainerInfo* unsafe_arena_release_container();

  // optional .mesos.Labels labels = 10;
  bool has_labels() const;
  void clear_labels();
  static const int kLabelsFieldNumber = 10;
  private:
  void _slow_mutable_labels();
  public:
  const ::mesos::Labels& labels() const;
  ::mesos::Labels* release_labels();
  ::mesos::Labels* mutable_labels();
  void set_allocated_labels(::mesos::Labels* labels);
  void unsafe_arena_set_allocated_labels(
      ::mesos::Labels* labels);
  ::mesos::Labels* unsafe_arena_release_labels();

  // optional .mesos.DiscoveryInfo discovery = 11;
  bool has_discovery() const;
  void clear_discovery();
  static const int kDiscoveryFieldNumber = 11;
  private:
  void _slow_mutable_discovery();
  public:
  const ::mesos::DiscoveryInfo& discovery() const;
  ::mesos::DiscoveryInfo* release_discovery();
  ::mesos::DiscoveryInfo* mutable_discovery();
  void set_allocated_discovery(::mesos::DiscoveryInfo* discovery);
  void unsafe_arena_set_allocated_discovery(
      ::mesos::DiscoveryInfo* discovery);
  ::mesos::DiscoveryInfo* unsafe_arena_release_discovery();

  // optional .mesos.KillPolicy kill_policy = 12;
  bool has_kill_policy() const;
  void clear_kill_policy();
  static const int kKillPolicyFieldNumber = 12;
  private:
  void _slow_mutable_kill_policy();
  public:
  const ::mesos::KillPolicy& kill_policy() const;
  ::mesos::KillPolicy* release_kill_policy();
  ::mesos::KillPolicy* mutable_kill_policy();
  void set_allocated_kill_policy(::mesos::KillPolicy* kill_policy);
  void unsafe_arena_set_allocated_kill_policy(
      ::mesos::KillPolicy* kill_policy);
  ::mesos::KillPolicy* unsafe_arena_release_kill_policy();

  // optional .mesos.CheckInfo check = 13;
  bool has_check() const;
  void clear_check();
  static const int kCheckFieldNumber = 13;
  private:
  void _slow_mutable_check();
  public:
  const ::mesos::CheckInfo& check() const;
  ::mesos::CheckInfo* release_check();
  ::mesos::CheckInfo* mutable_check();
  void set_allocated_check(::mesos::CheckInfo* check);
  void unsafe_arena_set_allocated_check(
      ::mesos::CheckInfo* check);
  ::mesos::CheckInfo* unsafe_arena_release_check();

  // optional .mesos.DurationInfo max_completion_time = 14;
  bool has_max_completion_time() const;
  void clear_max_completion_time();
  static const int kMaxCompletionTimeFieldNumber = 14;
  private:
  void _slow_mutable_max_completion_time();
  public:
  const ::mesos::DurationInfo& max_completion_time() const;
  ::mesos::DurationInfo* release_max_completion_time();
  ::mesos::DurationInfo* mutable_max_completion_time();
  void set_allocated_max_completion_time(::mesos::DurationInfo* max_completion_time);
  void unsafe_arena_set_allocated_max_completion_time(
      ::mesos::DurationInfo* max_completion_time);
  ::mesos::DurationInfo* unsafe_arena_release_max_completion_time();

  // @@protoc_insertion_point(class_scope:mesos.TaskInfo)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_task_id();
  void clear_has_task_id();
  void set_has_slave_id();
  void clear_has_slave_id();
  void set_has_executor();
  void clear_has_executor();
  void set_has_command();
  void clear_has_command();
  void set_has_container();
  void clear_has_container();
  void set_has_health_check();
  void clear_has_health_check();
  void set_has_check();
  void clear_has_check();
  void set_has_kill_policy();
  void clear_has_kill_policy();
  void set_has_data();
  void clear_has_data();
  void set_has_labels();
  void clear_has_labels();
  void set_has_discovery();
  void clear_has_discovery();
  void set_has_max_completion_time();
  void clear_has_max_completion_time();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource > resources_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  ::mesos::TaskID* task_id_;
  ::mesos::SlaveID* slave_id_;
  ::mesos::ExecutorInfo* executor_;
  ::mesos::CommandInfo* command_;
  ::mesos::HealthCheck* health_check_;
  ::mesos::ContainerInfo* container_;
  ::mesos::Labels* labels_;
  ::mesos::DiscoveryInfo* discovery_;
  ::mesos::KillPolicy* kill_policy_;
  ::mesos::CheckInfo* check_;
  ::mesos::DurationInfo* max_completion_time_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsTaskInfoImpl();
};
// -------------------------------------------------------------------

class TaskGroupInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.TaskGroupInfo) */ {
 public:
  TaskGroupInfo();
  virtual ~TaskGroupInfo();

  TaskGroupInfo(const TaskGroupInfo& from);

  inline TaskGroupInfo& operator=(const TaskGroupInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TaskGroupInfo(TaskGroupInfo&& from) noexcept
    : TaskGroupInfo() {
    *this = ::std::move(from);
  }

  inline TaskGroupInfo& operator=(TaskGroupInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const TaskGroupInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TaskGroupInfo* internal_default_instance() {
    return reinterpret_cast<const TaskGroupInfo*>(
               &_TaskGroupInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    86;

  void UnsafeArenaSwap(TaskGroupInfo* other);
  void Swap(TaskGroupInfo* other);
  friend void swap(TaskGroupInfo& a, TaskGroupInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TaskGroupInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  TaskGroupInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TaskGroupInfo& from);
  void MergeFrom(const TaskGroupInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TaskGroupInfo* other);
  protected:
  explicit TaskGroupInfo(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.TaskInfo tasks = 1;
  int tasks_size() const;
  void clear_tasks();
  static const int kTasksFieldNumber = 1;
  const ::mesos::TaskInfo& tasks(int index) const;
  ::mesos::TaskInfo* mutable_tasks(int index);
  ::mesos::TaskInfo* add_tasks();
  ::google::protobuf::RepeatedPtrField< ::mesos::TaskInfo >*
      mutable_tasks();
  const ::google::protobuf::RepeatedPtrField< ::mesos::TaskInfo >&
      tasks() const;

  // @@protoc_insertion_point(class_scope:mesos.TaskGroupInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::TaskInfo > tasks_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsTaskGroupInfoImpl();
};
// -------------------------------------------------------------------

class Task : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.Task) */ {
 public:
  Task();
  virtual ~Task();

  Task(const Task& from);

  inline Task& operator=(const Task& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Task(Task&& from) noexcept
    : Task() {
    *this = ::std::move(from);
  }

  inline Task& operator=(Task&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Task& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Task* internal_default_instance() {
    return reinterpret_cast<const Task*>(
               &_Task_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    87;

  void UnsafeArenaSwap(Task* other);
  void Swap(Task* other);
  friend void swap(Task& a, Task& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Task* New() const PROTOBUF_FINAL { return New(NULL); }

  Task* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Task& from);
  void MergeFrom(const Task& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Task* other);
  protected:
  explicit Task(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.Resource resources = 7;
  int resources_size() const;
  void clear_resources();
  static const int kResourcesFieldNumber = 7;
  const ::mesos::Resource& resources(int index) const;
  ::mesos::Resource* mutable_resources(int index);
  ::mesos::Resource* add_resources();
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
      mutable_resources();
  const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
      resources() const;

  // repeated .mesos.TaskStatus statuses = 8;
  int statuses_size() const;
  void clear_statuses();
  static const int kStatusesFieldNumber = 8;
  const ::mesos::TaskStatus& statuses(int index) const;
  ::mesos::TaskStatus* mutable_statuses(int index);
  ::mesos::TaskStatus* add_statuses();
  ::google::protobuf::RepeatedPtrField< ::mesos::TaskStatus >*
      mutable_statuses();
  const ::google::protobuf::RepeatedPtrField< ::mesos::TaskStatus >&
      statuses() const;

  // required string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_name();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      ::std::string* name);

  // optional bytes status_update_uuid = 10;
  bool has_status_update_uuid() const;
  void clear_status_update_uuid();
  static const int kStatusUpdateUuidFieldNumber = 10;
  const ::std::string& status_update_uuid() const;
  void set_status_update_uuid(const ::std::string& value);
  #if LANG_CXX11
  void set_status_update_uuid(::std::string&& value);
  #endif
  void set_status_update_uuid(const char* value);
  void set_status_update_uuid(const void* value, size_t size);
  ::std::string* mutable_status_update_uuid();
  ::std::string* release_status_update_uuid();
  void set_allocated_status_update_uuid(::std::string* status_update_uuid);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_status_update_uuid();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_status_update_uuid(
      ::std::string* status_update_uuid);

  // optional string user = 14;
  bool has_user() const;
  void clear_user();
  static const int kUserFieldNumber = 14;
  const ::std::string& user() const;
  void set_user(const ::std::string& value);
  #if LANG_CXX11
  void set_user(::std::string&& value);
  #endif
  void set_user(const char* value);
  void set_user(const char* value, size_t size);
  ::std::string* mutable_user();
  ::std::string* release_user();
  void set_allocated_user(::std::string* user);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_user();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_user(
      ::std::string* user);

  // required .mesos.TaskID task_id = 2;
  bool has_task_id() const;
  void clear_task_id();
  static const int kTaskIdFieldNumber = 2;
  private:
  void _slow_mutable_task_id();
  public:
  const ::mesos::TaskID& task_id() const;
  ::mesos::TaskID* release_task_id();
  ::mesos::TaskID* mutable_task_id();
  void set_allocated_task_id(::mesos::TaskID* task_id);
  void unsafe_arena_set_allocated_task_id(
      ::mesos::TaskID* task_id);
  ::mesos::TaskID* unsafe_arena_release_task_id();

  // required .mesos.FrameworkID framework_id = 3;
  bool has_framework_id() const;
  void clear_framework_id();
  static const int kFrameworkIdFieldNumber = 3;
  private:
  void _slow_mutable_framework_id();
  public:
  const ::mesos::FrameworkID& framework_id() const;
  ::mesos::FrameworkID* release_framework_id();
  ::mesos::FrameworkID* mutable_framework_id();
  void set_allocated_framework_id(::mesos::FrameworkID* framework_id);
  void unsafe_arena_set_allocated_framework_id(
      ::mesos::FrameworkID* framework_id);
  ::mesos::FrameworkID* unsafe_arena_release_framework_id();

  // optional .mesos.ExecutorID executor_id = 4;
  bool has_executor_id() const;
  void clear_executor_id();
  static const int kExecutorIdFieldNumber = 4;
  private:
  void _slow_mutable_executor_id();
  public:
  const ::mesos::ExecutorID& executor_id() const;
  ::mesos::ExecutorID* release_executor_id();
  ::mesos::ExecutorID* mutable_executor_id();
  void set_allocated_executor_id(::mesos::ExecutorID* executor_id);
  void unsafe_arena_set_allocated_executor_id(
      ::mesos::ExecutorID* executor_id);
  ::mesos::ExecutorID* unsafe_arena_release_executor_id();

  // required .mesos.SlaveID slave_id = 5;
  bool has_slave_id() const;
  void clear_slave_id();
  static const int kSlaveIdFieldNumber = 5;
  private:
  void _slow_mutable_slave_id();
  public:
  const ::mesos::SlaveID& slave_id() const;
  ::mesos::SlaveID* release_slave_id();
  ::mesos::SlaveID* mutable_slave_id();
  void set_allocated_slave_id(::mesos::SlaveID* slave_id);
  void unsafe_arena_set_allocated_slave_id(
      ::mesos::SlaveID* slave_id);
  ::mesos::SlaveID* unsafe_arena_release_slave_id();

  // optional .mesos.Labels labels = 11;
  bool has_labels() const;
  void clear_labels();
  static const int kLabelsFieldNumber = 11;
  private:
  void _slow_mutable_labels();
  public:
  const ::mesos::Labels& labels() const;
  ::mesos::Labels* release_labels();
  ::mesos::Labels* mutable_labels();
  void set_allocated_labels(::mesos::Labels* labels);
  void unsafe_arena_set_allocated_labels(
      ::mesos::Labels* labels);
  ::mesos::Labels* unsafe_arena_release_labels();

  // optional .mesos.DiscoveryInfo discovery = 12;
  bool has_discovery() const;
  void clear_discovery();
  static const int kDiscoveryFieldNumber = 12;
  private:
  void _slow_mutable_discovery();
  public:
  const ::mesos::DiscoveryInfo& discovery() const;
  ::mesos::DiscoveryInfo* release_discovery();
  ::mesos::DiscoveryInfo* mutable_discovery();
  void set_allocated_discovery(::mesos::DiscoveryInfo* discovery);
  void unsafe_arena_set_allocated_discovery(
      ::mesos::DiscoveryInfo* discovery);
  ::mesos::DiscoveryInfo* unsafe_arena_release_discovery();

  // optional .mesos.ContainerInfo container = 13;
  bool has_container() const;
  void clear_container();
  static const int kContainerFieldNumber = 13;
  private:
  void _slow_mutable_container();
  public:
  const ::mesos::ContainerInfo& container() const;
  ::mesos::ContainerInfo* release_container();
  ::mesos::ContainerInfo* mutable_container();
  void set_allocated_container(::mesos::ContainerInfo* container);
  void unsafe_arena_set_allocated_container(
      ::mesos::ContainerInfo* container);
  ::mesos::ContainerInfo* unsafe_arena_release_container();

  // required .mesos.TaskState state = 6;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 6;
  ::mesos::TaskState state() const;
  void set_state(::mesos::TaskState value);

  // optional .mesos.TaskState status_update_state = 9;
  bool has_status_update_state() const;
  void clear_status_update_state();
  static const int kStatusUpdateStateFieldNumber = 9;
  ::mesos::TaskState status_update_state() const;
  void set_status_update_state(::mesos::TaskState value);

  // @@protoc_insertion_point(class_scope:mesos.Task)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_task_id();
  void clear_has_task_id();
  void set_has_framework_id();
  void clear_has_framework_id();
  void set_has_executor_id();
  void clear_has_executor_id();
  void set_has_slave_id();
  void clear_has_slave_id();
  void set_has_state();
  void clear_has_state();
  void set_has_status_update_state();
  void clear_has_status_update_state();
  void set_has_status_update_uuid();
  void clear_has_status_update_uuid();
  void set_has_labels();
  void clear_has_labels();
  void set_has_discovery();
  void clear_has_discovery();
  void set_has_container();
  void clear_has_container();
  void set_has_user();
  void clear_has_user();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource > resources_;
  ::google::protobuf::RepeatedPtrField< ::mesos::TaskStatus > statuses_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr status_update_uuid_;
  ::google::protobuf::internal::ArenaStringPtr user_;
  ::mesos::TaskID* task_id_;
  ::mesos::FrameworkID* framework_id_;
  ::mesos::ExecutorID* executor_id_;
  ::mesos::SlaveID* slave_id_;
  ::mesos::Labels* labels_;
  ::mesos::DiscoveryInfo* discovery_;
  ::mesos::ContainerInfo* container_;
  int state_;
  int status_update_state_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsTaskImpl();
};
// -------------------------------------------------------------------

class TaskResourceLimitation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.TaskResourceLimitation) */ {
 public:
  TaskResourceLimitation();
  virtual ~TaskResourceLimitation();

  TaskResourceLimitation(const TaskResourceLimitation& from);

  inline TaskResourceLimitation& operator=(const TaskResourceLimitation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TaskResourceLimitation(TaskResourceLimitation&& from) noexcept
    : TaskResourceLimitation() {
    *this = ::std::move(from);
  }

  inline TaskResourceLimitation& operator=(TaskResourceLimitation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const TaskResourceLimitation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TaskResourceLimitation* internal_default_instance() {
    return reinterpret_cast<const TaskResourceLimitation*>(
               &_TaskResourceLimitation_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    88;

  void UnsafeArenaSwap(TaskResourceLimitation* other);
  void Swap(TaskResourceLimitation* other);
  friend void swap(TaskResourceLimitation& a, TaskResourceLimitation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TaskResourceLimitation* New() const PROTOBUF_FINAL { return New(NULL); }

  TaskResourceLimitation* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TaskResourceLimitation& from);
  void MergeFrom(const TaskResourceLimitation& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TaskResourceLimitation* other);
  protected:
  explicit TaskResourceLimitation(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.Resource resources = 1;
  int resources_size() const;
  void clear_resources();
  static const int kResourcesFieldNumber = 1;
  const ::mesos::Resource& resources(int index) const;
  ::mesos::Resource* mutable_resources(int index);
  ::mesos::Resource* add_resources();
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
      mutable_resources();
  const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
      resources() const;

  // @@protoc_insertion_point(class_scope:mesos.TaskResourceLimitation)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource > resources_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsTaskResourceLimitationImpl();
};
// -------------------------------------------------------------------

class UUID : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.UUID) */ {
 public:
  UUID();
  virtual ~UUID();

  UUID(const UUID& from);

  inline UUID& operator=(const UUID& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UUID(UUID&& from) noexcept
    : UUID() {
    *this = ::std::move(from);
  }

  inline UUID& operator=(UUID&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const UUID& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UUID* internal_default_instance() {
    return reinterpret_cast<const UUID*>(
               &_UUID_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    89;

  void UnsafeArenaSwap(UUID* other);
  void Swap(UUID* other);
  friend void swap(UUID& a, UUID& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UUID* New() const PROTOBUF_FINAL { return New(NULL); }

  UUID* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const UUID& from);
  void MergeFrom(const UUID& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(UUID* other);
  protected:
  explicit UUID(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes value = 1;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_value();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_value(
      ::std::string* value);

  // @@protoc_insertion_point(class_scope:mesos.UUID)
 private:
  void set_has_value();
  void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsUUIDImpl();
};
// -------------------------------------------------------------------

class Operation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.Operation) */ {
 public:
  Operation();
  virtual ~Operation();

  Operation(const Operation& from);

  inline Operation& operator=(const Operation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Operation(Operation&& from) noexcept
    : Operation() {
    *this = ::std::move(from);
  }

  inline Operation& operator=(Operation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Operation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Operation* internal_default_instance() {
    return reinterpret_cast<const Operation*>(
               &_Operation_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    90;

  void UnsafeArenaSwap(Operation* other);
  void Swap(Operation* other);
  friend void swap(Operation& a, Operation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Operation* New() const PROTOBUF_FINAL { return New(NULL); }

  Operation* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Operation& from);
  void MergeFrom(const Operation& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Operation* other);
  protected:
  explicit Operation(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.OperationStatus statuses = 5;
  int statuses_size() const;
  void clear_statuses();
  static const int kStatusesFieldNumber = 5;
  const ::mesos::OperationStatus& statuses(int index) const;
  ::mesos::OperationStatus* mutable_statuses(int index);
  ::mesos::OperationStatus* add_statuses();
  ::google::protobuf::RepeatedPtrField< ::mesos::OperationStatus >*
      mutable_statuses();
  const ::google::protobuf::RepeatedPtrField< ::mesos::OperationStatus >&
      statuses() const;

  // optional .mesos.FrameworkID framework_id = 1;
  bool has_framework_id() const;
  void clear_framework_id();
  static const int kFrameworkIdFieldNumber = 1;
  private:
  void _slow_mutable_framework_id();
  public:
  const ::mesos::FrameworkID& framework_id() const;
  ::mesos::FrameworkID* release_framework_id();
  ::mesos::FrameworkID* mutable_framework_id();
  void set_allocated_framework_id(::mesos::FrameworkID* framework_id);
  void unsafe_arena_set_allocated_framework_id(
      ::mesos::FrameworkID* framework_id);
  ::mesos::FrameworkID* unsafe_arena_release_framework_id();

  // optional .mesos.SlaveID slave_id = 2;
  bool has_slave_id() const;
  void clear_slave_id();
  static const int kSlaveIdFieldNumber = 2;
  private:
  void _slow_mutable_slave_id();
  public:
  const ::mesos::SlaveID& slave_id() const;
  ::mesos::SlaveID* release_slave_id();
  ::mesos::SlaveID* mutable_slave_id();
  void set_allocated_slave_id(::mesos::SlaveID* slave_id);
  void unsafe_arena_set_allocated_slave_id(
      ::mesos::SlaveID* slave_id);
  ::mesos::SlaveID* unsafe_arena_release_slave_id();

  // required .mesos.Offer.Operation info = 3;
  bool has_info() const;
  void clear_info();
  static const int kInfoFieldNumber = 3;
  private:
  void _slow_mutable_info();
  public:
  const ::mesos::Offer_Operation& info() const;
  ::mesos::Offer_Operation* release_info();
  ::mesos::Offer_Operation* mutable_info();
  void set_allocated_info(::mesos::Offer_Operation* info);
  void unsafe_arena_set_allocated_info(
      ::mesos::Offer_Operation* info);
  ::mesos::Offer_Operation* unsafe_arena_release_info();

  // required .mesos.OperationStatus latest_status = 4;
  bool has_latest_status() const;
  void clear_latest_status();
  static const int kLatestStatusFieldNumber = 4;
  private:
  void _slow_mutable_latest_status();
  public:
  const ::mesos::OperationStatus& latest_status() const;
  ::mesos::OperationStatus* release_latest_status();
  ::mesos::OperationStatus* mutable_latest_status();
  void set_allocated_latest_status(::mesos::OperationStatus* latest_status);
  void unsafe_arena_set_allocated_latest_status(
      ::mesos::OperationStatus* latest_status);
  ::mesos::OperationStatus* unsafe_arena_release_latest_status();

  // required .mesos.UUID uuid = 6;
  bool has_uuid() const;
  void clear_uuid();
  static const int kUuidFieldNumber = 6;
  private:
  void _slow_mutable_uuid();
  public:
  const ::mesos::UUID& uuid() const;
  ::mesos::UUID* release_uuid();
  ::mesos::UUID* mutable_uuid();
  void set_allocated_uuid(::mesos::UUID* uuid);
  void unsafe_arena_set_allocated_uuid(
      ::mesos::UUID* uuid);
  ::mesos::UUID* unsafe_arena_release_uuid();

  // @@protoc_insertion_point(class_scope:mesos.Operation)
 private:
  void set_has_framework_id();
  void clear_has_framework_id();
  void set_has_slave_id();
  void clear_has_slave_id();
  void set_has_info();
  void clear_has_info();
  void set_has_latest_status();
  void clear_has_latest_status();
  void set_has_uuid();
  void clear_has_uuid();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::OperationStatus > statuses_;
  ::mesos::FrameworkID* framework_id_;
  ::mesos::SlaveID* slave_id_;
  ::mesos::Offer_Operation* info_;
  ::mesos::OperationStatus* latest_status_;
  ::mesos::UUID* uuid_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsOperationImpl();
};
// -------------------------------------------------------------------

class OperationStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.OperationStatus) */ {
 public:
  OperationStatus();
  virtual ~OperationStatus();

  OperationStatus(const OperationStatus& from);

  inline OperationStatus& operator=(const OperationStatus& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OperationStatus(OperationStatus&& from) noexcept
    : OperationStatus() {
    *this = ::std::move(from);
  }

  inline OperationStatus& operator=(OperationStatus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const OperationStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OperationStatus* internal_default_instance() {
    return reinterpret_cast<const OperationStatus*>(
               &_OperationStatus_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    91;

  void UnsafeArenaSwap(OperationStatus* other);
  void Swap(OperationStatus* other);
  friend void swap(OperationStatus& a, OperationStatus& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OperationStatus* New() const PROTOBUF_FINAL { return New(NULL); }

  OperationStatus* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const OperationStatus& from);
  void MergeFrom(const OperationStatus& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(OperationStatus* other);
  protected:
  explicit OperationStatus(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.Resource converted_resources = 4;
  int converted_resources_size() const;
  void clear_converted_resources();
  static const int kConvertedResourcesFieldNumber = 4;
  const ::mesos::Resource& converted_resources(int index) const;
  ::mesos::Resource* mutable_converted_resources(int index);
  ::mesos::Resource* add_converted_resources();
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
      mutable_converted_resources();
  const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
      converted_resources() const;

  // optional string message = 3;
  bool has_message() const;
  void clear_message();
  static const int kMessageFieldNumber = 3;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_message();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_message(
      ::std::string* message);

  // optional .mesos.OperationID operation_id = 1;
  bool has_operation_id() const;
  void clear_operation_id();
  static const int kOperationIdFieldNumber = 1;
  private:
  void _slow_mutable_operation_id();
  public:
  const ::mesos::OperationID& operation_id() const;
  ::mesos::OperationID* release_operation_id();
  ::mesos::OperationID* mutable_operation_id();
  void set_allocated_operation_id(::mesos::OperationID* operation_id);
  void unsafe_arena_set_allocated_operation_id(
      ::mesos::OperationID* operation_id);
  ::mesos::OperationID* unsafe_arena_release_operation_id();

  // optional .mesos.UUID uuid = 5;
  bool has_uuid() const;
  void clear_uuid();
  static const int kUuidFieldNumber = 5;
  private:
  void _slow_mutable_uuid();
  public:
  const ::mesos::UUID& uuid() const;
  ::mesos::UUID* release_uuid();
  ::mesos::UUID* mutable_uuid();
  void set_allocated_uuid(::mesos::UUID* uuid);
  void unsafe_arena_set_allocated_uuid(
      ::mesos::UUID* uuid);
  ::mesos::UUID* unsafe_arena_release_uuid();

  // required .mesos.OperationState state = 2;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 2;
  ::mesos::OperationState state() const;
  void set_state(::mesos::OperationState value);

  // @@protoc_insertion_point(class_scope:mesos.OperationStatus)
 private:
  void set_has_operation_id();
  void clear_has_operation_id();
  void set_has_state();
  void clear_has_state();
  void set_has_message();
  void clear_has_message();
  void set_has_uuid();
  void clear_has_uuid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource > converted_resources_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  ::mesos::OperationID* operation_id_;
  ::mesos::UUID* uuid_;
  int state_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsOperationStatusImpl();
};
// -------------------------------------------------------------------

class CheckStatusInfo_Command : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.CheckStatusInfo.Command) */ {
 public:
  CheckStatusInfo_Command();
  virtual ~CheckStatusInfo_Command();

  CheckStatusInfo_Command(const CheckStatusInfo_Command& from);

  inline CheckStatusInfo_Command& operator=(const CheckStatusInfo_Command& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CheckStatusInfo_Command(CheckStatusInfo_Command&& from) noexcept
    : CheckStatusInfo_Command() {
    *this = ::std::move(from);
  }

  inline CheckStatusInfo_Command& operator=(CheckStatusInfo_Command&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const CheckStatusInfo_Command& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CheckStatusInfo_Command* internal_default_instance() {
    return reinterpret_cast<const CheckStatusInfo_Command*>(
               &_CheckStatusInfo_Command_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    92;

  void UnsafeArenaSwap(CheckStatusInfo_Command* other);
  void Swap(CheckStatusInfo_Command* other);
  friend void swap(CheckStatusInfo_Command& a, CheckStatusInfo_Command& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CheckStatusInfo_Command* New() const PROTOBUF_FINAL { return New(NULL); }

  CheckStatusInfo_Command* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CheckStatusInfo_Command& from);
  void MergeFrom(const CheckStatusInfo_Command& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CheckStatusInfo_Command* other);
  protected:
  explicit CheckStatusInfo_Command(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 exit_code = 1;
  bool has_exit_code() const;
  void clear_exit_code();
  static const int kExitCodeFieldNumber = 1;
  ::google::protobuf::int32 exit_code() const;
  void set_exit_code(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:mesos.CheckStatusInfo.Command)
 private:
  void set_has_exit_code();
  void clear_has_exit_code();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 exit_code_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsCheckStatusInfo_CommandImpl();
};
// -------------------------------------------------------------------

class CheckStatusInfo_Http : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.CheckStatusInfo.Http) */ {
 public:
  CheckStatusInfo_Http();
  virtual ~CheckStatusInfo_Http();

  CheckStatusInfo_Http(const CheckStatusInfo_Http& from);

  inline CheckStatusInfo_Http& operator=(const CheckStatusInfo_Http& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CheckStatusInfo_Http(CheckStatusInfo_Http&& from) noexcept
    : CheckStatusInfo_Http() {
    *this = ::std::move(from);
  }

  inline CheckStatusInfo_Http& operator=(CheckStatusInfo_Http&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const CheckStatusInfo_Http& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CheckStatusInfo_Http* internal_default_instance() {
    return reinterpret_cast<const CheckStatusInfo_Http*>(
               &_CheckStatusInfo_Http_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    93;

  void UnsafeArenaSwap(CheckStatusInfo_Http* other);
  void Swap(CheckStatusInfo_Http* other);
  friend void swap(CheckStatusInfo_Http& a, CheckStatusInfo_Http& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CheckStatusInfo_Http* New() const PROTOBUF_FINAL { return New(NULL); }

  CheckStatusInfo_Http* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CheckStatusInfo_Http& from);
  void MergeFrom(const CheckStatusInfo_Http& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CheckStatusInfo_Http* other);
  protected:
  explicit CheckStatusInfo_Http(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 status_code = 1;
  bool has_status_code() const;
  void clear_status_code();
  static const int kStatusCodeFieldNumber = 1;
  ::google::protobuf::uint32 status_code() const;
  void set_status_code(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mesos.CheckStatusInfo.Http)
 private:
  void set_has_status_code();
  void clear_has_status_code();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 status_code_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsCheckStatusInfo_HttpImpl();
};
// -------------------------------------------------------------------

class CheckStatusInfo_Tcp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.CheckStatusInfo.Tcp) */ {
 public:
  CheckStatusInfo_Tcp();
  virtual ~CheckStatusInfo_Tcp();

  CheckStatusInfo_Tcp(const CheckStatusInfo_Tcp& from);

  inline CheckStatusInfo_Tcp& operator=(const CheckStatusInfo_Tcp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CheckStatusInfo_Tcp(CheckStatusInfo_Tcp&& from) noexcept
    : CheckStatusInfo_Tcp() {
    *this = ::std::move(from);
  }

  inline CheckStatusInfo_Tcp& operator=(CheckStatusInfo_Tcp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const CheckStatusInfo_Tcp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CheckStatusInfo_Tcp* internal_default_instance() {
    return reinterpret_cast<const CheckStatusInfo_Tcp*>(
               &_CheckStatusInfo_Tcp_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    94;

  void UnsafeArenaSwap(CheckStatusInfo_Tcp* other);
  void Swap(CheckStatusInfo_Tcp* other);
  friend void swap(CheckStatusInfo_Tcp& a, CheckStatusInfo_Tcp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CheckStatusInfo_Tcp* New() const PROTOBUF_FINAL { return New(NULL); }

  CheckStatusInfo_Tcp* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CheckStatusInfo_Tcp& from);
  void MergeFrom(const CheckStatusInfo_Tcp& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CheckStatusInfo_Tcp* other);
  protected:
  explicit CheckStatusInfo_Tcp(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool succeeded = 1;
  bool has_succeeded() const;
  void clear_succeeded();
  static const int kSucceededFieldNumber = 1;
  bool succeeded() const;
  void set_succeeded(bool value);

  // @@protoc_insertion_point(class_scope:mesos.CheckStatusInfo.Tcp)
 private:
  void set_has_succeeded();
  void clear_has_succeeded();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  bool succeeded_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsCheckStatusInfo_TcpImpl();
};
// -------------------------------------------------------------------

class CheckStatusInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.CheckStatusInfo) */ {
 public:
  CheckStatusInfo();
  virtual ~CheckStatusInfo();

  CheckStatusInfo(const CheckStatusInfo& from);

  inline CheckStatusInfo& operator=(const CheckStatusInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CheckStatusInfo(CheckStatusInfo&& from) noexcept
    : CheckStatusInfo() {
    *this = ::std::move(from);
  }

  inline CheckStatusInfo& operator=(CheckStatusInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const CheckStatusInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CheckStatusInfo* internal_default_instance() {
    return reinterpret_cast<const CheckStatusInfo*>(
               &_CheckStatusInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    95;

  void UnsafeArenaSwap(CheckStatusInfo* other);
  void Swap(CheckStatusInfo* other);
  friend void swap(CheckStatusInfo& a, CheckStatusInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CheckStatusInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  CheckStatusInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CheckStatusInfo& from);
  void MergeFrom(const CheckStatusInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CheckStatusInfo* other);
  protected:
  explicit CheckStatusInfo(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef CheckStatusInfo_Command Command;
  typedef CheckStatusInfo_Http Http;
  typedef CheckStatusInfo_Tcp Tcp;

  // accessors -------------------------------------------------------

  // optional .mesos.CheckStatusInfo.Command command = 2;
  bool has_command() const;
  void clear_command();
  static const int kCommandFieldNumber = 2;
  private:
  void _slow_mutable_command();
  public:
  const ::mesos::CheckStatusInfo_Command& command() const;
  ::mesos::CheckStatusInfo_Command* release_command();
  ::mesos::CheckStatusInfo_Command* mutable_command();
  void set_allocated_command(::mesos::CheckStatusInfo_Command* command);
  void unsafe_arena_set_allocated_command(
      ::mesos::CheckStatusInfo_Command* command);
  ::mesos::CheckStatusInfo_Command* unsafe_arena_release_command();

  // optional .mesos.CheckStatusInfo.Http http = 3;
  bool has_http() const;
  void clear_http();
  static const int kHttpFieldNumber = 3;
  private:
  void _slow_mutable_http();
  public:
  const ::mesos::CheckStatusInfo_Http& http() const;
  ::mesos::CheckStatusInfo_Http* release_http();
  ::mesos::CheckStatusInfo_Http* mutable_http();
  void set_allocated_http(::mesos::CheckStatusInfo_Http* http);
  void unsafe_arena_set_allocated_http(
      ::mesos::CheckStatusInfo_Http* http);
  ::mesos::CheckStatusInfo_Http* unsafe_arena_release_http();

  // optional .mesos.CheckStatusInfo.Tcp tcp = 4;
  bool has_tcp() const;
  void clear_tcp();
  static const int kTcpFieldNumber = 4;
  private:
  void _slow_mutable_tcp();
  public:
  const ::mesos::CheckStatusInfo_Tcp& tcp() const;
  ::mesos::CheckStatusInfo_Tcp* release_tcp();
  ::mesos::CheckStatusInfo_Tcp* mutable_tcp();
  void set_allocated_tcp(::mesos::CheckStatusInfo_Tcp* tcp);
  void unsafe_arena_set_allocated_tcp(
      ::mesos::CheckStatusInfo_Tcp* tcp);
  ::mesos::CheckStatusInfo_Tcp* unsafe_arena_release_tcp();

  // optional .mesos.CheckInfo.Type type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::mesos::CheckInfo_Type type() const;
  void set_type(::mesos::CheckInfo_Type value);

  // @@protoc_insertion_point(class_scope:mesos.CheckStatusInfo)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_command();
  void clear_has_command();
  void set_has_http();
  void clear_has_http();
  void set_has_tcp();
  void clear_has_tcp();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::CheckStatusInfo_Command* command_;
  ::mesos::CheckStatusInfo_Http* http_;
  ::mesos::CheckStatusInfo_Tcp* tcp_;
  int type_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsCheckStatusInfoImpl();
};
// -------------------------------------------------------------------

class TaskStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.TaskStatus) */ {
 public:
  TaskStatus();
  virtual ~TaskStatus();

  TaskStatus(const TaskStatus& from);

  inline TaskStatus& operator=(const TaskStatus& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TaskStatus(TaskStatus&& from) noexcept
    : TaskStatus() {
    *this = ::std::move(from);
  }

  inline TaskStatus& operator=(TaskStatus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const TaskStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TaskStatus* internal_default_instance() {
    return reinterpret_cast<const TaskStatus*>(
               &_TaskStatus_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    96;

  void UnsafeArenaSwap(TaskStatus* other);
  void Swap(TaskStatus* other);
  friend void swap(TaskStatus& a, TaskStatus& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TaskStatus* New() const PROTOBUF_FINAL { return New(NULL); }

  TaskStatus* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TaskStatus& from);
  void MergeFrom(const TaskStatus& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TaskStatus* other);
  protected:
  explicit TaskStatus(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef TaskStatus_Source Source;
  static const Source SOURCE_MASTER =
    TaskStatus_Source_SOURCE_MASTER;
  static const Source SOURCE_SLAVE =
    TaskStatus_Source_SOURCE_SLAVE;
  static const Source SOURCE_EXECUTOR =
    TaskStatus_Source_SOURCE_EXECUTOR;
  static inline bool Source_IsValid(int value) {
    return TaskStatus_Source_IsValid(value);
  }
  static const Source Source_MIN =
    TaskStatus_Source_Source_MIN;
  static const Source Source_MAX =
    TaskStatus_Source_Source_MAX;
  static const int Source_ARRAYSIZE =
    TaskStatus_Source_Source_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Source_descriptor() {
    return TaskStatus_Source_descriptor();
  }
  static inline const ::std::string& Source_Name(Source value) {
    return TaskStatus_Source_Name(value);
  }
  static inline bool Source_Parse(const ::std::string& name,
      Source* value) {
    return TaskStatus_Source_Parse(name, value);
  }

  typedef TaskStatus_Reason Reason;
  static const Reason REASON_COMMAND_EXECUTOR_FAILED =
    TaskStatus_Reason_REASON_COMMAND_EXECUTOR_FAILED;
  static const Reason REASON_CONTAINER_LAUNCH_FAILED =
    TaskStatus_Reason_REASON_CONTAINER_LAUNCH_FAILED;
  static const Reason REASON_CONTAINER_LIMITATION =
    TaskStatus_Reason_REASON_CONTAINER_LIMITATION;
  static const Reason REASON_CONTAINER_LIMITATION_DISK =
    TaskStatus_Reason_REASON_CONTAINER_LIMITATION_DISK;
  static const Reason REASON_CONTAINER_LIMITATION_MEMORY =
    TaskStatus_Reason_REASON_CONTAINER_LIMITATION_MEMORY;
  static const Reason REASON_CONTAINER_PREEMPTED =
    TaskStatus_Reason_REASON_CONTAINER_PREEMPTED;
  static const Reason REASON_CONTAINER_UPDATE_FAILED =
    TaskStatus_Reason_REASON_CONTAINER_UPDATE_FAILED;
  static const Reason REASON_MAX_COMPLETION_TIME_REACHED =
    TaskStatus_Reason_REASON_MAX_COMPLETION_TIME_REACHED;
  static const Reason REASON_EXECUTOR_REGISTRATION_TIMEOUT =
    TaskStatus_Reason_REASON_EXECUTOR_REGISTRATION_TIMEOUT;
  static const Reason REASON_EXECUTOR_REREGISTRATION_TIMEOUT =
    TaskStatus_Reason_REASON_EXECUTOR_REREGISTRATION_TIMEOUT;
  static const Reason REASON_EXECUTOR_TERMINATED =
    TaskStatus_Reason_REASON_EXECUTOR_TERMINATED;
  static const Reason REASON_EXECUTOR_UNREGISTERED =
    TaskStatus_Reason_REASON_EXECUTOR_UNREGISTERED;
  static const Reason REASON_FRAMEWORK_REMOVED =
    TaskStatus_Reason_REASON_FRAMEWORK_REMOVED;
  static const Reason REASON_GC_ERROR =
    TaskStatus_Reason_REASON_GC_ERROR;
  static const Reason REASON_INVALID_FRAMEWORKID =
    TaskStatus_Reason_REASON_INVALID_FRAMEWORKID;
  static const Reason REASON_INVALID_OFFERS =
    TaskStatus_Reason_REASON_INVALID_OFFERS;
  static const Reason REASON_IO_SWITCHBOARD_EXITED =
    TaskStatus_Reason_REASON_IO_SWITCHBOARD_EXITED;
  static const Reason REASON_MASTER_DISCONNECTED =
    TaskStatus_Reason_REASON_MASTER_DISCONNECTED;
  static const Reason REASON_RECONCILIATION =
    TaskStatus_Reason_REASON_RECONCILIATION;
  static const Reason REASON_RESOURCES_UNKNOWN =
    TaskStatus_Reason_REASON_RESOURCES_UNKNOWN;
  static const Reason REASON_SLAVE_DISCONNECTED =
    TaskStatus_Reason_REASON_SLAVE_DISCONNECTED;
  static const Reason REASON_SLAVE_REMOVED =
    TaskStatus_Reason_REASON_SLAVE_REMOVED;
  static const Reason REASON_SLAVE_REMOVED_BY_OPERATOR =
    TaskStatus_Reason_REASON_SLAVE_REMOVED_BY_OPERATOR;
  static const Reason REASON_SLAVE_REREGISTERED =
    TaskStatus_Reason_REASON_SLAVE_REREGISTERED;
  static const Reason REASON_SLAVE_RESTARTED =
    TaskStatus_Reason_REASON_SLAVE_RESTARTED;
  static const Reason REASON_SLAVE_UNKNOWN =
    TaskStatus_Reason_REASON_SLAVE_UNKNOWN;
  static const Reason REASON_TASK_KILLED_DURING_LAUNCH =
    TaskStatus_Reason_REASON_TASK_KILLED_DURING_LAUNCH;
  static const Reason REASON_TASK_CHECK_STATUS_UPDATED =
    TaskStatus_Reason_REASON_TASK_CHECK_STATUS_UPDATED;
  static const Reason REASON_TASK_HEALTH_CHECK_STATUS_UPDATED =
    TaskStatus_Reason_REASON_TASK_HEALTH_CHECK_STATUS_UPDATED;
  static const Reason REASON_TASK_GROUP_INVALID =
    TaskStatus_Reason_REASON_TASK_GROUP_INVALID;
  static const Reason REASON_TASK_GROUP_UNAUTHORIZED =
    TaskStatus_Reason_REASON_TASK_GROUP_UNAUTHORIZED;
  static const Reason REASON_TASK_INVALID =
    TaskStatus_Reason_REASON_TASK_INVALID;
  static const Reason REASON_TASK_UNAUTHORIZED =
    TaskStatus_Reason_REASON_TASK_UNAUTHORIZED;
  static const Reason REASON_TASK_UNKNOWN =
    TaskStatus_Reason_REASON_TASK_UNKNOWN;
  static inline bool Reason_IsValid(int value) {
    return TaskStatus_Reason_IsValid(value);
  }
  static const Reason Reason_MIN =
    TaskStatus_Reason_Reason_MIN;
  static const Reason Reason_MAX =
    TaskStatus_Reason_Reason_MAX;
  static const int Reason_ARRAYSIZE =
    TaskStatus_Reason_Reason_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Reason_descriptor() {
    return TaskStatus_Reason_descriptor();
  }
  static inline const ::std::string& Reason_Name(Reason value) {
    return TaskStatus_Reason_Name(value);
  }
  static inline bool Reason_Parse(const ::std::string& name,
      Reason* value) {
    return TaskStatus_Reason_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional bytes data = 3;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 3;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_data();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_data(
      ::std::string* data);

  // optional string message = 4;
  bool has_message() const;
  void clear_message();
  static const int kMessageFieldNumber = 4;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_message();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_message(
      ::std::string* message);

  // optional bytes uuid = 11;
  bool has_uuid() const;
  void clear_uuid();
  static const int kUuidFieldNumber = 11;
  const ::std::string& uuid() const;
  void set_uuid(const ::std::string& value);
  #if LANG_CXX11
  void set_uuid(::std::string&& value);
  #endif
  void set_uuid(const char* value);
  void set_uuid(const void* value, size_t size);
  ::std::string* mutable_uuid();
  ::std::string* release_uuid();
  void set_allocated_uuid(::std::string* uuid);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_uuid();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_uuid(
      ::std::string* uuid);

  // required .mesos.TaskID task_id = 1;
  bool has_task_id() const;
  void clear_task_id();
  static const int kTaskIdFieldNumber = 1;
  private:
  void _slow_mutable_task_id();
  public:
  const ::mesos::TaskID& task_id() const;
  ::mesos::TaskID* release_task_id();
  ::mesos::TaskID* mutable_task_id();
  void set_allocated_task_id(::mesos::TaskID* task_id);
  void unsafe_arena_set_allocated_task_id(
      ::mesos::TaskID* task_id);
  ::mesos::TaskID* unsafe_arena_release_task_id();

  // optional .mesos.SlaveID slave_id = 5;
  bool has_slave_id() const;
  void clear_slave_id();
  static const int kSlaveIdFieldNumber = 5;
  private:
  void _slow_mutable_slave_id();
  public:
  const ::mesos::SlaveID& slave_id() const;
  ::mesos::SlaveID* release_slave_id();
  ::mesos::SlaveID* mutable_slave_id();
  void set_allocated_slave_id(::mesos::SlaveID* slave_id);
  void unsafe_arena_set_allocated_slave_id(
      ::mesos::SlaveID* slave_id);
  ::mesos::SlaveID* unsafe_arena_release_slave_id();

  // optional .mesos.ExecutorID executor_id = 7;
  bool has_executor_id() const;
  void clear_executor_id();
  static const int kExecutorIdFieldNumber = 7;
  private:
  void _slow_mutable_executor_id();
  public:
  const ::mesos::ExecutorID& executor_id() const;
  ::mesos::ExecutorID* release_executor_id();
  ::mesos::ExecutorID* mutable_executor_id();
  void set_allocated_executor_id(::mesos::ExecutorID* executor_id);
  void unsafe_arena_set_allocated_executor_id(
      ::mesos::ExecutorID* executor_id);
  ::mesos::ExecutorID* unsafe_arena_release_executor_id();

  // optional .mesos.Labels labels = 12;
  bool has_labels() const;
  void clear_labels();
  static const int kLabelsFieldNumber = 12;
  private:
  void _slow_mutable_labels();
  public:
  const ::mesos::Labels& labels() const;
  ::mesos::Labels* release_labels();
  ::mesos::Labels* mutable_labels();
  void set_allocated_labels(::mesos::Labels* labels);
  void unsafe_arena_set_allocated_labels(
      ::mesos::Labels* labels);
  ::mesos::Labels* unsafe_arena_release_labels();

  // optional .mesos.ContainerStatus container_status = 13;
  bool has_container_status() const;
  void clear_container_status();
  static const int kContainerStatusFieldNumber = 13;
  private:
  void _slow_mutable_container_status();
  public:
  const ::mesos::ContainerStatus& container_status() const;
  ::mesos::ContainerStatus* release_container_status();
  ::mesos::ContainerStatus* mutable_container_status();
  void set_allocated_container_status(::mesos::ContainerStatus* container_status);
  void unsafe_arena_set_allocated_container_status(
      ::mesos::ContainerStatus* container_status);
  ::mesos::ContainerStatus* unsafe_arena_release_container_status();

  // optional .mesos.TimeInfo unreachable_time = 14;
  bool has_unreachable_time() const;
  void clear_unreachable_time();
  static const int kUnreachableTimeFieldNumber = 14;
  private:
  void _slow_mutable_unreachable_time();
  public:
  const ::mesos::TimeInfo& unreachable_time() const;
  ::mesos::TimeInfo* release_unreachable_time();
  ::mesos::TimeInfo* mutable_unreachable_time();
  void set_allocated_unreachable_time(::mesos::TimeInfo* unreachable_time);
  void unsafe_arena_set_allocated_unreachable_time(
      ::mesos::TimeInfo* unreachable_time);
  ::mesos::TimeInfo* unsafe_arena_release_unreachable_time();

  // optional .mesos.CheckStatusInfo check_status = 15;
  bool has_check_status() const;
  void clear_check_status();
  static const int kCheckStatusFieldNumber = 15;
  private:
  void _slow_mutable_check_status();
  public:
  const ::mesos::CheckStatusInfo& check_status() const;
  ::mesos::CheckStatusInfo* release_check_status();
  ::mesos::CheckStatusInfo* mutable_check_status();
  void set_allocated_check_status(::mesos::CheckStatusInfo* check_status);
  void unsafe_arena_set_allocated_check_status(
      ::mesos::CheckStatusInfo* check_status);
  ::mesos::CheckStatusInfo* unsafe_arena_release_check_status();

  // optional .mesos.TaskResourceLimitation limitation = 16;
  bool has_limitation() const;
  void clear_limitation();
  static const int kLimitationFieldNumber = 16;
  private:
  void _slow_mutable_limitation();
  public:
  const ::mesos::TaskResourceLimitation& limitation() const;
  ::mesos::TaskResourceLimitation* release_limitation();
  ::mesos::TaskResourceLimitation* mutable_limitation();
  void set_allocated_limitation(::mesos::TaskResourceLimitation* limitation);
  void unsafe_arena_set_allocated_limitation(
      ::mesos::TaskResourceLimitation* limitation);
  ::mesos::TaskResourceLimitation* unsafe_arena_release_limitation();

  // optional double timestamp = 6;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 6;
  double timestamp() const;
  void set_timestamp(double value);

  // optional bool healthy = 8;
  bool has_healthy() const;
  void clear_healthy();
  static const int kHealthyFieldNumber = 8;
  bool healthy() const;
  void set_healthy(bool value);

  // optional .mesos.TaskStatus.Source source = 9;
  bool has_source() const;
  void clear_source();
  static const int kSourceFieldNumber = 9;
  ::mesos::TaskStatus_Source source() const;
  void set_source(::mesos::TaskStatus_Source value);

  // optional .mesos.TaskStatus.Reason reason = 10;
  bool has_reason() const;
  void clear_reason();
  static const int kReasonFieldNumber = 10;
  ::mesos::TaskStatus_Reason reason() const;
  void set_reason(::mesos::TaskStatus_Reason value);

  // required .mesos.TaskState state = 2;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 2;
  ::mesos::TaskState state() const;
  void set_state(::mesos::TaskState value);

  // @@protoc_insertion_point(class_scope:mesos.TaskStatus)
 private:
  void set_has_task_id();
  void clear_has_task_id();
  void set_has_state();
  void clear_has_state();
  void set_has_message();
  void clear_has_message();
  void set_has_source();
  void clear_has_source();
  void set_has_reason();
  void clear_has_reason();
  void set_has_data();
  void clear_has_data();
  void set_has_slave_id();
  void clear_has_slave_id();
  void set_has_executor_id();
  void clear_has_executor_id();
  void set_has_timestamp();
  void clear_has_timestamp();
  void set_has_uuid();
  void clear_has_uuid();
  void set_has_healthy();
  void clear_has_healthy();
  void set_has_check_status();
  void clear_has_check_status();
  void set_has_labels();
  void clear_has_labels();
  void set_has_container_status();
  void clear_has_container_status();
  void set_has_unreachable_time();
  void clear_has_unreachable_time();
  void set_has_limitation();
  void clear_has_limitation();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  ::google::protobuf::internal::ArenaStringPtr uuid_;
  ::mesos::TaskID* task_id_;
  ::mesos::SlaveID* slave_id_;
  ::mesos::ExecutorID* executor_id_;
  ::mesos::Labels* labels_;
  ::mesos::ContainerStatus* container_status_;
  ::mesos::TimeInfo* unreachable_time_;
  ::mesos::CheckStatusInfo* check_status_;
  ::mesos::TaskResourceLimitation* limitation_;
  double timestamp_;
  bool healthy_;
  int source_;
  int reason_;
  int state_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsTaskStatusImpl();
};
// -------------------------------------------------------------------

class Filters : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.Filters) */ {
 public:
  Filters();
  virtual ~Filters();

  Filters(const Filters& from);

  inline Filters& operator=(const Filters& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Filters(Filters&& from) noexcept
    : Filters() {
    *this = ::std::move(from);
  }

  inline Filters& operator=(Filters&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Filters& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Filters* internal_default_instance() {
    return reinterpret_cast<const Filters*>(
               &_Filters_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    97;

  void UnsafeArenaSwap(Filters* other);
  void Swap(Filters* other);
  friend void swap(Filters& a, Filters& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Filters* New() const PROTOBUF_FINAL { return New(NULL); }

  Filters* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Filters& from);
  void MergeFrom(const Filters& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Filters* other);
  protected:
  explicit Filters(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double refuse_seconds = 1 [default = 5];
  bool has_refuse_seconds() const;
  void clear_refuse_seconds();
  static const int kRefuseSecondsFieldNumber = 1;
  double refuse_seconds() const;
  void set_refuse_seconds(double value);

  // @@protoc_insertion_point(class_scope:mesos.Filters)
 private:
  void set_has_refuse_seconds();
  void clear_has_refuse_seconds();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  double refuse_seconds_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsFiltersImpl();
};
// -------------------------------------------------------------------

class Environment_Variable : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.Environment.Variable) */ {
 public:
  Environment_Variable();
  virtual ~Environment_Variable();

  Environment_Variable(const Environment_Variable& from);

  inline Environment_Variable& operator=(const Environment_Variable& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Environment_Variable(Environment_Variable&& from) noexcept
    : Environment_Variable() {
    *this = ::std::move(from);
  }

  inline Environment_Variable& operator=(Environment_Variable&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Environment_Variable& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Environment_Variable* internal_default_instance() {
    return reinterpret_cast<const Environment_Variable*>(
               &_Environment_Variable_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    98;

  void UnsafeArenaSwap(Environment_Variable* other);
  void Swap(Environment_Variable* other);
  friend void swap(Environment_Variable& a, Environment_Variable& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Environment_Variable* New() const PROTOBUF_FINAL { return New(NULL); }

  Environment_Variable* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Environment_Variable& from);
  void MergeFrom(const Environment_Variable& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Environment_Variable* other);
  protected:
  explicit Environment_Variable(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Environment_Variable_Type Type;
  static const Type UNKNOWN =
    Environment_Variable_Type_UNKNOWN;
  static const Type VALUE =
    Environment_Variable_Type_VALUE;
  static const Type SECRET =
    Environment_Variable_Type_SECRET;
  static inline bool Type_IsValid(int value) {
    return Environment_Variable_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Environment_Variable_Type_Type_MIN;
  static const Type Type_MAX =
    Environment_Variable_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Environment_Variable_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Environment_Variable_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Environment_Variable_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Environment_Variable_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_name();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      ::std::string* name);

  // optional string value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_value();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_value(
      ::std::string* value);

  // optional .mesos.Secret secret = 4;
  bool has_secret() const;
  void clear_secret();
  static const int kSecretFieldNumber = 4;
  private:
  void _slow_mutable_secret();
  public:
  const ::mesos::Secret& secret() const;
  ::mesos::Secret* release_secret();
  ::mesos::Secret* mutable_secret();
  void set_allocated_secret(::mesos::Secret* secret);
  void unsafe_arena_set_allocated_secret(
      ::mesos::Secret* secret);
  ::mesos::Secret* unsafe_arena_release_secret();

  // optional .mesos.Environment.Variable.Type type = 3 [default = VALUE];
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 3;
  ::mesos::Environment_Variable_Type type() const;
  void set_type(::mesos::Environment_Variable_Type value);

  // @@protoc_insertion_point(class_scope:mesos.Environment.Variable)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_type();
  void clear_has_type();
  void set_has_value();
  void clear_has_value();
  void set_has_secret();
  void clear_has_secret();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  ::mesos::Secret* secret_;
  int type_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsEnvironment_VariableImpl();
};
// -------------------------------------------------------------------

class Environment : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.Environment) */ {
 public:
  Environment();
  virtual ~Environment();

  Environment(const Environment& from);

  inline Environment& operator=(const Environment& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Environment(Environment&& from) noexcept
    : Environment() {
    *this = ::std::move(from);
  }

  inline Environment& operator=(Environment&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Environment& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Environment* internal_default_instance() {
    return reinterpret_cast<const Environment*>(
               &_Environment_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    99;

  void UnsafeArenaSwap(Environment* other);
  void Swap(Environment* other);
  friend void swap(Environment& a, Environment& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Environment* New() const PROTOBUF_FINAL { return New(NULL); }

  Environment* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Environment& from);
  void MergeFrom(const Environment& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Environment* other);
  protected:
  explicit Environment(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Environment_Variable Variable;

  // accessors -------------------------------------------------------

  // repeated .mesos.Environment.Variable variables = 1;
  int variables_size() const;
  void clear_variables();
  static const int kVariablesFieldNumber = 1;
  const ::mesos::Environment_Variable& variables(int index) const;
  ::mesos::Environment_Variable* mutable_variables(int index);
  ::mesos::Environment_Variable* add_variables();
  ::google::protobuf::RepeatedPtrField< ::mesos::Environment_Variable >*
      mutable_variables();
  const ::google::protobuf::RepeatedPtrField< ::mesos::Environment_Variable >&
      variables() const;

  // @@protoc_insertion_point(class_scope:mesos.Environment)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Environment_Variable > variables_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsEnvironmentImpl();
};
// -------------------------------------------------------------------

class Parameter : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.Parameter) */ {
 public:
  Parameter();
  virtual ~Parameter();

  Parameter(const Parameter& from);

  inline Parameter& operator=(const Parameter& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Parameter(Parameter&& from) noexcept
    : Parameter() {
    *this = ::std::move(from);
  }

  inline Parameter& operator=(Parameter&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Parameter& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Parameter* internal_default_instance() {
    return reinterpret_cast<const Parameter*>(
               &_Parameter_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    100;

  void UnsafeArenaSwap(Parameter* other);
  void Swap(Parameter* other);
  friend void swap(Parameter& a, Parameter& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Parameter* New() const PROTOBUF_FINAL { return New(NULL); }

  Parameter* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Parameter& from);
  void MergeFrom(const Parameter& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Parameter* other);
  protected:
  explicit Parameter(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string key = 1;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_key();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_key(
      ::std::string* key);

  // required string value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_value();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_value(
      ::std::string* value);

  // @@protoc_insertion_point(class_scope:mesos.Parameter)
 private:
  void set_has_key();
  void clear_has_key();
  void set_has_value();
  void clear_has_value();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsParameterImpl();
};
// -------------------------------------------------------------------

class Parameters : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.Parameters) */ {
 public:
  Parameters();
  virtual ~Parameters();

  Parameters(const Parameters& from);

  inline Parameters& operator=(const Parameters& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Parameters(Parameters&& from) noexcept
    : Parameters() {
    *this = ::std::move(from);
  }

  inline Parameters& operator=(Parameters&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Parameters& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Parameters* internal_default_instance() {
    return reinterpret_cast<const Parameters*>(
               &_Parameters_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    101;

  void UnsafeArenaSwap(Parameters* other);
  void Swap(Parameters* other);
  friend void swap(Parameters& a, Parameters& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Parameters* New() const PROTOBUF_FINAL { return New(NULL); }

  Parameters* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Parameters& from);
  void MergeFrom(const Parameters& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Parameters* other);
  protected:
  explicit Parameters(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.Parameter parameter = 1;
  int parameter_size() const;
  void clear_parameter();
  static const int kParameterFieldNumber = 1;
  const ::mesos::Parameter& parameter(int index) const;
  ::mesos::Parameter* mutable_parameter(int index);
  ::mesos::Parameter* add_parameter();
  ::google::protobuf::RepeatedPtrField< ::mesos::Parameter >*
      mutable_parameter();
  const ::google::protobuf::RepeatedPtrField< ::mesos::Parameter >&
      parameter() const;

  // @@protoc_insertion_point(class_scope:mesos.Parameters)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Parameter > parameter_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsParametersImpl();
};
// -------------------------------------------------------------------

class Credential : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.Credential) */ {
 public:
  Credential();
  virtual ~Credential();

  Credential(const Credential& from);

  inline Credential& operator=(const Credential& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Credential(Credential&& from) noexcept
    : Credential() {
    *this = ::std::move(from);
  }

  inline Credential& operator=(Credential&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Credential& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Credential* internal_default_instance() {
    return reinterpret_cast<const Credential*>(
               &_Credential_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    102;

  void UnsafeArenaSwap(Credential* other);
  void Swap(Credential* other);
  friend void swap(Credential& a, Credential& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Credential* New() const PROTOBUF_FINAL { return New(NULL); }

  Credential* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Credential& from);
  void MergeFrom(const Credential& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Credential* other);
  protected:
  explicit Credential(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string principal = 1;
  bool has_principal() const;
  void clear_principal();
  static const int kPrincipalFieldNumber = 1;
  const ::std::string& principal() const;
  void set_principal(const ::std::string& value);
  #if LANG_CXX11
  void set_principal(::std::string&& value);
  #endif
  void set_principal(const char* value);
  void set_principal(const char* value, size_t size);
  ::std::string* mutable_principal();
  ::std::string* release_principal();
  void set_allocated_principal(::std::string* principal);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_principal();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_principal(
      ::std::string* principal);

  // optional string secret = 2;
  bool has_secret() const;
  void clear_secret();
  static const int kSecretFieldNumber = 2;
  const ::std::string& secret() const;
  void set_secret(const ::std::string& value);
  #if LANG_CXX11
  void set_secret(::std::string&& value);
  #endif
  void set_secret(const char* value);
  void set_secret(const char* value, size_t size);
  ::std::string* mutable_secret();
  ::std::string* release_secret();
  void set_allocated_secret(::std::string* secret);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_secret();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_secret(
      ::std::string* secret);

  // @@protoc_insertion_point(class_scope:mesos.Credential)
 private:
  void set_has_principal();
  void clear_has_principal();
  void set_has_secret();
  void clear_has_secret();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr principal_;
  ::google::protobuf::internal::ArenaStringPtr secret_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsCredentialImpl();
};
// -------------------------------------------------------------------

class Credentials : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.Credentials) */ {
 public:
  Credentials();
  virtual ~Credentials();

  Credentials(const Credentials& from);

  inline Credentials& operator=(const Credentials& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Credentials(Credentials&& from) noexcept
    : Credentials() {
    *this = ::std::move(from);
  }

  inline Credentials& operator=(Credentials&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Credentials& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Credentials* internal_default_instance() {
    return reinterpret_cast<const Credentials*>(
               &_Credentials_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    103;

  void UnsafeArenaSwap(Credentials* other);
  void Swap(Credentials* other);
  friend void swap(Credentials& a, Credentials& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Credentials* New() const PROTOBUF_FINAL { return New(NULL); }

  Credentials* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Credentials& from);
  void MergeFrom(const Credentials& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Credentials* other);
  protected:
  explicit Credentials(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.Credential credentials = 1;
  int credentials_size() const;
  void clear_credentials();
  static const int kCredentialsFieldNumber = 1;
  const ::mesos::Credential& credentials(int index) const;
  ::mesos::Credential* mutable_credentials(int index);
  ::mesos::Credential* add_credentials();
  ::google::protobuf::RepeatedPtrField< ::mesos::Credential >*
      mutable_credentials();
  const ::google::protobuf::RepeatedPtrField< ::mesos::Credential >&
      credentials() const;

  // @@protoc_insertion_point(class_scope:mesos.Credentials)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Credential > credentials_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsCredentialsImpl();
};
// -------------------------------------------------------------------

class Secret_Reference : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.Secret.Reference) */ {
 public:
  Secret_Reference();
  virtual ~Secret_Reference();

  Secret_Reference(const Secret_Reference& from);

  inline Secret_Reference& operator=(const Secret_Reference& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Secret_Reference(Secret_Reference&& from) noexcept
    : Secret_Reference() {
    *this = ::std::move(from);
  }

  inline Secret_Reference& operator=(Secret_Reference&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Secret_Reference& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Secret_Reference* internal_default_instance() {
    return reinterpret_cast<const Secret_Reference*>(
               &_Secret_Reference_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    104;

  void UnsafeArenaSwap(Secret_Reference* other);
  void Swap(Secret_Reference* other);
  friend void swap(Secret_Reference& a, Secret_Reference& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Secret_Reference* New() const PROTOBUF_FINAL { return New(NULL); }

  Secret_Reference* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Secret_Reference& from);
  void MergeFrom(const Secret_Reference& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Secret_Reference* other);
  protected:
  explicit Secret_Reference(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_name();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      ::std::string* name);

  // optional string key = 2;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 2;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_key();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_key(
      ::std::string* key);

  // @@protoc_insertion_point(class_scope:mesos.Secret.Reference)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_key();
  void clear_has_key();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsSecret_ReferenceImpl();
};
// -------------------------------------------------------------------

class Secret_Value : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.Secret.Value) */ {
 public:
  Secret_Value();
  virtual ~Secret_Value();

  Secret_Value(const Secret_Value& from);

  inline Secret_Value& operator=(const Secret_Value& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Secret_Value(Secret_Value&& from) noexcept
    : Secret_Value() {
    *this = ::std::move(from);
  }

  inline Secret_Value& operator=(Secret_Value&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Secret_Value& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Secret_Value* internal_default_instance() {
    return reinterpret_cast<const Secret_Value*>(
               &_Secret_Value_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    105;

  void UnsafeArenaSwap(Secret_Value* other);
  void Swap(Secret_Value* other);
  friend void swap(Secret_Value& a, Secret_Value& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Secret_Value* New() const PROTOBUF_FINAL { return New(NULL); }

  Secret_Value* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Secret_Value& from);
  void MergeFrom(const Secret_Value& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Secret_Value* other);
  protected:
  explicit Secret_Value(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes data = 1;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 1;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_data();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_data(
      ::std::string* data);

  // @@protoc_insertion_point(class_scope:mesos.Secret.Value)
 private:
  void set_has_data();
  void clear_has_data();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsSecret_ValueImpl();
};
// -------------------------------------------------------------------

class Secret : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.Secret) */ {
 public:
  Secret();
  virtual ~Secret();

  Secret(const Secret& from);

  inline Secret& operator=(const Secret& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Secret(Secret&& from) noexcept
    : Secret() {
    *this = ::std::move(from);
  }

  inline Secret& operator=(Secret&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Secret& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Secret* internal_default_instance() {
    return reinterpret_cast<const Secret*>(
               &_Secret_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    106;

  void UnsafeArenaSwap(Secret* other);
  void Swap(Secret* other);
  friend void swap(Secret& a, Secret& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Secret* New() const PROTOBUF_FINAL { return New(NULL); }

  Secret* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Secret& from);
  void MergeFrom(const Secret& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Secret* other);
  protected:
  explicit Secret(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Secret_Reference Reference;
  typedef Secret_Value Value;

  typedef Secret_Type Type;
  static const Type UNKNOWN =
    Secret_Type_UNKNOWN;
  static const Type REFERENCE =
    Secret_Type_REFERENCE;
  static const Type VALUE =
    Secret_Type_VALUE;
  static inline bool Type_IsValid(int value) {
    return Secret_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Secret_Type_Type_MIN;
  static const Type Type_MAX =
    Secret_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Secret_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Secret_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Secret_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Secret_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .mesos.Secret.Reference reference = 2;
  bool has_reference() const;
  void clear_reference();
  static const int kReferenceFieldNumber = 2;
  private:
  void _slow_mutable_reference();
  public:
  const ::mesos::Secret_Reference& reference() const;
  ::mesos::Secret_Reference* release_reference();
  ::mesos::Secret_Reference* mutable_reference();
  void set_allocated_reference(::mesos::Secret_Reference* reference);
  void unsafe_arena_set_allocated_reference(
      ::mesos::Secret_Reference* reference);
  ::mesos::Secret_Reference* unsafe_arena_release_reference();

  // optional .mesos.Secret.Value value = 3;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 3;
  private:
  void _slow_mutable_value();
  public:
  const ::mesos::Secret_Value& value() const;
  ::mesos::Secret_Value* release_value();
  ::mesos::Secret_Value* mutable_value();
  void set_allocated_value(::mesos::Secret_Value* value);
  void unsafe_arena_set_allocated_value(
      ::mesos::Secret_Value* value);
  ::mesos::Secret_Value* unsafe_arena_release_value();

  // optional .mesos.Secret.Type type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::mesos::Secret_Type type() const;
  void set_type(::mesos::Secret_Type value);

  // @@protoc_insertion_point(class_scope:mesos.Secret)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_reference();
  void clear_has_reference();
  void set_has_value();
  void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::Secret_Reference* reference_;
  ::mesos::Secret_Value* value_;
  int type_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsSecretImpl();
};
// -------------------------------------------------------------------

class RateLimit : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.RateLimit) */ {
 public:
  RateLimit();
  virtual ~RateLimit();

  RateLimit(const RateLimit& from);

  inline RateLimit& operator=(const RateLimit& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RateLimit(RateLimit&& from) noexcept
    : RateLimit() {
    *this = ::std::move(from);
  }

  inline RateLimit& operator=(RateLimit&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const RateLimit& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RateLimit* internal_default_instance() {
    return reinterpret_cast<const RateLimit*>(
               &_RateLimit_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    107;

  void UnsafeArenaSwap(RateLimit* other);
  void Swap(RateLimit* other);
  friend void swap(RateLimit& a, RateLimit& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RateLimit* New() const PROTOBUF_FINAL { return New(NULL); }

  RateLimit* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RateLimit& from);
  void MergeFrom(const RateLimit& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RateLimit* other);
  protected:
  explicit RateLimit(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string principal = 2;
  bool has_principal() const;
  void clear_principal();
  static const int kPrincipalFieldNumber = 2;
  const ::std::string& principal() const;
  void set_principal(const ::std::string& value);
  #if LANG_CXX11
  void set_principal(::std::string&& value);
  #endif
  void set_principal(const char* value);
  void set_principal(const char* value, size_t size);
  ::std::string* mutable_principal();
  ::std::string* release_principal();
  void set_allocated_principal(::std::string* principal);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_principal();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_principal(
      ::std::string* principal);

  // optional double qps = 1;
  bool has_qps() const;
  void clear_qps();
  static const int kQpsFieldNumber = 1;
  double qps() const;
  void set_qps(double value);

  // optional uint64 capacity = 3;
  bool has_capacity() const;
  void clear_capacity();
  static const int kCapacityFieldNumber = 3;
  ::google::protobuf::uint64 capacity() const;
  void set_capacity(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:mesos.RateLimit)
 private:
  void set_has_qps();
  void clear_has_qps();
  void set_has_principal();
  void clear_has_principal();
  void set_has_capacity();
  void clear_has_capacity();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr principal_;
  double qps_;
  ::google::protobuf::uint64 capacity_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsRateLimitImpl();
};
// -------------------------------------------------------------------

class RateLimits : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.RateLimits) */ {
 public:
  RateLimits();
  virtual ~RateLimits();

  RateLimits(const RateLimits& from);

  inline RateLimits& operator=(const RateLimits& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RateLimits(RateLimits&& from) noexcept
    : RateLimits() {
    *this = ::std::move(from);
  }

  inline RateLimits& operator=(RateLimits&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const RateLimits& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RateLimits* internal_default_instance() {
    return reinterpret_cast<const RateLimits*>(
               &_RateLimits_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    108;

  void UnsafeArenaSwap(RateLimits* other);
  void Swap(RateLimits* other);
  friend void swap(RateLimits& a, RateLimits& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RateLimits* New() const PROTOBUF_FINAL { return New(NULL); }

  RateLimits* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RateLimits& from);
  void MergeFrom(const RateLimits& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RateLimits* other);
  protected:
  explicit RateLimits(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.RateLimit limits = 1;
  int limits_size() const;
  void clear_limits();
  static const int kLimitsFieldNumber = 1;
  const ::mesos::RateLimit& limits(int index) const;
  ::mesos::RateLimit* mutable_limits(int index);
  ::mesos::RateLimit* add_limits();
  ::google::protobuf::RepeatedPtrField< ::mesos::RateLimit >*
      mutable_limits();
  const ::google::protobuf::RepeatedPtrField< ::mesos::RateLimit >&
      limits() const;

  // optional double aggregate_default_qps = 2;
  bool has_aggregate_default_qps() const;
  void clear_aggregate_default_qps();
  static const int kAggregateDefaultQpsFieldNumber = 2;
  double aggregate_default_qps() const;
  void set_aggregate_default_qps(double value);

  // optional uint64 aggregate_default_capacity = 3;
  bool has_aggregate_default_capacity() const;
  void clear_aggregate_default_capacity();
  static const int kAggregateDefaultCapacityFieldNumber = 3;
  ::google::protobuf::uint64 aggregate_default_capacity() const;
  void set_aggregate_default_capacity(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:mesos.RateLimits)
 private:
  void set_has_aggregate_default_qps();
  void clear_has_aggregate_default_qps();
  void set_has_aggregate_default_capacity();
  void clear_has_aggregate_default_capacity();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::RateLimit > limits_;
  double aggregate_default_qps_;
  ::google::protobuf::uint64 aggregate_default_capacity_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsRateLimitsImpl();
};
// -------------------------------------------------------------------

class Image_Appc : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.Image.Appc) */ {
 public:
  Image_Appc();
  virtual ~Image_Appc();

  Image_Appc(const Image_Appc& from);

  inline Image_Appc& operator=(const Image_Appc& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Image_Appc(Image_Appc&& from) noexcept
    : Image_Appc() {
    *this = ::std::move(from);
  }

  inline Image_Appc& operator=(Image_Appc&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Image_Appc& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Image_Appc* internal_default_instance() {
    return reinterpret_cast<const Image_Appc*>(
               &_Image_Appc_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    109;

  void UnsafeArenaSwap(Image_Appc* other);
  void Swap(Image_Appc* other);
  friend void swap(Image_Appc& a, Image_Appc& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Image_Appc* New() const PROTOBUF_FINAL { return New(NULL); }

  Image_Appc* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Image_Appc& from);
  void MergeFrom(const Image_Appc& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Image_Appc* other);
  protected:
  explicit Image_Appc(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_name();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      ::std::string* name);

  // optional string id = 2;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 2;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_id();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_id(
      ::std::string* id);

  // optional .mesos.Labels labels = 3;
  bool has_labels() const;
  void clear_labels();
  static const int kLabelsFieldNumber = 3;
  private:
  void _slow_mutable_labels();
  public:
  const ::mesos::Labels& labels() const;
  ::mesos::Labels* release_labels();
  ::mesos::Labels* mutable_labels();
  void set_allocated_labels(::mesos::Labels* labels);
  void unsafe_arena_set_allocated_labels(
      ::mesos::Labels* labels);
  ::mesos::Labels* unsafe_arena_release_labels();

  // @@protoc_insertion_point(class_scope:mesos.Image.Appc)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_id();
  void clear_has_id();
  void set_has_labels();
  void clear_has_labels();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::mesos::Labels* labels_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsImage_AppcImpl();
};
// -------------------------------------------------------------------

class Image_Docker : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.Image.Docker) */ {
 public:
  Image_Docker();
  virtual ~Image_Docker();

  Image_Docker(const Image_Docker& from);

  inline Image_Docker& operator=(const Image_Docker& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Image_Docker(Image_Docker&& from) noexcept
    : Image_Docker() {
    *this = ::std::move(from);
  }

  inline Image_Docker& operator=(Image_Docker&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Image_Docker& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Image_Docker* internal_default_instance() {
    return reinterpret_cast<const Image_Docker*>(
               &_Image_Docker_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    110;

  void UnsafeArenaSwap(Image_Docker* other);
  void Swap(Image_Docker* other);
  friend void swap(Image_Docker& a, Image_Docker& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Image_Docker* New() const PROTOBUF_FINAL { return New(NULL); }

  Image_Docker* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Image_Docker& from);
  void MergeFrom(const Image_Docker& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Image_Docker* other);
  protected:
  explicit Image_Docker(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_name();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      ::std::string* name);

  // optional .mesos.Credential credential = 2 [deprecated = true];
  GOOGLE_PROTOBUF_DEPRECATED_ATTR bool has_credential() const;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void clear_credential();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR static const int kCredentialFieldNumber = 2;
  private:
  void _slow_mutable_credential();
  public:
  GOOGLE_PROTOBUF_DEPRECATED_ATTR const ::mesos::Credential& credential() const;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR ::mesos::Credential* release_credential();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR ::mesos::Credential* mutable_credential();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void set_allocated_credential(::mesos::Credential* credential);
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void unsafe_arena_set_allocated_credential(
      ::mesos::Credential* credential);
  GOOGLE_PROTOBUF_DEPRECATED_ATTR ::mesos::Credential* unsafe_arena_release_credential();

  // optional .mesos.Secret config = 3;
  bool has_config() const;
  void clear_config();
  static const int kConfigFieldNumber = 3;
  private:
  void _slow_mutable_config();
  public:
  const ::mesos::Secret& config() const;
  ::mesos::Secret* release_config();
  ::mesos::Secret* mutable_config();
  void set_allocated_config(::mesos::Secret* config);
  void unsafe_arena_set_allocated_config(
      ::mesos::Secret* config);
  ::mesos::Secret* unsafe_arena_release_config();

  // @@protoc_insertion_point(class_scope:mesos.Image.Docker)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_credential();
  void clear_has_credential();
  void set_has_config();
  void clear_has_config();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::mesos::Credential* credential_;
  ::mesos::Secret* config_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsImage_DockerImpl();
};
// -------------------------------------------------------------------

class Image : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.Image) */ {
 public:
  Image();
  virtual ~Image();

  Image(const Image& from);

  inline Image& operator=(const Image& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Image(Image&& from) noexcept
    : Image() {
    *this = ::std::move(from);
  }

  inline Image& operator=(Image&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Image& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Image* internal_default_instance() {
    return reinterpret_cast<const Image*>(
               &_Image_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    111;

  void UnsafeArenaSwap(Image* other);
  void Swap(Image* other);
  friend void swap(Image& a, Image& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Image* New() const PROTOBUF_FINAL { return New(NULL); }

  Image* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Image& from);
  void MergeFrom(const Image& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Image* other);
  protected:
  explicit Image(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Image_Appc Appc;
  typedef Image_Docker Docker;

  typedef Image_Type Type;
  static const Type APPC =
    Image_Type_APPC;
  static const Type DOCKER =
    Image_Type_DOCKER;
  static inline bool Type_IsValid(int value) {
    return Image_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Image_Type_Type_MIN;
  static const Type Type_MAX =
    Image_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Image_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Image_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Image_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Image_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .mesos.Image.Appc appc = 2;
  bool has_appc() const;
  void clear_appc();
  static const int kAppcFieldNumber = 2;
  private:
  void _slow_mutable_appc();
  public:
  const ::mesos::Image_Appc& appc() const;
  ::mesos::Image_Appc* release_appc();
  ::mesos::Image_Appc* mutable_appc();
  void set_allocated_appc(::mesos::Image_Appc* appc);
  void unsafe_arena_set_allocated_appc(
      ::mesos::Image_Appc* appc);
  ::mesos::Image_Appc* unsafe_arena_release_appc();

  // optional .mesos.Image.Docker docker = 3;
  bool has_docker() const;
  void clear_docker();
  static const int kDockerFieldNumber = 3;
  private:
  void _slow_mutable_docker();
  public:
  const ::mesos::Image_Docker& docker() const;
  ::mesos::Image_Docker* release_docker();
  ::mesos::Image_Docker* mutable_docker();
  void set_allocated_docker(::mesos::Image_Docker* docker);
  void unsafe_arena_set_allocated_docker(
      ::mesos::Image_Docker* docker);
  ::mesos::Image_Docker* unsafe_arena_release_docker();

  // required .mesos.Image.Type type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::mesos::Image_Type type() const;
  void set_type(::mesos::Image_Type value);

  // optional bool cached = 4 [default = true];
  bool has_cached() const;
  void clear_cached();
  static const int kCachedFieldNumber = 4;
  bool cached() const;
  void set_cached(bool value);

  // @@protoc_insertion_point(class_scope:mesos.Image)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_appc();
  void clear_has_appc();
  void set_has_docker();
  void clear_has_docker();
  void set_has_cached();
  void clear_has_cached();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::Image_Appc* appc_;
  ::mesos::Image_Docker* docker_;
  int type_;
  bool cached_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsImageImpl();
};
// -------------------------------------------------------------------

class MountPropagation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.MountPropagation) */ {
 public:
  MountPropagation();
  virtual ~MountPropagation();

  MountPropagation(const MountPropagation& from);

  inline MountPropagation& operator=(const MountPropagation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MountPropagation(MountPropagation&& from) noexcept
    : MountPropagation() {
    *this = ::std::move(from);
  }

  inline MountPropagation& operator=(MountPropagation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const MountPropagation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MountPropagation* internal_default_instance() {
    return reinterpret_cast<const MountPropagation*>(
               &_MountPropagation_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    112;

  void UnsafeArenaSwap(MountPropagation* other);
  void Swap(MountPropagation* other);
  friend void swap(MountPropagation& a, MountPropagation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MountPropagation* New() const PROTOBUF_FINAL { return New(NULL); }

  MountPropagation* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MountPropagation& from);
  void MergeFrom(const MountPropagation& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MountPropagation* other);
  protected:
  explicit MountPropagation(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef MountPropagation_Mode Mode;
  static const Mode UNKNOWN =
    MountPropagation_Mode_UNKNOWN;
  static const Mode HOST_TO_CONTAINER =
    MountPropagation_Mode_HOST_TO_CONTAINER;
  static const Mode BIDIRECTIONAL =
    MountPropagation_Mode_BIDIRECTIONAL;
  static inline bool Mode_IsValid(int value) {
    return MountPropagation_Mode_IsValid(value);
  }
  static const Mode Mode_MIN =
    MountPropagation_Mode_Mode_MIN;
  static const Mode Mode_MAX =
    MountPropagation_Mode_Mode_MAX;
  static const int Mode_ARRAYSIZE =
    MountPropagation_Mode_Mode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Mode_descriptor() {
    return MountPropagation_Mode_descriptor();
  }
  static inline const ::std::string& Mode_Name(Mode value) {
    return MountPropagation_Mode_Name(value);
  }
  static inline bool Mode_Parse(const ::std::string& name,
      Mode* value) {
    return MountPropagation_Mode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .mesos.MountPropagation.Mode mode = 1;
  bool has_mode() const;
  void clear_mode();
  static const int kModeFieldNumber = 1;
  ::mesos::MountPropagation_Mode mode() const;
  void set_mode(::mesos::MountPropagation_Mode value);

  // @@protoc_insertion_point(class_scope:mesos.MountPropagation)
 private:
  void set_has_mode();
  void clear_has_mode();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  int mode_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsMountPropagationImpl();
};
// -------------------------------------------------------------------

class Volume_Source_DockerVolume : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.Volume.Source.DockerVolume) */ {
 public:
  Volume_Source_DockerVolume();
  virtual ~Volume_Source_DockerVolume();

  Volume_Source_DockerVolume(const Volume_Source_DockerVolume& from);

  inline Volume_Source_DockerVolume& operator=(const Volume_Source_DockerVolume& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Volume_Source_DockerVolume(Volume_Source_DockerVolume&& from) noexcept
    : Volume_Source_DockerVolume() {
    *this = ::std::move(from);
  }

  inline Volume_Source_DockerVolume& operator=(Volume_Source_DockerVolume&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Volume_Source_DockerVolume& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Volume_Source_DockerVolume* internal_default_instance() {
    return reinterpret_cast<const Volume_Source_DockerVolume*>(
               &_Volume_Source_DockerVolume_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    113;

  void UnsafeArenaSwap(Volume_Source_DockerVolume* other);
  void Swap(Volume_Source_DockerVolume* other);
  friend void swap(Volume_Source_DockerVolume& a, Volume_Source_DockerVolume& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Volume_Source_DockerVolume* New() const PROTOBUF_FINAL { return New(NULL); }

  Volume_Source_DockerVolume* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Volume_Source_DockerVolume& from);
  void MergeFrom(const Volume_Source_DockerVolume& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Volume_Source_DockerVolume* other);
  protected:
  explicit Volume_Source_DockerVolume(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string driver = 1;
  bool has_driver() const;
  void clear_driver();
  static const int kDriverFieldNumber = 1;
  const ::std::string& driver() const;
  void set_driver(const ::std::string& value);
  #if LANG_CXX11
  void set_driver(::std::string&& value);
  #endif
  void set_driver(const char* value);
  void set_driver(const char* value, size_t size);
  ::std::string* mutable_driver();
  ::std::string* release_driver();
  void set_allocated_driver(::std::string* driver);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_driver();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_driver(
      ::std::string* driver);

  // required string name = 2;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_name();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      ::std::string* name);

  // optional .mesos.Parameters driver_options = 3;
  bool has_driver_options() const;
  void clear_driver_options();
  static const int kDriverOptionsFieldNumber = 3;
  private:
  void _slow_mutable_driver_options();
  public:
  const ::mesos::Parameters& driver_options() const;
  ::mesos::Parameters* release_driver_options();
  ::mesos::Parameters* mutable_driver_options();
  void set_allocated_driver_options(::mesos::Parameters* driver_options);
  void unsafe_arena_set_allocated_driver_options(
      ::mesos::Parameters* driver_options);
  ::mesos::Parameters* unsafe_arena_release_driver_options();

  // @@protoc_insertion_point(class_scope:mesos.Volume.Source.DockerVolume)
 private:
  void set_has_driver();
  void clear_has_driver();
  void set_has_name();
  void clear_has_name();
  void set_has_driver_options();
  void clear_has_driver_options();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr driver_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::mesos::Parameters* driver_options_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsVolume_Source_DockerVolumeImpl();
};
// -------------------------------------------------------------------

class Volume_Source_HostPath : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.Volume.Source.HostPath) */ {
 public:
  Volume_Source_HostPath();
  virtual ~Volume_Source_HostPath();

  Volume_Source_HostPath(const Volume_Source_HostPath& from);

  inline Volume_Source_HostPath& operator=(const Volume_Source_HostPath& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Volume_Source_HostPath(Volume_Source_HostPath&& from) noexcept
    : Volume_Source_HostPath() {
    *this = ::std::move(from);
  }

  inline Volume_Source_HostPath& operator=(Volume_Source_HostPath&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Volume_Source_HostPath& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Volume_Source_HostPath* internal_default_instance() {
    return reinterpret_cast<const Volume_Source_HostPath*>(
               &_Volume_Source_HostPath_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    114;

  void UnsafeArenaSwap(Volume_Source_HostPath* other);
  void Swap(Volume_Source_HostPath* other);
  friend void swap(Volume_Source_HostPath& a, Volume_Source_HostPath& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Volume_Source_HostPath* New() const PROTOBUF_FINAL { return New(NULL); }

  Volume_Source_HostPath* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Volume_Source_HostPath& from);
  void MergeFrom(const Volume_Source_HostPath& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Volume_Source_HostPath* other);
  protected:
  explicit Volume_Source_HostPath(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string path = 1;
  bool has_path() const;
  void clear_path();
  static const int kPathFieldNumber = 1;
  const ::std::string& path() const;
  void set_path(const ::std::string& value);
  #if LANG_CXX11
  void set_path(::std::string&& value);
  #endif
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  ::std::string* mutable_path();
  ::std::string* release_path();
  void set_allocated_path(::std::string* path);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_path();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_path(
      ::std::string* path);

  // optional .mesos.MountPropagation mount_propagation = 2;
  bool has_mount_propagation() const;
  void clear_mount_propagation();
  static const int kMountPropagationFieldNumber = 2;
  private:
  void _slow_mutable_mount_propagation();
  public:
  const ::mesos::MountPropagation& mount_propagation() const;
  ::mesos::MountPropagation* release_mount_propagation();
  ::mesos::MountPropagation* mutable_mount_propagation();
  void set_allocated_mount_propagation(::mesos::MountPropagation* mount_propagation);
  void unsafe_arena_set_allocated_mount_propagation(
      ::mesos::MountPropagation* mount_propagation);
  ::mesos::MountPropagation* unsafe_arena_release_mount_propagation();

  // @@protoc_insertion_point(class_scope:mesos.Volume.Source.HostPath)
 private:
  void set_has_path();
  void clear_has_path();
  void set_has_mount_propagation();
  void clear_has_mount_propagation();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr path_;
  ::mesos::MountPropagation* mount_propagation_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsVolume_Source_HostPathImpl();
};
// -------------------------------------------------------------------

class Volume_Source_SandboxPath : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.Volume.Source.SandboxPath) */ {
 public:
  Volume_Source_SandboxPath();
  virtual ~Volume_Source_SandboxPath();

  Volume_Source_SandboxPath(const Volume_Source_SandboxPath& from);

  inline Volume_Source_SandboxPath& operator=(const Volume_Source_SandboxPath& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Volume_Source_SandboxPath(Volume_Source_SandboxPath&& from) noexcept
    : Volume_Source_SandboxPath() {
    *this = ::std::move(from);
  }

  inline Volume_Source_SandboxPath& operator=(Volume_Source_SandboxPath&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Volume_Source_SandboxPath& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Volume_Source_SandboxPath* internal_default_instance() {
    return reinterpret_cast<const Volume_Source_SandboxPath*>(
               &_Volume_Source_SandboxPath_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    115;

  void UnsafeArenaSwap(Volume_Source_SandboxPath* other);
  void Swap(Volume_Source_SandboxPath* other);
  friend void swap(Volume_Source_SandboxPath& a, Volume_Source_SandboxPath& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Volume_Source_SandboxPath* New() const PROTOBUF_FINAL { return New(NULL); }

  Volume_Source_SandboxPath* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Volume_Source_SandboxPath& from);
  void MergeFrom(const Volume_Source_SandboxPath& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Volume_Source_SandboxPath* other);
  protected:
  explicit Volume_Source_SandboxPath(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Volume_Source_SandboxPath_Type Type;
  static const Type UNKNOWN =
    Volume_Source_SandboxPath_Type_UNKNOWN;
  static const Type SELF =
    Volume_Source_SandboxPath_Type_SELF;
  static const Type PARENT =
    Volume_Source_SandboxPath_Type_PARENT;
  static inline bool Type_IsValid(int value) {
    return Volume_Source_SandboxPath_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Volume_Source_SandboxPath_Type_Type_MIN;
  static const Type Type_MAX =
    Volume_Source_SandboxPath_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Volume_Source_SandboxPath_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Volume_Source_SandboxPath_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Volume_Source_SandboxPath_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Volume_Source_SandboxPath_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required string path = 2;
  bool has_path() const;
  void clear_path();
  static const int kPathFieldNumber = 2;
  const ::std::string& path() const;
  void set_path(const ::std::string& value);
  #if LANG_CXX11
  void set_path(::std::string&& value);
  #endif
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  ::std::string* mutable_path();
  ::std::string* release_path();
  void set_allocated_path(::std::string* path);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_path();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_path(
      ::std::string* path);

  // optional .mesos.Volume.Source.SandboxPath.Type type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::mesos::Volume_Source_SandboxPath_Type type() const;
  void set_type(::mesos::Volume_Source_SandboxPath_Type value);

  // @@protoc_insertion_point(class_scope:mesos.Volume.Source.SandboxPath)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_path();
  void clear_has_path();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr path_;
  int type_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsVolume_Source_SandboxPathImpl();
};
// -------------------------------------------------------------------

class Volume_Source : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.Volume.Source) */ {
 public:
  Volume_Source();
  virtual ~Volume_Source();

  Volume_Source(const Volume_Source& from);

  inline Volume_Source& operator=(const Volume_Source& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Volume_Source(Volume_Source&& from) noexcept
    : Volume_Source() {
    *this = ::std::move(from);
  }

  inline Volume_Source& operator=(Volume_Source&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Volume_Source& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Volume_Source* internal_default_instance() {
    return reinterpret_cast<const Volume_Source*>(
               &_Volume_Source_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    116;

  void UnsafeArenaSwap(Volume_Source* other);
  void Swap(Volume_Source* other);
  friend void swap(Volume_Source& a, Volume_Source& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Volume_Source* New() const PROTOBUF_FINAL { return New(NULL); }

  Volume_Source* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Volume_Source& from);
  void MergeFrom(const Volume_Source& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Volume_Source* other);
  protected:
  explicit Volume_Source(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Volume_Source_DockerVolume DockerVolume;
  typedef Volume_Source_HostPath HostPath;
  typedef Volume_Source_SandboxPath SandboxPath;

  typedef Volume_Source_Type Type;
  static const Type UNKNOWN =
    Volume_Source_Type_UNKNOWN;
  static const Type DOCKER_VOLUME =
    Volume_Source_Type_DOCKER_VOLUME;
  static const Type HOST_PATH =
    Volume_Source_Type_HOST_PATH;
  static const Type SANDBOX_PATH =
    Volume_Source_Type_SANDBOX_PATH;
  static const Type SECRET =
    Volume_Source_Type_SECRET;
  static inline bool Type_IsValid(int value) {
    return Volume_Source_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Volume_Source_Type_Type_MIN;
  static const Type Type_MAX =
    Volume_Source_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Volume_Source_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Volume_Source_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Volume_Source_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Volume_Source_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .mesos.Volume.Source.DockerVolume docker_volume = 2;
  bool has_docker_volume() const;
  void clear_docker_volume();
  static const int kDockerVolumeFieldNumber = 2;
  private:
  void _slow_mutable_docker_volume();
  public:
  const ::mesos::Volume_Source_DockerVolume& docker_volume() const;
  ::mesos::Volume_Source_DockerVolume* release_docker_volume();
  ::mesos::Volume_Source_DockerVolume* mutable_docker_volume();
  void set_allocated_docker_volume(::mesos::Volume_Source_DockerVolume* docker_volume);
  void unsafe_arena_set_allocated_docker_volume(
      ::mesos::Volume_Source_DockerVolume* docker_volume);
  ::mesos::Volume_Source_DockerVolume* unsafe_arena_release_docker_volume();

  // optional .mesos.Volume.Source.SandboxPath sandbox_path = 3;
  bool has_sandbox_path() const;
  void clear_sandbox_path();
  static const int kSandboxPathFieldNumber = 3;
  private:
  void _slow_mutable_sandbox_path();
  public:
  const ::mesos::Volume_Source_SandboxPath& sandbox_path() const;
  ::mesos::Volume_Source_SandboxPath* release_sandbox_path();
  ::mesos::Volume_Source_SandboxPath* mutable_sandbox_path();
  void set_allocated_sandbox_path(::mesos::Volume_Source_SandboxPath* sandbox_path);
  void unsafe_arena_set_allocated_sandbox_path(
      ::mesos::Volume_Source_SandboxPath* sandbox_path);
  ::mesos::Volume_Source_SandboxPath* unsafe_arena_release_sandbox_path();

  // optional .mesos.Secret secret = 4;
  bool has_secret() const;
  void clear_secret();
  static const int kSecretFieldNumber = 4;
  private:
  void _slow_mutable_secret();
  public:
  const ::mesos::Secret& secret() const;
  ::mesos::Secret* release_secret();
  ::mesos::Secret* mutable_secret();
  void set_allocated_secret(::mesos::Secret* secret);
  void unsafe_arena_set_allocated_secret(
      ::mesos::Secret* secret);
  ::mesos::Secret* unsafe_arena_release_secret();

  // optional .mesos.Volume.Source.HostPath host_path = 5;
  bool has_host_path() const;
  void clear_host_path();
  static const int kHostPathFieldNumber = 5;
  private:
  void _slow_mutable_host_path();
  public:
  const ::mesos::Volume_Source_HostPath& host_path() const;
  ::mesos::Volume_Source_HostPath* release_host_path();
  ::mesos::Volume_Source_HostPath* mutable_host_path();
  void set_allocated_host_path(::mesos::Volume_Source_HostPath* host_path);
  void unsafe_arena_set_allocated_host_path(
      ::mesos::Volume_Source_HostPath* host_path);
  ::mesos::Volume_Source_HostPath* unsafe_arena_release_host_path();

  // optional .mesos.Volume.Source.Type type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::mesos::Volume_Source_Type type() const;
  void set_type(::mesos::Volume_Source_Type value);

  // @@protoc_insertion_point(class_scope:mesos.Volume.Source)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_docker_volume();
  void clear_has_docker_volume();
  void set_has_host_path();
  void clear_has_host_path();
  void set_has_sandbox_path();
  void clear_has_sandbox_path();
  void set_has_secret();
  void clear_has_secret();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::Volume_Source_DockerVolume* docker_volume_;
  ::mesos::Volume_Source_SandboxPath* sandbox_path_;
  ::mesos::Secret* secret_;
  ::mesos::Volume_Source_HostPath* host_path_;
  int type_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsVolume_SourceImpl();
};
// -------------------------------------------------------------------

class Volume : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.Volume) */ {
 public:
  Volume();
  virtual ~Volume();

  Volume(const Volume& from);

  inline Volume& operator=(const Volume& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Volume(Volume&& from) noexcept
    : Volume() {
    *this = ::std::move(from);
  }

  inline Volume& operator=(Volume&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Volume& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Volume* internal_default_instance() {
    return reinterpret_cast<const Volume*>(
               &_Volume_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    117;

  void UnsafeArenaSwap(Volume* other);
  void Swap(Volume* other);
  friend void swap(Volume& a, Volume& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Volume* New() const PROTOBUF_FINAL { return New(NULL); }

  Volume* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Volume& from);
  void MergeFrom(const Volume& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Volume* other);
  protected:
  explicit Volume(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Volume_Source Source;

  typedef Volume_Mode Mode;
  static const Mode RW =
    Volume_Mode_RW;
  static const Mode RO =
    Volume_Mode_RO;
  static inline bool Mode_IsValid(int value) {
    return Volume_Mode_IsValid(value);
  }
  static const Mode Mode_MIN =
    Volume_Mode_Mode_MIN;
  static const Mode Mode_MAX =
    Volume_Mode_Mode_MAX;
  static const int Mode_ARRAYSIZE =
    Volume_Mode_Mode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Mode_descriptor() {
    return Volume_Mode_descriptor();
  }
  static inline const ::std::string& Mode_Name(Mode value) {
    return Volume_Mode_Name(value);
  }
  static inline bool Mode_Parse(const ::std::string& name,
      Mode* value) {
    return Volume_Mode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required string container_path = 1;
  bool has_container_path() const;
  void clear_container_path();
  static const int kContainerPathFieldNumber = 1;
  const ::std::string& container_path() const;
  void set_container_path(const ::std::string& value);
  #if LANG_CXX11
  void set_container_path(::std::string&& value);
  #endif
  void set_container_path(const char* value);
  void set_container_path(const char* value, size_t size);
  ::std::string* mutable_container_path();
  ::std::string* release_container_path();
  void set_allocated_container_path(::std::string* container_path);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_container_path();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_container_path(
      ::std::string* container_path);

  // optional string host_path = 2;
  bool has_host_path() const;
  void clear_host_path();
  static const int kHostPathFieldNumber = 2;
  const ::std::string& host_path() const;
  void set_host_path(const ::std::string& value);
  #if LANG_CXX11
  void set_host_path(::std::string&& value);
  #endif
  void set_host_path(const char* value);
  void set_host_path(const char* value, size_t size);
  ::std::string* mutable_host_path();
  ::std::string* release_host_path();
  void set_allocated_host_path(::std::string* host_path);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_host_path();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_host_path(
      ::std::string* host_path);

  // optional .mesos.Image image = 4;
  bool has_image() const;
  void clear_image();
  static const int kImageFieldNumber = 4;
  private:
  void _slow_mutable_image();
  public:
  const ::mesos::Image& image() const;
  ::mesos::Image* release_image();
  ::mesos::Image* mutable_image();
  void set_allocated_image(::mesos::Image* image);
  void unsafe_arena_set_allocated_image(
      ::mesos::Image* image);
  ::mesos::Image* unsafe_arena_release_image();

  // optional .mesos.Volume.Source source = 5;
  bool has_source() const;
  void clear_source();
  static const int kSourceFieldNumber = 5;
  private:
  void _slow_mutable_source();
  public:
  const ::mesos::Volume_Source& source() const;
  ::mesos::Volume_Source* release_source();
  ::mesos::Volume_Source* mutable_source();
  void set_allocated_source(::mesos::Volume_Source* source);
  void unsafe_arena_set_allocated_source(
      ::mesos::Volume_Source* source);
  ::mesos::Volume_Source* unsafe_arena_release_source();

  // required .mesos.Volume.Mode mode = 3;
  bool has_mode() const;
  void clear_mode();
  static const int kModeFieldNumber = 3;
  ::mesos::Volume_Mode mode() const;
  void set_mode(::mesos::Volume_Mode value);

  // @@protoc_insertion_point(class_scope:mesos.Volume)
 private:
  void set_has_mode();
  void clear_has_mode();
  void set_has_container_path();
  void clear_has_container_path();
  void set_has_host_path();
  void clear_has_host_path();
  void set_has_image();
  void clear_has_image();
  void set_has_source();
  void clear_has_source();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr container_path_;
  ::google::protobuf::internal::ArenaStringPtr host_path_;
  ::mesos::Image* image_;
  ::mesos::Volume_Source* source_;
  int mode_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsVolumeImpl();
};
// -------------------------------------------------------------------

class NetworkInfo_IPAddress : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.NetworkInfo.IPAddress) */ {
 public:
  NetworkInfo_IPAddress();
  virtual ~NetworkInfo_IPAddress();

  NetworkInfo_IPAddress(const NetworkInfo_IPAddress& from);

  inline NetworkInfo_IPAddress& operator=(const NetworkInfo_IPAddress& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NetworkInfo_IPAddress(NetworkInfo_IPAddress&& from) noexcept
    : NetworkInfo_IPAddress() {
    *this = ::std::move(from);
  }

  inline NetworkInfo_IPAddress& operator=(NetworkInfo_IPAddress&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const NetworkInfo_IPAddress& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NetworkInfo_IPAddress* internal_default_instance() {
    return reinterpret_cast<const NetworkInfo_IPAddress*>(
               &_NetworkInfo_IPAddress_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    118;

  void UnsafeArenaSwap(NetworkInfo_IPAddress* other);
  void Swap(NetworkInfo_IPAddress* other);
  friend void swap(NetworkInfo_IPAddress& a, NetworkInfo_IPAddress& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NetworkInfo_IPAddress* New() const PROTOBUF_FINAL { return New(NULL); }

  NetworkInfo_IPAddress* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const NetworkInfo_IPAddress& from);
  void MergeFrom(const NetworkInfo_IPAddress& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(NetworkInfo_IPAddress* other);
  protected:
  explicit NetworkInfo_IPAddress(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string ip_address = 2;
  bool has_ip_address() const;
  void clear_ip_address();
  static const int kIpAddressFieldNumber = 2;
  const ::std::string& ip_address() const;
  void set_ip_address(const ::std::string& value);
  #if LANG_CXX11
  void set_ip_address(::std::string&& value);
  #endif
  void set_ip_address(const char* value);
  void set_ip_address(const char* value, size_t size);
  ::std::string* mutable_ip_address();
  ::std::string* release_ip_address();
  void set_allocated_ip_address(::std::string* ip_address);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_ip_address();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_ip_address(
      ::std::string* ip_address);

  // optional .mesos.NetworkInfo.Protocol protocol = 1 [default = IPv4];
  bool has_protocol() const;
  void clear_protocol();
  static const int kProtocolFieldNumber = 1;
  ::mesos::NetworkInfo_Protocol protocol() const;
  void set_protocol(::mesos::NetworkInfo_Protocol value);

  // @@protoc_insertion_point(class_scope:mesos.NetworkInfo.IPAddress)
 private:
  void set_has_protocol();
  void clear_has_protocol();
  void set_has_ip_address();
  void clear_has_ip_address();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr ip_address_;
  int protocol_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsNetworkInfo_IPAddressImpl();
};
// -------------------------------------------------------------------

class NetworkInfo_PortMapping : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.NetworkInfo.PortMapping) */ {
 public:
  NetworkInfo_PortMapping();
  virtual ~NetworkInfo_PortMapping();

  NetworkInfo_PortMapping(const NetworkInfo_PortMapping& from);

  inline NetworkInfo_PortMapping& operator=(const NetworkInfo_PortMapping& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NetworkInfo_PortMapping(NetworkInfo_PortMapping&& from) noexcept
    : NetworkInfo_PortMapping() {
    *this = ::std::move(from);
  }

  inline NetworkInfo_PortMapping& operator=(NetworkInfo_PortMapping&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const NetworkInfo_PortMapping& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NetworkInfo_PortMapping* internal_default_instance() {
    return reinterpret_cast<const NetworkInfo_PortMapping*>(
               &_NetworkInfo_PortMapping_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    119;

  void UnsafeArenaSwap(NetworkInfo_PortMapping* other);
  void Swap(NetworkInfo_PortMapping* other);
  friend void swap(NetworkInfo_PortMapping& a, NetworkInfo_PortMapping& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NetworkInfo_PortMapping* New() const PROTOBUF_FINAL { return New(NULL); }

  NetworkInfo_PortMapping* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const NetworkInfo_PortMapping& from);
  void MergeFrom(const NetworkInfo_PortMapping& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(NetworkInfo_PortMapping* other);
  protected:
  explicit NetworkInfo_PortMapping(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string protocol = 3;
  bool has_protocol() const;
  void clear_protocol();
  static const int kProtocolFieldNumber = 3;
  const ::std::string& protocol() const;
  void set_protocol(const ::std::string& value);
  #if LANG_CXX11
  void set_protocol(::std::string&& value);
  #endif
  void set_protocol(const char* value);
  void set_protocol(const char* value, size_t size);
  ::std::string* mutable_protocol();
  ::std::string* release_protocol();
  void set_allocated_protocol(::std::string* protocol);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_protocol();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_protocol(
      ::std::string* protocol);

  // required uint32 host_port = 1;
  bool has_host_port() const;
  void clear_host_port();
  static const int kHostPortFieldNumber = 1;
  ::google::protobuf::uint32 host_port() const;
  void set_host_port(::google::protobuf::uint32 value);

  // required uint32 container_port = 2;
  bool has_container_port() const;
  void clear_container_port();
  static const int kContainerPortFieldNumber = 2;
  ::google::protobuf::uint32 container_port() const;
  void set_container_port(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mesos.NetworkInfo.PortMapping)
 private:
  void set_has_host_port();
  void clear_has_host_port();
  void set_has_container_port();
  void clear_has_container_port();
  void set_has_protocol();
  void clear_has_protocol();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr protocol_;
  ::google::protobuf::uint32 host_port_;
  ::google::protobuf::uint32 container_port_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsNetworkInfo_PortMappingImpl();
};
// -------------------------------------------------------------------

class NetworkInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.NetworkInfo) */ {
 public:
  NetworkInfo();
  virtual ~NetworkInfo();

  NetworkInfo(const NetworkInfo& from);

  inline NetworkInfo& operator=(const NetworkInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NetworkInfo(NetworkInfo&& from) noexcept
    : NetworkInfo() {
    *this = ::std::move(from);
  }

  inline NetworkInfo& operator=(NetworkInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const NetworkInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NetworkInfo* internal_default_instance() {
    return reinterpret_cast<const NetworkInfo*>(
               &_NetworkInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    120;

  void UnsafeArenaSwap(NetworkInfo* other);
  void Swap(NetworkInfo* other);
  friend void swap(NetworkInfo& a, NetworkInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NetworkInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  NetworkInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const NetworkInfo& from);
  void MergeFrom(const NetworkInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(NetworkInfo* other);
  protected:
  explicit NetworkInfo(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef NetworkInfo_IPAddress IPAddress;
  typedef NetworkInfo_PortMapping PortMapping;

  typedef NetworkInfo_Protocol Protocol;
  static const Protocol IPv4 =
    NetworkInfo_Protocol_IPv4;
  static const Protocol IPv6 =
    NetworkInfo_Protocol_IPv6;
  static inline bool Protocol_IsValid(int value) {
    return NetworkInfo_Protocol_IsValid(value);
  }
  static const Protocol Protocol_MIN =
    NetworkInfo_Protocol_Protocol_MIN;
  static const Protocol Protocol_MAX =
    NetworkInfo_Protocol_Protocol_MAX;
  static const int Protocol_ARRAYSIZE =
    NetworkInfo_Protocol_Protocol_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Protocol_descriptor() {
    return NetworkInfo_Protocol_descriptor();
  }
  static inline const ::std::string& Protocol_Name(Protocol value) {
    return NetworkInfo_Protocol_Name(value);
  }
  static inline bool Protocol_Parse(const ::std::string& name,
      Protocol* value) {
    return NetworkInfo_Protocol_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated string groups = 3;
  int groups_size() const;
  void clear_groups();
  static const int kGroupsFieldNumber = 3;
  const ::std::string& groups(int index) const;
  ::std::string* mutable_groups(int index);
  void set_groups(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_groups(int index, ::std::string&& value);
  #endif
  void set_groups(int index, const char* value);
  void set_groups(int index, const char* value, size_t size);
  ::std::string* add_groups();
  void add_groups(const ::std::string& value);
  #if LANG_CXX11
  void add_groups(::std::string&& value);
  #endif
  void add_groups(const char* value);
  void add_groups(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& groups() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_groups();

  // repeated .mesos.NetworkInfo.IPAddress ip_addresses = 5;
  int ip_addresses_size() const;
  void clear_ip_addresses();
  static const int kIpAddressesFieldNumber = 5;
  const ::mesos::NetworkInfo_IPAddress& ip_addresses(int index) const;
  ::mesos::NetworkInfo_IPAddress* mutable_ip_addresses(int index);
  ::mesos::NetworkInfo_IPAddress* add_ip_addresses();
  ::google::protobuf::RepeatedPtrField< ::mesos::NetworkInfo_IPAddress >*
      mutable_ip_addresses();
  const ::google::protobuf::RepeatedPtrField< ::mesos::NetworkInfo_IPAddress >&
      ip_addresses() const;

  // repeated .mesos.NetworkInfo.PortMapping port_mappings = 7;
  int port_mappings_size() const;
  void clear_port_mappings();
  static const int kPortMappingsFieldNumber = 7;
  const ::mesos::NetworkInfo_PortMapping& port_mappings(int index) const;
  ::mesos::NetworkInfo_PortMapping* mutable_port_mappings(int index);
  ::mesos::NetworkInfo_PortMapping* add_port_mappings();
  ::google::protobuf::RepeatedPtrField< ::mesos::NetworkInfo_PortMapping >*
      mutable_port_mappings();
  const ::google::protobuf::RepeatedPtrField< ::mesos::NetworkInfo_PortMapping >&
      port_mappings() const;

  // optional string name = 6;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 6;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_name();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      ::std::string* name);

  // optional .mesos.Labels labels = 4;
  bool has_labels() const;
  void clear_labels();
  static const int kLabelsFieldNumber = 4;
  private:
  void _slow_mutable_labels();
  public:
  const ::mesos::Labels& labels() const;
  ::mesos::Labels* release_labels();
  ::mesos::Labels* mutable_labels();
  void set_allocated_labels(::mesos::Labels* labels);
  void unsafe_arena_set_allocated_labels(
      ::mesos::Labels* labels);
  ::mesos::Labels* unsafe_arena_release_labels();

  // @@protoc_insertion_point(class_scope:mesos.NetworkInfo)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_labels();
  void clear_has_labels();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> groups_;
  ::google::protobuf::RepeatedPtrField< ::mesos::NetworkInfo_IPAddress > ip_addresses_;
  ::google::protobuf::RepeatedPtrField< ::mesos::NetworkInfo_PortMapping > port_mappings_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::mesos::Labels* labels_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsNetworkInfoImpl();
};
// -------------------------------------------------------------------

class CapabilityInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.CapabilityInfo) */ {
 public:
  CapabilityInfo();
  virtual ~CapabilityInfo();

  CapabilityInfo(const CapabilityInfo& from);

  inline CapabilityInfo& operator=(const CapabilityInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CapabilityInfo(CapabilityInfo&& from) noexcept
    : CapabilityInfo() {
    *this = ::std::move(from);
  }

  inline CapabilityInfo& operator=(CapabilityInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const CapabilityInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CapabilityInfo* internal_default_instance() {
    return reinterpret_cast<const CapabilityInfo*>(
               &_CapabilityInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    121;

  void UnsafeArenaSwap(CapabilityInfo* other);
  void Swap(CapabilityInfo* other);
  friend void swap(CapabilityInfo& a, CapabilityInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CapabilityInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  CapabilityInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CapabilityInfo& from);
  void MergeFrom(const CapabilityInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CapabilityInfo* other);
  protected:
  explicit CapabilityInfo(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef CapabilityInfo_Capability Capability;
  static const Capability UNKNOWN =
    CapabilityInfo_Capability_UNKNOWN;
  static const Capability CHOWN =
    CapabilityInfo_Capability_CHOWN;
  static const Capability DAC_OVERRIDE =
    CapabilityInfo_Capability_DAC_OVERRIDE;
  static const Capability DAC_READ_SEARCH =
    CapabilityInfo_Capability_DAC_READ_SEARCH;
  static const Capability FOWNER =
    CapabilityInfo_Capability_FOWNER;
  static const Capability FSETID =
    CapabilityInfo_Capability_FSETID;
  static const Capability KILL =
    CapabilityInfo_Capability_KILL;
  static const Capability SETGID =
    CapabilityInfo_Capability_SETGID;
  static const Capability SETUID =
    CapabilityInfo_Capability_SETUID;
  static const Capability SETPCAP =
    CapabilityInfo_Capability_SETPCAP;
  static const Capability LINUX_IMMUTABLE =
    CapabilityInfo_Capability_LINUX_IMMUTABLE;
  static const Capability NET_BIND_SERVICE =
    CapabilityInfo_Capability_NET_BIND_SERVICE;
  static const Capability NET_BROADCAST =
    CapabilityInfo_Capability_NET_BROADCAST;
  static const Capability NET_ADMIN =
    CapabilityInfo_Capability_NET_ADMIN;
  static const Capability NET_RAW =
    CapabilityInfo_Capability_NET_RAW;
  static const Capability IPC_LOCK =
    CapabilityInfo_Capability_IPC_LOCK;
  static const Capability IPC_OWNER =
    CapabilityInfo_Capability_IPC_OWNER;
  static const Capability SYS_MODULE =
    CapabilityInfo_Capability_SYS_MODULE;
  static const Capability SYS_RAWIO =
    CapabilityInfo_Capability_SYS_RAWIO;
  static const Capability SYS_CHROOT =
    CapabilityInfo_Capability_SYS_CHROOT;
  static const Capability SYS_PTRACE =
    CapabilityInfo_Capability_SYS_PTRACE;
  static const Capability SYS_PACCT =
    CapabilityInfo_Capability_SYS_PACCT;
  static const Capability SYS_ADMIN =
    CapabilityInfo_Capability_SYS_ADMIN;
  static const Capability SYS_BOOT =
    CapabilityInfo_Capability_SYS_BOOT;
  static const Capability SYS_NICE =
    CapabilityInfo_Capability_SYS_NICE;
  static const Capability SYS_RESOURCE =
    CapabilityInfo_Capability_SYS_RESOURCE;
  static const Capability SYS_TIME =
    CapabilityInfo_Capability_SYS_TIME;
  static const Capability SYS_TTY_CONFIG =
    CapabilityInfo_Capability_SYS_TTY_CONFIG;
  static const Capability MKNOD =
    CapabilityInfo_Capability_MKNOD;
  static const Capability LEASE =
    CapabilityInfo_Capability_LEASE;
  static const Capability AUDIT_WRITE =
    CapabilityInfo_Capability_AUDIT_WRITE;
  static const Capability AUDIT_CONTROL =
    CapabilityInfo_Capability_AUDIT_CONTROL;
  static const Capability SETFCAP =
    CapabilityInfo_Capability_SETFCAP;
  static const Capability MAC_OVERRIDE =
    CapabilityInfo_Capability_MAC_OVERRIDE;
  static const Capability MAC_ADMIN =
    CapabilityInfo_Capability_MAC_ADMIN;
  static const Capability SYSLOG =
    CapabilityInfo_Capability_SYSLOG;
  static const Capability WAKE_ALARM =
    CapabilityInfo_Capability_WAKE_ALARM;
  static const Capability BLOCK_SUSPEND =
    CapabilityInfo_Capability_BLOCK_SUSPEND;
  static const Capability AUDIT_READ =
    CapabilityInfo_Capability_AUDIT_READ;
  static inline bool Capability_IsValid(int value) {
    return CapabilityInfo_Capability_IsValid(value);
  }
  static const Capability Capability_MIN =
    CapabilityInfo_Capability_Capability_MIN;
  static const Capability Capability_MAX =
    CapabilityInfo_Capability_Capability_MAX;
  static const int Capability_ARRAYSIZE =
    CapabilityInfo_Capability_Capability_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Capability_descriptor() {
    return CapabilityInfo_Capability_descriptor();
  }
  static inline const ::std::string& Capability_Name(Capability value) {
    return CapabilityInfo_Capability_Name(value);
  }
  static inline bool Capability_Parse(const ::std::string& name,
      Capability* value) {
    return CapabilityInfo_Capability_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .mesos.CapabilityInfo.Capability capabilities = 1;
  int capabilities_size() const;
  void clear_capabilities();
  static const int kCapabilitiesFieldNumber = 1;
  ::mesos::CapabilityInfo_Capability capabilities(int index) const;
  void set_capabilities(int index, ::mesos::CapabilityInfo_Capability value);
  void add_capabilities(::mesos::CapabilityInfo_Capability value);
  const ::google::protobuf::RepeatedField<int>& capabilities() const;
  ::google::protobuf::RepeatedField<int>* mutable_capabilities();

  // @@protoc_insertion_point(class_scope:mesos.CapabilityInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField<int> capabilities_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsCapabilityInfoImpl();
};
// -------------------------------------------------------------------

class LinuxInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.LinuxInfo) */ {
 public:
  LinuxInfo();
  virtual ~LinuxInfo();

  LinuxInfo(const LinuxInfo& from);

  inline LinuxInfo& operator=(const LinuxInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LinuxInfo(LinuxInfo&& from) noexcept
    : LinuxInfo() {
    *this = ::std::move(from);
  }

  inline LinuxInfo& operator=(LinuxInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const LinuxInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LinuxInfo* internal_default_instance() {
    return reinterpret_cast<const LinuxInfo*>(
               &_LinuxInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    122;

  void UnsafeArenaSwap(LinuxInfo* other);
  void Swap(LinuxInfo* other);
  friend void swap(LinuxInfo& a, LinuxInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LinuxInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  LinuxInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LinuxInfo& from);
  void MergeFrom(const LinuxInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LinuxInfo* other);
  protected:
  explicit LinuxInfo(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mesos.CapabilityInfo capability_info = 1 [deprecated = true];
  GOOGLE_PROTOBUF_DEPRECATED_ATTR bool has_capability_info() const;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void clear_capability_info();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR static const int kCapabilityInfoFieldNumber = 1;
  private:
  void _slow_mutable_capability_info();
  public:
  GOOGLE_PROTOBUF_DEPRECATED_ATTR const ::mesos::CapabilityInfo& capability_info() const;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR ::mesos::CapabilityInfo* release_capability_info();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR ::mesos::CapabilityInfo* mutable_capability_info();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void set_allocated_capability_info(::mesos::CapabilityInfo* capability_info);
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void unsafe_arena_set_allocated_capability_info(
      ::mesos::CapabilityInfo* capability_info);
  GOOGLE_PROTOBUF_DEPRECATED_ATTR ::mesos::CapabilityInfo* unsafe_arena_release_capability_info();

  // optional .mesos.CapabilityInfo bounding_capabilities = 2;
  bool has_bounding_capabilities() const;
  void clear_bounding_capabilities();
  static const int kBoundingCapabilitiesFieldNumber = 2;
  private:
  void _slow_mutable_bounding_capabilities();
  public:
  const ::mesos::CapabilityInfo& bounding_capabilities() const;
  ::mesos::CapabilityInfo* release_bounding_capabilities();
  ::mesos::CapabilityInfo* mutable_bounding_capabilities();
  void set_allocated_bounding_capabilities(::mesos::CapabilityInfo* bounding_capabilities);
  void unsafe_arena_set_allocated_bounding_capabilities(
      ::mesos::CapabilityInfo* bounding_capabilities);
  ::mesos::CapabilityInfo* unsafe_arena_release_bounding_capabilities();

  // optional .mesos.CapabilityInfo effective_capabilities = 3;
  bool has_effective_capabilities() const;
  void clear_effective_capabilities();
  static const int kEffectiveCapabilitiesFieldNumber = 3;
  private:
  void _slow_mutable_effective_capabilities();
  public:
  const ::mesos::CapabilityInfo& effective_capabilities() const;
  ::mesos::CapabilityInfo* release_effective_capabilities();
  ::mesos::CapabilityInfo* mutable_effective_capabilities();
  void set_allocated_effective_capabilities(::mesos::CapabilityInfo* effective_capabilities);
  void unsafe_arena_set_allocated_effective_capabilities(
      ::mesos::CapabilityInfo* effective_capabilities);
  ::mesos::CapabilityInfo* unsafe_arena_release_effective_capabilities();

  // optional bool share_pid_namespace = 4;
  bool has_share_pid_namespace() const;
  void clear_share_pid_namespace();
  static const int kSharePidNamespaceFieldNumber = 4;
  bool share_pid_namespace() const;
  void set_share_pid_namespace(bool value);

  // @@protoc_insertion_point(class_scope:mesos.LinuxInfo)
 private:
  void set_has_capability_info();
  void clear_has_capability_info();
  void set_has_bounding_capabilities();
  void clear_has_bounding_capabilities();
  void set_has_effective_capabilities();
  void clear_has_effective_capabilities();
  void set_has_share_pid_namespace();
  void clear_has_share_pid_namespace();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::CapabilityInfo* capability_info_;
  ::mesos::CapabilityInfo* bounding_capabilities_;
  ::mesos::CapabilityInfo* effective_capabilities_;
  bool share_pid_namespace_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsLinuxInfoImpl();
};
// -------------------------------------------------------------------

class RLimitInfo_RLimit : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.RLimitInfo.RLimit) */ {
 public:
  RLimitInfo_RLimit();
  virtual ~RLimitInfo_RLimit();

  RLimitInfo_RLimit(const RLimitInfo_RLimit& from);

  inline RLimitInfo_RLimit& operator=(const RLimitInfo_RLimit& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RLimitInfo_RLimit(RLimitInfo_RLimit&& from) noexcept
    : RLimitInfo_RLimit() {
    *this = ::std::move(from);
  }

  inline RLimitInfo_RLimit& operator=(RLimitInfo_RLimit&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const RLimitInfo_RLimit& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RLimitInfo_RLimit* internal_default_instance() {
    return reinterpret_cast<const RLimitInfo_RLimit*>(
               &_RLimitInfo_RLimit_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    123;

  void UnsafeArenaSwap(RLimitInfo_RLimit* other);
  void Swap(RLimitInfo_RLimit* other);
  friend void swap(RLimitInfo_RLimit& a, RLimitInfo_RLimit& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RLimitInfo_RLimit* New() const PROTOBUF_FINAL { return New(NULL); }

  RLimitInfo_RLimit* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RLimitInfo_RLimit& from);
  void MergeFrom(const RLimitInfo_RLimit& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RLimitInfo_RLimit* other);
  protected:
  explicit RLimitInfo_RLimit(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef RLimitInfo_RLimit_Type Type;
  static const Type UNKNOWN =
    RLimitInfo_RLimit_Type_UNKNOWN;
  static const Type RLMT_AS =
    RLimitInfo_RLimit_Type_RLMT_AS;
  static const Type RLMT_CORE =
    RLimitInfo_RLimit_Type_RLMT_CORE;
  static const Type RLMT_CPU =
    RLimitInfo_RLimit_Type_RLMT_CPU;
  static const Type RLMT_DATA =
    RLimitInfo_RLimit_Type_RLMT_DATA;
  static const Type RLMT_FSIZE =
    RLimitInfo_RLimit_Type_RLMT_FSIZE;
  static const Type RLMT_LOCKS =
    RLimitInfo_RLimit_Type_RLMT_LOCKS;
  static const Type RLMT_MEMLOCK =
    RLimitInfo_RLimit_Type_RLMT_MEMLOCK;
  static const Type RLMT_MSGQUEUE =
    RLimitInfo_RLimit_Type_RLMT_MSGQUEUE;
  static const Type RLMT_NICE =
    RLimitInfo_RLimit_Type_RLMT_NICE;
  static const Type RLMT_NOFILE =
    RLimitInfo_RLimit_Type_RLMT_NOFILE;
  static const Type RLMT_NPROC =
    RLimitInfo_RLimit_Type_RLMT_NPROC;
  static const Type RLMT_RSS =
    RLimitInfo_RLimit_Type_RLMT_RSS;
  static const Type RLMT_RTPRIO =
    RLimitInfo_RLimit_Type_RLMT_RTPRIO;
  static const Type RLMT_RTTIME =
    RLimitInfo_RLimit_Type_RLMT_RTTIME;
  static const Type RLMT_SIGPENDING =
    RLimitInfo_RLimit_Type_RLMT_SIGPENDING;
  static const Type RLMT_STACK =
    RLimitInfo_RLimit_Type_RLMT_STACK;
  static inline bool Type_IsValid(int value) {
    return RLimitInfo_RLimit_Type_IsValid(value);
  }
  static const Type Type_MIN =
    RLimitInfo_RLimit_Type_Type_MIN;
  static const Type Type_MAX =
    RLimitInfo_RLimit_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    RLimitInfo_RLimit_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return RLimitInfo_RLimit_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return RLimitInfo_RLimit_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return RLimitInfo_RLimit_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional uint64 hard = 2;
  bool has_hard() const;
  void clear_hard();
  static const int kHardFieldNumber = 2;
  ::google::protobuf::uint64 hard() const;
  void set_hard(::google::protobuf::uint64 value);

  // optional uint64 soft = 3;
  bool has_soft() const;
  void clear_soft();
  static const int kSoftFieldNumber = 3;
  ::google::protobuf::uint64 soft() const;
  void set_soft(::google::protobuf::uint64 value);

  // optional .mesos.RLimitInfo.RLimit.Type type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::mesos::RLimitInfo_RLimit_Type type() const;
  void set_type(::mesos::RLimitInfo_RLimit_Type value);

  // @@protoc_insertion_point(class_scope:mesos.RLimitInfo.RLimit)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_hard();
  void clear_has_hard();
  void set_has_soft();
  void clear_has_soft();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint64 hard_;
  ::google::protobuf::uint64 soft_;
  int type_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsRLimitInfo_RLimitImpl();
};
// -------------------------------------------------------------------

class RLimitInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.RLimitInfo) */ {
 public:
  RLimitInfo();
  virtual ~RLimitInfo();

  RLimitInfo(const RLimitInfo& from);

  inline RLimitInfo& operator=(const RLimitInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RLimitInfo(RLimitInfo&& from) noexcept
    : RLimitInfo() {
    *this = ::std::move(from);
  }

  inline RLimitInfo& operator=(RLimitInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const RLimitInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RLimitInfo* internal_default_instance() {
    return reinterpret_cast<const RLimitInfo*>(
               &_RLimitInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    124;

  void UnsafeArenaSwap(RLimitInfo* other);
  void Swap(RLimitInfo* other);
  friend void swap(RLimitInfo& a, RLimitInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RLimitInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  RLimitInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RLimitInfo& from);
  void MergeFrom(const RLimitInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RLimitInfo* other);
  protected:
  explicit RLimitInfo(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef RLimitInfo_RLimit RLimit;

  // accessors -------------------------------------------------------

  // repeated .mesos.RLimitInfo.RLimit rlimits = 1;
  int rlimits_size() const;
  void clear_rlimits();
  static const int kRlimitsFieldNumber = 1;
  const ::mesos::RLimitInfo_RLimit& rlimits(int index) const;
  ::mesos::RLimitInfo_RLimit* mutable_rlimits(int index);
  ::mesos::RLimitInfo_RLimit* add_rlimits();
  ::google::protobuf::RepeatedPtrField< ::mesos::RLimitInfo_RLimit >*
      mutable_rlimits();
  const ::google::protobuf::RepeatedPtrField< ::mesos::RLimitInfo_RLimit >&
      rlimits() const;

  // @@protoc_insertion_point(class_scope:mesos.RLimitInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::RLimitInfo_RLimit > rlimits_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsRLimitInfoImpl();
};
// -------------------------------------------------------------------

class TTYInfo_WindowSize : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.TTYInfo.WindowSize) */ {
 public:
  TTYInfo_WindowSize();
  virtual ~TTYInfo_WindowSize();

  TTYInfo_WindowSize(const TTYInfo_WindowSize& from);

  inline TTYInfo_WindowSize& operator=(const TTYInfo_WindowSize& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TTYInfo_WindowSize(TTYInfo_WindowSize&& from) noexcept
    : TTYInfo_WindowSize() {
    *this = ::std::move(from);
  }

  inline TTYInfo_WindowSize& operator=(TTYInfo_WindowSize&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const TTYInfo_WindowSize& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TTYInfo_WindowSize* internal_default_instance() {
    return reinterpret_cast<const TTYInfo_WindowSize*>(
               &_TTYInfo_WindowSize_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    125;

  void UnsafeArenaSwap(TTYInfo_WindowSize* other);
  void Swap(TTYInfo_WindowSize* other);
  friend void swap(TTYInfo_WindowSize& a, TTYInfo_WindowSize& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TTYInfo_WindowSize* New() const PROTOBUF_FINAL { return New(NULL); }

  TTYInfo_WindowSize* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TTYInfo_WindowSize& from);
  void MergeFrom(const TTYInfo_WindowSize& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TTYInfo_WindowSize* other);
  protected:
  explicit TTYInfo_WindowSize(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 rows = 1;
  bool has_rows() const;
  void clear_rows();
  static const int kRowsFieldNumber = 1;
  ::google::protobuf::uint32 rows() const;
  void set_rows(::google::protobuf::uint32 value);

  // required uint32 columns = 2;
  bool has_columns() const;
  void clear_columns();
  static const int kColumnsFieldNumber = 2;
  ::google::protobuf::uint32 columns() const;
  void set_columns(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mesos.TTYInfo.WindowSize)
 private:
  void set_has_rows();
  void clear_has_rows();
  void set_has_columns();
  void clear_has_columns();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 rows_;
  ::google::protobuf::uint32 columns_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsTTYInfo_WindowSizeImpl();
};
// -------------------------------------------------------------------

class TTYInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.TTYInfo) */ {
 public:
  TTYInfo();
  virtual ~TTYInfo();

  TTYInfo(const TTYInfo& from);

  inline TTYInfo& operator=(const TTYInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TTYInfo(TTYInfo&& from) noexcept
    : TTYInfo() {
    *this = ::std::move(from);
  }

  inline TTYInfo& operator=(TTYInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const TTYInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TTYInfo* internal_default_instance() {
    return reinterpret_cast<const TTYInfo*>(
               &_TTYInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    126;

  void UnsafeArenaSwap(TTYInfo* other);
  void Swap(TTYInfo* other);
  friend void swap(TTYInfo& a, TTYInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TTYInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  TTYInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TTYInfo& from);
  void MergeFrom(const TTYInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TTYInfo* other);
  protected:
  explicit TTYInfo(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef TTYInfo_WindowSize WindowSize;

  // accessors -------------------------------------------------------

  // optional .mesos.TTYInfo.WindowSize window_size = 1;
  bool has_window_size() const;
  void clear_window_size();
  static const int kWindowSizeFieldNumber = 1;
  private:
  void _slow_mutable_window_size();
  public:
  const ::mesos::TTYInfo_WindowSize& window_size() const;
  ::mesos::TTYInfo_WindowSize* release_window_size();
  ::mesos::TTYInfo_WindowSize* mutable_window_size();
  void set_allocated_window_size(::mesos::TTYInfo_WindowSize* window_size);
  void unsafe_arena_set_allocated_window_size(
      ::mesos::TTYInfo_WindowSize* window_size);
  ::mesos::TTYInfo_WindowSize* unsafe_arena_release_window_size();

  // @@protoc_insertion_point(class_scope:mesos.TTYInfo)
 private:
  void set_has_window_size();
  void clear_has_window_size();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::TTYInfo_WindowSize* window_size_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsTTYInfoImpl();
};
// -------------------------------------------------------------------

class ContainerInfo_DockerInfo_PortMapping : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.ContainerInfo.DockerInfo.PortMapping) */ {
 public:
  ContainerInfo_DockerInfo_PortMapping();
  virtual ~ContainerInfo_DockerInfo_PortMapping();

  ContainerInfo_DockerInfo_PortMapping(const ContainerInfo_DockerInfo_PortMapping& from);

  inline ContainerInfo_DockerInfo_PortMapping& operator=(const ContainerInfo_DockerInfo_PortMapping& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ContainerInfo_DockerInfo_PortMapping(ContainerInfo_DockerInfo_PortMapping&& from) noexcept
    : ContainerInfo_DockerInfo_PortMapping() {
    *this = ::std::move(from);
  }

  inline ContainerInfo_DockerInfo_PortMapping& operator=(ContainerInfo_DockerInfo_PortMapping&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const ContainerInfo_DockerInfo_PortMapping& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ContainerInfo_DockerInfo_PortMapping* internal_default_instance() {
    return reinterpret_cast<const ContainerInfo_DockerInfo_PortMapping*>(
               &_ContainerInfo_DockerInfo_PortMapping_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    127;

  void UnsafeArenaSwap(ContainerInfo_DockerInfo_PortMapping* other);
  void Swap(ContainerInfo_DockerInfo_PortMapping* other);
  friend void swap(ContainerInfo_DockerInfo_PortMapping& a, ContainerInfo_DockerInfo_PortMapping& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ContainerInfo_DockerInfo_PortMapping* New() const PROTOBUF_FINAL { return New(NULL); }

  ContainerInfo_DockerInfo_PortMapping* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ContainerInfo_DockerInfo_PortMapping& from);
  void MergeFrom(const ContainerInfo_DockerInfo_PortMapping& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ContainerInfo_DockerInfo_PortMapping* other);
  protected:
  explicit ContainerInfo_DockerInfo_PortMapping(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string protocol = 3;
  bool has_protocol() const;
  void clear_protocol();
  static const int kProtocolFieldNumber = 3;
  const ::std::string& protocol() const;
  void set_protocol(const ::std::string& value);
  #if LANG_CXX11
  void set_protocol(::std::string&& value);
  #endif
  void set_protocol(const char* value);
  void set_protocol(const char* value, size_t size);
  ::std::string* mutable_protocol();
  ::std::string* release_protocol();
  void set_allocated_protocol(::std::string* protocol);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_protocol();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_protocol(
      ::std::string* protocol);

  // required uint32 host_port = 1;
  bool has_host_port() const;
  void clear_host_port();
  static const int kHostPortFieldNumber = 1;
  ::google::protobuf::uint32 host_port() const;
  void set_host_port(::google::protobuf::uint32 value);

  // required uint32 container_port = 2;
  bool has_container_port() const;
  void clear_container_port();
  static const int kContainerPortFieldNumber = 2;
  ::google::protobuf::uint32 container_port() const;
  void set_container_port(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mesos.ContainerInfo.DockerInfo.PortMapping)
 private:
  void set_has_host_port();
  void clear_has_host_port();
  void set_has_container_port();
  void clear_has_container_port();
  void set_has_protocol();
  void clear_has_protocol();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr protocol_;
  ::google::protobuf::uint32 host_port_;
  ::google::protobuf::uint32 container_port_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsContainerInfo_DockerInfo_PortMappingImpl();
};
// -------------------------------------------------------------------

class ContainerInfo_DockerInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.ContainerInfo.DockerInfo) */ {
 public:
  ContainerInfo_DockerInfo();
  virtual ~ContainerInfo_DockerInfo();

  ContainerInfo_DockerInfo(const ContainerInfo_DockerInfo& from);

  inline ContainerInfo_DockerInfo& operator=(const ContainerInfo_DockerInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ContainerInfo_DockerInfo(ContainerInfo_DockerInfo&& from) noexcept
    : ContainerInfo_DockerInfo() {
    *this = ::std::move(from);
  }

  inline ContainerInfo_DockerInfo& operator=(ContainerInfo_DockerInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const ContainerInfo_DockerInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ContainerInfo_DockerInfo* internal_default_instance() {
    return reinterpret_cast<const ContainerInfo_DockerInfo*>(
               &_ContainerInfo_DockerInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    128;

  void UnsafeArenaSwap(ContainerInfo_DockerInfo* other);
  void Swap(ContainerInfo_DockerInfo* other);
  friend void swap(ContainerInfo_DockerInfo& a, ContainerInfo_DockerInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ContainerInfo_DockerInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  ContainerInfo_DockerInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ContainerInfo_DockerInfo& from);
  void MergeFrom(const ContainerInfo_DockerInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ContainerInfo_DockerInfo* other);
  protected:
  explicit ContainerInfo_DockerInfo(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef ContainerInfo_DockerInfo_PortMapping PortMapping;

  typedef ContainerInfo_DockerInfo_Network Network;
  static const Network HOST =
    ContainerInfo_DockerInfo_Network_HOST;
  static const Network BRIDGE =
    ContainerInfo_DockerInfo_Network_BRIDGE;
  static const Network NONE =
    ContainerInfo_DockerInfo_Network_NONE;
  static const Network USER =
    ContainerInfo_DockerInfo_Network_USER;
  static inline bool Network_IsValid(int value) {
    return ContainerInfo_DockerInfo_Network_IsValid(value);
  }
  static const Network Network_MIN =
    ContainerInfo_DockerInfo_Network_Network_MIN;
  static const Network Network_MAX =
    ContainerInfo_DockerInfo_Network_Network_MAX;
  static const int Network_ARRAYSIZE =
    ContainerInfo_DockerInfo_Network_Network_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Network_descriptor() {
    return ContainerInfo_DockerInfo_Network_descriptor();
  }
  static inline const ::std::string& Network_Name(Network value) {
    return ContainerInfo_DockerInfo_Network_Name(value);
  }
  static inline bool Network_Parse(const ::std::string& name,
      Network* value) {
    return ContainerInfo_DockerInfo_Network_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .mesos.ContainerInfo.DockerInfo.PortMapping port_mappings = 3;
  int port_mappings_size() const;
  void clear_port_mappings();
  static const int kPortMappingsFieldNumber = 3;
  const ::mesos::ContainerInfo_DockerInfo_PortMapping& port_mappings(int index) const;
  ::mesos::ContainerInfo_DockerInfo_PortMapping* mutable_port_mappings(int index);
  ::mesos::ContainerInfo_DockerInfo_PortMapping* add_port_mappings();
  ::google::protobuf::RepeatedPtrField< ::mesos::ContainerInfo_DockerInfo_PortMapping >*
      mutable_port_mappings();
  const ::google::protobuf::RepeatedPtrField< ::mesos::ContainerInfo_DockerInfo_PortMapping >&
      port_mappings() const;

  // repeated .mesos.Parameter parameters = 5;
  int parameters_size() const;
  void clear_parameters();
  static const int kParametersFieldNumber = 5;
  const ::mesos::Parameter& parameters(int index) const;
  ::mesos::Parameter* mutable_parameters(int index);
  ::mesos::Parameter* add_parameters();
  ::google::protobuf::RepeatedPtrField< ::mesos::Parameter >*
      mutable_parameters();
  const ::google::protobuf::RepeatedPtrField< ::mesos::Parameter >&
      parameters() const;

  // required string image = 1;
  bool has_image() const;
  void clear_image();
  static const int kImageFieldNumber = 1;
  const ::std::string& image() const;
  void set_image(const ::std::string& value);
  #if LANG_CXX11
  void set_image(::std::string&& value);
  #endif
  void set_image(const char* value);
  void set_image(const char* value, size_t size);
  ::std::string* mutable_image();
  ::std::string* release_image();
  void set_allocated_image(::std::string* image);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_image();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_image(
      ::std::string* image);

  // optional string volume_driver = 7 [deprecated = true];
  GOOGLE_PROTOBUF_DEPRECATED_ATTR bool has_volume_driver() const;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void clear_volume_driver();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR static const int kVolumeDriverFieldNumber = 7;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR const ::std::string& volume_driver() const;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void set_volume_driver(const ::std::string& value);
  #if LANG_CXX11
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void set_volume_driver(::std::string&& value);
  #endif
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void set_volume_driver(const char* value);
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void set_volume_driver(const char* value, size_t size);
  GOOGLE_PROTOBUF_DEPRECATED_ATTR ::std::string* mutable_volume_driver();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR ::std::string* release_volume_driver();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void set_allocated_volume_driver(::std::string* volume_driver);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_volume_driver();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_volume_driver(
      ::std::string* volume_driver);

  // optional bool privileged = 4 [default = false];
  bool has_privileged() const;
  void clear_privileged();
  static const int kPrivilegedFieldNumber = 4;
  bool privileged() const;
  void set_privileged(bool value);

  // optional bool force_pull_image = 6;
  bool has_force_pull_image() const;
  void clear_force_pull_image();
  static const int kForcePullImageFieldNumber = 6;
  bool force_pull_image() const;
  void set_force_pull_image(bool value);

  // optional .mesos.ContainerInfo.DockerInfo.Network network = 2 [default = HOST];
  bool has_network() const;
  void clear_network();
  static const int kNetworkFieldNumber = 2;
  ::mesos::ContainerInfo_DockerInfo_Network network() const;
  void set_network(::mesos::ContainerInfo_DockerInfo_Network value);

  // @@protoc_insertion_point(class_scope:mesos.ContainerInfo.DockerInfo)
 private:
  void set_has_image();
  void clear_has_image();
  void set_has_network();
  void clear_has_network();
  void set_has_privileged();
  void clear_has_privileged();
  void set_has_force_pull_image();
  void clear_has_force_pull_image();
  void set_has_volume_driver();
  void clear_has_volume_driver();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::ContainerInfo_DockerInfo_PortMapping > port_mappings_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Parameter > parameters_;
  ::google::protobuf::internal::ArenaStringPtr image_;
  ::google::protobuf::internal::ArenaStringPtr volume_driver_;
  bool privileged_;
  bool force_pull_image_;
  int network_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsContainerInfo_DockerInfoImpl();
};
// -------------------------------------------------------------------

class ContainerInfo_MesosInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.ContainerInfo.MesosInfo) */ {
 public:
  ContainerInfo_MesosInfo();
  virtual ~ContainerInfo_MesosInfo();

  ContainerInfo_MesosInfo(const ContainerInfo_MesosInfo& from);

  inline ContainerInfo_MesosInfo& operator=(const ContainerInfo_MesosInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ContainerInfo_MesosInfo(ContainerInfo_MesosInfo&& from) noexcept
    : ContainerInfo_MesosInfo() {
    *this = ::std::move(from);
  }

  inline ContainerInfo_MesosInfo& operator=(ContainerInfo_MesosInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const ContainerInfo_MesosInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ContainerInfo_MesosInfo* internal_default_instance() {
    return reinterpret_cast<const ContainerInfo_MesosInfo*>(
               &_ContainerInfo_MesosInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    129;

  void UnsafeArenaSwap(ContainerInfo_MesosInfo* other);
  void Swap(ContainerInfo_MesosInfo* other);
  friend void swap(ContainerInfo_MesosInfo& a, ContainerInfo_MesosInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ContainerInfo_MesosInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  ContainerInfo_MesosInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ContainerInfo_MesosInfo& from);
  void MergeFrom(const ContainerInfo_MesosInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ContainerInfo_MesosInfo* other);
  protected:
  explicit ContainerInfo_MesosInfo(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mesos.Image image = 1;
  bool has_image() const;
  void clear_image();
  static const int kImageFieldNumber = 1;
  private:
  void _slow_mutable_image();
  public:
  const ::mesos::Image& image() const;
  ::mesos::Image* release_image();
  ::mesos::Image* mutable_image();
  void set_allocated_image(::mesos::Image* image);
  void unsafe_arena_set_allocated_image(
      ::mesos::Image* image);
  ::mesos::Image* unsafe_arena_release_image();

  // @@protoc_insertion_point(class_scope:mesos.ContainerInfo.MesosInfo)
 private:
  void set_has_image();
  void clear_has_image();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::Image* image_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsContainerInfo_MesosInfoImpl();
};
// -------------------------------------------------------------------

class ContainerInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.ContainerInfo) */ {
 public:
  ContainerInfo();
  virtual ~ContainerInfo();

  ContainerInfo(const ContainerInfo& from);

  inline ContainerInfo& operator=(const ContainerInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ContainerInfo(ContainerInfo&& from) noexcept
    : ContainerInfo() {
    *this = ::std::move(from);
  }

  inline ContainerInfo& operator=(ContainerInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const ContainerInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ContainerInfo* internal_default_instance() {
    return reinterpret_cast<const ContainerInfo*>(
               &_ContainerInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    130;

  void UnsafeArenaSwap(ContainerInfo* other);
  void Swap(ContainerInfo* other);
  friend void swap(ContainerInfo& a, ContainerInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ContainerInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  ContainerInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ContainerInfo& from);
  void MergeFrom(const ContainerInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ContainerInfo* other);
  protected:
  explicit ContainerInfo(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef ContainerInfo_DockerInfo DockerInfo;
  typedef ContainerInfo_MesosInfo MesosInfo;

  typedef ContainerInfo_Type Type;
  static const Type DOCKER =
    ContainerInfo_Type_DOCKER;
  static const Type MESOS =
    ContainerInfo_Type_MESOS;
  static inline bool Type_IsValid(int value) {
    return ContainerInfo_Type_IsValid(value);
  }
  static const Type Type_MIN =
    ContainerInfo_Type_Type_MIN;
  static const Type Type_MAX =
    ContainerInfo_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    ContainerInfo_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return ContainerInfo_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return ContainerInfo_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return ContainerInfo_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .mesos.Volume volumes = 2;
  int volumes_size() const;
  void clear_volumes();
  static const int kVolumesFieldNumber = 2;
  const ::mesos::Volume& volumes(int index) const;
  ::mesos::Volume* mutable_volumes(int index);
  ::mesos::Volume* add_volumes();
  ::google::protobuf::RepeatedPtrField< ::mesos::Volume >*
      mutable_volumes();
  const ::google::protobuf::RepeatedPtrField< ::mesos::Volume >&
      volumes() const;

  // repeated .mesos.NetworkInfo network_infos = 7;
  int network_infos_size() const;
  void clear_network_infos();
  static const int kNetworkInfosFieldNumber = 7;
  const ::mesos::NetworkInfo& network_infos(int index) const;
  ::mesos::NetworkInfo* mutable_network_infos(int index);
  ::mesos::NetworkInfo* add_network_infos();
  ::google::protobuf::RepeatedPtrField< ::mesos::NetworkInfo >*
      mutable_network_infos();
  const ::google::protobuf::RepeatedPtrField< ::mesos::NetworkInfo >&
      network_infos() const;

  // optional string hostname = 4;
  bool has_hostname() const;
  void clear_hostname();
  static const int kHostnameFieldNumber = 4;
  const ::std::string& hostname() const;
  void set_hostname(const ::std::string& value);
  #if LANG_CXX11
  void set_hostname(::std::string&& value);
  #endif
  void set_hostname(const char* value);
  void set_hostname(const char* value, size_t size);
  ::std::string* mutable_hostname();
  ::std::string* release_hostname();
  void set_allocated_hostname(::std::string* hostname);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_hostname();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_hostname(
      ::std::string* hostname);

  // optional .mesos.ContainerInfo.DockerInfo docker = 3;
  bool has_docker() const;
  void clear_docker();
  static const int kDockerFieldNumber = 3;
  private:
  void _slow_mutable_docker();
  public:
  const ::mesos::ContainerInfo_DockerInfo& docker() const;
  ::mesos::ContainerInfo_DockerInfo* release_docker();
  ::mesos::ContainerInfo_DockerInfo* mutable_docker();
  void set_allocated_docker(::mesos::ContainerInfo_DockerInfo* docker);
  void unsafe_arena_set_allocated_docker(
      ::mesos::ContainerInfo_DockerInfo* docker);
  ::mesos::ContainerInfo_DockerInfo* unsafe_arena_release_docker();

  // optional .mesos.ContainerInfo.MesosInfo mesos = 5;
  bool has_mesos() const;
  void clear_mesos();
  static const int kMesosFieldNumber = 5;
  private:
  void _slow_mutable_mesos();
  public:
  const ::mesos::ContainerInfo_MesosInfo& mesos() const;
  ::mesos::ContainerInfo_MesosInfo* release_mesos();
  ::mesos::ContainerInfo_MesosInfo* mutable_mesos();
  void set_allocated_mesos(::mesos::ContainerInfo_MesosInfo* mesos);
  void unsafe_arena_set_allocated_mesos(
      ::mesos::ContainerInfo_MesosInfo* mesos);
  ::mesos::ContainerInfo_MesosInfo* unsafe_arena_release_mesos();

  // optional .mesos.LinuxInfo linux_info = 8;
  bool has_linux_info() const;
  void clear_linux_info();
  static const int kLinuxInfoFieldNumber = 8;
  private:
  void _slow_mutable_linux_info();
  public:
  const ::mesos::LinuxInfo& linux_info() const;
  ::mesos::LinuxInfo* release_linux_info();
  ::mesos::LinuxInfo* mutable_linux_info();
  void set_allocated_linux_info(::mesos::LinuxInfo* linux_info);
  void unsafe_arena_set_allocated_linux_info(
      ::mesos::LinuxInfo* linux_info);
  ::mesos::LinuxInfo* unsafe_arena_release_linux_info();

  // optional .mesos.RLimitInfo rlimit_info = 9;
  bool has_rlimit_info() const;
  void clear_rlimit_info();
  static const int kRlimitInfoFieldNumber = 9;
  private:
  void _slow_mutable_rlimit_info();
  public:
  const ::mesos::RLimitInfo& rlimit_info() const;
  ::mesos::RLimitInfo* release_rlimit_info();
  ::mesos::RLimitInfo* mutable_rlimit_info();
  void set_allocated_rlimit_info(::mesos::RLimitInfo* rlimit_info);
  void unsafe_arena_set_allocated_rlimit_info(
      ::mesos::RLimitInfo* rlimit_info);
  ::mesos::RLimitInfo* unsafe_arena_release_rlimit_info();

  // optional .mesos.TTYInfo tty_info = 10;
  bool has_tty_info() const;
  void clear_tty_info();
  static const int kTtyInfoFieldNumber = 10;
  private:
  void _slow_mutable_tty_info();
  public:
  const ::mesos::TTYInfo& tty_info() const;
  ::mesos::TTYInfo* release_tty_info();
  ::mesos::TTYInfo* mutable_tty_info();
  void set_allocated_tty_info(::mesos::TTYInfo* tty_info);
  void unsafe_arena_set_allocated_tty_info(
      ::mesos::TTYInfo* tty_info);
  ::mesos::TTYInfo* unsafe_arena_release_tty_info();

  // required .mesos.ContainerInfo.Type type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::mesos::ContainerInfo_Type type() const;
  void set_type(::mesos::ContainerInfo_Type value);

  // @@protoc_insertion_point(class_scope:mesos.ContainerInfo)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_hostname();
  void clear_has_hostname();
  void set_has_docker();
  void clear_has_docker();
  void set_has_mesos();
  void clear_has_mesos();
  void set_has_linux_info();
  void clear_has_linux_info();
  void set_has_rlimit_info();
  void clear_has_rlimit_info();
  void set_has_tty_info();
  void clear_has_tty_info();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Volume > volumes_;
  ::google::protobuf::RepeatedPtrField< ::mesos::NetworkInfo > network_infos_;
  ::google::protobuf::internal::ArenaStringPtr hostname_;
  ::mesos::ContainerInfo_DockerInfo* docker_;
  ::mesos::ContainerInfo_MesosInfo* mesos_;
  ::mesos::LinuxInfo* linux_info_;
  ::mesos::RLimitInfo* rlimit_info_;
  ::mesos::TTYInfo* tty_info_;
  int type_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsContainerInfoImpl();
};
// -------------------------------------------------------------------

class ContainerStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.ContainerStatus) */ {
 public:
  ContainerStatus();
  virtual ~ContainerStatus();

  ContainerStatus(const ContainerStatus& from);

  inline ContainerStatus& operator=(const ContainerStatus& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ContainerStatus(ContainerStatus&& from) noexcept
    : ContainerStatus() {
    *this = ::std::move(from);
  }

  inline ContainerStatus& operator=(ContainerStatus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const ContainerStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ContainerStatus* internal_default_instance() {
    return reinterpret_cast<const ContainerStatus*>(
               &_ContainerStatus_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    131;

  void UnsafeArenaSwap(ContainerStatus* other);
  void Swap(ContainerStatus* other);
  friend void swap(ContainerStatus& a, ContainerStatus& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ContainerStatus* New() const PROTOBUF_FINAL { return New(NULL); }

  ContainerStatus* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ContainerStatus& from);
  void MergeFrom(const ContainerStatus& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ContainerStatus* other);
  protected:
  explicit ContainerStatus(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.NetworkInfo network_infos = 1;
  int network_infos_size() const;
  void clear_network_infos();
  static const int kNetworkInfosFieldNumber = 1;
  const ::mesos::NetworkInfo& network_infos(int index) const;
  ::mesos::NetworkInfo* mutable_network_infos(int index);
  ::mesos::NetworkInfo* add_network_infos();
  ::google::protobuf::RepeatedPtrField< ::mesos::NetworkInfo >*
      mutable_network_infos();
  const ::google::protobuf::RepeatedPtrField< ::mesos::NetworkInfo >&
      network_infos() const;

  // optional .mesos.CgroupInfo cgroup_info = 2;
  bool has_cgroup_info() const;
  void clear_cgroup_info();
  static const int kCgroupInfoFieldNumber = 2;
  private:
  void _slow_mutable_cgroup_info();
  public:
  const ::mesos::CgroupInfo& cgroup_info() const;
  ::mesos::CgroupInfo* release_cgroup_info();
  ::mesos::CgroupInfo* mutable_cgroup_info();
  void set_allocated_cgroup_info(::mesos::CgroupInfo* cgroup_info);
  void unsafe_arena_set_allocated_cgroup_info(
      ::mesos::CgroupInfo* cgroup_info);
  ::mesos::CgroupInfo* unsafe_arena_release_cgroup_info();

  // optional .mesos.ContainerID container_id = 4;
  bool has_container_id() const;
  void clear_container_id();
  static const int kContainerIdFieldNumber = 4;
  private:
  void _slow_mutable_container_id();
  public:
  const ::mesos::ContainerID& container_id() const;
  ::mesos::ContainerID* release_container_id();
  ::mesos::ContainerID* mutable_container_id();
  void set_allocated_container_id(::mesos::ContainerID* container_id);
  void unsafe_arena_set_allocated_container_id(
      ::mesos::ContainerID* container_id);
  ::mesos::ContainerID* unsafe_arena_release_container_id();

  // optional uint32 executor_pid = 3;
  bool has_executor_pid() const;
  void clear_executor_pid();
  static const int kExecutorPidFieldNumber = 3;
  ::google::protobuf::uint32 executor_pid() const;
  void set_executor_pid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mesos.ContainerStatus)
 private:
  void set_has_container_id();
  void clear_has_container_id();
  void set_has_cgroup_info();
  void clear_has_cgroup_info();
  void set_has_executor_pid();
  void clear_has_executor_pid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::NetworkInfo > network_infos_;
  ::mesos::CgroupInfo* cgroup_info_;
  ::mesos::ContainerID* container_id_;
  ::google::protobuf::uint32 executor_pid_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsContainerStatusImpl();
};
// -------------------------------------------------------------------

class CgroupInfo_Blkio_Value : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.CgroupInfo.Blkio.Value) */ {
 public:
  CgroupInfo_Blkio_Value();
  virtual ~CgroupInfo_Blkio_Value();

  CgroupInfo_Blkio_Value(const CgroupInfo_Blkio_Value& from);

  inline CgroupInfo_Blkio_Value& operator=(const CgroupInfo_Blkio_Value& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CgroupInfo_Blkio_Value(CgroupInfo_Blkio_Value&& from) noexcept
    : CgroupInfo_Blkio_Value() {
    *this = ::std::move(from);
  }

  inline CgroupInfo_Blkio_Value& operator=(CgroupInfo_Blkio_Value&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const CgroupInfo_Blkio_Value& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CgroupInfo_Blkio_Value* internal_default_instance() {
    return reinterpret_cast<const CgroupInfo_Blkio_Value*>(
               &_CgroupInfo_Blkio_Value_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    132;

  void UnsafeArenaSwap(CgroupInfo_Blkio_Value* other);
  void Swap(CgroupInfo_Blkio_Value* other);
  friend void swap(CgroupInfo_Blkio_Value& a, CgroupInfo_Blkio_Value& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CgroupInfo_Blkio_Value* New() const PROTOBUF_FINAL { return New(NULL); }

  CgroupInfo_Blkio_Value* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CgroupInfo_Blkio_Value& from);
  void MergeFrom(const CgroupInfo_Blkio_Value& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CgroupInfo_Blkio_Value* other);
  protected:
  explicit CgroupInfo_Blkio_Value(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  ::google::protobuf::uint64 value() const;
  void set_value(::google::protobuf::uint64 value);

  // optional .mesos.CgroupInfo.Blkio.Operation op = 1;
  bool has_op() const;
  void clear_op();
  static const int kOpFieldNumber = 1;
  ::mesos::CgroupInfo_Blkio_Operation op() const;
  void set_op(::mesos::CgroupInfo_Blkio_Operation value);

  // @@protoc_insertion_point(class_scope:mesos.CgroupInfo.Blkio.Value)
 private:
  void set_has_op();
  void clear_has_op();
  void set_has_value();
  void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint64 value_;
  int op_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsCgroupInfo_Blkio_ValueImpl();
};
// -------------------------------------------------------------------

class CgroupInfo_Blkio_CFQ_Statistics : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.CgroupInfo.Blkio.CFQ.Statistics) */ {
 public:
  CgroupInfo_Blkio_CFQ_Statistics();
  virtual ~CgroupInfo_Blkio_CFQ_Statistics();

  CgroupInfo_Blkio_CFQ_Statistics(const CgroupInfo_Blkio_CFQ_Statistics& from);

  inline CgroupInfo_Blkio_CFQ_Statistics& operator=(const CgroupInfo_Blkio_CFQ_Statistics& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CgroupInfo_Blkio_CFQ_Statistics(CgroupInfo_Blkio_CFQ_Statistics&& from) noexcept
    : CgroupInfo_Blkio_CFQ_Statistics() {
    *this = ::std::move(from);
  }

  inline CgroupInfo_Blkio_CFQ_Statistics& operator=(CgroupInfo_Blkio_CFQ_Statistics&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const CgroupInfo_Blkio_CFQ_Statistics& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CgroupInfo_Blkio_CFQ_Statistics* internal_default_instance() {
    return reinterpret_cast<const CgroupInfo_Blkio_CFQ_Statistics*>(
               &_CgroupInfo_Blkio_CFQ_Statistics_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    133;

  void UnsafeArenaSwap(CgroupInfo_Blkio_CFQ_Statistics* other);
  void Swap(CgroupInfo_Blkio_CFQ_Statistics* other);
  friend void swap(CgroupInfo_Blkio_CFQ_Statistics& a, CgroupInfo_Blkio_CFQ_Statistics& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CgroupInfo_Blkio_CFQ_Statistics* New() const PROTOBUF_FINAL { return New(NULL); }

  CgroupInfo_Blkio_CFQ_Statistics* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CgroupInfo_Blkio_CFQ_Statistics& from);
  void MergeFrom(const CgroupInfo_Blkio_CFQ_Statistics& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CgroupInfo_Blkio_CFQ_Statistics* other);
  protected:
  explicit CgroupInfo_Blkio_CFQ_Statistics(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.CgroupInfo.Blkio.Value io_serviced = 4;
  int io_serviced_size() const;
  void clear_io_serviced();
  static const int kIoServicedFieldNumber = 4;
  const ::mesos::CgroupInfo_Blkio_Value& io_serviced(int index) const;
  ::mesos::CgroupInfo_Blkio_Value* mutable_io_serviced(int index);
  ::mesos::CgroupInfo_Blkio_Value* add_io_serviced();
  ::google::protobuf::RepeatedPtrField< ::mesos::CgroupInfo_Blkio_Value >*
      mutable_io_serviced();
  const ::google::protobuf::RepeatedPtrField< ::mesos::CgroupInfo_Blkio_Value >&
      io_serviced() const;

  // repeated .mesos.CgroupInfo.Blkio.Value io_service_bytes = 5;
  int io_service_bytes_size() const;
  void clear_io_service_bytes();
  static const int kIoServiceBytesFieldNumber = 5;
  const ::mesos::CgroupInfo_Blkio_Value& io_service_bytes(int index) const;
  ::mesos::CgroupInfo_Blkio_Value* mutable_io_service_bytes(int index);
  ::mesos::CgroupInfo_Blkio_Value* add_io_service_bytes();
  ::google::protobuf::RepeatedPtrField< ::mesos::CgroupInfo_Blkio_Value >*
      mutable_io_service_bytes();
  const ::google::protobuf::RepeatedPtrField< ::mesos::CgroupInfo_Blkio_Value >&
      io_service_bytes() const;

  // repeated .mesos.CgroupInfo.Blkio.Value io_service_time = 6;
  int io_service_time_size() const;
  void clear_io_service_time();
  static const int kIoServiceTimeFieldNumber = 6;
  const ::mesos::CgroupInfo_Blkio_Value& io_service_time(int index) const;
  ::mesos::CgroupInfo_Blkio_Value* mutable_io_service_time(int index);
  ::mesos::CgroupInfo_Blkio_Value* add_io_service_time();
  ::google::protobuf::RepeatedPtrField< ::mesos::CgroupInfo_Blkio_Value >*
      mutable_io_service_time();
  const ::google::protobuf::RepeatedPtrField< ::mesos::CgroupInfo_Blkio_Value >&
      io_service_time() const;

  // repeated .mesos.CgroupInfo.Blkio.Value io_wait_time = 7;
  int io_wait_time_size() const;
  void clear_io_wait_time();
  static const int kIoWaitTimeFieldNumber = 7;
  const ::mesos::CgroupInfo_Blkio_Value& io_wait_time(int index) const;
  ::mesos::CgroupInfo_Blkio_Value* mutable_io_wait_time(int index);
  ::mesos::CgroupInfo_Blkio_Value* add_io_wait_time();
  ::google::protobuf::RepeatedPtrField< ::mesos::CgroupInfo_Blkio_Value >*
      mutable_io_wait_time();
  const ::google::protobuf::RepeatedPtrField< ::mesos::CgroupInfo_Blkio_Value >&
      io_wait_time() const;

  // repeated .mesos.CgroupInfo.Blkio.Value io_merged = 8;
  int io_merged_size() const;
  void clear_io_merged();
  static const int kIoMergedFieldNumber = 8;
  const ::mesos::CgroupInfo_Blkio_Value& io_merged(int index) const;
  ::mesos::CgroupInfo_Blkio_Value* mutable_io_merged(int index);
  ::mesos::CgroupInfo_Blkio_Value* add_io_merged();
  ::google::protobuf::RepeatedPtrField< ::mesos::CgroupInfo_Blkio_Value >*
      mutable_io_merged();
  const ::google::protobuf::RepeatedPtrField< ::mesos::CgroupInfo_Blkio_Value >&
      io_merged() const;

  // repeated .mesos.CgroupInfo.Blkio.Value io_queued = 9;
  int io_queued_size() const;
  void clear_io_queued();
  static const int kIoQueuedFieldNumber = 9;
  const ::mesos::CgroupInfo_Blkio_Value& io_queued(int index) const;
  ::mesos::CgroupInfo_Blkio_Value* mutable_io_queued(int index);
  ::mesos::CgroupInfo_Blkio_Value* add_io_queued();
  ::google::protobuf::RepeatedPtrField< ::mesos::CgroupInfo_Blkio_Value >*
      mutable_io_queued();
  const ::google::protobuf::RepeatedPtrField< ::mesos::CgroupInfo_Blkio_Value >&
      io_queued() const;

  // optional .mesos.Device.Number device = 1;
  bool has_device() const;
  void clear_device();
  static const int kDeviceFieldNumber = 1;
  private:
  void _slow_mutable_device();
  public:
  const ::mesos::Device_Number& device() const;
  ::mesos::Device_Number* release_device();
  ::mesos::Device_Number* mutable_device();
  void set_allocated_device(::mesos::Device_Number* device);
  void unsafe_arena_set_allocated_device(
      ::mesos::Device_Number* device);
  ::mesos::Device_Number* unsafe_arena_release_device();

  // optional uint64 sectors = 2;
  bool has_sectors() const;
  void clear_sectors();
  static const int kSectorsFieldNumber = 2;
  ::google::protobuf::uint64 sectors() const;
  void set_sectors(::google::protobuf::uint64 value);

  // optional uint64 time = 3;
  bool has_time() const;
  void clear_time();
  static const int kTimeFieldNumber = 3;
  ::google::protobuf::uint64 time() const;
  void set_time(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:mesos.CgroupInfo.Blkio.CFQ.Statistics)
 private:
  void set_has_device();
  void clear_has_device();
  void set_has_sectors();
  void clear_has_sectors();
  void set_has_time();
  void clear_has_time();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::CgroupInfo_Blkio_Value > io_serviced_;
  ::google::protobuf::RepeatedPtrField< ::mesos::CgroupInfo_Blkio_Value > io_service_bytes_;
  ::google::protobuf::RepeatedPtrField< ::mesos::CgroupInfo_Blkio_Value > io_service_time_;
  ::google::protobuf::RepeatedPtrField< ::mesos::CgroupInfo_Blkio_Value > io_wait_time_;
  ::google::protobuf::RepeatedPtrField< ::mesos::CgroupInfo_Blkio_Value > io_merged_;
  ::google::protobuf::RepeatedPtrField< ::mesos::CgroupInfo_Blkio_Value > io_queued_;
  ::mesos::Device_Number* device_;
  ::google::protobuf::uint64 sectors_;
  ::google::protobuf::uint64 time_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsCgroupInfo_Blkio_CFQ_StatisticsImpl();
};
// -------------------------------------------------------------------

class CgroupInfo_Blkio_CFQ : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.CgroupInfo.Blkio.CFQ) */ {
 public:
  CgroupInfo_Blkio_CFQ();
  virtual ~CgroupInfo_Blkio_CFQ();

  CgroupInfo_Blkio_CFQ(const CgroupInfo_Blkio_CFQ& from);

  inline CgroupInfo_Blkio_CFQ& operator=(const CgroupInfo_Blkio_CFQ& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CgroupInfo_Blkio_CFQ(CgroupInfo_Blkio_CFQ&& from) noexcept
    : CgroupInfo_Blkio_CFQ() {
    *this = ::std::move(from);
  }

  inline CgroupInfo_Blkio_CFQ& operator=(CgroupInfo_Blkio_CFQ&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const CgroupInfo_Blkio_CFQ& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CgroupInfo_Blkio_CFQ* internal_default_instance() {
    return reinterpret_cast<const CgroupInfo_Blkio_CFQ*>(
               &_CgroupInfo_Blkio_CFQ_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    134;

  void UnsafeArenaSwap(CgroupInfo_Blkio_CFQ* other);
  void Swap(CgroupInfo_Blkio_CFQ* other);
  friend void swap(CgroupInfo_Blkio_CFQ& a, CgroupInfo_Blkio_CFQ& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CgroupInfo_Blkio_CFQ* New() const PROTOBUF_FINAL { return New(NULL); }

  CgroupInfo_Blkio_CFQ* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CgroupInfo_Blkio_CFQ& from);
  void MergeFrom(const CgroupInfo_Blkio_CFQ& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CgroupInfo_Blkio_CFQ* other);
  protected:
  explicit CgroupInfo_Blkio_CFQ(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef CgroupInfo_Blkio_CFQ_Statistics Statistics;

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:mesos.CgroupInfo.Blkio.CFQ)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsCgroupInfo_Blkio_CFQImpl();
};
// -------------------------------------------------------------------

class CgroupInfo_Blkio_Throttling_Statistics : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.CgroupInfo.Blkio.Throttling.Statistics) */ {
 public:
  CgroupInfo_Blkio_Throttling_Statistics();
  virtual ~CgroupInfo_Blkio_Throttling_Statistics();

  CgroupInfo_Blkio_Throttling_Statistics(const CgroupInfo_Blkio_Throttling_Statistics& from);

  inline CgroupInfo_Blkio_Throttling_Statistics& operator=(const CgroupInfo_Blkio_Throttling_Statistics& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CgroupInfo_Blkio_Throttling_Statistics(CgroupInfo_Blkio_Throttling_Statistics&& from) noexcept
    : CgroupInfo_Blkio_Throttling_Statistics() {
    *this = ::std::move(from);
  }

  inline CgroupInfo_Blkio_Throttling_Statistics& operator=(CgroupInfo_Blkio_Throttling_Statistics&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const CgroupInfo_Blkio_Throttling_Statistics& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CgroupInfo_Blkio_Throttling_Statistics* internal_default_instance() {
    return reinterpret_cast<const CgroupInfo_Blkio_Throttling_Statistics*>(
               &_CgroupInfo_Blkio_Throttling_Statistics_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    135;

  void UnsafeArenaSwap(CgroupInfo_Blkio_Throttling_Statistics* other);
  void Swap(CgroupInfo_Blkio_Throttling_Statistics* other);
  friend void swap(CgroupInfo_Blkio_Throttling_Statistics& a, CgroupInfo_Blkio_Throttling_Statistics& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CgroupInfo_Blkio_Throttling_Statistics* New() const PROTOBUF_FINAL { return New(NULL); }

  CgroupInfo_Blkio_Throttling_Statistics* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CgroupInfo_Blkio_Throttling_Statistics& from);
  void MergeFrom(const CgroupInfo_Blkio_Throttling_Statistics& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CgroupInfo_Blkio_Throttling_Statistics* other);
  protected:
  explicit CgroupInfo_Blkio_Throttling_Statistics(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.CgroupInfo.Blkio.Value io_serviced = 2;
  int io_serviced_size() const;
  void clear_io_serviced();
  static const int kIoServicedFieldNumber = 2;
  const ::mesos::CgroupInfo_Blkio_Value& io_serviced(int index) const;
  ::mesos::CgroupInfo_Blkio_Value* mutable_io_serviced(int index);
  ::mesos::CgroupInfo_Blkio_Value* add_io_serviced();
  ::google::protobuf::RepeatedPtrField< ::mesos::CgroupInfo_Blkio_Value >*
      mutable_io_serviced();
  const ::google::protobuf::RepeatedPtrField< ::mesos::CgroupInfo_Blkio_Value >&
      io_serviced() const;

  // repeated .mesos.CgroupInfo.Blkio.Value io_service_bytes = 3;
  int io_service_bytes_size() const;
  void clear_io_service_bytes();
  static const int kIoServiceBytesFieldNumber = 3;
  const ::mesos::CgroupInfo_Blkio_Value& io_service_bytes(int index) const;
  ::mesos::CgroupInfo_Blkio_Value* mutable_io_service_bytes(int index);
  ::mesos::CgroupInfo_Blkio_Value* add_io_service_bytes();
  ::google::protobuf::RepeatedPtrField< ::mesos::CgroupInfo_Blkio_Value >*
      mutable_io_service_bytes();
  const ::google::protobuf::RepeatedPtrField< ::mesos::CgroupInfo_Blkio_Value >&
      io_service_bytes() const;

  // optional .mesos.Device.Number device = 1;
  bool has_device() const;
  void clear_device();
  static const int kDeviceFieldNumber = 1;
  private:
  void _slow_mutable_device();
  public:
  const ::mesos::Device_Number& device() const;
  ::mesos::Device_Number* release_device();
  ::mesos::Device_Number* mutable_device();
  void set_allocated_device(::mesos::Device_Number* device);
  void unsafe_arena_set_allocated_device(
      ::mesos::Device_Number* device);
  ::mesos::Device_Number* unsafe_arena_release_device();

  // @@protoc_insertion_point(class_scope:mesos.CgroupInfo.Blkio.Throttling.Statistics)
 private:
  void set_has_device();
  void clear_has_device();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::CgroupInfo_Blkio_Value > io_serviced_;
  ::google::protobuf::RepeatedPtrField< ::mesos::CgroupInfo_Blkio_Value > io_service_bytes_;
  ::mesos::Device_Number* device_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsCgroupInfo_Blkio_Throttling_StatisticsImpl();
};
// -------------------------------------------------------------------

class CgroupInfo_Blkio_Throttling : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.CgroupInfo.Blkio.Throttling) */ {
 public:
  CgroupInfo_Blkio_Throttling();
  virtual ~CgroupInfo_Blkio_Throttling();

  CgroupInfo_Blkio_Throttling(const CgroupInfo_Blkio_Throttling& from);

  inline CgroupInfo_Blkio_Throttling& operator=(const CgroupInfo_Blkio_Throttling& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CgroupInfo_Blkio_Throttling(CgroupInfo_Blkio_Throttling&& from) noexcept
    : CgroupInfo_Blkio_Throttling() {
    *this = ::std::move(from);
  }

  inline CgroupInfo_Blkio_Throttling& operator=(CgroupInfo_Blkio_Throttling&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const CgroupInfo_Blkio_Throttling& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CgroupInfo_Blkio_Throttling* internal_default_instance() {
    return reinterpret_cast<const CgroupInfo_Blkio_Throttling*>(
               &_CgroupInfo_Blkio_Throttling_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    136;

  void UnsafeArenaSwap(CgroupInfo_Blkio_Throttling* other);
  void Swap(CgroupInfo_Blkio_Throttling* other);
  friend void swap(CgroupInfo_Blkio_Throttling& a, CgroupInfo_Blkio_Throttling& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CgroupInfo_Blkio_Throttling* New() const PROTOBUF_FINAL { return New(NULL); }

  CgroupInfo_Blkio_Throttling* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CgroupInfo_Blkio_Throttling& from);
  void MergeFrom(const CgroupInfo_Blkio_Throttling& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CgroupInfo_Blkio_Throttling* other);
  protected:
  explicit CgroupInfo_Blkio_Throttling(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef CgroupInfo_Blkio_Throttling_Statistics Statistics;

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:mesos.CgroupInfo.Blkio.Throttling)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsCgroupInfo_Blkio_ThrottlingImpl();
};
// -------------------------------------------------------------------

class CgroupInfo_Blkio_Statistics : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.CgroupInfo.Blkio.Statistics) */ {
 public:
  CgroupInfo_Blkio_Statistics();
  virtual ~CgroupInfo_Blkio_Statistics();

  CgroupInfo_Blkio_Statistics(const CgroupInfo_Blkio_Statistics& from);

  inline CgroupInfo_Blkio_Statistics& operator=(const CgroupInfo_Blkio_Statistics& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CgroupInfo_Blkio_Statistics(CgroupInfo_Blkio_Statistics&& from) noexcept
    : CgroupInfo_Blkio_Statistics() {
    *this = ::std::move(from);
  }

  inline CgroupInfo_Blkio_Statistics& operator=(CgroupInfo_Blkio_Statistics&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const CgroupInfo_Blkio_Statistics& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CgroupInfo_Blkio_Statistics* internal_default_instance() {
    return reinterpret_cast<const CgroupInfo_Blkio_Statistics*>(
               &_CgroupInfo_Blkio_Statistics_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    137;

  void UnsafeArenaSwap(CgroupInfo_Blkio_Statistics* other);
  void Swap(CgroupInfo_Blkio_Statistics* other);
  friend void swap(CgroupInfo_Blkio_Statistics& a, CgroupInfo_Blkio_Statistics& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CgroupInfo_Blkio_Statistics* New() const PROTOBUF_FINAL { return New(NULL); }

  CgroupInfo_Blkio_Statistics* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CgroupInfo_Blkio_Statistics& from);
  void MergeFrom(const CgroupInfo_Blkio_Statistics& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CgroupInfo_Blkio_Statistics* other);
  protected:
  explicit CgroupInfo_Blkio_Statistics(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.CgroupInfo.Blkio.CFQ.Statistics cfq = 1;
  int cfq_size() const;
  void clear_cfq();
  static const int kCfqFieldNumber = 1;
  const ::mesos::CgroupInfo_Blkio_CFQ_Statistics& cfq(int index) const;
  ::mesos::CgroupInfo_Blkio_CFQ_Statistics* mutable_cfq(int index);
  ::mesos::CgroupInfo_Blkio_CFQ_Statistics* add_cfq();
  ::google::protobuf::RepeatedPtrField< ::mesos::CgroupInfo_Blkio_CFQ_Statistics >*
      mutable_cfq();
  const ::google::protobuf::RepeatedPtrField< ::mesos::CgroupInfo_Blkio_CFQ_Statistics >&
      cfq() const;

  // repeated .mesos.CgroupInfo.Blkio.CFQ.Statistics cfq_recursive = 2;
  int cfq_recursive_size() const;
  void clear_cfq_recursive();
  static const int kCfqRecursiveFieldNumber = 2;
  const ::mesos::CgroupInfo_Blkio_CFQ_Statistics& cfq_recursive(int index) const;
  ::mesos::CgroupInfo_Blkio_CFQ_Statistics* mutable_cfq_recursive(int index);
  ::mesos::CgroupInfo_Blkio_CFQ_Statistics* add_cfq_recursive();
  ::google::protobuf::RepeatedPtrField< ::mesos::CgroupInfo_Blkio_CFQ_Statistics >*
      mutable_cfq_recursive();
  const ::google::protobuf::RepeatedPtrField< ::mesos::CgroupInfo_Blkio_CFQ_Statistics >&
      cfq_recursive() const;

  // repeated .mesos.CgroupInfo.Blkio.Throttling.Statistics throttling = 3;
  int throttling_size() const;
  void clear_throttling();
  static const int kThrottlingFieldNumber = 3;
  const ::mesos::CgroupInfo_Blkio_Throttling_Statistics& throttling(int index) const;
  ::mesos::CgroupInfo_Blkio_Throttling_Statistics* mutable_throttling(int index);
  ::mesos::CgroupInfo_Blkio_Throttling_Statistics* add_throttling();
  ::google::protobuf::RepeatedPtrField< ::mesos::CgroupInfo_Blkio_Throttling_Statistics >*
      mutable_throttling();
  const ::google::protobuf::RepeatedPtrField< ::mesos::CgroupInfo_Blkio_Throttling_Statistics >&
      throttling() const;

  // @@protoc_insertion_point(class_scope:mesos.CgroupInfo.Blkio.Statistics)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::CgroupInfo_Blkio_CFQ_Statistics > cfq_;
  ::google::protobuf::RepeatedPtrField< ::mesos::CgroupInfo_Blkio_CFQ_Statistics > cfq_recursive_;
  ::google::protobuf::RepeatedPtrField< ::mesos::CgroupInfo_Blkio_Throttling_Statistics > throttling_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsCgroupInfo_Blkio_StatisticsImpl();
};
// -------------------------------------------------------------------

class CgroupInfo_Blkio : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.CgroupInfo.Blkio) */ {
 public:
  CgroupInfo_Blkio();
  virtual ~CgroupInfo_Blkio();

  CgroupInfo_Blkio(const CgroupInfo_Blkio& from);

  inline CgroupInfo_Blkio& operator=(const CgroupInfo_Blkio& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CgroupInfo_Blkio(CgroupInfo_Blkio&& from) noexcept
    : CgroupInfo_Blkio() {
    *this = ::std::move(from);
  }

  inline CgroupInfo_Blkio& operator=(CgroupInfo_Blkio&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const CgroupInfo_Blkio& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CgroupInfo_Blkio* internal_default_instance() {
    return reinterpret_cast<const CgroupInfo_Blkio*>(
               &_CgroupInfo_Blkio_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    138;

  void UnsafeArenaSwap(CgroupInfo_Blkio* other);
  void Swap(CgroupInfo_Blkio* other);
  friend void swap(CgroupInfo_Blkio& a, CgroupInfo_Blkio& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CgroupInfo_Blkio* New() const PROTOBUF_FINAL { return New(NULL); }

  CgroupInfo_Blkio* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CgroupInfo_Blkio& from);
  void MergeFrom(const CgroupInfo_Blkio& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CgroupInfo_Blkio* other);
  protected:
  explicit CgroupInfo_Blkio(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef CgroupInfo_Blkio_Value Value;
  typedef CgroupInfo_Blkio_CFQ CFQ;
  typedef CgroupInfo_Blkio_Throttling Throttling;
  typedef CgroupInfo_Blkio_Statistics Statistics;

  typedef CgroupInfo_Blkio_Operation Operation;
  static const Operation UNKNOWN =
    CgroupInfo_Blkio_Operation_UNKNOWN;
  static const Operation TOTAL =
    CgroupInfo_Blkio_Operation_TOTAL;
  static const Operation READ =
    CgroupInfo_Blkio_Operation_READ;
  static const Operation WRITE =
    CgroupInfo_Blkio_Operation_WRITE;
  static const Operation SYNC =
    CgroupInfo_Blkio_Operation_SYNC;
  static const Operation ASYNC =
    CgroupInfo_Blkio_Operation_ASYNC;
  static inline bool Operation_IsValid(int value) {
    return CgroupInfo_Blkio_Operation_IsValid(value);
  }
  static const Operation Operation_MIN =
    CgroupInfo_Blkio_Operation_Operation_MIN;
  static const Operation Operation_MAX =
    CgroupInfo_Blkio_Operation_Operation_MAX;
  static const int Operation_ARRAYSIZE =
    CgroupInfo_Blkio_Operation_Operation_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Operation_descriptor() {
    return CgroupInfo_Blkio_Operation_descriptor();
  }
  static inline const ::std::string& Operation_Name(Operation value) {
    return CgroupInfo_Blkio_Operation_Name(value);
  }
  static inline bool Operation_Parse(const ::std::string& name,
      Operation* value) {
    return CgroupInfo_Blkio_Operation_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:mesos.CgroupInfo.Blkio)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsCgroupInfo_BlkioImpl();
};
// -------------------------------------------------------------------

class CgroupInfo_NetCls : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.CgroupInfo.NetCls) */ {
 public:
  CgroupInfo_NetCls();
  virtual ~CgroupInfo_NetCls();

  CgroupInfo_NetCls(const CgroupInfo_NetCls& from);

  inline CgroupInfo_NetCls& operator=(const CgroupInfo_NetCls& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CgroupInfo_NetCls(CgroupInfo_NetCls&& from) noexcept
    : CgroupInfo_NetCls() {
    *this = ::std::move(from);
  }

  inline CgroupInfo_NetCls& operator=(CgroupInfo_NetCls&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const CgroupInfo_NetCls& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CgroupInfo_NetCls* internal_default_instance() {
    return reinterpret_cast<const CgroupInfo_NetCls*>(
               &_CgroupInfo_NetCls_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    139;

  void UnsafeArenaSwap(CgroupInfo_NetCls* other);
  void Swap(CgroupInfo_NetCls* other);
  friend void swap(CgroupInfo_NetCls& a, CgroupInfo_NetCls& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CgroupInfo_NetCls* New() const PROTOBUF_FINAL { return New(NULL); }

  CgroupInfo_NetCls* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CgroupInfo_NetCls& from);
  void MergeFrom(const CgroupInfo_NetCls& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CgroupInfo_NetCls* other);
  protected:
  explicit CgroupInfo_NetCls(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 classid = 1;
  bool has_classid() const;
  void clear_classid();
  static const int kClassidFieldNumber = 1;
  ::google::protobuf::uint32 classid() const;
  void set_classid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mesos.CgroupInfo.NetCls)
 private:
  void set_has_classid();
  void clear_has_classid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 classid_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsCgroupInfo_NetClsImpl();
};
// -------------------------------------------------------------------

class CgroupInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.CgroupInfo) */ {
 public:
  CgroupInfo();
  virtual ~CgroupInfo();

  CgroupInfo(const CgroupInfo& from);

  inline CgroupInfo& operator=(const CgroupInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CgroupInfo(CgroupInfo&& from) noexcept
    : CgroupInfo() {
    *this = ::std::move(from);
  }

  inline CgroupInfo& operator=(CgroupInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const CgroupInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CgroupInfo* internal_default_instance() {
    return reinterpret_cast<const CgroupInfo*>(
               &_CgroupInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    140;

  void UnsafeArenaSwap(CgroupInfo* other);
  void Swap(CgroupInfo* other);
  friend void swap(CgroupInfo& a, CgroupInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CgroupInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  CgroupInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CgroupInfo& from);
  void MergeFrom(const CgroupInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CgroupInfo* other);
  protected:
  explicit CgroupInfo(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef CgroupInfo_Blkio Blkio;
  typedef CgroupInfo_NetCls NetCls;

  // accessors -------------------------------------------------------

  // optional .mesos.CgroupInfo.NetCls net_cls = 1;
  bool has_net_cls() const;
  void clear_net_cls();
  static const int kNetClsFieldNumber = 1;
  private:
  void _slow_mutable_net_cls();
  public:
  const ::mesos::CgroupInfo_NetCls& net_cls() const;
  ::mesos::CgroupInfo_NetCls* release_net_cls();
  ::mesos::CgroupInfo_NetCls* mutable_net_cls();
  void set_allocated_net_cls(::mesos::CgroupInfo_NetCls* net_cls);
  void unsafe_arena_set_allocated_net_cls(
      ::mesos::CgroupInfo_NetCls* net_cls);
  ::mesos::CgroupInfo_NetCls* unsafe_arena_release_net_cls();

  // @@protoc_insertion_point(class_scope:mesos.CgroupInfo)
 private:
  void set_has_net_cls();
  void clear_has_net_cls();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::CgroupInfo_NetCls* net_cls_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsCgroupInfoImpl();
};
// -------------------------------------------------------------------

class Labels : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.Labels) */ {
 public:
  Labels();
  virtual ~Labels();

  Labels(const Labels& from);

  inline Labels& operator=(const Labels& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Labels(Labels&& from) noexcept
    : Labels() {
    *this = ::std::move(from);
  }

  inline Labels& operator=(Labels&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Labels& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Labels* internal_default_instance() {
    return reinterpret_cast<const Labels*>(
               &_Labels_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    141;

  void UnsafeArenaSwap(Labels* other);
  void Swap(Labels* other);
  friend void swap(Labels& a, Labels& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Labels* New() const PROTOBUF_FINAL { return New(NULL); }

  Labels* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Labels& from);
  void MergeFrom(const Labels& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Labels* other);
  protected:
  explicit Labels(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.Label labels = 1;
  int labels_size() const;
  void clear_labels();
  static const int kLabelsFieldNumber = 1;
  const ::mesos::Label& labels(int index) const;
  ::mesos::Label* mutable_labels(int index);
  ::mesos::Label* add_labels();
  ::google::protobuf::RepeatedPtrField< ::mesos::Label >*
      mutable_labels();
  const ::google::protobuf::RepeatedPtrField< ::mesos::Label >&
      labels() const;

  // @@protoc_insertion_point(class_scope:mesos.Labels)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Label > labels_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsLabelsImpl();
};
// -------------------------------------------------------------------

class Label : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.Label) */ {
 public:
  Label();
  virtual ~Label();

  Label(const Label& from);

  inline Label& operator=(const Label& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Label(Label&& from) noexcept
    : Label() {
    *this = ::std::move(from);
  }

  inline Label& operator=(Label&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Label& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Label* internal_default_instance() {
    return reinterpret_cast<const Label*>(
               &_Label_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    142;

  void UnsafeArenaSwap(Label* other);
  void Swap(Label* other);
  friend void swap(Label& a, Label& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Label* New() const PROTOBUF_FINAL { return New(NULL); }

  Label* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Label& from);
  void MergeFrom(const Label& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Label* other);
  protected:
  explicit Label(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string key = 1;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_key();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_key(
      ::std::string* key);

  // optional string value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_value();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_value(
      ::std::string* value);

  // @@protoc_insertion_point(class_scope:mesos.Label)
 private:
  void set_has_key();
  void clear_has_key();
  void set_has_value();
  void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsLabelImpl();
};
// -------------------------------------------------------------------

class Port : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.Port) */ {
 public:
  Port();
  virtual ~Port();

  Port(const Port& from);

  inline Port& operator=(const Port& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Port(Port&& from) noexcept
    : Port() {
    *this = ::std::move(from);
  }

  inline Port& operator=(Port&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Port& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Port* internal_default_instance() {
    return reinterpret_cast<const Port*>(
               &_Port_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    143;

  void UnsafeArenaSwap(Port* other);
  void Swap(Port* other);
  friend void swap(Port& a, Port& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Port* New() const PROTOBUF_FINAL { return New(NULL); }

  Port* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Port& from);
  void MergeFrom(const Port& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Port* other);
  protected:
  explicit Port(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 2;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_name();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      ::std::string* name);

  // optional string protocol = 3;
  bool has_protocol() const;
  void clear_protocol();
  static const int kProtocolFieldNumber = 3;
  const ::std::string& protocol() const;
  void set_protocol(const ::std::string& value);
  #if LANG_CXX11
  void set_protocol(::std::string&& value);
  #endif
  void set_protocol(const char* value);
  void set_protocol(const char* value, size_t size);
  ::std::string* mutable_protocol();
  ::std::string* release_protocol();
  void set_allocated_protocol(::std::string* protocol);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_protocol();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_protocol(
      ::std::string* protocol);

  // optional .mesos.Labels labels = 5;
  bool has_labels() const;
  void clear_labels();
  static const int kLabelsFieldNumber = 5;
  private:
  void _slow_mutable_labels();
  public:
  const ::mesos::Labels& labels() const;
  ::mesos::Labels* release_labels();
  ::mesos::Labels* mutable_labels();
  void set_allocated_labels(::mesos::Labels* labels);
  void unsafe_arena_set_allocated_labels(
      ::mesos::Labels* labels);
  ::mesos::Labels* unsafe_arena_release_labels();

  // required uint32 number = 1;
  bool has_number() const;
  void clear_number();
  static const int kNumberFieldNumber = 1;
  ::google::protobuf::uint32 number() const;
  void set_number(::google::protobuf::uint32 value);

  // optional .mesos.DiscoveryInfo.Visibility visibility = 4;
  bool has_visibility() const;
  void clear_visibility();
  static const int kVisibilityFieldNumber = 4;
  ::mesos::DiscoveryInfo_Visibility visibility() const;
  void set_visibility(::mesos::DiscoveryInfo_Visibility value);

  // @@protoc_insertion_point(class_scope:mesos.Port)
 private:
  void set_has_number();
  void clear_has_number();
  void set_has_name();
  void clear_has_name();
  void set_has_protocol();
  void clear_has_protocol();
  void set_has_visibility();
  void clear_has_visibility();
  void set_has_labels();
  void clear_has_labels();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr protocol_;
  ::mesos::Labels* labels_;
  ::google::protobuf::uint32 number_;
  int visibility_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsPortImpl();
};
// -------------------------------------------------------------------

class Ports : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.Ports) */ {
 public:
  Ports();
  virtual ~Ports();

  Ports(const Ports& from);

  inline Ports& operator=(const Ports& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Ports(Ports&& from) noexcept
    : Ports() {
    *this = ::std::move(from);
  }

  inline Ports& operator=(Ports&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Ports& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Ports* internal_default_instance() {
    return reinterpret_cast<const Ports*>(
               &_Ports_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    144;

  void UnsafeArenaSwap(Ports* other);
  void Swap(Ports* other);
  friend void swap(Ports& a, Ports& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Ports* New() const PROTOBUF_FINAL { return New(NULL); }

  Ports* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Ports& from);
  void MergeFrom(const Ports& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Ports* other);
  protected:
  explicit Ports(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.Port ports = 1;
  int ports_size() const;
  void clear_ports();
  static const int kPortsFieldNumber = 1;
  const ::mesos::Port& ports(int index) const;
  ::mesos::Port* mutable_ports(int index);
  ::mesos::Port* add_ports();
  ::google::protobuf::RepeatedPtrField< ::mesos::Port >*
      mutable_ports();
  const ::google::protobuf::RepeatedPtrField< ::mesos::Port >&
      ports() const;

  // @@protoc_insertion_point(class_scope:mesos.Ports)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Port > ports_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsPortsImpl();
};
// -------------------------------------------------------------------

class DiscoveryInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.DiscoveryInfo) */ {
 public:
  DiscoveryInfo();
  virtual ~DiscoveryInfo();

  DiscoveryInfo(const DiscoveryInfo& from);

  inline DiscoveryInfo& operator=(const DiscoveryInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DiscoveryInfo(DiscoveryInfo&& from) noexcept
    : DiscoveryInfo() {
    *this = ::std::move(from);
  }

  inline DiscoveryInfo& operator=(DiscoveryInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const DiscoveryInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DiscoveryInfo* internal_default_instance() {
    return reinterpret_cast<const DiscoveryInfo*>(
               &_DiscoveryInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    145;

  void UnsafeArenaSwap(DiscoveryInfo* other);
  void Swap(DiscoveryInfo* other);
  friend void swap(DiscoveryInfo& a, DiscoveryInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DiscoveryInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  DiscoveryInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DiscoveryInfo& from);
  void MergeFrom(const DiscoveryInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DiscoveryInfo* other);
  protected:
  explicit DiscoveryInfo(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef DiscoveryInfo_Visibility Visibility;
  static const Visibility FRAMEWORK =
    DiscoveryInfo_Visibility_FRAMEWORK;
  static const Visibility CLUSTER =
    DiscoveryInfo_Visibility_CLUSTER;
  static const Visibility EXTERNAL =
    DiscoveryInfo_Visibility_EXTERNAL;
  static inline bool Visibility_IsValid(int value) {
    return DiscoveryInfo_Visibility_IsValid(value);
  }
  static const Visibility Visibility_MIN =
    DiscoveryInfo_Visibility_Visibility_MIN;
  static const Visibility Visibility_MAX =
    DiscoveryInfo_Visibility_Visibility_MAX;
  static const int Visibility_ARRAYSIZE =
    DiscoveryInfo_Visibility_Visibility_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Visibility_descriptor() {
    return DiscoveryInfo_Visibility_descriptor();
  }
  static inline const ::std::string& Visibility_Name(Visibility value) {
    return DiscoveryInfo_Visibility_Name(value);
  }
  static inline bool Visibility_Parse(const ::std::string& name,
      Visibility* value) {
    return DiscoveryInfo_Visibility_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string name = 2;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_name();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      ::std::string* name);

  // optional string environment = 3;
  bool has_environment() const;
  void clear_environment();
  static const int kEnvironmentFieldNumber = 3;
  const ::std::string& environment() const;
  void set_environment(const ::std::string& value);
  #if LANG_CXX11
  void set_environment(::std::string&& value);
  #endif
  void set_environment(const char* value);
  void set_environment(const char* value, size_t size);
  ::std::string* mutable_environment();
  ::std::string* release_environment();
  void set_allocated_environment(::std::string* environment);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_environment();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_environment(
      ::std::string* environment);

  // optional string location = 4;
  bool has_location() const;
  void clear_location();
  static const int kLocationFieldNumber = 4;
  const ::std::string& location() const;
  void set_location(const ::std::string& value);
  #if LANG_CXX11
  void set_location(::std::string&& value);
  #endif
  void set_location(const char* value);
  void set_location(const char* value, size_t size);
  ::std::string* mutable_location();
  ::std::string* release_location();
  void set_allocated_location(::std::string* location);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_location();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_location(
      ::std::string* location);

  // optional string version = 5;
  bool has_version() const;
  void clear_version();
  static const int kVersionFieldNumber = 5;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_version();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_version(
      ::std::string* version);

  // optional .mesos.Ports ports = 6;
  bool has_ports() const;
  void clear_ports();
  static const int kPortsFieldNumber = 6;
  private:
  void _slow_mutable_ports();
  public:
  const ::mesos::Ports& ports() const;
  ::mesos::Ports* release_ports();
  ::mesos::Ports* mutable_ports();
  void set_allocated_ports(::mesos::Ports* ports);
  void unsafe_arena_set_allocated_ports(
      ::mesos::Ports* ports);
  ::mesos::Ports* unsafe_arena_release_ports();

  // optional .mesos.Labels labels = 7;
  bool has_labels() const;
  void clear_labels();
  static const int kLabelsFieldNumber = 7;
  private:
  void _slow_mutable_labels();
  public:
  const ::mesos::Labels& labels() const;
  ::mesos::Labels* release_labels();
  ::mesos::Labels* mutable_labels();
  void set_allocated_labels(::mesos::Labels* labels);
  void unsafe_arena_set_allocated_labels(
      ::mesos::Labels* labels);
  ::mesos::Labels* unsafe_arena_release_labels();

  // required .mesos.DiscoveryInfo.Visibility visibility = 1;
  bool has_visibility() const;
  void clear_visibility();
  static const int kVisibilityFieldNumber = 1;
  ::mesos::DiscoveryInfo_Visibility visibility() const;
  void set_visibility(::mesos::DiscoveryInfo_Visibility value);

  // @@protoc_insertion_point(class_scope:mesos.DiscoveryInfo)
 private:
  void set_has_visibility();
  void clear_has_visibility();
  void set_has_name();
  void clear_has_name();
  void set_has_environment();
  void clear_has_environment();
  void set_has_location();
  void clear_has_location();
  void set_has_version();
  void clear_has_version();
  void set_has_ports();
  void clear_has_ports();
  void set_has_labels();
  void clear_has_labels();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr environment_;
  ::google::protobuf::internal::ArenaStringPtr location_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  ::mesos::Ports* ports_;
  ::mesos::Labels* labels_;
  int visibility_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsDiscoveryInfoImpl();
};
// -------------------------------------------------------------------

class WeightInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.WeightInfo) */ {
 public:
  WeightInfo();
  virtual ~WeightInfo();

  WeightInfo(const WeightInfo& from);

  inline WeightInfo& operator=(const WeightInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WeightInfo(WeightInfo&& from) noexcept
    : WeightInfo() {
    *this = ::std::move(from);
  }

  inline WeightInfo& operator=(WeightInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const WeightInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WeightInfo* internal_default_instance() {
    return reinterpret_cast<const WeightInfo*>(
               &_WeightInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    146;

  void UnsafeArenaSwap(WeightInfo* other);
  void Swap(WeightInfo* other);
  friend void swap(WeightInfo& a, WeightInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WeightInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  WeightInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const WeightInfo& from);
  void MergeFrom(const WeightInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(WeightInfo* other);
  protected:
  explicit WeightInfo(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string role = 2;
  bool has_role() const;
  void clear_role();
  static const int kRoleFieldNumber = 2;
  const ::std::string& role() const;
  void set_role(const ::std::string& value);
  #if LANG_CXX11
  void set_role(::std::string&& value);
  #endif
  void set_role(const char* value);
  void set_role(const char* value, size_t size);
  ::std::string* mutable_role();
  ::std::string* release_role();
  void set_allocated_role(::std::string* role);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_role();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_role(
      ::std::string* role);

  // required double weight = 1;
  bool has_weight() const;
  void clear_weight();
  static const int kWeightFieldNumber = 1;
  double weight() const;
  void set_weight(double value);

  // @@protoc_insertion_point(class_scope:mesos.WeightInfo)
 private:
  void set_has_weight();
  void clear_has_weight();
  void set_has_role();
  void clear_has_role();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr role_;
  double weight_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsWeightInfoImpl();
};
// -------------------------------------------------------------------

class VersionInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.VersionInfo) */ {
 public:
  VersionInfo();
  virtual ~VersionInfo();

  VersionInfo(const VersionInfo& from);

  inline VersionInfo& operator=(const VersionInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  VersionInfo(VersionInfo&& from) noexcept
    : VersionInfo() {
    *this = ::std::move(from);
  }

  inline VersionInfo& operator=(VersionInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const VersionInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VersionInfo* internal_default_instance() {
    return reinterpret_cast<const VersionInfo*>(
               &_VersionInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    147;

  void UnsafeArenaSwap(VersionInfo* other);
  void Swap(VersionInfo* other);
  friend void swap(VersionInfo& a, VersionInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VersionInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  VersionInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const VersionInfo& from);
  void MergeFrom(const VersionInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(VersionInfo* other);
  protected:
  explicit VersionInfo(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string version = 1;
  bool has_version() const;
  void clear_version();
  static const int kVersionFieldNumber = 1;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_version();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_version(
      ::std::string* version);

  // optional string build_date = 2;
  bool has_build_date() const;
  void clear_build_date();
  static const int kBuildDateFieldNumber = 2;
  const ::std::string& build_date() const;
  void set_build_date(const ::std::string& value);
  #if LANG_CXX11
  void set_build_date(::std::string&& value);
  #endif
  void set_build_date(const char* value);
  void set_build_date(const char* value, size_t size);
  ::std::string* mutable_build_date();
  ::std::string* release_build_date();
  void set_allocated_build_date(::std::string* build_date);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_build_date();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_build_date(
      ::std::string* build_date);

  // optional string build_user = 4;
  bool has_build_user() const;
  void clear_build_user();
  static const int kBuildUserFieldNumber = 4;
  const ::std::string& build_user() const;
  void set_build_user(const ::std::string& value);
  #if LANG_CXX11
  void set_build_user(::std::string&& value);
  #endif
  void set_build_user(const char* value);
  void set_build_user(const char* value, size_t size);
  ::std::string* mutable_build_user();
  ::std::string* release_build_user();
  void set_allocated_build_user(::std::string* build_user);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_build_user();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_build_user(
      ::std::string* build_user);

  // optional string git_sha = 5;
  bool has_git_sha() const;
  void clear_git_sha();
  static const int kGitShaFieldNumber = 5;
  const ::std::string& git_sha() const;
  void set_git_sha(const ::std::string& value);
  #if LANG_CXX11
  void set_git_sha(::std::string&& value);
  #endif
  void set_git_sha(const char* value);
  void set_git_sha(const char* value, size_t size);
  ::std::string* mutable_git_sha();
  ::std::string* release_git_sha();
  void set_allocated_git_sha(::std::string* git_sha);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_git_sha();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_git_sha(
      ::std::string* git_sha);

  // optional string git_branch = 6;
  bool has_git_branch() const;
  void clear_git_branch();
  static const int kGitBranchFieldNumber = 6;
  const ::std::string& git_branch() const;
  void set_git_branch(const ::std::string& value);
  #if LANG_CXX11
  void set_git_branch(::std::string&& value);
  #endif
  void set_git_branch(const char* value);
  void set_git_branch(const char* value, size_t size);
  ::std::string* mutable_git_branch();
  ::std::string* release_git_branch();
  void set_allocated_git_branch(::std::string* git_branch);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_git_branch();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_git_branch(
      ::std::string* git_branch);

  // optional string git_tag = 7;
  bool has_git_tag() const;
  void clear_git_tag();
  static const int kGitTagFieldNumber = 7;
  const ::std::string& git_tag() const;
  void set_git_tag(const ::std::string& value);
  #if LANG_CXX11
  void set_git_tag(::std::string&& value);
  #endif
  void set_git_tag(const char* value);
  void set_git_tag(const char* value, size_t size);
  ::std::string* mutable_git_tag();
  ::std::string* release_git_tag();
  void set_allocated_git_tag(::std::string* git_tag);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_git_tag();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_git_tag(
      ::std::string* git_tag);

  // optional double build_time = 3;
  bool has_build_time() const;
  void clear_build_time();
  static const int kBuildTimeFieldNumber = 3;
  double build_time() const;
  void set_build_time(double value);

  // @@protoc_insertion_point(class_scope:mesos.VersionInfo)
 private:
  void set_has_version();
  void clear_has_version();
  void set_has_build_date();
  void clear_has_build_date();
  void set_has_build_time();
  void clear_has_build_time();
  void set_has_build_user();
  void clear_has_build_user();
  void set_has_git_sha();
  void clear_has_git_sha();
  void set_has_git_branch();
  void clear_has_git_branch();
  void set_has_git_tag();
  void clear_has_git_tag();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  ::google::protobuf::internal::ArenaStringPtr build_date_;
  ::google::protobuf::internal::ArenaStringPtr build_user_;
  ::google::protobuf::internal::ArenaStringPtr git_sha_;
  ::google::protobuf::internal::ArenaStringPtr git_branch_;
  ::google::protobuf::internal::ArenaStringPtr git_tag_;
  double build_time_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsVersionInfoImpl();
};
// -------------------------------------------------------------------

class Flag : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.Flag) */ {
 public:
  Flag();
  virtual ~Flag();

  Flag(const Flag& from);

  inline Flag& operator=(const Flag& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Flag(Flag&& from) noexcept
    : Flag() {
    *this = ::std::move(from);
  }

  inline Flag& operator=(Flag&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Flag& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Flag* internal_default_instance() {
    return reinterpret_cast<const Flag*>(
               &_Flag_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    148;

  void UnsafeArenaSwap(Flag* other);
  void Swap(Flag* other);
  friend void swap(Flag& a, Flag& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Flag* New() const PROTOBUF_FINAL { return New(NULL); }

  Flag* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Flag& from);
  void MergeFrom(const Flag& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Flag* other);
  protected:
  explicit Flag(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_name();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      ::std::string* name);

  // optional string value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_value();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_value(
      ::std::string* value);

  // @@protoc_insertion_point(class_scope:mesos.Flag)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_value();
  void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsFlagImpl();
};
// -------------------------------------------------------------------

class Role : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.Role) */ {
 public:
  Role();
  virtual ~Role();

  Role(const Role& from);

  inline Role& operator=(const Role& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Role(Role&& from) noexcept
    : Role() {
    *this = ::std::move(from);
  }

  inline Role& operator=(Role&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Role& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Role* internal_default_instance() {
    return reinterpret_cast<const Role*>(
               &_Role_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    149;

  void UnsafeArenaSwap(Role* other);
  void Swap(Role* other);
  friend void swap(Role& a, Role& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Role* New() const PROTOBUF_FINAL { return New(NULL); }

  Role* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Role& from);
  void MergeFrom(const Role& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Role* other);
  protected:
  explicit Role(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.FrameworkID frameworks = 3;
  int frameworks_size() const;
  void clear_frameworks();
  static const int kFrameworksFieldNumber = 3;
  const ::mesos::FrameworkID& frameworks(int index) const;
  ::mesos::FrameworkID* mutable_frameworks(int index);
  ::mesos::FrameworkID* add_frameworks();
  ::google::protobuf::RepeatedPtrField< ::mesos::FrameworkID >*
      mutable_frameworks();
  const ::google::protobuf::RepeatedPtrField< ::mesos::FrameworkID >&
      frameworks() const;

  // repeated .mesos.Resource resources = 4;
  int resources_size() const;
  void clear_resources();
  static const int kResourcesFieldNumber = 4;
  const ::mesos::Resource& resources(int index) const;
  ::mesos::Resource* mutable_resources(int index);
  ::mesos::Resource* add_resources();
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
      mutable_resources();
  const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
      resources() const;

  // required string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_name();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      ::std::string* name);

  // required double weight = 2;
  bool has_weight() const;
  void clear_weight();
  static const int kWeightFieldNumber = 2;
  double weight() const;
  void set_weight(double value);

  // @@protoc_insertion_point(class_scope:mesos.Role)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_weight();
  void clear_has_weight();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::FrameworkID > frameworks_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource > resources_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  double weight_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsRoleImpl();
};
// -------------------------------------------------------------------

class Metric : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.Metric) */ {
 public:
  Metric();
  virtual ~Metric();

  Metric(const Metric& from);

  inline Metric& operator=(const Metric& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Metric(Metric&& from) noexcept
    : Metric() {
    *this = ::std::move(from);
  }

  inline Metric& operator=(Metric&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Metric& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Metric* internal_default_instance() {
    return reinterpret_cast<const Metric*>(
               &_Metric_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    150;

  void UnsafeArenaSwap(Metric* other);
  void Swap(Metric* other);
  friend void swap(Metric& a, Metric& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Metric* New() const PROTOBUF_FINAL { return New(NULL); }

  Metric* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Metric& from);
  void MergeFrom(const Metric& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Metric* other);
  protected:
  explicit Metric(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_name();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      ::std::string* name);

  // optional double value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  double value() const;
  void set_value(double value);

  // @@protoc_insertion_point(class_scope:mesos.Metric)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_value();
  void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  double value_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsMetricImpl();
};
// -------------------------------------------------------------------

class FileInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.FileInfo) */ {
 public:
  FileInfo();
  virtual ~FileInfo();

  FileInfo(const FileInfo& from);

  inline FileInfo& operator=(const FileInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FileInfo(FileInfo&& from) noexcept
    : FileInfo() {
    *this = ::std::move(from);
  }

  inline FileInfo& operator=(FileInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const FileInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FileInfo* internal_default_instance() {
    return reinterpret_cast<const FileInfo*>(
               &_FileInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    151;

  void UnsafeArenaSwap(FileInfo* other);
  void Swap(FileInfo* other);
  friend void swap(FileInfo& a, FileInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FileInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  FileInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const FileInfo& from);
  void MergeFrom(const FileInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(FileInfo* other);
  protected:
  explicit FileInfo(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string path = 1;
  bool has_path() const;
  void clear_path();
  static const int kPathFieldNumber = 1;
  const ::std::string& path() const;
  void set_path(const ::std::string& value);
  #if LANG_CXX11
  void set_path(::std::string&& value);
  #endif
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  ::std::string* mutable_path();
  ::std::string* release_path();
  void set_allocated_path(::std::string* path);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_path();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_path(
      ::std::string* path);

  // optional string uid = 6;
  bool has_uid() const;
  void clear_uid();
  static const int kUidFieldNumber = 6;
  const ::std::string& uid() const;
  void set_uid(const ::std::string& value);
  #if LANG_CXX11
  void set_uid(::std::string&& value);
  #endif
  void set_uid(const char* value);
  void set_uid(const char* value, size_t size);
  ::std::string* mutable_uid();
  ::std::string* release_uid();
  void set_allocated_uid(::std::string* uid);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_uid();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_uid(
      ::std::string* uid);

  // optional string gid = 7;
  bool has_gid() const;
  void clear_gid();
  static const int kGidFieldNumber = 7;
  const ::std::string& gid() const;
  void set_gid(const ::std::string& value);
  #if LANG_CXX11
  void set_gid(::std::string&& value);
  #endif
  void set_gid(const char* value);
  void set_gid(const char* value, size_t size);
  ::std::string* mutable_gid();
  ::std::string* release_gid();
  void set_allocated_gid(::std::string* gid);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_gid();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_gid(
      ::std::string* gid);

  // optional .mesos.TimeInfo mtime = 4;
  bool has_mtime() const;
  void clear_mtime();
  static const int kMtimeFieldNumber = 4;
  private:
  void _slow_mutable_mtime();
  public:
  const ::mesos::TimeInfo& mtime() const;
  ::mesos::TimeInfo* release_mtime();
  ::mesos::TimeInfo* mutable_mtime();
  void set_allocated_mtime(::mesos::TimeInfo* mtime);
  void unsafe_arena_set_allocated_mtime(
      ::mesos::TimeInfo* mtime);
  ::mesos::TimeInfo* unsafe_arena_release_mtime();

  // optional uint64 size = 3;
  bool has_size() const;
  void clear_size();
  static const int kSizeFieldNumber = 3;
  ::google::protobuf::uint64 size() const;
  void set_size(::google::protobuf::uint64 value);

  // optional int32 nlink = 2;
  bool has_nlink() const;
  void clear_nlink();
  static const int kNlinkFieldNumber = 2;
  ::google::protobuf::int32 nlink() const;
  void set_nlink(::google::protobuf::int32 value);

  // optional uint32 mode = 5;
  bool has_mode() const;
  void clear_mode();
  static const int kModeFieldNumber = 5;
  ::google::protobuf::uint32 mode() const;
  void set_mode(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mesos.FileInfo)
 private:
  void set_has_path();
  void clear_has_path();
  void set_has_nlink();
  void clear_has_nlink();
  void set_has_size();
  void clear_has_size();
  void set_has_mtime();
  void clear_has_mtime();
  void set_has_mode();
  void clear_has_mode();
  void set_has_uid();
  void clear_has_uid();
  void set_has_gid();
  void clear_has_gid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr path_;
  ::google::protobuf::internal::ArenaStringPtr uid_;
  ::google::protobuf::internal::ArenaStringPtr gid_;
  ::mesos::TimeInfo* mtime_;
  ::google::protobuf::uint64 size_;
  ::google::protobuf::int32 nlink_;
  ::google::protobuf::uint32 mode_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsFileInfoImpl();
};
// -------------------------------------------------------------------

class Device_Number : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.Device.Number) */ {
 public:
  Device_Number();
  virtual ~Device_Number();

  Device_Number(const Device_Number& from);

  inline Device_Number& operator=(const Device_Number& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Device_Number(Device_Number&& from) noexcept
    : Device_Number() {
    *this = ::std::move(from);
  }

  inline Device_Number& operator=(Device_Number&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Device_Number& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Device_Number* internal_default_instance() {
    return reinterpret_cast<const Device_Number*>(
               &_Device_Number_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    152;

  void UnsafeArenaSwap(Device_Number* other);
  void Swap(Device_Number* other);
  friend void swap(Device_Number& a, Device_Number& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Device_Number* New() const PROTOBUF_FINAL { return New(NULL); }

  Device_Number* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Device_Number& from);
  void MergeFrom(const Device_Number& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Device_Number* other);
  protected:
  explicit Device_Number(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 major_number = 1;
  bool has_major_number() const;
  void clear_major_number();
  static const int kMajorNumberFieldNumber = 1;
  ::google::protobuf::uint64 major_number() const;
  void set_major_number(::google::protobuf::uint64 value);

  // required uint64 minor_number = 2;
  bool has_minor_number() const;
  void clear_minor_number();
  static const int kMinorNumberFieldNumber = 2;
  ::google::protobuf::uint64 minor_number() const;
  void set_minor_number(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:mesos.Device.Number)
 private:
  void set_has_major_number();
  void clear_has_major_number();
  void set_has_minor_number();
  void clear_has_minor_number();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint64 major_number_;
  ::google::protobuf::uint64 minor_number_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsDevice_NumberImpl();
};
// -------------------------------------------------------------------

class Device : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.Device) */ {
 public:
  Device();
  virtual ~Device();

  Device(const Device& from);

  inline Device& operator=(const Device& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Device(Device&& from) noexcept
    : Device() {
    *this = ::std::move(from);
  }

  inline Device& operator=(Device&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Device& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Device* internal_default_instance() {
    return reinterpret_cast<const Device*>(
               &_Device_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    153;

  void UnsafeArenaSwap(Device* other);
  void Swap(Device* other);
  friend void swap(Device& a, Device& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Device* New() const PROTOBUF_FINAL { return New(NULL); }

  Device* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Device& from);
  void MergeFrom(const Device& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Device* other);
  protected:
  explicit Device(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Device_Number Number;

  // accessors -------------------------------------------------------

  // optional string path = 1;
  bool has_path() const;
  void clear_path();
  static const int kPathFieldNumber = 1;
  const ::std::string& path() const;
  void set_path(const ::std::string& value);
  #if LANG_CXX11
  void set_path(::std::string&& value);
  #endif
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  ::std::string* mutable_path();
  ::std::string* release_path();
  void set_allocated_path(::std::string* path);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_path();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_path(
      ::std::string* path);

  // optional .mesos.Device.Number number = 2;
  bool has_number() const;
  void clear_number();
  static const int kNumberFieldNumber = 2;
  private:
  void _slow_mutable_number();
  public:
  const ::mesos::Device_Number& number() const;
  ::mesos::Device_Number* release_number();
  ::mesos::Device_Number* mutable_number();
  void set_allocated_number(::mesos::Device_Number* number);
  void unsafe_arena_set_allocated_number(
      ::mesos::Device_Number* number);
  ::mesos::Device_Number* unsafe_arena_release_number();

  // @@protoc_insertion_point(class_scope:mesos.Device)
 private:
  void set_has_path();
  void clear_has_path();
  void set_has_number();
  void clear_has_number();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr path_;
  ::mesos::Device_Number* number_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsDeviceImpl();
};
// -------------------------------------------------------------------

class DeviceAccess_Access : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.DeviceAccess.Access) */ {
 public:
  DeviceAccess_Access();
  virtual ~DeviceAccess_Access();

  DeviceAccess_Access(const DeviceAccess_Access& from);

  inline DeviceAccess_Access& operator=(const DeviceAccess_Access& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DeviceAccess_Access(DeviceAccess_Access&& from) noexcept
    : DeviceAccess_Access() {
    *this = ::std::move(from);
  }

  inline DeviceAccess_Access& operator=(DeviceAccess_Access&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const DeviceAccess_Access& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeviceAccess_Access* internal_default_instance() {
    return reinterpret_cast<const DeviceAccess_Access*>(
               &_DeviceAccess_Access_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    154;

  void UnsafeArenaSwap(DeviceAccess_Access* other);
  void Swap(DeviceAccess_Access* other);
  friend void swap(DeviceAccess_Access& a, DeviceAccess_Access& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DeviceAccess_Access* New() const PROTOBUF_FINAL { return New(NULL); }

  DeviceAccess_Access* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DeviceAccess_Access& from);
  void MergeFrom(const DeviceAccess_Access& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DeviceAccess_Access* other);
  protected:
  explicit DeviceAccess_Access(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool read = 1;
  bool has_read() const;
  void clear_read();
  static const int kReadFieldNumber = 1;
  bool read() const;
  void set_read(bool value);

  // optional bool write = 2;
  bool has_write() const;
  void clear_write();
  static const int kWriteFieldNumber = 2;
  bool write() const;
  void set_write(bool value);

  // optional bool mknod = 3;
  bool has_mknod() const;
  void clear_mknod();
  static const int kMknodFieldNumber = 3;
  bool mknod() const;
  void set_mknod(bool value);

  // @@protoc_insertion_point(class_scope:mesos.DeviceAccess.Access)
 private:
  void set_has_read();
  void clear_has_read();
  void set_has_write();
  void clear_has_write();
  void set_has_mknod();
  void clear_has_mknod();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  bool read_;
  bool write_;
  bool mknod_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsDeviceAccess_AccessImpl();
};
// -------------------------------------------------------------------

class DeviceAccess : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.DeviceAccess) */ {
 public:
  DeviceAccess();
  virtual ~DeviceAccess();

  DeviceAccess(const DeviceAccess& from);

  inline DeviceAccess& operator=(const DeviceAccess& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DeviceAccess(DeviceAccess&& from) noexcept
    : DeviceAccess() {
    *this = ::std::move(from);
  }

  inline DeviceAccess& operator=(DeviceAccess&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const DeviceAccess& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeviceAccess* internal_default_instance() {
    return reinterpret_cast<const DeviceAccess*>(
               &_DeviceAccess_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    155;

  void UnsafeArenaSwap(DeviceAccess* other);
  void Swap(DeviceAccess* other);
  friend void swap(DeviceAccess& a, DeviceAccess& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DeviceAccess* New() const PROTOBUF_FINAL { return New(NULL); }

  DeviceAccess* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DeviceAccess& from);
  void MergeFrom(const DeviceAccess& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DeviceAccess* other);
  protected:
  explicit DeviceAccess(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef DeviceAccess_Access Access;

  // accessors -------------------------------------------------------

  // required .mesos.Device device = 1;
  bool has_device() const;
  void clear_device();
  static const int kDeviceFieldNumber = 1;
  private:
  void _slow_mutable_device();
  public:
  const ::mesos::Device& device() const;
  ::mesos::Device* release_device();
  ::mesos::Device* mutable_device();
  void set_allocated_device(::mesos::Device* device);
  void unsafe_arena_set_allocated_device(
      ::mesos::Device* device);
  ::mesos::Device* unsafe_arena_release_device();

  // required .mesos.DeviceAccess.Access access = 2;
  bool has_access() const;
  void clear_access();
  static const int kAccessFieldNumber = 2;
  private:
  void _slow_mutable_access();
  public:
  const ::mesos::DeviceAccess_Access& access() const;
  ::mesos::DeviceAccess_Access* release_access();
  ::mesos::DeviceAccess_Access* mutable_access();
  void set_allocated_access(::mesos::DeviceAccess_Access* access);
  void unsafe_arena_set_allocated_access(
      ::mesos::DeviceAccess_Access* access);
  ::mesos::DeviceAccess_Access* unsafe_arena_release_access();

  // @@protoc_insertion_point(class_scope:mesos.DeviceAccess)
 private:
  void set_has_device();
  void clear_has_device();
  void set_has_access();
  void clear_has_access();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::Device* device_;
  ::mesos::DeviceAccess_Access* access_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsDeviceAccessImpl();
};
// -------------------------------------------------------------------

class DeviceWhitelist : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.DeviceWhitelist) */ {
 public:
  DeviceWhitelist();
  virtual ~DeviceWhitelist();

  DeviceWhitelist(const DeviceWhitelist& from);

  inline DeviceWhitelist& operator=(const DeviceWhitelist& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DeviceWhitelist(DeviceWhitelist&& from) noexcept
    : DeviceWhitelist() {
    *this = ::std::move(from);
  }

  inline DeviceWhitelist& operator=(DeviceWhitelist&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const DeviceWhitelist& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeviceWhitelist* internal_default_instance() {
    return reinterpret_cast<const DeviceWhitelist*>(
               &_DeviceWhitelist_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    156;

  void UnsafeArenaSwap(DeviceWhitelist* other);
  void Swap(DeviceWhitelist* other);
  friend void swap(DeviceWhitelist& a, DeviceWhitelist& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DeviceWhitelist* New() const PROTOBUF_FINAL { return New(NULL); }

  DeviceWhitelist* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DeviceWhitelist& from);
  void MergeFrom(const DeviceWhitelist& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DeviceWhitelist* other);
  protected:
  explicit DeviceWhitelist(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.DeviceAccess allowed_devices = 1;
  int allowed_devices_size() const;
  void clear_allowed_devices();
  static const int kAllowedDevicesFieldNumber = 1;
  const ::mesos::DeviceAccess& allowed_devices(int index) const;
  ::mesos::DeviceAccess* mutable_allowed_devices(int index);
  ::mesos::DeviceAccess* add_allowed_devices();
  ::google::protobuf::RepeatedPtrField< ::mesos::DeviceAccess >*
      mutable_allowed_devices();
  const ::google::protobuf::RepeatedPtrField< ::mesos::DeviceAccess >&
      allowed_devices() const;

  // @@protoc_insertion_point(class_scope:mesos.DeviceWhitelist)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::DeviceAccess > allowed_devices_;
  friend struct ::protobuf_mesos_2fmesos_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fmesos_2eproto::InitDefaultsDeviceWhitelistImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// FrameworkID

// required string value = 1;
inline bool FrameworkID::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FrameworkID::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FrameworkID::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FrameworkID::clear_value() {
  value_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_value();
}
inline const ::std::string& FrameworkID::value() const {
  // @@protoc_insertion_point(field_get:mesos.FrameworkID.value)
  return value_.Get();
}
inline void FrameworkID::set_value(const ::std::string& value) {
  set_has_value();
  value_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.FrameworkID.value)
}
#if LANG_CXX11
inline void FrameworkID::set_value(::std::string&& value) {
  set_has_value();
  value_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.FrameworkID.value)
}
#endif
inline void FrameworkID::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_value();
  value_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.FrameworkID.value)
}
inline void FrameworkID::set_value(const char* value,
    size_t size) {
  set_has_value();
  value_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.FrameworkID.value)
}
inline ::std::string* FrameworkID::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:mesos.FrameworkID.value)
  return value_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* FrameworkID::release_value() {
  // @@protoc_insertion_point(field_release:mesos.FrameworkID.value)
  clear_has_value();
  return value_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void FrameworkID::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.FrameworkID.value)
}
inline ::std::string* FrameworkID::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.FrameworkID.value)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_value();
  return value_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void FrameworkID::unsafe_arena_set_allocated_value(
    ::std::string* value) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.FrameworkID.value)
}

// -------------------------------------------------------------------

// OfferID

// required string value = 1;
inline bool OfferID::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OfferID::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OfferID::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OfferID::clear_value() {
  value_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_value();
}
inline const ::std::string& OfferID::value() const {
  // @@protoc_insertion_point(field_get:mesos.OfferID.value)
  return value_.Get();
}
inline void OfferID::set_value(const ::std::string& value) {
  set_has_value();
  value_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.OfferID.value)
}
#if LANG_CXX11
inline void OfferID::set_value(::std::string&& value) {
  set_has_value();
  value_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.OfferID.value)
}
#endif
inline void OfferID::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_value();
  value_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.OfferID.value)
}
inline void OfferID::set_value(const char* value,
    size_t size) {
  set_has_value();
  value_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.OfferID.value)
}
inline ::std::string* OfferID::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:mesos.OfferID.value)
  return value_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* OfferID::release_value() {
  // @@protoc_insertion_point(field_release:mesos.OfferID.value)
  clear_has_value();
  return value_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void OfferID::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.OfferID.value)
}
inline ::std::string* OfferID::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.OfferID.value)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_value();
  return value_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void OfferID::unsafe_arena_set_allocated_value(
    ::std::string* value) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.OfferID.value)
}

// -------------------------------------------------------------------

// SlaveID

// required string value = 1;
inline bool SlaveID::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SlaveID::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SlaveID::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SlaveID::clear_value() {
  value_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_value();
}
inline const ::std::string& SlaveID::value() const {
  // @@protoc_insertion_point(field_get:mesos.SlaveID.value)
  return value_.Get();
}
inline void SlaveID::set_value(const ::std::string& value) {
  set_has_value();
  value_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.SlaveID.value)
}
#if LANG_CXX11
inline void SlaveID::set_value(::std::string&& value) {
  set_has_value();
  value_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.SlaveID.value)
}
#endif
inline void SlaveID::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_value();
  value_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.SlaveID.value)
}
inline void SlaveID::set_value(const char* value,
    size_t size) {
  set_has_value();
  value_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.SlaveID.value)
}
inline ::std::string* SlaveID::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:mesos.SlaveID.value)
  return value_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* SlaveID::release_value() {
  // @@protoc_insertion_point(field_release:mesos.SlaveID.value)
  clear_has_value();
  return value_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void SlaveID::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.SlaveID.value)
}
inline ::std::string* SlaveID::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.SlaveID.value)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_value();
  return value_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void SlaveID::unsafe_arena_set_allocated_value(
    ::std::string* value) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.SlaveID.value)
}

// -------------------------------------------------------------------

// TaskID

// required string value = 1;
inline bool TaskID::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TaskID::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TaskID::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TaskID::clear_value() {
  value_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_value();
}
inline const ::std::string& TaskID::value() const {
  // @@protoc_insertion_point(field_get:mesos.TaskID.value)
  return value_.Get();
}
inline void TaskID::set_value(const ::std::string& value) {
  set_has_value();
  value_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.TaskID.value)
}
#if LANG_CXX11
inline void TaskID::set_value(::std::string&& value) {
  set_has_value();
  value_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.TaskID.value)
}
#endif
inline void TaskID::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_value();
  value_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.TaskID.value)
}
inline void TaskID::set_value(const char* value,
    size_t size) {
  set_has_value();
  value_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.TaskID.value)
}
inline ::std::string* TaskID::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:mesos.TaskID.value)
  return value_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* TaskID::release_value() {
  // @@protoc_insertion_point(field_release:mesos.TaskID.value)
  clear_has_value();
  return value_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void TaskID::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.TaskID.value)
}
inline ::std::string* TaskID::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.TaskID.value)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_value();
  return value_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void TaskID::unsafe_arena_set_allocated_value(
    ::std::string* value) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.TaskID.value)
}

// -------------------------------------------------------------------

// ExecutorID

// required string value = 1;
inline bool ExecutorID::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExecutorID::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExecutorID::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExecutorID::clear_value() {
  value_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_value();
}
inline const ::std::string& ExecutorID::value() const {
  // @@protoc_insertion_point(field_get:mesos.ExecutorID.value)
  return value_.Get();
}
inline void ExecutorID::set_value(const ::std::string& value) {
  set_has_value();
  value_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.ExecutorID.value)
}
#if LANG_CXX11
inline void ExecutorID::set_value(::std::string&& value) {
  set_has_value();
  value_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.ExecutorID.value)
}
#endif
inline void ExecutorID::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_value();
  value_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.ExecutorID.value)
}
inline void ExecutorID::set_value(const char* value,
    size_t size) {
  set_has_value();
  value_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.ExecutorID.value)
}
inline ::std::string* ExecutorID::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:mesos.ExecutorID.value)
  return value_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* ExecutorID::release_value() {
  // @@protoc_insertion_point(field_release:mesos.ExecutorID.value)
  clear_has_value();
  return value_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void ExecutorID::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.ExecutorID.value)
}
inline ::std::string* ExecutorID::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.ExecutorID.value)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_value();
  return value_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void ExecutorID::unsafe_arena_set_allocated_value(
    ::std::string* value) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.ExecutorID.value)
}

// -------------------------------------------------------------------

// ContainerID

// required string value = 1;
inline bool ContainerID::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ContainerID::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ContainerID::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ContainerID::clear_value() {
  value_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_value();
}
inline const ::std::string& ContainerID::value() const {
  // @@protoc_insertion_point(field_get:mesos.ContainerID.value)
  return value_.Get();
}
inline void ContainerID::set_value(const ::std::string& value) {
  set_has_value();
  value_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.ContainerID.value)
}
#if LANG_CXX11
inline void ContainerID::set_value(::std::string&& value) {
  set_has_value();
  value_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.ContainerID.value)
}
#endif
inline void ContainerID::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_value();
  value_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.ContainerID.value)
}
inline void ContainerID::set_value(const char* value,
    size_t size) {
  set_has_value();
  value_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.ContainerID.value)
}
inline ::std::string* ContainerID::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:mesos.ContainerID.value)
  return value_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* ContainerID::release_value() {
  // @@protoc_insertion_point(field_release:mesos.ContainerID.value)
  clear_has_value();
  return value_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void ContainerID::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.ContainerID.value)
}
inline ::std::string* ContainerID::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.ContainerID.value)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_value();
  return value_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void ContainerID::unsafe_arena_set_allocated_value(
    ::std::string* value) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.ContainerID.value)
}

// optional .mesos.ContainerID parent = 2;
inline bool ContainerID::has_parent() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ContainerID::set_has_parent() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ContainerID::clear_has_parent() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ContainerID::clear_parent() {
  if (parent_ != NULL) parent_->Clear();
  clear_has_parent();
}
inline const ::mesos::ContainerID& ContainerID::parent() const {
  const ::mesos::ContainerID* p = parent_;
  // @@protoc_insertion_point(field_get:mesos.ContainerID.parent)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ContainerID*>(
      &::mesos::_ContainerID_default_instance_);
}
inline ::mesos::ContainerID* ContainerID::release_parent() {
  // @@protoc_insertion_point(field_release:mesos.ContainerID.parent)
  clear_has_parent();
  ::mesos::ContainerID* temp = parent_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  parent_ = NULL;
  return temp;
}
inline ::mesos::ContainerID* ContainerID::unsafe_arena_release_parent() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.ContainerID.parent)
  clear_has_parent();
  ::mesos::ContainerID* temp = parent_;
  parent_ = NULL;
  return temp;
}
inline ::mesos::ContainerID* ContainerID::mutable_parent() {
  set_has_parent();
  if (parent_ == NULL) {
    _slow_mutable_parent();
  }
  // @@protoc_insertion_point(field_mutable:mesos.ContainerID.parent)
  return parent_;
}
inline void ContainerID::set_allocated_parent(::mesos::ContainerID* parent) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete parent_;
  }
  if (parent) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(parent);
    if (message_arena != submessage_arena) {
      parent = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, parent, submessage_arena);
    }
    set_has_parent();
  } else {
    clear_has_parent();
  }
  parent_ = parent;
  // @@protoc_insertion_point(field_set_allocated:mesos.ContainerID.parent)
}

// -------------------------------------------------------------------

// ResourceProviderID

// required string value = 1;
inline bool ResourceProviderID::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResourceProviderID::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResourceProviderID::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResourceProviderID::clear_value() {
  value_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_value();
}
inline const ::std::string& ResourceProviderID::value() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceProviderID.value)
  return value_.Get();
}
inline void ResourceProviderID::set_value(const ::std::string& value) {
  set_has_value();
  value_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.ResourceProviderID.value)
}
#if LANG_CXX11
inline void ResourceProviderID::set_value(::std::string&& value) {
  set_has_value();
  value_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.ResourceProviderID.value)
}
#endif
inline void ResourceProviderID::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_value();
  value_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.ResourceProviderID.value)
}
inline void ResourceProviderID::set_value(const char* value,
    size_t size) {
  set_has_value();
  value_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.ResourceProviderID.value)
}
inline ::std::string* ResourceProviderID::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:mesos.ResourceProviderID.value)
  return value_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* ResourceProviderID::release_value() {
  // @@protoc_insertion_point(field_release:mesos.ResourceProviderID.value)
  clear_has_value();
  return value_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void ResourceProviderID::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.ResourceProviderID.value)
}
inline ::std::string* ResourceProviderID::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.ResourceProviderID.value)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_value();
  return value_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void ResourceProviderID::unsafe_arena_set_allocated_value(
    ::std::string* value) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.ResourceProviderID.value)
}

// -------------------------------------------------------------------

// OperationID

// required string value = 1;
inline bool OperationID::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OperationID::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OperationID::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OperationID::clear_value() {
  value_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_value();
}
inline const ::std::string& OperationID::value() const {
  // @@protoc_insertion_point(field_get:mesos.OperationID.value)
  return value_.Get();
}
inline void OperationID::set_value(const ::std::string& value) {
  set_has_value();
  value_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.OperationID.value)
}
#if LANG_CXX11
inline void OperationID::set_value(::std::string&& value) {
  set_has_value();
  value_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.OperationID.value)
}
#endif
inline void OperationID::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_value();
  value_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.OperationID.value)
}
inline void OperationID::set_value(const char* value,
    size_t size) {
  set_has_value();
  value_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.OperationID.value)
}
inline ::std::string* OperationID::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:mesos.OperationID.value)
  return value_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* OperationID::release_value() {
  // @@protoc_insertion_point(field_release:mesos.OperationID.value)
  clear_has_value();
  return value_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void OperationID::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.OperationID.value)
}
inline ::std::string* OperationID::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.OperationID.value)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_value();
  return value_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void OperationID::unsafe_arena_set_allocated_value(
    ::std::string* value) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.OperationID.value)
}

// -------------------------------------------------------------------

// TimeInfo

// required int64 nanoseconds = 1;
inline bool TimeInfo::has_nanoseconds() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TimeInfo::set_has_nanoseconds() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TimeInfo::clear_has_nanoseconds() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TimeInfo::clear_nanoseconds() {
  nanoseconds_ = GOOGLE_LONGLONG(0);
  clear_has_nanoseconds();
}
inline ::google::protobuf::int64 TimeInfo::nanoseconds() const {
  // @@protoc_insertion_point(field_get:mesos.TimeInfo.nanoseconds)
  return nanoseconds_;
}
inline void TimeInfo::set_nanoseconds(::google::protobuf::int64 value) {
  set_has_nanoseconds();
  nanoseconds_ = value;
  // @@protoc_insertion_point(field_set:mesos.TimeInfo.nanoseconds)
}

// -------------------------------------------------------------------

// DurationInfo

// required int64 nanoseconds = 1;
inline bool DurationInfo::has_nanoseconds() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DurationInfo::set_has_nanoseconds() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DurationInfo::clear_has_nanoseconds() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DurationInfo::clear_nanoseconds() {
  nanoseconds_ = GOOGLE_LONGLONG(0);
  clear_has_nanoseconds();
}
inline ::google::protobuf::int64 DurationInfo::nanoseconds() const {
  // @@protoc_insertion_point(field_get:mesos.DurationInfo.nanoseconds)
  return nanoseconds_;
}
inline void DurationInfo::set_nanoseconds(::google::protobuf::int64 value) {
  set_has_nanoseconds();
  nanoseconds_ = value;
  // @@protoc_insertion_point(field_set:mesos.DurationInfo.nanoseconds)
}

// -------------------------------------------------------------------

// Address

// optional string hostname = 1;
inline bool Address::has_hostname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Address::set_has_hostname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Address::clear_has_hostname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Address::clear_hostname() {
  hostname_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_hostname();
}
inline const ::std::string& Address::hostname() const {
  // @@protoc_insertion_point(field_get:mesos.Address.hostname)
  return hostname_.Get();
}
inline void Address::set_hostname(const ::std::string& value) {
  set_has_hostname();
  hostname_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.Address.hostname)
}
#if LANG_CXX11
inline void Address::set_hostname(::std::string&& value) {
  set_has_hostname();
  hostname_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.Address.hostname)
}
#endif
inline void Address::set_hostname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_hostname();
  hostname_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.Address.hostname)
}
inline void Address::set_hostname(const char* value,
    size_t size) {
  set_has_hostname();
  hostname_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.Address.hostname)
}
inline ::std::string* Address::mutable_hostname() {
  set_has_hostname();
  // @@protoc_insertion_point(field_mutable:mesos.Address.hostname)
  return hostname_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* Address::release_hostname() {
  // @@protoc_insertion_point(field_release:mesos.Address.hostname)
  clear_has_hostname();
  return hostname_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void Address::set_allocated_hostname(::std::string* hostname) {
  if (hostname != NULL) {
    set_has_hostname();
  } else {
    clear_has_hostname();
  }
  hostname_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hostname,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.Address.hostname)
}
inline ::std::string* Address::unsafe_arena_release_hostname() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Address.hostname)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_hostname();
  return hostname_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void Address::unsafe_arena_set_allocated_hostname(
    ::std::string* hostname) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (hostname != NULL) {
    set_has_hostname();
  } else {
    clear_has_hostname();
  }
  hostname_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      hostname, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.Address.hostname)
}

// optional string ip = 2;
inline bool Address::has_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Address::set_has_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Address::clear_has_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Address::clear_ip() {
  ip_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_ip();
}
inline const ::std::string& Address::ip() const {
  // @@protoc_insertion_point(field_get:mesos.Address.ip)
  return ip_.Get();
}
inline void Address::set_ip(const ::std::string& value) {
  set_has_ip();
  ip_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.Address.ip)
}
#if LANG_CXX11
inline void Address::set_ip(::std::string&& value) {
  set_has_ip();
  ip_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.Address.ip)
}
#endif
inline void Address::set_ip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_ip();
  ip_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.Address.ip)
}
inline void Address::set_ip(const char* value,
    size_t size) {
  set_has_ip();
  ip_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.Address.ip)
}
inline ::std::string* Address::mutable_ip() {
  set_has_ip();
  // @@protoc_insertion_point(field_mutable:mesos.Address.ip)
  return ip_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* Address::release_ip() {
  // @@protoc_insertion_point(field_release:mesos.Address.ip)
  clear_has_ip();
  return ip_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void Address::set_allocated_ip(::std::string* ip) {
  if (ip != NULL) {
    set_has_ip();
  } else {
    clear_has_ip();
  }
  ip_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ip,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.Address.ip)
}
inline ::std::string* Address::unsafe_arena_release_ip() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Address.ip)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_ip();
  return ip_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void Address::unsafe_arena_set_allocated_ip(
    ::std::string* ip) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (ip != NULL) {
    set_has_ip();
  } else {
    clear_has_ip();
  }
  ip_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ip, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.Address.ip)
}

// required int32 port = 3;
inline bool Address::has_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Address::set_has_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Address::clear_has_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Address::clear_port() {
  port_ = 0;
  clear_has_port();
}
inline ::google::protobuf::int32 Address::port() const {
  // @@protoc_insertion_point(field_get:mesos.Address.port)
  return port_;
}
inline void Address::set_port(::google::protobuf::int32 value) {
  set_has_port();
  port_ = value;
  // @@protoc_insertion_point(field_set:mesos.Address.port)
}

// -------------------------------------------------------------------

// URL

// required string scheme = 1;
inline bool URL::has_scheme() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void URL::set_has_scheme() {
  _has_bits_[0] |= 0x00000001u;
}
inline void URL::clear_has_scheme() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void URL::clear_scheme() {
  scheme_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_scheme();
}
inline const ::std::string& URL::scheme() const {
  // @@protoc_insertion_point(field_get:mesos.URL.scheme)
  return scheme_.Get();
}
inline void URL::set_scheme(const ::std::string& value) {
  set_has_scheme();
  scheme_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.URL.scheme)
}
#if LANG_CXX11
inline void URL::set_scheme(::std::string&& value) {
  set_has_scheme();
  scheme_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.URL.scheme)
}
#endif
inline void URL::set_scheme(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_scheme();
  scheme_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.URL.scheme)
}
inline void URL::set_scheme(const char* value,
    size_t size) {
  set_has_scheme();
  scheme_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.URL.scheme)
}
inline ::std::string* URL::mutable_scheme() {
  set_has_scheme();
  // @@protoc_insertion_point(field_mutable:mesos.URL.scheme)
  return scheme_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* URL::release_scheme() {
  // @@protoc_insertion_point(field_release:mesos.URL.scheme)
  clear_has_scheme();
  return scheme_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void URL::set_allocated_scheme(::std::string* scheme) {
  if (scheme != NULL) {
    set_has_scheme();
  } else {
    clear_has_scheme();
  }
  scheme_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), scheme,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.URL.scheme)
}
inline ::std::string* URL::unsafe_arena_release_scheme() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.URL.scheme)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_scheme();
  return scheme_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void URL::unsafe_arena_set_allocated_scheme(
    ::std::string* scheme) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (scheme != NULL) {
    set_has_scheme();
  } else {
    clear_has_scheme();
  }
  scheme_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      scheme, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.URL.scheme)
}

// required .mesos.Address address = 2;
inline bool URL::has_address() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void URL::set_has_address() {
  _has_bits_[0] |= 0x00000008u;
}
inline void URL::clear_has_address() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void URL::clear_address() {
  if (address_ != NULL) address_->Clear();
  clear_has_address();
}
inline const ::mesos::Address& URL::address() const {
  const ::mesos::Address* p = address_;
  // @@protoc_insertion_point(field_get:mesos.URL.address)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::Address*>(
      &::mesos::_Address_default_instance_);
}
inline ::mesos::Address* URL::release_address() {
  // @@protoc_insertion_point(field_release:mesos.URL.address)
  clear_has_address();
  ::mesos::Address* temp = address_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  address_ = NULL;
  return temp;
}
inline ::mesos::Address* URL::unsafe_arena_release_address() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.URL.address)
  clear_has_address();
  ::mesos::Address* temp = address_;
  address_ = NULL;
  return temp;
}
inline ::mesos::Address* URL::mutable_address() {
  set_has_address();
  if (address_ == NULL) {
    _slow_mutable_address();
  }
  // @@protoc_insertion_point(field_mutable:mesos.URL.address)
  return address_;
}
inline void URL::set_allocated_address(::mesos::Address* address) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete address_;
  }
  if (address) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(address);
    if (message_arena != submessage_arena) {
      address = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, address, submessage_arena);
    }
    set_has_address();
  } else {
    clear_has_address();
  }
  address_ = address;
  // @@protoc_insertion_point(field_set_allocated:mesos.URL.address)
}

// optional string path = 3;
inline bool URL::has_path() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void URL::set_has_path() {
  _has_bits_[0] |= 0x00000002u;
}
inline void URL::clear_has_path() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void URL::clear_path() {
  path_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_path();
}
inline const ::std::string& URL::path() const {
  // @@protoc_insertion_point(field_get:mesos.URL.path)
  return path_.Get();
}
inline void URL::set_path(const ::std::string& value) {
  set_has_path();
  path_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.URL.path)
}
#if LANG_CXX11
inline void URL::set_path(::std::string&& value) {
  set_has_path();
  path_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.URL.path)
}
#endif
inline void URL::set_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_path();
  path_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.URL.path)
}
inline void URL::set_path(const char* value,
    size_t size) {
  set_has_path();
  path_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.URL.path)
}
inline ::std::string* URL::mutable_path() {
  set_has_path();
  // @@protoc_insertion_point(field_mutable:mesos.URL.path)
  return path_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* URL::release_path() {
  // @@protoc_insertion_point(field_release:mesos.URL.path)
  clear_has_path();
  return path_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void URL::set_allocated_path(::std::string* path) {
  if (path != NULL) {
    set_has_path();
  } else {
    clear_has_path();
  }
  path_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), path,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.URL.path)
}
inline ::std::string* URL::unsafe_arena_release_path() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.URL.path)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_path();
  return path_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void URL::unsafe_arena_set_allocated_path(
    ::std::string* path) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (path != NULL) {
    set_has_path();
  } else {
    clear_has_path();
  }
  path_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      path, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.URL.path)
}

// repeated .mesos.Parameter query = 4;
inline int URL::query_size() const {
  return query_.size();
}
inline void URL::clear_query() {
  query_.Clear();
}
inline const ::mesos::Parameter& URL::query(int index) const {
  // @@protoc_insertion_point(field_get:mesos.URL.query)
  return query_.Get(index);
}
inline ::mesos::Parameter* URL::mutable_query(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.URL.query)
  return query_.Mutable(index);
}
inline ::mesos::Parameter* URL::add_query() {
  // @@protoc_insertion_point(field_add:mesos.URL.query)
  return query_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Parameter >*
URL::mutable_query() {
  // @@protoc_insertion_point(field_mutable_list:mesos.URL.query)
  return &query_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Parameter >&
URL::query() const {
  // @@protoc_insertion_point(field_list:mesos.URL.query)
  return query_;
}

// optional string fragment = 5;
inline bool URL::has_fragment() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void URL::set_has_fragment() {
  _has_bits_[0] |= 0x00000004u;
}
inline void URL::clear_has_fragment() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void URL::clear_fragment() {
  fragment_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_fragment();
}
inline const ::std::string& URL::fragment() const {
  // @@protoc_insertion_point(field_get:mesos.URL.fragment)
  return fragment_.Get();
}
inline void URL::set_fragment(const ::std::string& value) {
  set_has_fragment();
  fragment_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.URL.fragment)
}
#if LANG_CXX11
inline void URL::set_fragment(::std::string&& value) {
  set_has_fragment();
  fragment_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.URL.fragment)
}
#endif
inline void URL::set_fragment(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_fragment();
  fragment_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.URL.fragment)
}
inline void URL::set_fragment(const char* value,
    size_t size) {
  set_has_fragment();
  fragment_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.URL.fragment)
}
inline ::std::string* URL::mutable_fragment() {
  set_has_fragment();
  // @@protoc_insertion_point(field_mutable:mesos.URL.fragment)
  return fragment_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* URL::release_fragment() {
  // @@protoc_insertion_point(field_release:mesos.URL.fragment)
  clear_has_fragment();
  return fragment_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void URL::set_allocated_fragment(::std::string* fragment) {
  if (fragment != NULL) {
    set_has_fragment();
  } else {
    clear_has_fragment();
  }
  fragment_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), fragment,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.URL.fragment)
}
inline ::std::string* URL::unsafe_arena_release_fragment() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.URL.fragment)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_fragment();
  return fragment_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void URL::unsafe_arena_set_allocated_fragment(
    ::std::string* fragment) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (fragment != NULL) {
    set_has_fragment();
  } else {
    clear_has_fragment();
  }
  fragment_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      fragment, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.URL.fragment)
}

// -------------------------------------------------------------------

// Unavailability

// required .mesos.TimeInfo start = 1;
inline bool Unavailability::has_start() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Unavailability::set_has_start() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Unavailability::clear_has_start() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Unavailability::clear_start() {
  if (start_ != NULL) start_->Clear();
  clear_has_start();
}
inline const ::mesos::TimeInfo& Unavailability::start() const {
  const ::mesos::TimeInfo* p = start_;
  // @@protoc_insertion_point(field_get:mesos.Unavailability.start)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::TimeInfo*>(
      &::mesos::_TimeInfo_default_instance_);
}
inline ::mesos::TimeInfo* Unavailability::release_start() {
  // @@protoc_insertion_point(field_release:mesos.Unavailability.start)
  clear_has_start();
  ::mesos::TimeInfo* temp = start_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  start_ = NULL;
  return temp;
}
inline ::mesos::TimeInfo* Unavailability::unsafe_arena_release_start() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Unavailability.start)
  clear_has_start();
  ::mesos::TimeInfo* temp = start_;
  start_ = NULL;
  return temp;
}
inline ::mesos::TimeInfo* Unavailability::mutable_start() {
  set_has_start();
  if (start_ == NULL) {
    _slow_mutable_start();
  }
  // @@protoc_insertion_point(field_mutable:mesos.Unavailability.start)
  return start_;
}
inline void Unavailability::set_allocated_start(::mesos::TimeInfo* start) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete start_;
  }
  if (start) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(start);
    if (message_arena != submessage_arena) {
      start = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, start, submessage_arena);
    }
    set_has_start();
  } else {
    clear_has_start();
  }
  start_ = start;
  // @@protoc_insertion_point(field_set_allocated:mesos.Unavailability.start)
}

// optional .mesos.DurationInfo duration = 2;
inline bool Unavailability::has_duration() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Unavailability::set_has_duration() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Unavailability::clear_has_duration() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Unavailability::clear_duration() {
  if (duration_ != NULL) duration_->Clear();
  clear_has_duration();
}
inline const ::mesos::DurationInfo& Unavailability::duration() const {
  const ::mesos::DurationInfo* p = duration_;
  // @@protoc_insertion_point(field_get:mesos.Unavailability.duration)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::DurationInfo*>(
      &::mesos::_DurationInfo_default_instance_);
}
inline ::mesos::DurationInfo* Unavailability::release_duration() {
  // @@protoc_insertion_point(field_release:mesos.Unavailability.duration)
  clear_has_duration();
  ::mesos::DurationInfo* temp = duration_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  duration_ = NULL;
  return temp;
}
inline ::mesos::DurationInfo* Unavailability::unsafe_arena_release_duration() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Unavailability.duration)
  clear_has_duration();
  ::mesos::DurationInfo* temp = duration_;
  duration_ = NULL;
  return temp;
}
inline ::mesos::DurationInfo* Unavailability::mutable_duration() {
  set_has_duration();
  if (duration_ == NULL) {
    _slow_mutable_duration();
  }
  // @@protoc_insertion_point(field_mutable:mesos.Unavailability.duration)
  return duration_;
}
inline void Unavailability::set_allocated_duration(::mesos::DurationInfo* duration) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete duration_;
  }
  if (duration) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(duration);
    if (message_arena != submessage_arena) {
      duration = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, duration, submessage_arena);
    }
    set_has_duration();
  } else {
    clear_has_duration();
  }
  duration_ = duration;
  // @@protoc_insertion_point(field_set_allocated:mesos.Unavailability.duration)
}

// -------------------------------------------------------------------

// MachineID

// optional string hostname = 1;
inline bool MachineID::has_hostname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MachineID::set_has_hostname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MachineID::clear_has_hostname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MachineID::clear_hostname() {
  hostname_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_hostname();
}
inline const ::std::string& MachineID::hostname() const {
  // @@protoc_insertion_point(field_get:mesos.MachineID.hostname)
  return hostname_.Get();
}
inline void MachineID::set_hostname(const ::std::string& value) {
  set_has_hostname();
  hostname_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.MachineID.hostname)
}
#if LANG_CXX11
inline void MachineID::set_hostname(::std::string&& value) {
  set_has_hostname();
  hostname_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.MachineID.hostname)
}
#endif
inline void MachineID::set_hostname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_hostname();
  hostname_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.MachineID.hostname)
}
inline void MachineID::set_hostname(const char* value,
    size_t size) {
  set_has_hostname();
  hostname_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.MachineID.hostname)
}
inline ::std::string* MachineID::mutable_hostname() {
  set_has_hostname();
  // @@protoc_insertion_point(field_mutable:mesos.MachineID.hostname)
  return hostname_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* MachineID::release_hostname() {
  // @@protoc_insertion_point(field_release:mesos.MachineID.hostname)
  clear_has_hostname();
  return hostname_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void MachineID::set_allocated_hostname(::std::string* hostname) {
  if (hostname != NULL) {
    set_has_hostname();
  } else {
    clear_has_hostname();
  }
  hostname_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hostname,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.MachineID.hostname)
}
inline ::std::string* MachineID::unsafe_arena_release_hostname() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.MachineID.hostname)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_hostname();
  return hostname_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void MachineID::unsafe_arena_set_allocated_hostname(
    ::std::string* hostname) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (hostname != NULL) {
    set_has_hostname();
  } else {
    clear_has_hostname();
  }
  hostname_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      hostname, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.MachineID.hostname)
}

// optional string ip = 2;
inline bool MachineID::has_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MachineID::set_has_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MachineID::clear_has_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MachineID::clear_ip() {
  ip_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_ip();
}
inline const ::std::string& MachineID::ip() const {
  // @@protoc_insertion_point(field_get:mesos.MachineID.ip)
  return ip_.Get();
}
inline void MachineID::set_ip(const ::std::string& value) {
  set_has_ip();
  ip_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.MachineID.ip)
}
#if LANG_CXX11
inline void MachineID::set_ip(::std::string&& value) {
  set_has_ip();
  ip_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.MachineID.ip)
}
#endif
inline void MachineID::set_ip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_ip();
  ip_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.MachineID.ip)
}
inline void MachineID::set_ip(const char* value,
    size_t size) {
  set_has_ip();
  ip_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.MachineID.ip)
}
inline ::std::string* MachineID::mutable_ip() {
  set_has_ip();
  // @@protoc_insertion_point(field_mutable:mesos.MachineID.ip)
  return ip_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* MachineID::release_ip() {
  // @@protoc_insertion_point(field_release:mesos.MachineID.ip)
  clear_has_ip();
  return ip_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void MachineID::set_allocated_ip(::std::string* ip) {
  if (ip != NULL) {
    set_has_ip();
  } else {
    clear_has_ip();
  }
  ip_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ip,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.MachineID.ip)
}
inline ::std::string* MachineID::unsafe_arena_release_ip() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.MachineID.ip)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_ip();
  return ip_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void MachineID::unsafe_arena_set_allocated_ip(
    ::std::string* ip) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (ip != NULL) {
    set_has_ip();
  } else {
    clear_has_ip();
  }
  ip_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ip, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.MachineID.ip)
}

// -------------------------------------------------------------------

// MachineInfo

// required .mesos.MachineID id = 1;
inline bool MachineInfo::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MachineInfo::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MachineInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MachineInfo::clear_id() {
  if (id_ != NULL) id_->Clear();
  clear_has_id();
}
inline const ::mesos::MachineID& MachineInfo::id() const {
  const ::mesos::MachineID* p = id_;
  // @@protoc_insertion_point(field_get:mesos.MachineInfo.id)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::MachineID*>(
      &::mesos::_MachineID_default_instance_);
}
inline ::mesos::MachineID* MachineInfo::release_id() {
  // @@protoc_insertion_point(field_release:mesos.MachineInfo.id)
  clear_has_id();
  ::mesos::MachineID* temp = id_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  id_ = NULL;
  return temp;
}
inline ::mesos::MachineID* MachineInfo::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.MachineInfo.id)
  clear_has_id();
  ::mesos::MachineID* temp = id_;
  id_ = NULL;
  return temp;
}
inline ::mesos::MachineID* MachineInfo::mutable_id() {
  set_has_id();
  if (id_ == NULL) {
    _slow_mutable_id();
  }
  // @@protoc_insertion_point(field_mutable:mesos.MachineInfo.id)
  return id_;
}
inline void MachineInfo::set_allocated_id(::mesos::MachineID* id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete id_;
  }
  if (id) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(id);
    if (message_arena != submessage_arena) {
      id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    set_has_id();
  } else {
    clear_has_id();
  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:mesos.MachineInfo.id)
}

// optional .mesos.MachineInfo.Mode mode = 2;
inline bool MachineInfo::has_mode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MachineInfo::set_has_mode() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MachineInfo::clear_has_mode() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MachineInfo::clear_mode() {
  mode_ = 1;
  clear_has_mode();
}
inline ::mesos::MachineInfo_Mode MachineInfo::mode() const {
  // @@protoc_insertion_point(field_get:mesos.MachineInfo.mode)
  return static_cast< ::mesos::MachineInfo_Mode >(mode_);
}
inline void MachineInfo::set_mode(::mesos::MachineInfo_Mode value) {
  assert(::mesos::MachineInfo_Mode_IsValid(value));
  set_has_mode();
  mode_ = value;
  // @@protoc_insertion_point(field_set:mesos.MachineInfo.mode)
}

// optional .mesos.Unavailability unavailability = 3;
inline bool MachineInfo::has_unavailability() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MachineInfo::set_has_unavailability() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MachineInfo::clear_has_unavailability() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MachineInfo::clear_unavailability() {
  if (unavailability_ != NULL) unavailability_->Clear();
  clear_has_unavailability();
}
inline const ::mesos::Unavailability& MachineInfo::unavailability() const {
  const ::mesos::Unavailability* p = unavailability_;
  // @@protoc_insertion_point(field_get:mesos.MachineInfo.unavailability)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::Unavailability*>(
      &::mesos::_Unavailability_default_instance_);
}
inline ::mesos::Unavailability* MachineInfo::release_unavailability() {
  // @@protoc_insertion_point(field_release:mesos.MachineInfo.unavailability)
  clear_has_unavailability();
  ::mesos::Unavailability* temp = unavailability_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  unavailability_ = NULL;
  return temp;
}
inline ::mesos::Unavailability* MachineInfo::unsafe_arena_release_unavailability() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.MachineInfo.unavailability)
  clear_has_unavailability();
  ::mesos::Unavailability* temp = unavailability_;
  unavailability_ = NULL;
  return temp;
}
inline ::mesos::Unavailability* MachineInfo::mutable_unavailability() {
  set_has_unavailability();
  if (unavailability_ == NULL) {
    _slow_mutable_unavailability();
  }
  // @@protoc_insertion_point(field_mutable:mesos.MachineInfo.unavailability)
  return unavailability_;
}
inline void MachineInfo::set_allocated_unavailability(::mesos::Unavailability* unavailability) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete unavailability_;
  }
  if (unavailability) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(unavailability);
    if (message_arena != submessage_arena) {
      unavailability = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, unavailability, submessage_arena);
    }
    set_has_unavailability();
  } else {
    clear_has_unavailability();
  }
  unavailability_ = unavailability;
  // @@protoc_insertion_point(field_set_allocated:mesos.MachineInfo.unavailability)
}

// -------------------------------------------------------------------

// FrameworkInfo_Capability

// optional .mesos.FrameworkInfo.Capability.Type type = 1;
inline bool FrameworkInfo_Capability::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FrameworkInfo_Capability::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FrameworkInfo_Capability::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FrameworkInfo_Capability::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::mesos::FrameworkInfo_Capability_Type FrameworkInfo_Capability::type() const {
  // @@protoc_insertion_point(field_get:mesos.FrameworkInfo.Capability.type)
  return static_cast< ::mesos::FrameworkInfo_Capability_Type >(type_);
}
inline void FrameworkInfo_Capability::set_type(::mesos::FrameworkInfo_Capability_Type value) {
  assert(::mesos::FrameworkInfo_Capability_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:mesos.FrameworkInfo.Capability.type)
}

// -------------------------------------------------------------------

// FrameworkInfo

// required string user = 1;
inline bool FrameworkInfo::has_user() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FrameworkInfo::set_has_user() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FrameworkInfo::clear_has_user() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FrameworkInfo::clear_user() {
  user_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_user();
}
inline const ::std::string& FrameworkInfo::user() const {
  // @@protoc_insertion_point(field_get:mesos.FrameworkInfo.user)
  return user_.Get();
}
inline void FrameworkInfo::set_user(const ::std::string& value) {
  set_has_user();
  user_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.FrameworkInfo.user)
}
#if LANG_CXX11
inline void FrameworkInfo::set_user(::std::string&& value) {
  set_has_user();
  user_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.FrameworkInfo.user)
}
#endif
inline void FrameworkInfo::set_user(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_user();
  user_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.FrameworkInfo.user)
}
inline void FrameworkInfo::set_user(const char* value,
    size_t size) {
  set_has_user();
  user_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.FrameworkInfo.user)
}
inline ::std::string* FrameworkInfo::mutable_user() {
  set_has_user();
  // @@protoc_insertion_point(field_mutable:mesos.FrameworkInfo.user)
  return user_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* FrameworkInfo::release_user() {
  // @@protoc_insertion_point(field_release:mesos.FrameworkInfo.user)
  clear_has_user();
  return user_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void FrameworkInfo::set_allocated_user(::std::string* user) {
  if (user != NULL) {
    set_has_user();
  } else {
    clear_has_user();
  }
  user_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.FrameworkInfo.user)
}
inline ::std::string* FrameworkInfo::unsafe_arena_release_user() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.FrameworkInfo.user)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_user();
  return user_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void FrameworkInfo::unsafe_arena_set_allocated_user(
    ::std::string* user) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (user != NULL) {
    set_has_user();
  } else {
    clear_has_user();
  }
  user_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      user, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.FrameworkInfo.user)
}

// required string name = 2;
inline bool FrameworkInfo::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FrameworkInfo::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FrameworkInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FrameworkInfo::clear_name() {
  name_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_name();
}
inline const ::std::string& FrameworkInfo::name() const {
  // @@protoc_insertion_point(field_get:mesos.FrameworkInfo.name)
  return name_.Get();
}
inline void FrameworkInfo::set_name(const ::std::string& value) {
  set_has_name();
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.FrameworkInfo.name)
}
#if LANG_CXX11
inline void FrameworkInfo::set_name(::std::string&& value) {
  set_has_name();
  name_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.FrameworkInfo.name)
}
#endif
inline void FrameworkInfo::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.FrameworkInfo.name)
}
inline void FrameworkInfo::set_name(const char* value,
    size_t size) {
  set_has_name();
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.FrameworkInfo.name)
}
inline ::std::string* FrameworkInfo::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:mesos.FrameworkInfo.name)
  return name_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* FrameworkInfo::release_name() {
  // @@protoc_insertion_point(field_release:mesos.FrameworkInfo.name)
  clear_has_name();
  return name_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void FrameworkInfo::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.FrameworkInfo.name)
}
inline ::std::string* FrameworkInfo::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.FrameworkInfo.name)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_name();
  return name_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void FrameworkInfo::unsafe_arena_set_allocated_name(
    ::std::string* name) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      name, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.FrameworkInfo.name)
}

// optional .mesos.FrameworkID id = 3;
inline bool FrameworkInfo::has_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void FrameworkInfo::set_has_id() {
  _has_bits_[0] |= 0x00000040u;
}
inline void FrameworkInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void FrameworkInfo::clear_id() {
  if (id_ != NULL) id_->Clear();
  clear_has_id();
}
inline const ::mesos::FrameworkID& FrameworkInfo::id() const {
  const ::mesos::FrameworkID* p = id_;
  // @@protoc_insertion_point(field_get:mesos.FrameworkInfo.id)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::FrameworkID*>(
      &::mesos::_FrameworkID_default_instance_);
}
inline ::mesos::FrameworkID* FrameworkInfo::release_id() {
  // @@protoc_insertion_point(field_release:mesos.FrameworkInfo.id)
  clear_has_id();
  ::mesos::FrameworkID* temp = id_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  id_ = NULL;
  return temp;
}
inline ::mesos::FrameworkID* FrameworkInfo::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.FrameworkInfo.id)
  clear_has_id();
  ::mesos::FrameworkID* temp = id_;
  id_ = NULL;
  return temp;
}
inline ::mesos::FrameworkID* FrameworkInfo::mutable_id() {
  set_has_id();
  if (id_ == NULL) {
    _slow_mutable_id();
  }
  // @@protoc_insertion_point(field_mutable:mesos.FrameworkInfo.id)
  return id_;
}
inline void FrameworkInfo::set_allocated_id(::mesos::FrameworkID* id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete id_;
  }
  if (id) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(id);
    if (message_arena != submessage_arena) {
      id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    set_has_id();
  } else {
    clear_has_id();
  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:mesos.FrameworkInfo.id)
}

// optional double failover_timeout = 4 [default = 0];
inline bool FrameworkInfo::has_failover_timeout() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void FrameworkInfo::set_has_failover_timeout() {
  _has_bits_[0] |= 0x00000100u;
}
inline void FrameworkInfo::clear_has_failover_timeout() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void FrameworkInfo::clear_failover_timeout() {
  failover_timeout_ = 0;
  clear_has_failover_timeout();
}
inline double FrameworkInfo::failover_timeout() const {
  // @@protoc_insertion_point(field_get:mesos.FrameworkInfo.failover_timeout)
  return failover_timeout_;
}
inline void FrameworkInfo::set_failover_timeout(double value) {
  set_has_failover_timeout();
  failover_timeout_ = value;
  // @@protoc_insertion_point(field_set:mesos.FrameworkInfo.failover_timeout)
}

// optional bool checkpoint = 5 [default = false];
inline bool FrameworkInfo::has_checkpoint() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void FrameworkInfo::set_has_checkpoint() {
  _has_bits_[0] |= 0x00000200u;
}
inline void FrameworkInfo::clear_has_checkpoint() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void FrameworkInfo::clear_checkpoint() {
  checkpoint_ = false;
  clear_has_checkpoint();
}
inline bool FrameworkInfo::checkpoint() const {
  // @@protoc_insertion_point(field_get:mesos.FrameworkInfo.checkpoint)
  return checkpoint_;
}
inline void FrameworkInfo::set_checkpoint(bool value) {
  set_has_checkpoint();
  checkpoint_ = value;
  // @@protoc_insertion_point(field_set:mesos.FrameworkInfo.checkpoint)
}

// optional string role = 6 [default = "*", deprecated = true];
inline bool FrameworkInfo::has_role() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FrameworkInfo::set_has_role() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FrameworkInfo::clear_has_role() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FrameworkInfo::clear_role() {
  role_.ClearToDefault(&::mesos::FrameworkInfo::_default_role_.get(), GetArenaNoVirtual());
  clear_has_role();
}
inline const ::std::string& FrameworkInfo::role() const {
  // @@protoc_insertion_point(field_get:mesos.FrameworkInfo.role)
  return role_.Get();
}
inline void FrameworkInfo::set_role(const ::std::string& value) {
  set_has_role();
  role_.Set(&::mesos::FrameworkInfo::_default_role_.get(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.FrameworkInfo.role)
}
#if LANG_CXX11
inline void FrameworkInfo::set_role(::std::string&& value) {
  set_has_role();
  role_.Set(
    &::mesos::FrameworkInfo::_default_role_.get(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.FrameworkInfo.role)
}
#endif
inline void FrameworkInfo::set_role(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_role();
  role_.Set(&::mesos::FrameworkInfo::_default_role_.get(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.FrameworkInfo.role)
}
inline void FrameworkInfo::set_role(const char* value,
    size_t size) {
  set_has_role();
  role_.Set(&::mesos::FrameworkInfo::_default_role_.get(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.FrameworkInfo.role)
}
inline ::std::string* FrameworkInfo::mutable_role() {
  set_has_role();
  // @@protoc_insertion_point(field_mutable:mesos.FrameworkInfo.role)
  return role_.Mutable(&::mesos::FrameworkInfo::_default_role_.get(), GetArenaNoVirtual());
}
inline ::std::string* FrameworkInfo::release_role() {
  // @@protoc_insertion_point(field_release:mesos.FrameworkInfo.role)
  clear_has_role();
  return role_.Release(&::mesos::FrameworkInfo::_default_role_.get(), GetArenaNoVirtual());
}
inline void FrameworkInfo::set_allocated_role(::std::string* role) {
  if (role != NULL) {
    set_has_role();
  } else {
    clear_has_role();
  }
  role_.SetAllocated(&::mesos::FrameworkInfo::_default_role_.get(), role,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.FrameworkInfo.role)
}
inline ::std::string* FrameworkInfo::unsafe_arena_release_role() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.FrameworkInfo.role)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_role();
  return role_.UnsafeArenaRelease(&::mesos::FrameworkInfo::_default_role_.get(),
      GetArenaNoVirtual());
}
inline void FrameworkInfo::unsafe_arena_set_allocated_role(
    ::std::string* role) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (role != NULL) {
    set_has_role();
  } else {
    clear_has_role();
  }
  role_.UnsafeArenaSetAllocated(&::mesos::FrameworkInfo::_default_role_.get(),
      role, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.FrameworkInfo.role)
}

// repeated string roles = 12;
inline int FrameworkInfo::roles_size() const {
  return roles_.size();
}
inline void FrameworkInfo::clear_roles() {
  roles_.Clear();
}
inline const ::std::string& FrameworkInfo::roles(int index) const {
  // @@protoc_insertion_point(field_get:mesos.FrameworkInfo.roles)
  return roles_.Get(index);
}
inline ::std::string* FrameworkInfo::mutable_roles(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.FrameworkInfo.roles)
  return roles_.Mutable(index);
}
inline void FrameworkInfo::set_roles(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:mesos.FrameworkInfo.roles)
  roles_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void FrameworkInfo::set_roles(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:mesos.FrameworkInfo.roles)
  roles_.Mutable(index)->assign(std::move(value));
}
#endif
inline void FrameworkInfo::set_roles(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  roles_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.FrameworkInfo.roles)
}
inline void FrameworkInfo::set_roles(int index, const char* value, size_t size) {
  roles_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.FrameworkInfo.roles)
}
inline ::std::string* FrameworkInfo::add_roles() {
  // @@protoc_insertion_point(field_add_mutable:mesos.FrameworkInfo.roles)
  return roles_.Add();
}
inline void FrameworkInfo::add_roles(const ::std::string& value) {
  roles_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:mesos.FrameworkInfo.roles)
}
#if LANG_CXX11
inline void FrameworkInfo::add_roles(::std::string&& value) {
  roles_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:mesos.FrameworkInfo.roles)
}
#endif
inline void FrameworkInfo::add_roles(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  roles_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:mesos.FrameworkInfo.roles)
}
inline void FrameworkInfo::add_roles(const char* value, size_t size) {
  roles_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:mesos.FrameworkInfo.roles)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
FrameworkInfo::roles() const {
  // @@protoc_insertion_point(field_list:mesos.FrameworkInfo.roles)
  return roles_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
FrameworkInfo::mutable_roles() {
  // @@protoc_insertion_point(field_mutable_list:mesos.FrameworkInfo.roles)
  return &roles_;
}

// optional string hostname = 7;
inline bool FrameworkInfo::has_hostname() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FrameworkInfo::set_has_hostname() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FrameworkInfo::clear_has_hostname() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FrameworkInfo::clear_hostname() {
  hostname_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_hostname();
}
inline const ::std::string& FrameworkInfo::hostname() const {
  // @@protoc_insertion_point(field_get:mesos.FrameworkInfo.hostname)
  return hostname_.Get();
}
inline void FrameworkInfo::set_hostname(const ::std::string& value) {
  set_has_hostname();
  hostname_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.FrameworkInfo.hostname)
}
#if LANG_CXX11
inline void FrameworkInfo::set_hostname(::std::string&& value) {
  set_has_hostname();
  hostname_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.FrameworkInfo.hostname)
}
#endif
inline void FrameworkInfo::set_hostname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_hostname();
  hostname_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.FrameworkInfo.hostname)
}
inline void FrameworkInfo::set_hostname(const char* value,
    size_t size) {
  set_has_hostname();
  hostname_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.FrameworkInfo.hostname)
}
inline ::std::string* FrameworkInfo::mutable_hostname() {
  set_has_hostname();
  // @@protoc_insertion_point(field_mutable:mesos.FrameworkInfo.hostname)
  return hostname_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* FrameworkInfo::release_hostname() {
  // @@protoc_insertion_point(field_release:mesos.FrameworkInfo.hostname)
  clear_has_hostname();
  return hostname_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void FrameworkInfo::set_allocated_hostname(::std::string* hostname) {
  if (hostname != NULL) {
    set_has_hostname();
  } else {
    clear_has_hostname();
  }
  hostname_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hostname,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.FrameworkInfo.hostname)
}
inline ::std::string* FrameworkInfo::unsafe_arena_release_hostname() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.FrameworkInfo.hostname)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_hostname();
  return hostname_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void FrameworkInfo::unsafe_arena_set_allocated_hostname(
    ::std::string* hostname) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (hostname != NULL) {
    set_has_hostname();
  } else {
    clear_has_hostname();
  }
  hostname_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      hostname, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.FrameworkInfo.hostname)
}

// optional string principal = 8;
inline bool FrameworkInfo::has_principal() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FrameworkInfo::set_has_principal() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FrameworkInfo::clear_has_principal() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FrameworkInfo::clear_principal() {
  principal_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_principal();
}
inline const ::std::string& FrameworkInfo::principal() const {
  // @@protoc_insertion_point(field_get:mesos.FrameworkInfo.principal)
  return principal_.Get();
}
inline void FrameworkInfo::set_principal(const ::std::string& value) {
  set_has_principal();
  principal_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.FrameworkInfo.principal)
}
#if LANG_CXX11
inline void FrameworkInfo::set_principal(::std::string&& value) {
  set_has_principal();
  principal_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.FrameworkInfo.principal)
}
#endif
inline void FrameworkInfo::set_principal(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_principal();
  principal_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.FrameworkInfo.principal)
}
inline void FrameworkInfo::set_principal(const char* value,
    size_t size) {
  set_has_principal();
  principal_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.FrameworkInfo.principal)
}
inline ::std::string* FrameworkInfo::mutable_principal() {
  set_has_principal();
  // @@protoc_insertion_point(field_mutable:mesos.FrameworkInfo.principal)
  return principal_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* FrameworkInfo::release_principal() {
  // @@protoc_insertion_point(field_release:mesos.FrameworkInfo.principal)
  clear_has_principal();
  return principal_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void FrameworkInfo::set_allocated_principal(::std::string* principal) {
  if (principal != NULL) {
    set_has_principal();
  } else {
    clear_has_principal();
  }
  principal_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), principal,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.FrameworkInfo.principal)
}
inline ::std::string* FrameworkInfo::unsafe_arena_release_principal() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.FrameworkInfo.principal)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_principal();
  return principal_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void FrameworkInfo::unsafe_arena_set_allocated_principal(
    ::std::string* principal) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (principal != NULL) {
    set_has_principal();
  } else {
    clear_has_principal();
  }
  principal_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      principal, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.FrameworkInfo.principal)
}

// optional string webui_url = 9;
inline bool FrameworkInfo::has_webui_url() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void FrameworkInfo::set_has_webui_url() {
  _has_bits_[0] |= 0x00000020u;
}
inline void FrameworkInfo::clear_has_webui_url() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void FrameworkInfo::clear_webui_url() {
  webui_url_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_webui_url();
}
inline const ::std::string& FrameworkInfo::webui_url() const {
  // @@protoc_insertion_point(field_get:mesos.FrameworkInfo.webui_url)
  return webui_url_.Get();
}
inline void FrameworkInfo::set_webui_url(const ::std::string& value) {
  set_has_webui_url();
  webui_url_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.FrameworkInfo.webui_url)
}
#if LANG_CXX11
inline void FrameworkInfo::set_webui_url(::std::string&& value) {
  set_has_webui_url();
  webui_url_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.FrameworkInfo.webui_url)
}
#endif
inline void FrameworkInfo::set_webui_url(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_webui_url();
  webui_url_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.FrameworkInfo.webui_url)
}
inline void FrameworkInfo::set_webui_url(const char* value,
    size_t size) {
  set_has_webui_url();
  webui_url_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.FrameworkInfo.webui_url)
}
inline ::std::string* FrameworkInfo::mutable_webui_url() {
  set_has_webui_url();
  // @@protoc_insertion_point(field_mutable:mesos.FrameworkInfo.webui_url)
  return webui_url_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* FrameworkInfo::release_webui_url() {
  // @@protoc_insertion_point(field_release:mesos.FrameworkInfo.webui_url)
  clear_has_webui_url();
  return webui_url_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void FrameworkInfo::set_allocated_webui_url(::std::string* webui_url) {
  if (webui_url != NULL) {
    set_has_webui_url();
  } else {
    clear_has_webui_url();
  }
  webui_url_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), webui_url,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.FrameworkInfo.webui_url)
}
inline ::std::string* FrameworkInfo::unsafe_arena_release_webui_url() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.FrameworkInfo.webui_url)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_webui_url();
  return webui_url_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void FrameworkInfo::unsafe_arena_set_allocated_webui_url(
    ::std::string* webui_url) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (webui_url != NULL) {
    set_has_webui_url();
  } else {
    clear_has_webui_url();
  }
  webui_url_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      webui_url, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.FrameworkInfo.webui_url)
}

// repeated .mesos.FrameworkInfo.Capability capabilities = 10;
inline int FrameworkInfo::capabilities_size() const {
  return capabilities_.size();
}
inline void FrameworkInfo::clear_capabilities() {
  capabilities_.Clear();
}
inline const ::mesos::FrameworkInfo_Capability& FrameworkInfo::capabilities(int index) const {
  // @@protoc_insertion_point(field_get:mesos.FrameworkInfo.capabilities)
  return capabilities_.Get(index);
}
inline ::mesos::FrameworkInfo_Capability* FrameworkInfo::mutable_capabilities(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.FrameworkInfo.capabilities)
  return capabilities_.Mutable(index);
}
inline ::mesos::FrameworkInfo_Capability* FrameworkInfo::add_capabilities() {
  // @@protoc_insertion_point(field_add:mesos.FrameworkInfo.capabilities)
  return capabilities_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::FrameworkInfo_Capability >*
FrameworkInfo::mutable_capabilities() {
  // @@protoc_insertion_point(field_mutable_list:mesos.FrameworkInfo.capabilities)
  return &capabilities_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::FrameworkInfo_Capability >&
FrameworkInfo::capabilities() const {
  // @@protoc_insertion_point(field_list:mesos.FrameworkInfo.capabilities)
  return capabilities_;
}

// optional .mesos.Labels labels = 11;
inline bool FrameworkInfo::has_labels() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void FrameworkInfo::set_has_labels() {
  _has_bits_[0] |= 0x00000080u;
}
inline void FrameworkInfo::clear_has_labels() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void FrameworkInfo::clear_labels() {
  if (labels_ != NULL) labels_->Clear();
  clear_has_labels();
}
inline const ::mesos::Labels& FrameworkInfo::labels() const {
  const ::mesos::Labels* p = labels_;
  // @@protoc_insertion_point(field_get:mesos.FrameworkInfo.labels)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::Labels*>(
      &::mesos::_Labels_default_instance_);
}
inline ::mesos::Labels* FrameworkInfo::release_labels() {
  // @@protoc_insertion_point(field_release:mesos.FrameworkInfo.labels)
  clear_has_labels();
  ::mesos::Labels* temp = labels_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  labels_ = NULL;
  return temp;
}
inline ::mesos::Labels* FrameworkInfo::unsafe_arena_release_labels() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.FrameworkInfo.labels)
  clear_has_labels();
  ::mesos::Labels* temp = labels_;
  labels_ = NULL;
  return temp;
}
inline ::mesos::Labels* FrameworkInfo::mutable_labels() {
  set_has_labels();
  if (labels_ == NULL) {
    _slow_mutable_labels();
  }
  // @@protoc_insertion_point(field_mutable:mesos.FrameworkInfo.labels)
  return labels_;
}
inline void FrameworkInfo::set_allocated_labels(::mesos::Labels* labels) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete labels_;
  }
  if (labels) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(labels);
    if (message_arena != submessage_arena) {
      labels = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, labels, submessage_arena);
    }
    set_has_labels();
  } else {
    clear_has_labels();
  }
  labels_ = labels;
  // @@protoc_insertion_point(field_set_allocated:mesos.FrameworkInfo.labels)
}

// -------------------------------------------------------------------

// CheckInfo_Command

// required .mesos.CommandInfo command = 1;
inline bool CheckInfo_Command::has_command() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CheckInfo_Command::set_has_command() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CheckInfo_Command::clear_has_command() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CheckInfo_Command::clear_command() {
  if (command_ != NULL) command_->Clear();
  clear_has_command();
}
inline const ::mesos::CommandInfo& CheckInfo_Command::command() const {
  const ::mesos::CommandInfo* p = command_;
  // @@protoc_insertion_point(field_get:mesos.CheckInfo.Command.command)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::CommandInfo*>(
      &::mesos::_CommandInfo_default_instance_);
}
inline ::mesos::CommandInfo* CheckInfo_Command::release_command() {
  // @@protoc_insertion_point(field_release:mesos.CheckInfo.Command.command)
  clear_has_command();
  ::mesos::CommandInfo* temp = command_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  command_ = NULL;
  return temp;
}
inline ::mesos::CommandInfo* CheckInfo_Command::unsafe_arena_release_command() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.CheckInfo.Command.command)
  clear_has_command();
  ::mesos::CommandInfo* temp = command_;
  command_ = NULL;
  return temp;
}
inline ::mesos::CommandInfo* CheckInfo_Command::mutable_command() {
  set_has_command();
  if (command_ == NULL) {
    _slow_mutable_command();
  }
  // @@protoc_insertion_point(field_mutable:mesos.CheckInfo.Command.command)
  return command_;
}
inline void CheckInfo_Command::set_allocated_command(::mesos::CommandInfo* command) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete command_;
  }
  if (command) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(command);
    if (message_arena != submessage_arena) {
      command = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, command, submessage_arena);
    }
    set_has_command();
  } else {
    clear_has_command();
  }
  command_ = command;
  // @@protoc_insertion_point(field_set_allocated:mesos.CheckInfo.Command.command)
}

// -------------------------------------------------------------------

// CheckInfo_Http

// required uint32 port = 1;
inline bool CheckInfo_Http::has_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CheckInfo_Http::set_has_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CheckInfo_Http::clear_has_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CheckInfo_Http::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 CheckInfo_Http::port() const {
  // @@protoc_insertion_point(field_get:mesos.CheckInfo.Http.port)
  return port_;
}
inline void CheckInfo_Http::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
  // @@protoc_insertion_point(field_set:mesos.CheckInfo.Http.port)
}

// optional string path = 2;
inline bool CheckInfo_Http::has_path() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CheckInfo_Http::set_has_path() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CheckInfo_Http::clear_has_path() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CheckInfo_Http::clear_path() {
  path_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_path();
}
inline const ::std::string& CheckInfo_Http::path() const {
  // @@protoc_insertion_point(field_get:mesos.CheckInfo.Http.path)
  return path_.Get();
}
inline void CheckInfo_Http::set_path(const ::std::string& value) {
  set_has_path();
  path_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.CheckInfo.Http.path)
}
#if LANG_CXX11
inline void CheckInfo_Http::set_path(::std::string&& value) {
  set_has_path();
  path_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.CheckInfo.Http.path)
}
#endif
inline void CheckInfo_Http::set_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_path();
  path_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.CheckInfo.Http.path)
}
inline void CheckInfo_Http::set_path(const char* value,
    size_t size) {
  set_has_path();
  path_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.CheckInfo.Http.path)
}
inline ::std::string* CheckInfo_Http::mutable_path() {
  set_has_path();
  // @@protoc_insertion_point(field_mutable:mesos.CheckInfo.Http.path)
  return path_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* CheckInfo_Http::release_path() {
  // @@protoc_insertion_point(field_release:mesos.CheckInfo.Http.path)
  clear_has_path();
  return path_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void CheckInfo_Http::set_allocated_path(::std::string* path) {
  if (path != NULL) {
    set_has_path();
  } else {
    clear_has_path();
  }
  path_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), path,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.CheckInfo.Http.path)
}
inline ::std::string* CheckInfo_Http::unsafe_arena_release_path() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.CheckInfo.Http.path)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_path();
  return path_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void CheckInfo_Http::unsafe_arena_set_allocated_path(
    ::std::string* path) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (path != NULL) {
    set_has_path();
  } else {
    clear_has_path();
  }
  path_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      path, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.CheckInfo.Http.path)
}

// -------------------------------------------------------------------

// CheckInfo_Tcp

// required uint32 port = 1;
inline bool CheckInfo_Tcp::has_port() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CheckInfo_Tcp::set_has_port() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CheckInfo_Tcp::clear_has_port() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CheckInfo_Tcp::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 CheckInfo_Tcp::port() const {
  // @@protoc_insertion_point(field_get:mesos.CheckInfo.Tcp.port)
  return port_;
}
inline void CheckInfo_Tcp::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
  // @@protoc_insertion_point(field_set:mesos.CheckInfo.Tcp.port)
}

// -------------------------------------------------------------------

// CheckInfo

// optional .mesos.CheckInfo.Type type = 1;
inline bool CheckInfo::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CheckInfo::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CheckInfo::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CheckInfo::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::mesos::CheckInfo_Type CheckInfo::type() const {
  // @@protoc_insertion_point(field_get:mesos.CheckInfo.type)
  return static_cast< ::mesos::CheckInfo_Type >(type_);
}
inline void CheckInfo::set_type(::mesos::CheckInfo_Type value) {
  assert(::mesos::CheckInfo_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:mesos.CheckInfo.type)
}

// optional .mesos.CheckInfo.Command command = 2;
inline bool CheckInfo::has_command() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CheckInfo::set_has_command() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CheckInfo::clear_has_command() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CheckInfo::clear_command() {
  if (command_ != NULL) command_->Clear();
  clear_has_command();
}
inline const ::mesos::CheckInfo_Command& CheckInfo::command() const {
  const ::mesos::CheckInfo_Command* p = command_;
  // @@protoc_insertion_point(field_get:mesos.CheckInfo.command)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::CheckInfo_Command*>(
      &::mesos::_CheckInfo_Command_default_instance_);
}
inline ::mesos::CheckInfo_Command* CheckInfo::release_command() {
  // @@protoc_insertion_point(field_release:mesos.CheckInfo.command)
  clear_has_command();
  ::mesos::CheckInfo_Command* temp = command_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  command_ = NULL;
  return temp;
}
inline ::mesos::CheckInfo_Command* CheckInfo::unsafe_arena_release_command() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.CheckInfo.command)
  clear_has_command();
  ::mesos::CheckInfo_Command* temp = command_;
  command_ = NULL;
  return temp;
}
inline ::mesos::CheckInfo_Command* CheckInfo::mutable_command() {
  set_has_command();
  if (command_ == NULL) {
    _slow_mutable_command();
  }
  // @@protoc_insertion_point(field_mutable:mesos.CheckInfo.command)
  return command_;
}
inline void CheckInfo::set_allocated_command(::mesos::CheckInfo_Command* command) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete command_;
  }
  if (command) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(command);
    if (message_arena != submessage_arena) {
      command = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, command, submessage_arena);
    }
    set_has_command();
  } else {
    clear_has_command();
  }
  command_ = command;
  // @@protoc_insertion_point(field_set_allocated:mesos.CheckInfo.command)
}

// optional .mesos.CheckInfo.Http http = 3;
inline bool CheckInfo::has_http() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CheckInfo::set_has_http() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CheckInfo::clear_has_http() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CheckInfo::clear_http() {
  if (http_ != NULL) http_->Clear();
  clear_has_http();
}
inline const ::mesos::CheckInfo_Http& CheckInfo::http() const {
  const ::mesos::CheckInfo_Http* p = http_;
  // @@protoc_insertion_point(field_get:mesos.CheckInfo.http)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::CheckInfo_Http*>(
      &::mesos::_CheckInfo_Http_default_instance_);
}
inline ::mesos::CheckInfo_Http* CheckInfo::release_http() {
  // @@protoc_insertion_point(field_release:mesos.CheckInfo.http)
  clear_has_http();
  ::mesos::CheckInfo_Http* temp = http_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  http_ = NULL;
  return temp;
}
inline ::mesos::CheckInfo_Http* CheckInfo::unsafe_arena_release_http() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.CheckInfo.http)
  clear_has_http();
  ::mesos::CheckInfo_Http* temp = http_;
  http_ = NULL;
  return temp;
}
inline ::mesos::CheckInfo_Http* CheckInfo::mutable_http() {
  set_has_http();
  if (http_ == NULL) {
    _slow_mutable_http();
  }
  // @@protoc_insertion_point(field_mutable:mesos.CheckInfo.http)
  return http_;
}
inline void CheckInfo::set_allocated_http(::mesos::CheckInfo_Http* http) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete http_;
  }
  if (http) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(http);
    if (message_arena != submessage_arena) {
      http = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, http, submessage_arena);
    }
    set_has_http();
  } else {
    clear_has_http();
  }
  http_ = http;
  // @@protoc_insertion_point(field_set_allocated:mesos.CheckInfo.http)
}

// optional .mesos.CheckInfo.Tcp tcp = 7;
inline bool CheckInfo::has_tcp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CheckInfo::set_has_tcp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CheckInfo::clear_has_tcp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CheckInfo::clear_tcp() {
  if (tcp_ != NULL) tcp_->Clear();
  clear_has_tcp();
}
inline const ::mesos::CheckInfo_Tcp& CheckInfo::tcp() const {
  const ::mesos::CheckInfo_Tcp* p = tcp_;
  // @@protoc_insertion_point(field_get:mesos.CheckInfo.tcp)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::CheckInfo_Tcp*>(
      &::mesos::_CheckInfo_Tcp_default_instance_);
}
inline ::mesos::CheckInfo_Tcp* CheckInfo::release_tcp() {
  // @@protoc_insertion_point(field_release:mesos.CheckInfo.tcp)
  clear_has_tcp();
  ::mesos::CheckInfo_Tcp* temp = tcp_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  tcp_ = NULL;
  return temp;
}
inline ::mesos::CheckInfo_Tcp* CheckInfo::unsafe_arena_release_tcp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.CheckInfo.tcp)
  clear_has_tcp();
  ::mesos::CheckInfo_Tcp* temp = tcp_;
  tcp_ = NULL;
  return temp;
}
inline ::mesos::CheckInfo_Tcp* CheckInfo::mutable_tcp() {
  set_has_tcp();
  if (tcp_ == NULL) {
    _slow_mutable_tcp();
  }
  // @@protoc_insertion_point(field_mutable:mesos.CheckInfo.tcp)
  return tcp_;
}
inline void CheckInfo::set_allocated_tcp(::mesos::CheckInfo_Tcp* tcp) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete tcp_;
  }
  if (tcp) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(tcp);
    if (message_arena != submessage_arena) {
      tcp = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, tcp, submessage_arena);
    }
    set_has_tcp();
  } else {
    clear_has_tcp();
  }
  tcp_ = tcp;
  // @@protoc_insertion_point(field_set_allocated:mesos.CheckInfo.tcp)
}

// optional double delay_seconds = 4 [default = 15];
inline bool CheckInfo::has_delay_seconds() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CheckInfo::set_has_delay_seconds() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CheckInfo::clear_has_delay_seconds() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CheckInfo::clear_delay_seconds() {
  delay_seconds_ = 15;
  clear_has_delay_seconds();
}
inline double CheckInfo::delay_seconds() const {
  // @@protoc_insertion_point(field_get:mesos.CheckInfo.delay_seconds)
  return delay_seconds_;
}
inline void CheckInfo::set_delay_seconds(double value) {
  set_has_delay_seconds();
  delay_seconds_ = value;
  // @@protoc_insertion_point(field_set:mesos.CheckInfo.delay_seconds)
}

// optional double interval_seconds = 5 [default = 10];
inline bool CheckInfo::has_interval_seconds() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CheckInfo::set_has_interval_seconds() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CheckInfo::clear_has_interval_seconds() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CheckInfo::clear_interval_seconds() {
  interval_seconds_ = 10;
  clear_has_interval_seconds();
}
inline double CheckInfo::interval_seconds() const {
  // @@protoc_insertion_point(field_get:mesos.CheckInfo.interval_seconds)
  return interval_seconds_;
}
inline void CheckInfo::set_interval_seconds(double value) {
  set_has_interval_seconds();
  interval_seconds_ = value;
  // @@protoc_insertion_point(field_set:mesos.CheckInfo.interval_seconds)
}

// optional double timeout_seconds = 6 [default = 20];
inline bool CheckInfo::has_timeout_seconds() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CheckInfo::set_has_timeout_seconds() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CheckInfo::clear_has_timeout_seconds() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CheckInfo::clear_timeout_seconds() {
  timeout_seconds_ = 20;
  clear_has_timeout_seconds();
}
inline double CheckInfo::timeout_seconds() const {
  // @@protoc_insertion_point(field_get:mesos.CheckInfo.timeout_seconds)
  return timeout_seconds_;
}
inline void CheckInfo::set_timeout_seconds(double value) {
  set_has_timeout_seconds();
  timeout_seconds_ = value;
  // @@protoc_insertion_point(field_set:mesos.CheckInfo.timeout_seconds)
}

// -------------------------------------------------------------------

// HealthCheck_HTTPCheckInfo

// optional .mesos.NetworkInfo.Protocol protocol = 5 [default = IPv4];
inline bool HealthCheck_HTTPCheckInfo::has_protocol() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void HealthCheck_HTTPCheckInfo::set_has_protocol() {
  _has_bits_[0] |= 0x00000008u;
}
inline void HealthCheck_HTTPCheckInfo::clear_has_protocol() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void HealthCheck_HTTPCheckInfo::clear_protocol() {
  protocol_ = 1;
  clear_has_protocol();
}
inline ::mesos::NetworkInfo_Protocol HealthCheck_HTTPCheckInfo::protocol() const {
  // @@protoc_insertion_point(field_get:mesos.HealthCheck.HTTPCheckInfo.protocol)
  return static_cast< ::mesos::NetworkInfo_Protocol >(protocol_);
}
inline void HealthCheck_HTTPCheckInfo::set_protocol(::mesos::NetworkInfo_Protocol value) {
  assert(::mesos::NetworkInfo_Protocol_IsValid(value));
  set_has_protocol();
  protocol_ = value;
  // @@protoc_insertion_point(field_set:mesos.HealthCheck.HTTPCheckInfo.protocol)
}

// optional string scheme = 3;
inline bool HealthCheck_HTTPCheckInfo::has_scheme() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HealthCheck_HTTPCheckInfo::set_has_scheme() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HealthCheck_HTTPCheckInfo::clear_has_scheme() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HealthCheck_HTTPCheckInfo::clear_scheme() {
  scheme_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_scheme();
}
inline const ::std::string& HealthCheck_HTTPCheckInfo::scheme() const {
  // @@protoc_insertion_point(field_get:mesos.HealthCheck.HTTPCheckInfo.scheme)
  return scheme_.Get();
}
inline void HealthCheck_HTTPCheckInfo::set_scheme(const ::std::string& value) {
  set_has_scheme();
  scheme_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.HealthCheck.HTTPCheckInfo.scheme)
}
#if LANG_CXX11
inline void HealthCheck_HTTPCheckInfo::set_scheme(::std::string&& value) {
  set_has_scheme();
  scheme_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.HealthCheck.HTTPCheckInfo.scheme)
}
#endif
inline void HealthCheck_HTTPCheckInfo::set_scheme(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_scheme();
  scheme_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.HealthCheck.HTTPCheckInfo.scheme)
}
inline void HealthCheck_HTTPCheckInfo::set_scheme(const char* value,
    size_t size) {
  set_has_scheme();
  scheme_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.HealthCheck.HTTPCheckInfo.scheme)
}
inline ::std::string* HealthCheck_HTTPCheckInfo::mutable_scheme() {
  set_has_scheme();
  // @@protoc_insertion_point(field_mutable:mesos.HealthCheck.HTTPCheckInfo.scheme)
  return scheme_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* HealthCheck_HTTPCheckInfo::release_scheme() {
  // @@protoc_insertion_point(field_release:mesos.HealthCheck.HTTPCheckInfo.scheme)
  clear_has_scheme();
  return scheme_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void HealthCheck_HTTPCheckInfo::set_allocated_scheme(::std::string* scheme) {
  if (scheme != NULL) {
    set_has_scheme();
  } else {
    clear_has_scheme();
  }
  scheme_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), scheme,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.HealthCheck.HTTPCheckInfo.scheme)
}
inline ::std::string* HealthCheck_HTTPCheckInfo::unsafe_arena_release_scheme() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.HealthCheck.HTTPCheckInfo.scheme)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_scheme();
  return scheme_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void HealthCheck_HTTPCheckInfo::unsafe_arena_set_allocated_scheme(
    ::std::string* scheme) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (scheme != NULL) {
    set_has_scheme();
  } else {
    clear_has_scheme();
  }
  scheme_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      scheme, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.HealthCheck.HTTPCheckInfo.scheme)
}

// required uint32 port = 1;
inline bool HealthCheck_HTTPCheckInfo::has_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HealthCheck_HTTPCheckInfo::set_has_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HealthCheck_HTTPCheckInfo::clear_has_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HealthCheck_HTTPCheckInfo::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 HealthCheck_HTTPCheckInfo::port() const {
  // @@protoc_insertion_point(field_get:mesos.HealthCheck.HTTPCheckInfo.port)
  return port_;
}
inline void HealthCheck_HTTPCheckInfo::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
  // @@protoc_insertion_point(field_set:mesos.HealthCheck.HTTPCheckInfo.port)
}

// optional string path = 2;
inline bool HealthCheck_HTTPCheckInfo::has_path() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HealthCheck_HTTPCheckInfo::set_has_path() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HealthCheck_HTTPCheckInfo::clear_has_path() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HealthCheck_HTTPCheckInfo::clear_path() {
  path_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_path();
}
inline const ::std::string& HealthCheck_HTTPCheckInfo::path() const {
  // @@protoc_insertion_point(field_get:mesos.HealthCheck.HTTPCheckInfo.path)
  return path_.Get();
}
inline void HealthCheck_HTTPCheckInfo::set_path(const ::std::string& value) {
  set_has_path();
  path_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.HealthCheck.HTTPCheckInfo.path)
}
#if LANG_CXX11
inline void HealthCheck_HTTPCheckInfo::set_path(::std::string&& value) {
  set_has_path();
  path_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.HealthCheck.HTTPCheckInfo.path)
}
#endif
inline void HealthCheck_HTTPCheckInfo::set_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_path();
  path_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.HealthCheck.HTTPCheckInfo.path)
}
inline void HealthCheck_HTTPCheckInfo::set_path(const char* value,
    size_t size) {
  set_has_path();
  path_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.HealthCheck.HTTPCheckInfo.path)
}
inline ::std::string* HealthCheck_HTTPCheckInfo::mutable_path() {
  set_has_path();
  // @@protoc_insertion_point(field_mutable:mesos.HealthCheck.HTTPCheckInfo.path)
  return path_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* HealthCheck_HTTPCheckInfo::release_path() {
  // @@protoc_insertion_point(field_release:mesos.HealthCheck.HTTPCheckInfo.path)
  clear_has_path();
  return path_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void HealthCheck_HTTPCheckInfo::set_allocated_path(::std::string* path) {
  if (path != NULL) {
    set_has_path();
  } else {
    clear_has_path();
  }
  path_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), path,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.HealthCheck.HTTPCheckInfo.path)
}
inline ::std::string* HealthCheck_HTTPCheckInfo::unsafe_arena_release_path() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.HealthCheck.HTTPCheckInfo.path)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_path();
  return path_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void HealthCheck_HTTPCheckInfo::unsafe_arena_set_allocated_path(
    ::std::string* path) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (path != NULL) {
    set_has_path();
  } else {
    clear_has_path();
  }
  path_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      path, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.HealthCheck.HTTPCheckInfo.path)
}

// repeated uint32 statuses = 4;
inline int HealthCheck_HTTPCheckInfo::statuses_size() const {
  return statuses_.size();
}
inline void HealthCheck_HTTPCheckInfo::clear_statuses() {
  statuses_.Clear();
}
inline ::google::protobuf::uint32 HealthCheck_HTTPCheckInfo::statuses(int index) const {
  // @@protoc_insertion_point(field_get:mesos.HealthCheck.HTTPCheckInfo.statuses)
  return statuses_.Get(index);
}
inline void HealthCheck_HTTPCheckInfo::set_statuses(int index, ::google::protobuf::uint32 value) {
  statuses_.Set(index, value);
  // @@protoc_insertion_point(field_set:mesos.HealthCheck.HTTPCheckInfo.statuses)
}
inline void HealthCheck_HTTPCheckInfo::add_statuses(::google::protobuf::uint32 value) {
  statuses_.Add(value);
  // @@protoc_insertion_point(field_add:mesos.HealthCheck.HTTPCheckInfo.statuses)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
HealthCheck_HTTPCheckInfo::statuses() const {
  // @@protoc_insertion_point(field_list:mesos.HealthCheck.HTTPCheckInfo.statuses)
  return statuses_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
HealthCheck_HTTPCheckInfo::mutable_statuses() {
  // @@protoc_insertion_point(field_mutable_list:mesos.HealthCheck.HTTPCheckInfo.statuses)
  return &statuses_;
}

// -------------------------------------------------------------------

// HealthCheck_TCPCheckInfo

// optional .mesos.NetworkInfo.Protocol protocol = 2 [default = IPv4];
inline bool HealthCheck_TCPCheckInfo::has_protocol() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HealthCheck_TCPCheckInfo::set_has_protocol() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HealthCheck_TCPCheckInfo::clear_has_protocol() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HealthCheck_TCPCheckInfo::clear_protocol() {
  protocol_ = 1;
  clear_has_protocol();
}
inline ::mesos::NetworkInfo_Protocol HealthCheck_TCPCheckInfo::protocol() const {
  // @@protoc_insertion_point(field_get:mesos.HealthCheck.TCPCheckInfo.protocol)
  return static_cast< ::mesos::NetworkInfo_Protocol >(protocol_);
}
inline void HealthCheck_TCPCheckInfo::set_protocol(::mesos::NetworkInfo_Protocol value) {
  assert(::mesos::NetworkInfo_Protocol_IsValid(value));
  set_has_protocol();
  protocol_ = value;
  // @@protoc_insertion_point(field_set:mesos.HealthCheck.TCPCheckInfo.protocol)
}

// required uint32 port = 1;
inline bool HealthCheck_TCPCheckInfo::has_port() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HealthCheck_TCPCheckInfo::set_has_port() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HealthCheck_TCPCheckInfo::clear_has_port() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HealthCheck_TCPCheckInfo::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 HealthCheck_TCPCheckInfo::port() const {
  // @@protoc_insertion_point(field_get:mesos.HealthCheck.TCPCheckInfo.port)
  return port_;
}
inline void HealthCheck_TCPCheckInfo::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
  // @@protoc_insertion_point(field_set:mesos.HealthCheck.TCPCheckInfo.port)
}

// -------------------------------------------------------------------

// HealthCheck

// optional double delay_seconds = 2 [default = 15];
inline bool HealthCheck::has_delay_seconds() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void HealthCheck::set_has_delay_seconds() {
  _has_bits_[0] |= 0x00000020u;
}
inline void HealthCheck::clear_has_delay_seconds() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void HealthCheck::clear_delay_seconds() {
  delay_seconds_ = 15;
  clear_has_delay_seconds();
}
inline double HealthCheck::delay_seconds() const {
  // @@protoc_insertion_point(field_get:mesos.HealthCheck.delay_seconds)
  return delay_seconds_;
}
inline void HealthCheck::set_delay_seconds(double value) {
  set_has_delay_seconds();
  delay_seconds_ = value;
  // @@protoc_insertion_point(field_set:mesos.HealthCheck.delay_seconds)
}

// optional double interval_seconds = 3 [default = 10];
inline bool HealthCheck::has_interval_seconds() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void HealthCheck::set_has_interval_seconds() {
  _has_bits_[0] |= 0x00000040u;
}
inline void HealthCheck::clear_has_interval_seconds() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void HealthCheck::clear_interval_seconds() {
  interval_seconds_ = 10;
  clear_has_interval_seconds();
}
inline double HealthCheck::interval_seconds() const {
  // @@protoc_insertion_point(field_get:mesos.HealthCheck.interval_seconds)
  return interval_seconds_;
}
inline void HealthCheck::set_interval_seconds(double value) {
  set_has_interval_seconds();
  interval_seconds_ = value;
  // @@protoc_insertion_point(field_set:mesos.HealthCheck.interval_seconds)
}

// optional double timeout_seconds = 4 [default = 20];
inline bool HealthCheck::has_timeout_seconds() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void HealthCheck::set_has_timeout_seconds() {
  _has_bits_[0] |= 0x00000080u;
}
inline void HealthCheck::clear_has_timeout_seconds() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void HealthCheck::clear_timeout_seconds() {
  timeout_seconds_ = 20;
  clear_has_timeout_seconds();
}
inline double HealthCheck::timeout_seconds() const {
  // @@protoc_insertion_point(field_get:mesos.HealthCheck.timeout_seconds)
  return timeout_seconds_;
}
inline void HealthCheck::set_timeout_seconds(double value) {
  set_has_timeout_seconds();
  timeout_seconds_ = value;
  // @@protoc_insertion_point(field_set:mesos.HealthCheck.timeout_seconds)
}

// optional uint32 consecutive_failures = 5 [default = 3];
inline bool HealthCheck::has_consecutive_failures() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void HealthCheck::set_has_consecutive_failures() {
  _has_bits_[0] |= 0x00000010u;
}
inline void HealthCheck::clear_has_consecutive_failures() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void HealthCheck::clear_consecutive_failures() {
  consecutive_failures_ = 3u;
  clear_has_consecutive_failures();
}
inline ::google::protobuf::uint32 HealthCheck::consecutive_failures() const {
  // @@protoc_insertion_point(field_get:mesos.HealthCheck.consecutive_failures)
  return consecutive_failures_;
}
inline void HealthCheck::set_consecutive_failures(::google::protobuf::uint32 value) {
  set_has_consecutive_failures();
  consecutive_failures_ = value;
  // @@protoc_insertion_point(field_set:mesos.HealthCheck.consecutive_failures)
}

// optional double grace_period_seconds = 6 [default = 10];
inline bool HealthCheck::has_grace_period_seconds() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void HealthCheck::set_has_grace_period_seconds() {
  _has_bits_[0] |= 0x00000100u;
}
inline void HealthCheck::clear_has_grace_period_seconds() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void HealthCheck::clear_grace_period_seconds() {
  grace_period_seconds_ = 10;
  clear_has_grace_period_seconds();
}
inline double HealthCheck::grace_period_seconds() const {
  // @@protoc_insertion_point(field_get:mesos.HealthCheck.grace_period_seconds)
  return grace_period_seconds_;
}
inline void HealthCheck::set_grace_period_seconds(double value) {
  set_has_grace_period_seconds();
  grace_period_seconds_ = value;
  // @@protoc_insertion_point(field_set:mesos.HealthCheck.grace_period_seconds)
}

// optional .mesos.HealthCheck.Type type = 8;
inline bool HealthCheck::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void HealthCheck::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void HealthCheck::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void HealthCheck::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::mesos::HealthCheck_Type HealthCheck::type() const {
  // @@protoc_insertion_point(field_get:mesos.HealthCheck.type)
  return static_cast< ::mesos::HealthCheck_Type >(type_);
}
inline void HealthCheck::set_type(::mesos::HealthCheck_Type value) {
  assert(::mesos::HealthCheck_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:mesos.HealthCheck.type)
}

// optional .mesos.CommandInfo command = 7;
inline bool HealthCheck::has_command() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HealthCheck::set_has_command() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HealthCheck::clear_has_command() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HealthCheck::clear_command() {
  if (command_ != NULL) command_->Clear();
  clear_has_command();
}
inline const ::mesos::CommandInfo& HealthCheck::command() const {
  const ::mesos::CommandInfo* p = command_;
  // @@protoc_insertion_point(field_get:mesos.HealthCheck.command)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::CommandInfo*>(
      &::mesos::_CommandInfo_default_instance_);
}
inline ::mesos::CommandInfo* HealthCheck::release_command() {
  // @@protoc_insertion_point(field_release:mesos.HealthCheck.command)
  clear_has_command();
  ::mesos::CommandInfo* temp = command_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  command_ = NULL;
  return temp;
}
inline ::mesos::CommandInfo* HealthCheck::unsafe_arena_release_command() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.HealthCheck.command)
  clear_has_command();
  ::mesos::CommandInfo* temp = command_;
  command_ = NULL;
  return temp;
}
inline ::mesos::CommandInfo* HealthCheck::mutable_command() {
  set_has_command();
  if (command_ == NULL) {
    _slow_mutable_command();
  }
  // @@protoc_insertion_point(field_mutable:mesos.HealthCheck.command)
  return command_;
}
inline void HealthCheck::set_allocated_command(::mesos::CommandInfo* command) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete command_;
  }
  if (command) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(command);
    if (message_arena != submessage_arena) {
      command = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, command, submessage_arena);
    }
    set_has_command();
  } else {
    clear_has_command();
  }
  command_ = command;
  // @@protoc_insertion_point(field_set_allocated:mesos.HealthCheck.command)
}

// optional .mesos.HealthCheck.HTTPCheckInfo http = 1;
inline bool HealthCheck::has_http() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HealthCheck::set_has_http() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HealthCheck::clear_has_http() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HealthCheck::clear_http() {
  if (http_ != NULL) http_->Clear();
  clear_has_http();
}
inline const ::mesos::HealthCheck_HTTPCheckInfo& HealthCheck::http() const {
  const ::mesos::HealthCheck_HTTPCheckInfo* p = http_;
  // @@protoc_insertion_point(field_get:mesos.HealthCheck.http)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::HealthCheck_HTTPCheckInfo*>(
      &::mesos::_HealthCheck_HTTPCheckInfo_default_instance_);
}
inline ::mesos::HealthCheck_HTTPCheckInfo* HealthCheck::release_http() {
  // @@protoc_insertion_point(field_release:mesos.HealthCheck.http)
  clear_has_http();
  ::mesos::HealthCheck_HTTPCheckInfo* temp = http_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  http_ = NULL;
  return temp;
}
inline ::mesos::HealthCheck_HTTPCheckInfo* HealthCheck::unsafe_arena_release_http() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.HealthCheck.http)
  clear_has_http();
  ::mesos::HealthCheck_HTTPCheckInfo* temp = http_;
  http_ = NULL;
  return temp;
}
inline ::mesos::HealthCheck_HTTPCheckInfo* HealthCheck::mutable_http() {
  set_has_http();
  if (http_ == NULL) {
    _slow_mutable_http();
  }
  // @@protoc_insertion_point(field_mutable:mesos.HealthCheck.http)
  return http_;
}
inline void HealthCheck::set_allocated_http(::mesos::HealthCheck_HTTPCheckInfo* http) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete http_;
  }
  if (http) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(http);
    if (message_arena != submessage_arena) {
      http = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, http, submessage_arena);
    }
    set_has_http();
  } else {
    clear_has_http();
  }
  http_ = http;
  // @@protoc_insertion_point(field_set_allocated:mesos.HealthCheck.http)
}

// optional .mesos.HealthCheck.TCPCheckInfo tcp = 9;
inline bool HealthCheck::has_tcp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HealthCheck::set_has_tcp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HealthCheck::clear_has_tcp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HealthCheck::clear_tcp() {
  if (tcp_ != NULL) tcp_->Clear();
  clear_has_tcp();
}
inline const ::mesos::HealthCheck_TCPCheckInfo& HealthCheck::tcp() const {
  const ::mesos::HealthCheck_TCPCheckInfo* p = tcp_;
  // @@protoc_insertion_point(field_get:mesos.HealthCheck.tcp)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::HealthCheck_TCPCheckInfo*>(
      &::mesos::_HealthCheck_TCPCheckInfo_default_instance_);
}
inline ::mesos::HealthCheck_TCPCheckInfo* HealthCheck::release_tcp() {
  // @@protoc_insertion_point(field_release:mesos.HealthCheck.tcp)
  clear_has_tcp();
  ::mesos::HealthCheck_TCPCheckInfo* temp = tcp_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  tcp_ = NULL;
  return temp;
}
inline ::mesos::HealthCheck_TCPCheckInfo* HealthCheck::unsafe_arena_release_tcp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.HealthCheck.tcp)
  clear_has_tcp();
  ::mesos::HealthCheck_TCPCheckInfo* temp = tcp_;
  tcp_ = NULL;
  return temp;
}
inline ::mesos::HealthCheck_TCPCheckInfo* HealthCheck::mutable_tcp() {
  set_has_tcp();
  if (tcp_ == NULL) {
    _slow_mutable_tcp();
  }
  // @@protoc_insertion_point(field_mutable:mesos.HealthCheck.tcp)
  return tcp_;
}
inline void HealthCheck::set_allocated_tcp(::mesos::HealthCheck_TCPCheckInfo* tcp) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete tcp_;
  }
  if (tcp) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(tcp);
    if (message_arena != submessage_arena) {
      tcp = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, tcp, submessage_arena);
    }
    set_has_tcp();
  } else {
    clear_has_tcp();
  }
  tcp_ = tcp;
  // @@protoc_insertion_point(field_set_allocated:mesos.HealthCheck.tcp)
}

// -------------------------------------------------------------------

// KillPolicy

// optional .mesos.DurationInfo grace_period = 1;
inline bool KillPolicy::has_grace_period() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void KillPolicy::set_has_grace_period() {
  _has_bits_[0] |= 0x00000001u;
}
inline void KillPolicy::clear_has_grace_period() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void KillPolicy::clear_grace_period() {
  if (grace_period_ != NULL) grace_period_->Clear();
  clear_has_grace_period();
}
inline const ::mesos::DurationInfo& KillPolicy::grace_period() const {
  const ::mesos::DurationInfo* p = grace_period_;
  // @@protoc_insertion_point(field_get:mesos.KillPolicy.grace_period)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::DurationInfo*>(
      &::mesos::_DurationInfo_default_instance_);
}
inline ::mesos::DurationInfo* KillPolicy::release_grace_period() {
  // @@protoc_insertion_point(field_release:mesos.KillPolicy.grace_period)
  clear_has_grace_period();
  ::mesos::DurationInfo* temp = grace_period_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  grace_period_ = NULL;
  return temp;
}
inline ::mesos::DurationInfo* KillPolicy::unsafe_arena_release_grace_period() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.KillPolicy.grace_period)
  clear_has_grace_period();
  ::mesos::DurationInfo* temp = grace_period_;
  grace_period_ = NULL;
  return temp;
}
inline ::mesos::DurationInfo* KillPolicy::mutable_grace_period() {
  set_has_grace_period();
  if (grace_period_ == NULL) {
    _slow_mutable_grace_period();
  }
  // @@protoc_insertion_point(field_mutable:mesos.KillPolicy.grace_period)
  return grace_period_;
}
inline void KillPolicy::set_allocated_grace_period(::mesos::DurationInfo* grace_period) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete grace_period_;
  }
  if (grace_period) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(grace_period);
    if (message_arena != submessage_arena) {
      grace_period = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, grace_period, submessage_arena);
    }
    set_has_grace_period();
  } else {
    clear_has_grace_period();
  }
  grace_period_ = grace_period;
  // @@protoc_insertion_point(field_set_allocated:mesos.KillPolicy.grace_period)
}

// -------------------------------------------------------------------

// CommandInfo_URI

// required string value = 1;
inline bool CommandInfo_URI::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandInfo_URI::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandInfo_URI::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandInfo_URI::clear_value() {
  value_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_value();
}
inline const ::std::string& CommandInfo_URI::value() const {
  // @@protoc_insertion_point(field_get:mesos.CommandInfo.URI.value)
  return value_.Get();
}
inline void CommandInfo_URI::set_value(const ::std::string& value) {
  set_has_value();
  value_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.CommandInfo.URI.value)
}
#if LANG_CXX11
inline void CommandInfo_URI::set_value(::std::string&& value) {
  set_has_value();
  value_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.CommandInfo.URI.value)
}
#endif
inline void CommandInfo_URI::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_value();
  value_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.CommandInfo.URI.value)
}
inline void CommandInfo_URI::set_value(const char* value,
    size_t size) {
  set_has_value();
  value_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.CommandInfo.URI.value)
}
inline ::std::string* CommandInfo_URI::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:mesos.CommandInfo.URI.value)
  return value_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* CommandInfo_URI::release_value() {
  // @@protoc_insertion_point(field_release:mesos.CommandInfo.URI.value)
  clear_has_value();
  return value_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void CommandInfo_URI::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.CommandInfo.URI.value)
}
inline ::std::string* CommandInfo_URI::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.CommandInfo.URI.value)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_value();
  return value_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void CommandInfo_URI::unsafe_arena_set_allocated_value(
    ::std::string* value) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.CommandInfo.URI.value)
}

// optional bool executable = 2;
inline bool CommandInfo_URI::has_executable() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandInfo_URI::set_has_executable() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandInfo_URI::clear_has_executable() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandInfo_URI::clear_executable() {
  executable_ = false;
  clear_has_executable();
}
inline bool CommandInfo_URI::executable() const {
  // @@protoc_insertion_point(field_get:mesos.CommandInfo.URI.executable)
  return executable_;
}
inline void CommandInfo_URI::set_executable(bool value) {
  set_has_executable();
  executable_ = value;
  // @@protoc_insertion_point(field_set:mesos.CommandInfo.URI.executable)
}

// optional bool extract = 3 [default = true];
inline bool CommandInfo_URI::has_extract() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CommandInfo_URI::set_has_extract() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CommandInfo_URI::clear_has_extract() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CommandInfo_URI::clear_extract() {
  extract_ = true;
  clear_has_extract();
}
inline bool CommandInfo_URI::extract() const {
  // @@protoc_insertion_point(field_get:mesos.CommandInfo.URI.extract)
  return extract_;
}
inline void CommandInfo_URI::set_extract(bool value) {
  set_has_extract();
  extract_ = value;
  // @@protoc_insertion_point(field_set:mesos.CommandInfo.URI.extract)
}

// optional bool cache = 4;
inline bool CommandInfo_URI::has_cache() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandInfo_URI::set_has_cache() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandInfo_URI::clear_has_cache() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandInfo_URI::clear_cache() {
  cache_ = false;
  clear_has_cache();
}
inline bool CommandInfo_URI::cache() const {
  // @@protoc_insertion_point(field_get:mesos.CommandInfo.URI.cache)
  return cache_;
}
inline void CommandInfo_URI::set_cache(bool value) {
  set_has_cache();
  cache_ = value;
  // @@protoc_insertion_point(field_set:mesos.CommandInfo.URI.cache)
}

// optional string output_file = 5;
inline bool CommandInfo_URI::has_output_file() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandInfo_URI::set_has_output_file() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandInfo_URI::clear_has_output_file() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandInfo_URI::clear_output_file() {
  output_file_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_output_file();
}
inline const ::std::string& CommandInfo_URI::output_file() const {
  // @@protoc_insertion_point(field_get:mesos.CommandInfo.URI.output_file)
  return output_file_.Get();
}
inline void CommandInfo_URI::set_output_file(const ::std::string& value) {
  set_has_output_file();
  output_file_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.CommandInfo.URI.output_file)
}
#if LANG_CXX11
inline void CommandInfo_URI::set_output_file(::std::string&& value) {
  set_has_output_file();
  output_file_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.CommandInfo.URI.output_file)
}
#endif
inline void CommandInfo_URI::set_output_file(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_output_file();
  output_file_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.CommandInfo.URI.output_file)
}
inline void CommandInfo_URI::set_output_file(const char* value,
    size_t size) {
  set_has_output_file();
  output_file_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.CommandInfo.URI.output_file)
}
inline ::std::string* CommandInfo_URI::mutable_output_file() {
  set_has_output_file();
  // @@protoc_insertion_point(field_mutable:mesos.CommandInfo.URI.output_file)
  return output_file_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* CommandInfo_URI::release_output_file() {
  // @@protoc_insertion_point(field_release:mesos.CommandInfo.URI.output_file)
  clear_has_output_file();
  return output_file_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void CommandInfo_URI::set_allocated_output_file(::std::string* output_file) {
  if (output_file != NULL) {
    set_has_output_file();
  } else {
    clear_has_output_file();
  }
  output_file_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), output_file,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.CommandInfo.URI.output_file)
}
inline ::std::string* CommandInfo_URI::unsafe_arena_release_output_file() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.CommandInfo.URI.output_file)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_output_file();
  return output_file_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void CommandInfo_URI::unsafe_arena_set_allocated_output_file(
    ::std::string* output_file) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (output_file != NULL) {
    set_has_output_file();
  } else {
    clear_has_output_file();
  }
  output_file_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      output_file, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.CommandInfo.URI.output_file)
}

// -------------------------------------------------------------------

// CommandInfo

// repeated .mesos.CommandInfo.URI uris = 1;
inline int CommandInfo::uris_size() const {
  return uris_.size();
}
inline void CommandInfo::clear_uris() {
  uris_.Clear();
}
inline const ::mesos::CommandInfo_URI& CommandInfo::uris(int index) const {
  // @@protoc_insertion_point(field_get:mesos.CommandInfo.uris)
  return uris_.Get(index);
}
inline ::mesos::CommandInfo_URI* CommandInfo::mutable_uris(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.CommandInfo.uris)
  return uris_.Mutable(index);
}
inline ::mesos::CommandInfo_URI* CommandInfo::add_uris() {
  // @@protoc_insertion_point(field_add:mesos.CommandInfo.uris)
  return uris_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::CommandInfo_URI >*
CommandInfo::mutable_uris() {
  // @@protoc_insertion_point(field_mutable_list:mesos.CommandInfo.uris)
  return &uris_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::CommandInfo_URI >&
CommandInfo::uris() const {
  // @@protoc_insertion_point(field_list:mesos.CommandInfo.uris)
  return uris_;
}

// optional .mesos.Environment environment = 2;
inline bool CommandInfo::has_environment() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandInfo::set_has_environment() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandInfo::clear_has_environment() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandInfo::clear_environment() {
  if (environment_ != NULL) environment_->Clear();
  clear_has_environment();
}
inline const ::mesos::Environment& CommandInfo::environment() const {
  const ::mesos::Environment* p = environment_;
  // @@protoc_insertion_point(field_get:mesos.CommandInfo.environment)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::Environment*>(
      &::mesos::_Environment_default_instance_);
}
inline ::mesos::Environment* CommandInfo::release_environment() {
  // @@protoc_insertion_point(field_release:mesos.CommandInfo.environment)
  clear_has_environment();
  ::mesos::Environment* temp = environment_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  environment_ = NULL;
  return temp;
}
inline ::mesos::Environment* CommandInfo::unsafe_arena_release_environment() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.CommandInfo.environment)
  clear_has_environment();
  ::mesos::Environment* temp = environment_;
  environment_ = NULL;
  return temp;
}
inline ::mesos::Environment* CommandInfo::mutable_environment() {
  set_has_environment();
  if (environment_ == NULL) {
    _slow_mutable_environment();
  }
  // @@protoc_insertion_point(field_mutable:mesos.CommandInfo.environment)
  return environment_;
}
inline void CommandInfo::set_allocated_environment(::mesos::Environment* environment) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete environment_;
  }
  if (environment) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(environment);
    if (message_arena != submessage_arena) {
      environment = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, environment, submessage_arena);
    }
    set_has_environment();
  } else {
    clear_has_environment();
  }
  environment_ = environment;
  // @@protoc_insertion_point(field_set_allocated:mesos.CommandInfo.environment)
}

// optional bool shell = 6 [default = true];
inline bool CommandInfo::has_shell() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandInfo::set_has_shell() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandInfo::clear_has_shell() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandInfo::clear_shell() {
  shell_ = true;
  clear_has_shell();
}
inline bool CommandInfo::shell() const {
  // @@protoc_insertion_point(field_get:mesos.CommandInfo.shell)
  return shell_;
}
inline void CommandInfo::set_shell(bool value) {
  set_has_shell();
  shell_ = value;
  // @@protoc_insertion_point(field_set:mesos.CommandInfo.shell)
}

// optional string value = 3;
inline bool CommandInfo::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandInfo::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandInfo::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandInfo::clear_value() {
  value_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_value();
}
inline const ::std::string& CommandInfo::value() const {
  // @@protoc_insertion_point(field_get:mesos.CommandInfo.value)
  return value_.Get();
}
inline void CommandInfo::set_value(const ::std::string& value) {
  set_has_value();
  value_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.CommandInfo.value)
}
#if LANG_CXX11
inline void CommandInfo::set_value(::std::string&& value) {
  set_has_value();
  value_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.CommandInfo.value)
}
#endif
inline void CommandInfo::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_value();
  value_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.CommandInfo.value)
}
inline void CommandInfo::set_value(const char* value,
    size_t size) {
  set_has_value();
  value_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.CommandInfo.value)
}
inline ::std::string* CommandInfo::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:mesos.CommandInfo.value)
  return value_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* CommandInfo::release_value() {
  // @@protoc_insertion_point(field_release:mesos.CommandInfo.value)
  clear_has_value();
  return value_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void CommandInfo::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.CommandInfo.value)
}
inline ::std::string* CommandInfo::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.CommandInfo.value)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_value();
  return value_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void CommandInfo::unsafe_arena_set_allocated_value(
    ::std::string* value) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.CommandInfo.value)
}

// repeated string arguments = 7;
inline int CommandInfo::arguments_size() const {
  return arguments_.size();
}
inline void CommandInfo::clear_arguments() {
  arguments_.Clear();
}
inline const ::std::string& CommandInfo::arguments(int index) const {
  // @@protoc_insertion_point(field_get:mesos.CommandInfo.arguments)
  return arguments_.Get(index);
}
inline ::std::string* CommandInfo::mutable_arguments(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.CommandInfo.arguments)
  return arguments_.Mutable(index);
}
inline void CommandInfo::set_arguments(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:mesos.CommandInfo.arguments)
  arguments_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void CommandInfo::set_arguments(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:mesos.CommandInfo.arguments)
  arguments_.Mutable(index)->assign(std::move(value));
}
#endif
inline void CommandInfo::set_arguments(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  arguments_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.CommandInfo.arguments)
}
inline void CommandInfo::set_arguments(int index, const char* value, size_t size) {
  arguments_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.CommandInfo.arguments)
}
inline ::std::string* CommandInfo::add_arguments() {
  // @@protoc_insertion_point(field_add_mutable:mesos.CommandInfo.arguments)
  return arguments_.Add();
}
inline void CommandInfo::add_arguments(const ::std::string& value) {
  arguments_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:mesos.CommandInfo.arguments)
}
#if LANG_CXX11
inline void CommandInfo::add_arguments(::std::string&& value) {
  arguments_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:mesos.CommandInfo.arguments)
}
#endif
inline void CommandInfo::add_arguments(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  arguments_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:mesos.CommandInfo.arguments)
}
inline void CommandInfo::add_arguments(const char* value, size_t size) {
  arguments_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:mesos.CommandInfo.arguments)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
CommandInfo::arguments() const {
  // @@protoc_insertion_point(field_list:mesos.CommandInfo.arguments)
  return arguments_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
CommandInfo::mutable_arguments() {
  // @@protoc_insertion_point(field_mutable_list:mesos.CommandInfo.arguments)
  return &arguments_;
}

// optional string user = 5;
inline bool CommandInfo::has_user() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandInfo::set_has_user() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandInfo::clear_has_user() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandInfo::clear_user() {
  user_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_user();
}
inline const ::std::string& CommandInfo::user() const {
  // @@protoc_insertion_point(field_get:mesos.CommandInfo.user)
  return user_.Get();
}
inline void CommandInfo::set_user(const ::std::string& value) {
  set_has_user();
  user_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.CommandInfo.user)
}
#if LANG_CXX11
inline void CommandInfo::set_user(::std::string&& value) {
  set_has_user();
  user_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.CommandInfo.user)
}
#endif
inline void CommandInfo::set_user(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_user();
  user_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.CommandInfo.user)
}
inline void CommandInfo::set_user(const char* value,
    size_t size) {
  set_has_user();
  user_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.CommandInfo.user)
}
inline ::std::string* CommandInfo::mutable_user() {
  set_has_user();
  // @@protoc_insertion_point(field_mutable:mesos.CommandInfo.user)
  return user_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* CommandInfo::release_user() {
  // @@protoc_insertion_point(field_release:mesos.CommandInfo.user)
  clear_has_user();
  return user_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void CommandInfo::set_allocated_user(::std::string* user) {
  if (user != NULL) {
    set_has_user();
  } else {
    clear_has_user();
  }
  user_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.CommandInfo.user)
}
inline ::std::string* CommandInfo::unsafe_arena_release_user() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.CommandInfo.user)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_user();
  return user_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void CommandInfo::unsafe_arena_set_allocated_user(
    ::std::string* user) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (user != NULL) {
    set_has_user();
  } else {
    clear_has_user();
  }
  user_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      user, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.CommandInfo.user)
}

// -------------------------------------------------------------------

// ExecutorInfo

// optional .mesos.ExecutorInfo.Type type = 15;
inline bool ExecutorInfo::has_type() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ExecutorInfo::set_has_type() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ExecutorInfo::clear_has_type() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ExecutorInfo::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::mesos::ExecutorInfo_Type ExecutorInfo::type() const {
  // @@protoc_insertion_point(field_get:mesos.ExecutorInfo.type)
  return static_cast< ::mesos::ExecutorInfo_Type >(type_);
}
inline void ExecutorInfo::set_type(::mesos::ExecutorInfo_Type value) {
  assert(::mesos::ExecutorInfo_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:mesos.ExecutorInfo.type)
}

// required .mesos.ExecutorID executor_id = 1;
inline bool ExecutorInfo::has_executor_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ExecutorInfo::set_has_executor_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ExecutorInfo::clear_has_executor_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ExecutorInfo::clear_executor_id() {
  if (executor_id_ != NULL) executor_id_->Clear();
  clear_has_executor_id();
}
inline const ::mesos::ExecutorID& ExecutorInfo::executor_id() const {
  const ::mesos::ExecutorID* p = executor_id_;
  // @@protoc_insertion_point(field_get:mesos.ExecutorInfo.executor_id)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ExecutorID*>(
      &::mesos::_ExecutorID_default_instance_);
}
inline ::mesos::ExecutorID* ExecutorInfo::release_executor_id() {
  // @@protoc_insertion_point(field_release:mesos.ExecutorInfo.executor_id)
  clear_has_executor_id();
  ::mesos::ExecutorID* temp = executor_id_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  executor_id_ = NULL;
  return temp;
}
inline ::mesos::ExecutorID* ExecutorInfo::unsafe_arena_release_executor_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.ExecutorInfo.executor_id)
  clear_has_executor_id();
  ::mesos::ExecutorID* temp = executor_id_;
  executor_id_ = NULL;
  return temp;
}
inline ::mesos::ExecutorID* ExecutorInfo::mutable_executor_id() {
  set_has_executor_id();
  if (executor_id_ == NULL) {
    _slow_mutable_executor_id();
  }
  // @@protoc_insertion_point(field_mutable:mesos.ExecutorInfo.executor_id)
  return executor_id_;
}
inline void ExecutorInfo::set_allocated_executor_id(::mesos::ExecutorID* executor_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete executor_id_;
  }
  if (executor_id) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(executor_id);
    if (message_arena != submessage_arena) {
      executor_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, executor_id, submessage_arena);
    }
    set_has_executor_id();
  } else {
    clear_has_executor_id();
  }
  executor_id_ = executor_id;
  // @@protoc_insertion_point(field_set_allocated:mesos.ExecutorInfo.executor_id)
}

// optional .mesos.FrameworkID framework_id = 8;
inline bool ExecutorInfo::has_framework_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ExecutorInfo::set_has_framework_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ExecutorInfo::clear_has_framework_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ExecutorInfo::clear_framework_id() {
  if (framework_id_ != NULL) framework_id_->Clear();
  clear_has_framework_id();
}
inline const ::mesos::FrameworkID& ExecutorInfo::framework_id() const {
  const ::mesos::FrameworkID* p = framework_id_;
  // @@protoc_insertion_point(field_get:mesos.ExecutorInfo.framework_id)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::FrameworkID*>(
      &::mesos::_FrameworkID_default_instance_);
}
inline ::mesos::FrameworkID* ExecutorInfo::release_framework_id() {
  // @@protoc_insertion_point(field_release:mesos.ExecutorInfo.framework_id)
  clear_has_framework_id();
  ::mesos::FrameworkID* temp = framework_id_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  framework_id_ = NULL;
  return temp;
}
inline ::mesos::FrameworkID* ExecutorInfo::unsafe_arena_release_framework_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.ExecutorInfo.framework_id)
  clear_has_framework_id();
  ::mesos::FrameworkID* temp = framework_id_;
  framework_id_ = NULL;
  return temp;
}
inline ::mesos::FrameworkID* ExecutorInfo::mutable_framework_id() {
  set_has_framework_id();
  if (framework_id_ == NULL) {
    _slow_mutable_framework_id();
  }
  // @@protoc_insertion_point(field_mutable:mesos.ExecutorInfo.framework_id)
  return framework_id_;
}
inline void ExecutorInfo::set_allocated_framework_id(::mesos::FrameworkID* framework_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete framework_id_;
  }
  if (framework_id) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(framework_id);
    if (message_arena != submessage_arena) {
      framework_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, framework_id, submessage_arena);
    }
    set_has_framework_id();
  } else {
    clear_has_framework_id();
  }
  framework_id_ = framework_id;
  // @@protoc_insertion_point(field_set_allocated:mesos.ExecutorInfo.framework_id)
}

// optional .mesos.CommandInfo command = 7;
inline bool ExecutorInfo::has_command() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ExecutorInfo::set_has_command() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ExecutorInfo::clear_has_command() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ExecutorInfo::clear_command() {
  if (command_ != NULL) command_->Clear();
  clear_has_command();
}
inline const ::mesos::CommandInfo& ExecutorInfo::command() const {
  const ::mesos::CommandInfo* p = command_;
  // @@protoc_insertion_point(field_get:mesos.ExecutorInfo.command)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::CommandInfo*>(
      &::mesos::_CommandInfo_default_instance_);
}
inline ::mesos::CommandInfo* ExecutorInfo::release_command() {
  // @@protoc_insertion_point(field_release:mesos.ExecutorInfo.command)
  clear_has_command();
  ::mesos::CommandInfo* temp = command_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  command_ = NULL;
  return temp;
}
inline ::mesos::CommandInfo* ExecutorInfo::unsafe_arena_release_command() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.ExecutorInfo.command)
  clear_has_command();
  ::mesos::CommandInfo* temp = command_;
  command_ = NULL;
  return temp;
}
inline ::mesos::CommandInfo* ExecutorInfo::mutable_command() {
  set_has_command();
  if (command_ == NULL) {
    _slow_mutable_command();
  }
  // @@protoc_insertion_point(field_mutable:mesos.ExecutorInfo.command)
  return command_;
}
inline void ExecutorInfo::set_allocated_command(::mesos::CommandInfo* command) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete command_;
  }
  if (command) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(command);
    if (message_arena != submessage_arena) {
      command = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, command, submessage_arena);
    }
    set_has_command();
  } else {
    clear_has_command();
  }
  command_ = command;
  // @@protoc_insertion_point(field_set_allocated:mesos.ExecutorInfo.command)
}

// optional .mesos.ContainerInfo container = 11;
inline bool ExecutorInfo::has_container() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ExecutorInfo::set_has_container() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ExecutorInfo::clear_has_container() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ExecutorInfo::clear_container() {
  if (container_ != NULL) container_->Clear();
  clear_has_container();
}
inline const ::mesos::ContainerInfo& ExecutorInfo::container() const {
  const ::mesos::ContainerInfo* p = container_;
  // @@protoc_insertion_point(field_get:mesos.ExecutorInfo.container)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ContainerInfo*>(
      &::mesos::_ContainerInfo_default_instance_);
}
inline ::mesos::ContainerInfo* ExecutorInfo::release_container() {
  // @@protoc_insertion_point(field_release:mesos.ExecutorInfo.container)
  clear_has_container();
  ::mesos::ContainerInfo* temp = container_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  container_ = NULL;
  return temp;
}
inline ::mesos::ContainerInfo* ExecutorInfo::unsafe_arena_release_container() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.ExecutorInfo.container)
  clear_has_container();
  ::mesos::ContainerInfo* temp = container_;
  container_ = NULL;
  return temp;
}
inline ::mesos::ContainerInfo* ExecutorInfo::mutable_container() {
  set_has_container();
  if (container_ == NULL) {
    _slow_mutable_container();
  }
  // @@protoc_insertion_point(field_mutable:mesos.ExecutorInfo.container)
  return container_;
}
inline void ExecutorInfo::set_allocated_container(::mesos::ContainerInfo* container) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete container_;
  }
  if (container) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(container);
    if (message_arena != submessage_arena) {
      container = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, container, submessage_arena);
    }
    set_has_container();
  } else {
    clear_has_container();
  }
  container_ = container;
  // @@protoc_insertion_point(field_set_allocated:mesos.ExecutorInfo.container)
}

// repeated .mesos.Resource resources = 5;
inline int ExecutorInfo::resources_size() const {
  return resources_.size();
}
inline void ExecutorInfo::clear_resources() {
  resources_.Clear();
}
inline const ::mesos::Resource& ExecutorInfo::resources(int index) const {
  // @@protoc_insertion_point(field_get:mesos.ExecutorInfo.resources)
  return resources_.Get(index);
}
inline ::mesos::Resource* ExecutorInfo::mutable_resources(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.ExecutorInfo.resources)
  return resources_.Mutable(index);
}
inline ::mesos::Resource* ExecutorInfo::add_resources() {
  // @@protoc_insertion_point(field_add:mesos.ExecutorInfo.resources)
  return resources_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
ExecutorInfo::mutable_resources() {
  // @@protoc_insertion_point(field_mutable_list:mesos.ExecutorInfo.resources)
  return &resources_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
ExecutorInfo::resources() const {
  // @@protoc_insertion_point(field_list:mesos.ExecutorInfo.resources)
  return resources_;
}

// optional string name = 9;
inline bool ExecutorInfo::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ExecutorInfo::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ExecutorInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ExecutorInfo::clear_name() {
  name_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_name();
}
inline const ::std::string& ExecutorInfo::name() const {
  // @@protoc_insertion_point(field_get:mesos.ExecutorInfo.name)
  return name_.Get();
}
inline void ExecutorInfo::set_name(const ::std::string& value) {
  set_has_name();
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.ExecutorInfo.name)
}
#if LANG_CXX11
inline void ExecutorInfo::set_name(::std::string&& value) {
  set_has_name();
  name_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.ExecutorInfo.name)
}
#endif
inline void ExecutorInfo::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.ExecutorInfo.name)
}
inline void ExecutorInfo::set_name(const char* value,
    size_t size) {
  set_has_name();
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.ExecutorInfo.name)
}
inline ::std::string* ExecutorInfo::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:mesos.ExecutorInfo.name)
  return name_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* ExecutorInfo::release_name() {
  // @@protoc_insertion_point(field_release:mesos.ExecutorInfo.name)
  clear_has_name();
  return name_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void ExecutorInfo::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.ExecutorInfo.name)
}
inline ::std::string* ExecutorInfo::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.ExecutorInfo.name)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_name();
  return name_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void ExecutorInfo::unsafe_arena_set_allocated_name(
    ::std::string* name) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      name, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.ExecutorInfo.name)
}

// optional string source = 10 [deprecated = true];
inline bool ExecutorInfo::has_source() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ExecutorInfo::set_has_source() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ExecutorInfo::clear_has_source() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ExecutorInfo::clear_source() {
  source_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_source();
}
inline const ::std::string& ExecutorInfo::source() const {
  // @@protoc_insertion_point(field_get:mesos.ExecutorInfo.source)
  return source_.Get();
}
inline void ExecutorInfo::set_source(const ::std::string& value) {
  set_has_source();
  source_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.ExecutorInfo.source)
}
#if LANG_CXX11
inline void ExecutorInfo::set_source(::std::string&& value) {
  set_has_source();
  source_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.ExecutorInfo.source)
}
#endif
inline void ExecutorInfo::set_source(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_source();
  source_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.ExecutorInfo.source)
}
inline void ExecutorInfo::set_source(const char* value,
    size_t size) {
  set_has_source();
  source_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.ExecutorInfo.source)
}
inline ::std::string* ExecutorInfo::mutable_source() {
  set_has_source();
  // @@protoc_insertion_point(field_mutable:mesos.ExecutorInfo.source)
  return source_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* ExecutorInfo::release_source() {
  // @@protoc_insertion_point(field_release:mesos.ExecutorInfo.source)
  clear_has_source();
  return source_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void ExecutorInfo::set_allocated_source(::std::string* source) {
  if (source != NULL) {
    set_has_source();
  } else {
    clear_has_source();
  }
  source_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), source,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.ExecutorInfo.source)
}
inline ::std::string* ExecutorInfo::unsafe_arena_release_source() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.ExecutorInfo.source)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_source();
  return source_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void ExecutorInfo::unsafe_arena_set_allocated_source(
    ::std::string* source) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (source != NULL) {
    set_has_source();
  } else {
    clear_has_source();
  }
  source_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      source, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.ExecutorInfo.source)
}

// optional bytes data = 4;
inline bool ExecutorInfo::has_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExecutorInfo::set_has_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExecutorInfo::clear_has_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExecutorInfo::clear_data() {
  data_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_data();
}
inline const ::std::string& ExecutorInfo::data() const {
  // @@protoc_insertion_point(field_get:mesos.ExecutorInfo.data)
  return data_.Get();
}
inline void ExecutorInfo::set_data(const ::std::string& value) {
  set_has_data();
  data_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.ExecutorInfo.data)
}
#if LANG_CXX11
inline void ExecutorInfo::set_data(::std::string&& value) {
  set_has_data();
  data_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.ExecutorInfo.data)
}
#endif
inline void ExecutorInfo::set_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_data();
  data_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.ExecutorInfo.data)
}
inline void ExecutorInfo::set_data(const void* value,
    size_t size) {
  set_has_data();
  data_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.ExecutorInfo.data)
}
inline ::std::string* ExecutorInfo::mutable_data() {
  set_has_data();
  // @@protoc_insertion_point(field_mutable:mesos.ExecutorInfo.data)
  return data_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* ExecutorInfo::release_data() {
  // @@protoc_insertion_point(field_release:mesos.ExecutorInfo.data)
  clear_has_data();
  return data_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void ExecutorInfo::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    set_has_data();
  } else {
    clear_has_data();
  }
  data_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.ExecutorInfo.data)
}
inline ::std::string* ExecutorInfo::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.ExecutorInfo.data)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_data();
  return data_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void ExecutorInfo::unsafe_arena_set_allocated_data(
    ::std::string* data) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (data != NULL) {
    set_has_data();
  } else {
    clear_has_data();
  }
  data_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      data, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.ExecutorInfo.data)
}

// optional .mesos.DiscoveryInfo discovery = 12;
inline bool ExecutorInfo::has_discovery() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ExecutorInfo::set_has_discovery() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ExecutorInfo::clear_has_discovery() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ExecutorInfo::clear_discovery() {
  if (discovery_ != NULL) discovery_->Clear();
  clear_has_discovery();
}
inline const ::mesos::DiscoveryInfo& ExecutorInfo::discovery() const {
  const ::mesos::DiscoveryInfo* p = discovery_;
  // @@protoc_insertion_point(field_get:mesos.ExecutorInfo.discovery)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::DiscoveryInfo*>(
      &::mesos::_DiscoveryInfo_default_instance_);
}
inline ::mesos::DiscoveryInfo* ExecutorInfo::release_discovery() {
  // @@protoc_insertion_point(field_release:mesos.ExecutorInfo.discovery)
  clear_has_discovery();
  ::mesos::DiscoveryInfo* temp = discovery_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  discovery_ = NULL;
  return temp;
}
inline ::mesos::DiscoveryInfo* ExecutorInfo::unsafe_arena_release_discovery() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.ExecutorInfo.discovery)
  clear_has_discovery();
  ::mesos::DiscoveryInfo* temp = discovery_;
  discovery_ = NULL;
  return temp;
}
inline ::mesos::DiscoveryInfo* ExecutorInfo::mutable_discovery() {
  set_has_discovery();
  if (discovery_ == NULL) {
    _slow_mutable_discovery();
  }
  // @@protoc_insertion_point(field_mutable:mesos.ExecutorInfo.discovery)
  return discovery_;
}
inline void ExecutorInfo::set_allocated_discovery(::mesos::DiscoveryInfo* discovery) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete discovery_;
  }
  if (discovery) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(discovery);
    if (message_arena != submessage_arena) {
      discovery = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, discovery, submessage_arena);
    }
    set_has_discovery();
  } else {
    clear_has_discovery();
  }
  discovery_ = discovery;
  // @@protoc_insertion_point(field_set_allocated:mesos.ExecutorInfo.discovery)
}

// optional .mesos.DurationInfo shutdown_grace_period = 13;
inline bool ExecutorInfo::has_shutdown_grace_period() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ExecutorInfo::set_has_shutdown_grace_period() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ExecutorInfo::clear_has_shutdown_grace_period() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ExecutorInfo::clear_shutdown_grace_period() {
  if (shutdown_grace_period_ != NULL) shutdown_grace_period_->Clear();
  clear_has_shutdown_grace_period();
}
inline const ::mesos::DurationInfo& ExecutorInfo::shutdown_grace_period() const {
  const ::mesos::DurationInfo* p = shutdown_grace_period_;
  // @@protoc_insertion_point(field_get:mesos.ExecutorInfo.shutdown_grace_period)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::DurationInfo*>(
      &::mesos::_DurationInfo_default_instance_);
}
inline ::mesos::DurationInfo* ExecutorInfo::release_shutdown_grace_period() {
  // @@protoc_insertion_point(field_release:mesos.ExecutorInfo.shutdown_grace_period)
  clear_has_shutdown_grace_period();
  ::mesos::DurationInfo* temp = shutdown_grace_period_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  shutdown_grace_period_ = NULL;
  return temp;
}
inline ::mesos::DurationInfo* ExecutorInfo::unsafe_arena_release_shutdown_grace_period() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.ExecutorInfo.shutdown_grace_period)
  clear_has_shutdown_grace_period();
  ::mesos::DurationInfo* temp = shutdown_grace_period_;
  shutdown_grace_period_ = NULL;
  return temp;
}
inline ::mesos::DurationInfo* ExecutorInfo::mutable_shutdown_grace_period() {
  set_has_shutdown_grace_period();
  if (shutdown_grace_period_ == NULL) {
    _slow_mutable_shutdown_grace_period();
  }
  // @@protoc_insertion_point(field_mutable:mesos.ExecutorInfo.shutdown_grace_period)
  return shutdown_grace_period_;
}
inline void ExecutorInfo::set_allocated_shutdown_grace_period(::mesos::DurationInfo* shutdown_grace_period) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete shutdown_grace_period_;
  }
  if (shutdown_grace_period) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(shutdown_grace_period);
    if (message_arena != submessage_arena) {
      shutdown_grace_period = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, shutdown_grace_period, submessage_arena);
    }
    set_has_shutdown_grace_period();
  } else {
    clear_has_shutdown_grace_period();
  }
  shutdown_grace_period_ = shutdown_grace_period;
  // @@protoc_insertion_point(field_set_allocated:mesos.ExecutorInfo.shutdown_grace_period)
}

// optional .mesos.Labels labels = 14;
inline bool ExecutorInfo::has_labels() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ExecutorInfo::set_has_labels() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ExecutorInfo::clear_has_labels() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ExecutorInfo::clear_labels() {
  if (labels_ != NULL) labels_->Clear();
  clear_has_labels();
}
inline const ::mesos::Labels& ExecutorInfo::labels() const {
  const ::mesos::Labels* p = labels_;
  // @@protoc_insertion_point(field_get:mesos.ExecutorInfo.labels)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::Labels*>(
      &::mesos::_Labels_default_instance_);
}
inline ::mesos::Labels* ExecutorInfo::release_labels() {
  // @@protoc_insertion_point(field_release:mesos.ExecutorInfo.labels)
  clear_has_labels();
  ::mesos::Labels* temp = labels_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  labels_ = NULL;
  return temp;
}
inline ::mesos::Labels* ExecutorInfo::unsafe_arena_release_labels() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.ExecutorInfo.labels)
  clear_has_labels();
  ::mesos::Labels* temp = labels_;
  labels_ = NULL;
  return temp;
}
inline ::mesos::Labels* ExecutorInfo::mutable_labels() {
  set_has_labels();
  if (labels_ == NULL) {
    _slow_mutable_labels();
  }
  // @@protoc_insertion_point(field_mutable:mesos.ExecutorInfo.labels)
  return labels_;
}
inline void ExecutorInfo::set_allocated_labels(::mesos::Labels* labels) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete labels_;
  }
  if (labels) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(labels);
    if (message_arena != submessage_arena) {
      labels = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, labels, submessage_arena);
    }
    set_has_labels();
  } else {
    clear_has_labels();
  }
  labels_ = labels;
  // @@protoc_insertion_point(field_set_allocated:mesos.ExecutorInfo.labels)
}

// -------------------------------------------------------------------

// DomainInfo_FaultDomain_RegionInfo

// required string name = 1;
inline bool DomainInfo_FaultDomain_RegionInfo::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DomainInfo_FaultDomain_RegionInfo::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DomainInfo_FaultDomain_RegionInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DomainInfo_FaultDomain_RegionInfo::clear_name() {
  name_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_name();
}
inline const ::std::string& DomainInfo_FaultDomain_RegionInfo::name() const {
  // @@protoc_insertion_point(field_get:mesos.DomainInfo.FaultDomain.RegionInfo.name)
  return name_.Get();
}
inline void DomainInfo_FaultDomain_RegionInfo::set_name(const ::std::string& value) {
  set_has_name();
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.DomainInfo.FaultDomain.RegionInfo.name)
}
#if LANG_CXX11
inline void DomainInfo_FaultDomain_RegionInfo::set_name(::std::string&& value) {
  set_has_name();
  name_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.DomainInfo.FaultDomain.RegionInfo.name)
}
#endif
inline void DomainInfo_FaultDomain_RegionInfo::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.DomainInfo.FaultDomain.RegionInfo.name)
}
inline void DomainInfo_FaultDomain_RegionInfo::set_name(const char* value,
    size_t size) {
  set_has_name();
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.DomainInfo.FaultDomain.RegionInfo.name)
}
inline ::std::string* DomainInfo_FaultDomain_RegionInfo::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:mesos.DomainInfo.FaultDomain.RegionInfo.name)
  return name_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* DomainInfo_FaultDomain_RegionInfo::release_name() {
  // @@protoc_insertion_point(field_release:mesos.DomainInfo.FaultDomain.RegionInfo.name)
  clear_has_name();
  return name_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void DomainInfo_FaultDomain_RegionInfo::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.DomainInfo.FaultDomain.RegionInfo.name)
}
inline ::std::string* DomainInfo_FaultDomain_RegionInfo::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.DomainInfo.FaultDomain.RegionInfo.name)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_name();
  return name_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void DomainInfo_FaultDomain_RegionInfo::unsafe_arena_set_allocated_name(
    ::std::string* name) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      name, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.DomainInfo.FaultDomain.RegionInfo.name)
}

// -------------------------------------------------------------------

// DomainInfo_FaultDomain_ZoneInfo

// required string name = 1;
inline bool DomainInfo_FaultDomain_ZoneInfo::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DomainInfo_FaultDomain_ZoneInfo::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DomainInfo_FaultDomain_ZoneInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DomainInfo_FaultDomain_ZoneInfo::clear_name() {
  name_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_name();
}
inline const ::std::string& DomainInfo_FaultDomain_ZoneInfo::name() const {
  // @@protoc_insertion_point(field_get:mesos.DomainInfo.FaultDomain.ZoneInfo.name)
  return name_.Get();
}
inline void DomainInfo_FaultDomain_ZoneInfo::set_name(const ::std::string& value) {
  set_has_name();
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.DomainInfo.FaultDomain.ZoneInfo.name)
}
#if LANG_CXX11
inline void DomainInfo_FaultDomain_ZoneInfo::set_name(::std::string&& value) {
  set_has_name();
  name_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.DomainInfo.FaultDomain.ZoneInfo.name)
}
#endif
inline void DomainInfo_FaultDomain_ZoneInfo::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.DomainInfo.FaultDomain.ZoneInfo.name)
}
inline void DomainInfo_FaultDomain_ZoneInfo::set_name(const char* value,
    size_t size) {
  set_has_name();
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.DomainInfo.FaultDomain.ZoneInfo.name)
}
inline ::std::string* DomainInfo_FaultDomain_ZoneInfo::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:mesos.DomainInfo.FaultDomain.ZoneInfo.name)
  return name_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* DomainInfo_FaultDomain_ZoneInfo::release_name() {
  // @@protoc_insertion_point(field_release:mesos.DomainInfo.FaultDomain.ZoneInfo.name)
  clear_has_name();
  return name_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void DomainInfo_FaultDomain_ZoneInfo::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.DomainInfo.FaultDomain.ZoneInfo.name)
}
inline ::std::string* DomainInfo_FaultDomain_ZoneInfo::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.DomainInfo.FaultDomain.ZoneInfo.name)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_name();
  return name_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void DomainInfo_FaultDomain_ZoneInfo::unsafe_arena_set_allocated_name(
    ::std::string* name) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      name, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.DomainInfo.FaultDomain.ZoneInfo.name)
}

// -------------------------------------------------------------------

// DomainInfo_FaultDomain

// required .mesos.DomainInfo.FaultDomain.RegionInfo region = 1;
inline bool DomainInfo_FaultDomain::has_region() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DomainInfo_FaultDomain::set_has_region() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DomainInfo_FaultDomain::clear_has_region() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DomainInfo_FaultDomain::clear_region() {
  if (region_ != NULL) region_->Clear();
  clear_has_region();
}
inline const ::mesos::DomainInfo_FaultDomain_RegionInfo& DomainInfo_FaultDomain::region() const {
  const ::mesos::DomainInfo_FaultDomain_RegionInfo* p = region_;
  // @@protoc_insertion_point(field_get:mesos.DomainInfo.FaultDomain.region)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::DomainInfo_FaultDomain_RegionInfo*>(
      &::mesos::_DomainInfo_FaultDomain_RegionInfo_default_instance_);
}
inline ::mesos::DomainInfo_FaultDomain_RegionInfo* DomainInfo_FaultDomain::release_region() {
  // @@protoc_insertion_point(field_release:mesos.DomainInfo.FaultDomain.region)
  clear_has_region();
  ::mesos::DomainInfo_FaultDomain_RegionInfo* temp = region_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  region_ = NULL;
  return temp;
}
inline ::mesos::DomainInfo_FaultDomain_RegionInfo* DomainInfo_FaultDomain::unsafe_arena_release_region() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.DomainInfo.FaultDomain.region)
  clear_has_region();
  ::mesos::DomainInfo_FaultDomain_RegionInfo* temp = region_;
  region_ = NULL;
  return temp;
}
inline ::mesos::DomainInfo_FaultDomain_RegionInfo* DomainInfo_FaultDomain::mutable_region() {
  set_has_region();
  if (region_ == NULL) {
    _slow_mutable_region();
  }
  // @@protoc_insertion_point(field_mutable:mesos.DomainInfo.FaultDomain.region)
  return region_;
}
inline void DomainInfo_FaultDomain::set_allocated_region(::mesos::DomainInfo_FaultDomain_RegionInfo* region) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete region_;
  }
  if (region) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(region);
    if (message_arena != submessage_arena) {
      region = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, region, submessage_arena);
    }
    set_has_region();
  } else {
    clear_has_region();
  }
  region_ = region;
  // @@protoc_insertion_point(field_set_allocated:mesos.DomainInfo.FaultDomain.region)
}

// required .mesos.DomainInfo.FaultDomain.ZoneInfo zone = 2;
inline bool DomainInfo_FaultDomain::has_zone() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DomainInfo_FaultDomain::set_has_zone() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DomainInfo_FaultDomain::clear_has_zone() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DomainInfo_FaultDomain::clear_zone() {
  if (zone_ != NULL) zone_->Clear();
  clear_has_zone();
}
inline const ::mesos::DomainInfo_FaultDomain_ZoneInfo& DomainInfo_FaultDomain::zone() const {
  const ::mesos::DomainInfo_FaultDomain_ZoneInfo* p = zone_;
  // @@protoc_insertion_point(field_get:mesos.DomainInfo.FaultDomain.zone)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::DomainInfo_FaultDomain_ZoneInfo*>(
      &::mesos::_DomainInfo_FaultDomain_ZoneInfo_default_instance_);
}
inline ::mesos::DomainInfo_FaultDomain_ZoneInfo* DomainInfo_FaultDomain::release_zone() {
  // @@protoc_insertion_point(field_release:mesos.DomainInfo.FaultDomain.zone)
  clear_has_zone();
  ::mesos::DomainInfo_FaultDomain_ZoneInfo* temp = zone_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  zone_ = NULL;
  return temp;
}
inline ::mesos::DomainInfo_FaultDomain_ZoneInfo* DomainInfo_FaultDomain::unsafe_arena_release_zone() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.DomainInfo.FaultDomain.zone)
  clear_has_zone();
  ::mesos::DomainInfo_FaultDomain_ZoneInfo* temp = zone_;
  zone_ = NULL;
  return temp;
}
inline ::mesos::DomainInfo_FaultDomain_ZoneInfo* DomainInfo_FaultDomain::mutable_zone() {
  set_has_zone();
  if (zone_ == NULL) {
    _slow_mutable_zone();
  }
  // @@protoc_insertion_point(field_mutable:mesos.DomainInfo.FaultDomain.zone)
  return zone_;
}
inline void DomainInfo_FaultDomain::set_allocated_zone(::mesos::DomainInfo_FaultDomain_ZoneInfo* zone) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete zone_;
  }
  if (zone) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(zone);
    if (message_arena != submessage_arena) {
      zone = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, zone, submessage_arena);
    }
    set_has_zone();
  } else {
    clear_has_zone();
  }
  zone_ = zone;
  // @@protoc_insertion_point(field_set_allocated:mesos.DomainInfo.FaultDomain.zone)
}

// -------------------------------------------------------------------

// DomainInfo

// optional .mesos.DomainInfo.FaultDomain fault_domain = 1;
inline bool DomainInfo::has_fault_domain() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DomainInfo::set_has_fault_domain() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DomainInfo::clear_has_fault_domain() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DomainInfo::clear_fault_domain() {
  if (fault_domain_ != NULL) fault_domain_->Clear();
  clear_has_fault_domain();
}
inline const ::mesos::DomainInfo_FaultDomain& DomainInfo::fault_domain() const {
  const ::mesos::DomainInfo_FaultDomain* p = fault_domain_;
  // @@protoc_insertion_point(field_get:mesos.DomainInfo.fault_domain)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::DomainInfo_FaultDomain*>(
      &::mesos::_DomainInfo_FaultDomain_default_instance_);
}
inline ::mesos::DomainInfo_FaultDomain* DomainInfo::release_fault_domain() {
  // @@protoc_insertion_point(field_release:mesos.DomainInfo.fault_domain)
  clear_has_fault_domain();
  ::mesos::DomainInfo_FaultDomain* temp = fault_domain_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  fault_domain_ = NULL;
  return temp;
}
inline ::mesos::DomainInfo_FaultDomain* DomainInfo::unsafe_arena_release_fault_domain() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.DomainInfo.fault_domain)
  clear_has_fault_domain();
  ::mesos::DomainInfo_FaultDomain* temp = fault_domain_;
  fault_domain_ = NULL;
  return temp;
}
inline ::mesos::DomainInfo_FaultDomain* DomainInfo::mutable_fault_domain() {
  set_has_fault_domain();
  if (fault_domain_ == NULL) {
    _slow_mutable_fault_domain();
  }
  // @@protoc_insertion_point(field_mutable:mesos.DomainInfo.fault_domain)
  return fault_domain_;
}
inline void DomainInfo::set_allocated_fault_domain(::mesos::DomainInfo_FaultDomain* fault_domain) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete fault_domain_;
  }
  if (fault_domain) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(fault_domain);
    if (message_arena != submessage_arena) {
      fault_domain = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, fault_domain, submessage_arena);
    }
    set_has_fault_domain();
  } else {
    clear_has_fault_domain();
  }
  fault_domain_ = fault_domain;
  // @@protoc_insertion_point(field_set_allocated:mesos.DomainInfo.fault_domain)
}

// -------------------------------------------------------------------

// MasterInfo_Capability

// optional .mesos.MasterInfo.Capability.Type type = 1;
inline bool MasterInfo_Capability::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MasterInfo_Capability::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MasterInfo_Capability::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MasterInfo_Capability::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::mesos::MasterInfo_Capability_Type MasterInfo_Capability::type() const {
  // @@protoc_insertion_point(field_get:mesos.MasterInfo.Capability.type)
  return static_cast< ::mesos::MasterInfo_Capability_Type >(type_);
}
inline void MasterInfo_Capability::set_type(::mesos::MasterInfo_Capability_Type value) {
  assert(::mesos::MasterInfo_Capability_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:mesos.MasterInfo.Capability.type)
}

// -------------------------------------------------------------------

// MasterInfo

// required string id = 1;
inline bool MasterInfo::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MasterInfo::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MasterInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MasterInfo::clear_id() {
  id_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_id();
}
inline const ::std::string& MasterInfo::id() const {
  // @@protoc_insertion_point(field_get:mesos.MasterInfo.id)
  return id_.Get();
}
inline void MasterInfo::set_id(const ::std::string& value) {
  set_has_id();
  id_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.MasterInfo.id)
}
#if LANG_CXX11
inline void MasterInfo::set_id(::std::string&& value) {
  set_has_id();
  id_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.MasterInfo.id)
}
#endif
inline void MasterInfo::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_id();
  id_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.MasterInfo.id)
}
inline void MasterInfo::set_id(const char* value,
    size_t size) {
  set_has_id();
  id_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.MasterInfo.id)
}
inline ::std::string* MasterInfo::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:mesos.MasterInfo.id)
  return id_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* MasterInfo::release_id() {
  // @@protoc_insertion_point(field_release:mesos.MasterInfo.id)
  clear_has_id();
  return id_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void MasterInfo::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.MasterInfo.id)
}
inline ::std::string* MasterInfo::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.MasterInfo.id)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_id();
  return id_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void MasterInfo::unsafe_arena_set_allocated_id(
    ::std::string* id) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      id, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.MasterInfo.id)
}

// required uint32 ip = 2;
inline bool MasterInfo::has_ip() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MasterInfo::set_has_ip() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MasterInfo::clear_has_ip() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MasterInfo::clear_ip() {
  ip_ = 0u;
  clear_has_ip();
}
inline ::google::protobuf::uint32 MasterInfo::ip() const {
  // @@protoc_insertion_point(field_get:mesos.MasterInfo.ip)
  return ip_;
}
inline void MasterInfo::set_ip(::google::protobuf::uint32 value) {
  set_has_ip();
  ip_ = value;
  // @@protoc_insertion_point(field_set:mesos.MasterInfo.ip)
}

// required uint32 port = 3 [default = 5050];
inline bool MasterInfo::has_port() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MasterInfo::set_has_port() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MasterInfo::clear_has_port() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MasterInfo::clear_port() {
  port_ = 5050u;
  clear_has_port();
}
inline ::google::protobuf::uint32 MasterInfo::port() const {
  // @@protoc_insertion_point(field_get:mesos.MasterInfo.port)
  return port_;
}
inline void MasterInfo::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
  // @@protoc_insertion_point(field_set:mesos.MasterInfo.port)
}

// optional string pid = 4;
inline bool MasterInfo::has_pid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MasterInfo::set_has_pid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MasterInfo::clear_has_pid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MasterInfo::clear_pid() {
  pid_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_pid();
}
inline const ::std::string& MasterInfo::pid() const {
  // @@protoc_insertion_point(field_get:mesos.MasterInfo.pid)
  return pid_.Get();
}
inline void MasterInfo::set_pid(const ::std::string& value) {
  set_has_pid();
  pid_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.MasterInfo.pid)
}
#if LANG_CXX11
inline void MasterInfo::set_pid(::std::string&& value) {
  set_has_pid();
  pid_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.MasterInfo.pid)
}
#endif
inline void MasterInfo::set_pid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_pid();
  pid_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.MasterInfo.pid)
}
inline void MasterInfo::set_pid(const char* value,
    size_t size) {
  set_has_pid();
  pid_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.MasterInfo.pid)
}
inline ::std::string* MasterInfo::mutable_pid() {
  set_has_pid();
  // @@protoc_insertion_point(field_mutable:mesos.MasterInfo.pid)
  return pid_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* MasterInfo::release_pid() {
  // @@protoc_insertion_point(field_release:mesos.MasterInfo.pid)
  clear_has_pid();
  return pid_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void MasterInfo::set_allocated_pid(::std::string* pid) {
  if (pid != NULL) {
    set_has_pid();
  } else {
    clear_has_pid();
  }
  pid_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pid,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.MasterInfo.pid)
}
inline ::std::string* MasterInfo::unsafe_arena_release_pid() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.MasterInfo.pid)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_pid();
  return pid_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void MasterInfo::unsafe_arena_set_allocated_pid(
    ::std::string* pid) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (pid != NULL) {
    set_has_pid();
  } else {
    clear_has_pid();
  }
  pid_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      pid, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.MasterInfo.pid)
}

// optional string hostname = 5;
inline bool MasterInfo::has_hostname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MasterInfo::set_has_hostname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MasterInfo::clear_has_hostname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MasterInfo::clear_hostname() {
  hostname_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_hostname();
}
inline const ::std::string& MasterInfo::hostname() const {
  // @@protoc_insertion_point(field_get:mesos.MasterInfo.hostname)
  return hostname_.Get();
}
inline void MasterInfo::set_hostname(const ::std::string& value) {
  set_has_hostname();
  hostname_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.MasterInfo.hostname)
}
#if LANG_CXX11
inline void MasterInfo::set_hostname(::std::string&& value) {
  set_has_hostname();
  hostname_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.MasterInfo.hostname)
}
#endif
inline void MasterInfo::set_hostname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_hostname();
  hostname_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.MasterInfo.hostname)
}
inline void MasterInfo::set_hostname(const char* value,
    size_t size) {
  set_has_hostname();
  hostname_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.MasterInfo.hostname)
}
inline ::std::string* MasterInfo::mutable_hostname() {
  set_has_hostname();
  // @@protoc_insertion_point(field_mutable:mesos.MasterInfo.hostname)
  return hostname_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* MasterInfo::release_hostname() {
  // @@protoc_insertion_point(field_release:mesos.MasterInfo.hostname)
  clear_has_hostname();
  return hostname_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void MasterInfo::set_allocated_hostname(::std::string* hostname) {
  if (hostname != NULL) {
    set_has_hostname();
  } else {
    clear_has_hostname();
  }
  hostname_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hostname,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.MasterInfo.hostname)
}
inline ::std::string* MasterInfo::unsafe_arena_release_hostname() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.MasterInfo.hostname)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_hostname();
  return hostname_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void MasterInfo::unsafe_arena_set_allocated_hostname(
    ::std::string* hostname) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (hostname != NULL) {
    set_has_hostname();
  } else {
    clear_has_hostname();
  }
  hostname_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      hostname, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.MasterInfo.hostname)
}

// optional string version = 6;
inline bool MasterInfo::has_version() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MasterInfo::set_has_version() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MasterInfo::clear_has_version() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MasterInfo::clear_version() {
  version_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_version();
}
inline const ::std::string& MasterInfo::version() const {
  // @@protoc_insertion_point(field_get:mesos.MasterInfo.version)
  return version_.Get();
}
inline void MasterInfo::set_version(const ::std::string& value) {
  set_has_version();
  version_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.MasterInfo.version)
}
#if LANG_CXX11
inline void MasterInfo::set_version(::std::string&& value) {
  set_has_version();
  version_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.MasterInfo.version)
}
#endif
inline void MasterInfo::set_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_version();
  version_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.MasterInfo.version)
}
inline void MasterInfo::set_version(const char* value,
    size_t size) {
  set_has_version();
  version_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.MasterInfo.version)
}
inline ::std::string* MasterInfo::mutable_version() {
  set_has_version();
  // @@protoc_insertion_point(field_mutable:mesos.MasterInfo.version)
  return version_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* MasterInfo::release_version() {
  // @@protoc_insertion_point(field_release:mesos.MasterInfo.version)
  clear_has_version();
  return version_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void MasterInfo::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    set_has_version();
  } else {
    clear_has_version();
  }
  version_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.MasterInfo.version)
}
inline ::std::string* MasterInfo::unsafe_arena_release_version() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.MasterInfo.version)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_version();
  return version_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void MasterInfo::unsafe_arena_set_allocated_version(
    ::std::string* version) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (version != NULL) {
    set_has_version();
  } else {
    clear_has_version();
  }
  version_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      version, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.MasterInfo.version)
}

// optional .mesos.Address address = 7;
inline bool MasterInfo::has_address() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MasterInfo::set_has_address() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MasterInfo::clear_has_address() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MasterInfo::clear_address() {
  if (address_ != NULL) address_->Clear();
  clear_has_address();
}
inline const ::mesos::Address& MasterInfo::address() const {
  const ::mesos::Address* p = address_;
  // @@protoc_insertion_point(field_get:mesos.MasterInfo.address)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::Address*>(
      &::mesos::_Address_default_instance_);
}
inline ::mesos::Address* MasterInfo::release_address() {
  // @@protoc_insertion_point(field_release:mesos.MasterInfo.address)
  clear_has_address();
  ::mesos::Address* temp = address_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  address_ = NULL;
  return temp;
}
inline ::mesos::Address* MasterInfo::unsafe_arena_release_address() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.MasterInfo.address)
  clear_has_address();
  ::mesos::Address* temp = address_;
  address_ = NULL;
  return temp;
}
inline ::mesos::Address* MasterInfo::mutable_address() {
  set_has_address();
  if (address_ == NULL) {
    _slow_mutable_address();
  }
  // @@protoc_insertion_point(field_mutable:mesos.MasterInfo.address)
  return address_;
}
inline void MasterInfo::set_allocated_address(::mesos::Address* address) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete address_;
  }
  if (address) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(address);
    if (message_arena != submessage_arena) {
      address = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, address, submessage_arena);
    }
    set_has_address();
  } else {
    clear_has_address();
  }
  address_ = address;
  // @@protoc_insertion_point(field_set_allocated:mesos.MasterInfo.address)
}

// optional .mesos.DomainInfo domain = 8;
inline bool MasterInfo::has_domain() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MasterInfo::set_has_domain() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MasterInfo::clear_has_domain() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MasterInfo::clear_domain() {
  if (domain_ != NULL) domain_->Clear();
  clear_has_domain();
}
inline const ::mesos::DomainInfo& MasterInfo::domain() const {
  const ::mesos::DomainInfo* p = domain_;
  // @@protoc_insertion_point(field_get:mesos.MasterInfo.domain)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::DomainInfo*>(
      &::mesos::_DomainInfo_default_instance_);
}
inline ::mesos::DomainInfo* MasterInfo::release_domain() {
  // @@protoc_insertion_point(field_release:mesos.MasterInfo.domain)
  clear_has_domain();
  ::mesos::DomainInfo* temp = domain_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  domain_ = NULL;
  return temp;
}
inline ::mesos::DomainInfo* MasterInfo::unsafe_arena_release_domain() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.MasterInfo.domain)
  clear_has_domain();
  ::mesos::DomainInfo* temp = domain_;
  domain_ = NULL;
  return temp;
}
inline ::mesos::DomainInfo* MasterInfo::mutable_domain() {
  set_has_domain();
  if (domain_ == NULL) {
    _slow_mutable_domain();
  }
  // @@protoc_insertion_point(field_mutable:mesos.MasterInfo.domain)
  return domain_;
}
inline void MasterInfo::set_allocated_domain(::mesos::DomainInfo* domain) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete domain_;
  }
  if (domain) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(domain);
    if (message_arena != submessage_arena) {
      domain = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, domain, submessage_arena);
    }
    set_has_domain();
  } else {
    clear_has_domain();
  }
  domain_ = domain;
  // @@protoc_insertion_point(field_set_allocated:mesos.MasterInfo.domain)
}

// repeated .mesos.MasterInfo.Capability capabilities = 9;
inline int MasterInfo::capabilities_size() const {
  return capabilities_.size();
}
inline void MasterInfo::clear_capabilities() {
  capabilities_.Clear();
}
inline const ::mesos::MasterInfo_Capability& MasterInfo::capabilities(int index) const {
  // @@protoc_insertion_point(field_get:mesos.MasterInfo.capabilities)
  return capabilities_.Get(index);
}
inline ::mesos::MasterInfo_Capability* MasterInfo::mutable_capabilities(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.MasterInfo.capabilities)
  return capabilities_.Mutable(index);
}
inline ::mesos::MasterInfo_Capability* MasterInfo::add_capabilities() {
  // @@protoc_insertion_point(field_add:mesos.MasterInfo.capabilities)
  return capabilities_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::MasterInfo_Capability >*
MasterInfo::mutable_capabilities() {
  // @@protoc_insertion_point(field_mutable_list:mesos.MasterInfo.capabilities)
  return &capabilities_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::MasterInfo_Capability >&
MasterInfo::capabilities() const {
  // @@protoc_insertion_point(field_list:mesos.MasterInfo.capabilities)
  return capabilities_;
}

// -------------------------------------------------------------------

// SlaveInfo_Capability

// optional .mesos.SlaveInfo.Capability.Type type = 1;
inline bool SlaveInfo_Capability::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SlaveInfo_Capability::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SlaveInfo_Capability::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SlaveInfo_Capability::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::mesos::SlaveInfo_Capability_Type SlaveInfo_Capability::type() const {
  // @@protoc_insertion_point(field_get:mesos.SlaveInfo.Capability.type)
  return static_cast< ::mesos::SlaveInfo_Capability_Type >(type_);
}
inline void SlaveInfo_Capability::set_type(::mesos::SlaveInfo_Capability_Type value) {
  assert(::mesos::SlaveInfo_Capability_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:mesos.SlaveInfo.Capability.type)
}

// -------------------------------------------------------------------

// SlaveInfo

// required string hostname = 1;
inline bool SlaveInfo::has_hostname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SlaveInfo::set_has_hostname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SlaveInfo::clear_has_hostname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SlaveInfo::clear_hostname() {
  hostname_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_hostname();
}
inline const ::std::string& SlaveInfo::hostname() const {
  // @@protoc_insertion_point(field_get:mesos.SlaveInfo.hostname)
  return hostname_.Get();
}
inline void SlaveInfo::set_hostname(const ::std::string& value) {
  set_has_hostname();
  hostname_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.SlaveInfo.hostname)
}
#if LANG_CXX11
inline void SlaveInfo::set_hostname(::std::string&& value) {
  set_has_hostname();
  hostname_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.SlaveInfo.hostname)
}
#endif
inline void SlaveInfo::set_hostname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_hostname();
  hostname_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.SlaveInfo.hostname)
}
inline void SlaveInfo::set_hostname(const char* value,
    size_t size) {
  set_has_hostname();
  hostname_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.SlaveInfo.hostname)
}
inline ::std::string* SlaveInfo::mutable_hostname() {
  set_has_hostname();
  // @@protoc_insertion_point(field_mutable:mesos.SlaveInfo.hostname)
  return hostname_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* SlaveInfo::release_hostname() {
  // @@protoc_insertion_point(field_release:mesos.SlaveInfo.hostname)
  clear_has_hostname();
  return hostname_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void SlaveInfo::set_allocated_hostname(::std::string* hostname) {
  if (hostname != NULL) {
    set_has_hostname();
  } else {
    clear_has_hostname();
  }
  hostname_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hostname,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.SlaveInfo.hostname)
}
inline ::std::string* SlaveInfo::unsafe_arena_release_hostname() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.SlaveInfo.hostname)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_hostname();
  return hostname_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void SlaveInfo::unsafe_arena_set_allocated_hostname(
    ::std::string* hostname) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (hostname != NULL) {
    set_has_hostname();
  } else {
    clear_has_hostname();
  }
  hostname_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      hostname, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.SlaveInfo.hostname)
}

// optional int32 port = 8 [default = 5051];
inline bool SlaveInfo::has_port() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SlaveInfo::set_has_port() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SlaveInfo::clear_has_port() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SlaveInfo::clear_port() {
  port_ = 5051;
  clear_has_port();
}
inline ::google::protobuf::int32 SlaveInfo::port() const {
  // @@protoc_insertion_point(field_get:mesos.SlaveInfo.port)
  return port_;
}
inline void SlaveInfo::set_port(::google::protobuf::int32 value) {
  set_has_port();
  port_ = value;
  // @@protoc_insertion_point(field_set:mesos.SlaveInfo.port)
}

// repeated .mesos.Resource resources = 3;
inline int SlaveInfo::resources_size() const {
  return resources_.size();
}
inline void SlaveInfo::clear_resources() {
  resources_.Clear();
}
inline const ::mesos::Resource& SlaveInfo::resources(int index) const {
  // @@protoc_insertion_point(field_get:mesos.SlaveInfo.resources)
  return resources_.Get(index);
}
inline ::mesos::Resource* SlaveInfo::mutable_resources(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.SlaveInfo.resources)
  return resources_.Mutable(index);
}
inline ::mesos::Resource* SlaveInfo::add_resources() {
  // @@protoc_insertion_point(field_add:mesos.SlaveInfo.resources)
  return resources_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
SlaveInfo::mutable_resources() {
  // @@protoc_insertion_point(field_mutable_list:mesos.SlaveInfo.resources)
  return &resources_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
SlaveInfo::resources() const {
  // @@protoc_insertion_point(field_list:mesos.SlaveInfo.resources)
  return resources_;
}

// repeated .mesos.Attribute attributes = 5;
inline int SlaveInfo::attributes_size() const {
  return attributes_.size();
}
inline void SlaveInfo::clear_attributes() {
  attributes_.Clear();
}
inline const ::mesos::Attribute& SlaveInfo::attributes(int index) const {
  // @@protoc_insertion_point(field_get:mesos.SlaveInfo.attributes)
  return attributes_.Get(index);
}
inline ::mesos::Attribute* SlaveInfo::mutable_attributes(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.SlaveInfo.attributes)
  return attributes_.Mutable(index);
}
inline ::mesos::Attribute* SlaveInfo::add_attributes() {
  // @@protoc_insertion_point(field_add:mesos.SlaveInfo.attributes)
  return attributes_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Attribute >*
SlaveInfo::mutable_attributes() {
  // @@protoc_insertion_point(field_mutable_list:mesos.SlaveInfo.attributes)
  return &attributes_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Attribute >&
SlaveInfo::attributes() const {
  // @@protoc_insertion_point(field_list:mesos.SlaveInfo.attributes)
  return attributes_;
}

// optional .mesos.SlaveID id = 6;
inline bool SlaveInfo::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SlaveInfo::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SlaveInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SlaveInfo::clear_id() {
  if (id_ != NULL) id_->Clear();
  clear_has_id();
}
inline const ::mesos::SlaveID& SlaveInfo::id() const {
  const ::mesos::SlaveID* p = id_;
  // @@protoc_insertion_point(field_get:mesos.SlaveInfo.id)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::SlaveID*>(
      &::mesos::_SlaveID_default_instance_);
}
inline ::mesos::SlaveID* SlaveInfo::release_id() {
  // @@protoc_insertion_point(field_release:mesos.SlaveInfo.id)
  clear_has_id();
  ::mesos::SlaveID* temp = id_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  id_ = NULL;
  return temp;
}
inline ::mesos::SlaveID* SlaveInfo::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.SlaveInfo.id)
  clear_has_id();
  ::mesos::SlaveID* temp = id_;
  id_ = NULL;
  return temp;
}
inline ::mesos::SlaveID* SlaveInfo::mutable_id() {
  set_has_id();
  if (id_ == NULL) {
    _slow_mutable_id();
  }
  // @@protoc_insertion_point(field_mutable:mesos.SlaveInfo.id)
  return id_;
}
inline void SlaveInfo::set_allocated_id(::mesos::SlaveID* id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete id_;
  }
  if (id) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(id);
    if (message_arena != submessage_arena) {
      id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    set_has_id();
  } else {
    clear_has_id();
  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:mesos.SlaveInfo.id)
}

// optional .mesos.DomainInfo domain = 10;
inline bool SlaveInfo::has_domain() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SlaveInfo::set_has_domain() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SlaveInfo::clear_has_domain() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SlaveInfo::clear_domain() {
  if (domain_ != NULL) domain_->Clear();
  clear_has_domain();
}
inline const ::mesos::DomainInfo& SlaveInfo::domain() const {
  const ::mesos::DomainInfo* p = domain_;
  // @@protoc_insertion_point(field_get:mesos.SlaveInfo.domain)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::DomainInfo*>(
      &::mesos::_DomainInfo_default_instance_);
}
inline ::mesos::DomainInfo* SlaveInfo::release_domain() {
  // @@protoc_insertion_point(field_release:mesos.SlaveInfo.domain)
  clear_has_domain();
  ::mesos::DomainInfo* temp = domain_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  domain_ = NULL;
  return temp;
}
inline ::mesos::DomainInfo* SlaveInfo::unsafe_arena_release_domain() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.SlaveInfo.domain)
  clear_has_domain();
  ::mesos::DomainInfo* temp = domain_;
  domain_ = NULL;
  return temp;
}
inline ::mesos::DomainInfo* SlaveInfo::mutable_domain() {
  set_has_domain();
  if (domain_ == NULL) {
    _slow_mutable_domain();
  }
  // @@protoc_insertion_point(field_mutable:mesos.SlaveInfo.domain)
  return domain_;
}
inline void SlaveInfo::set_allocated_domain(::mesos::DomainInfo* domain) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete domain_;
  }
  if (domain) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(domain);
    if (message_arena != submessage_arena) {
      domain = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, domain, submessage_arena);
    }
    set_has_domain();
  } else {
    clear_has_domain();
  }
  domain_ = domain;
  // @@protoc_insertion_point(field_set_allocated:mesos.SlaveInfo.domain)
}

// optional bool checkpoint = 7 [default = false];
inline bool SlaveInfo::has_checkpoint() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SlaveInfo::set_has_checkpoint() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SlaveInfo::clear_has_checkpoint() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SlaveInfo::clear_checkpoint() {
  checkpoint_ = false;
  clear_has_checkpoint();
}
inline bool SlaveInfo::checkpoint() const {
  // @@protoc_insertion_point(field_get:mesos.SlaveInfo.checkpoint)
  return checkpoint_;
}
inline void SlaveInfo::set_checkpoint(bool value) {
  set_has_checkpoint();
  checkpoint_ = value;
  // @@protoc_insertion_point(field_set:mesos.SlaveInfo.checkpoint)
}

// -------------------------------------------------------------------

// CSIPluginContainerInfo

// repeated .mesos.CSIPluginContainerInfo.Service services = 1;
inline int CSIPluginContainerInfo::services_size() const {
  return services_.size();
}
inline void CSIPluginContainerInfo::clear_services() {
  services_.Clear();
}
inline ::mesos::CSIPluginContainerInfo_Service CSIPluginContainerInfo::services(int index) const {
  // @@protoc_insertion_point(field_get:mesos.CSIPluginContainerInfo.services)
  return static_cast< ::mesos::CSIPluginContainerInfo_Service >(services_.Get(index));
}
inline void CSIPluginContainerInfo::set_services(int index, ::mesos::CSIPluginContainerInfo_Service value) {
  assert(::mesos::CSIPluginContainerInfo_Service_IsValid(value));
  services_.Set(index, value);
  // @@protoc_insertion_point(field_set:mesos.CSIPluginContainerInfo.services)
}
inline void CSIPluginContainerInfo::add_services(::mesos::CSIPluginContainerInfo_Service value) {
  assert(::mesos::CSIPluginContainerInfo_Service_IsValid(value));
  services_.Add(value);
  // @@protoc_insertion_point(field_add:mesos.CSIPluginContainerInfo.services)
}
inline const ::google::protobuf::RepeatedField<int>&
CSIPluginContainerInfo::services() const {
  // @@protoc_insertion_point(field_list:mesos.CSIPluginContainerInfo.services)
  return services_;
}
inline ::google::protobuf::RepeatedField<int>*
CSIPluginContainerInfo::mutable_services() {
  // @@protoc_insertion_point(field_mutable_list:mesos.CSIPluginContainerInfo.services)
  return &services_;
}

// optional .mesos.CommandInfo command = 2;
inline bool CSIPluginContainerInfo::has_command() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSIPluginContainerInfo::set_has_command() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSIPluginContainerInfo::clear_has_command() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSIPluginContainerInfo::clear_command() {
  if (command_ != NULL) command_->Clear();
  clear_has_command();
}
inline const ::mesos::CommandInfo& CSIPluginContainerInfo::command() const {
  const ::mesos::CommandInfo* p = command_;
  // @@protoc_insertion_point(field_get:mesos.CSIPluginContainerInfo.command)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::CommandInfo*>(
      &::mesos::_CommandInfo_default_instance_);
}
inline ::mesos::CommandInfo* CSIPluginContainerInfo::release_command() {
  // @@protoc_insertion_point(field_release:mesos.CSIPluginContainerInfo.command)
  clear_has_command();
  ::mesos::CommandInfo* temp = command_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  command_ = NULL;
  return temp;
}
inline ::mesos::CommandInfo* CSIPluginContainerInfo::unsafe_arena_release_command() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.CSIPluginContainerInfo.command)
  clear_has_command();
  ::mesos::CommandInfo* temp = command_;
  command_ = NULL;
  return temp;
}
inline ::mesos::CommandInfo* CSIPluginContainerInfo::mutable_command() {
  set_has_command();
  if (command_ == NULL) {
    _slow_mutable_command();
  }
  // @@protoc_insertion_point(field_mutable:mesos.CSIPluginContainerInfo.command)
  return command_;
}
inline void CSIPluginContainerInfo::set_allocated_command(::mesos::CommandInfo* command) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete command_;
  }
  if (command) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(command);
    if (message_arena != submessage_arena) {
      command = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, command, submessage_arena);
    }
    set_has_command();
  } else {
    clear_has_command();
  }
  command_ = command;
  // @@protoc_insertion_point(field_set_allocated:mesos.CSIPluginContainerInfo.command)
}

// repeated .mesos.Resource resources = 3;
inline int CSIPluginContainerInfo::resources_size() const {
  return resources_.size();
}
inline void CSIPluginContainerInfo::clear_resources() {
  resources_.Clear();
}
inline const ::mesos::Resource& CSIPluginContainerInfo::resources(int index) const {
  // @@protoc_insertion_point(field_get:mesos.CSIPluginContainerInfo.resources)
  return resources_.Get(index);
}
inline ::mesos::Resource* CSIPluginContainerInfo::mutable_resources(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.CSIPluginContainerInfo.resources)
  return resources_.Mutable(index);
}
inline ::mesos::Resource* CSIPluginContainerInfo::add_resources() {
  // @@protoc_insertion_point(field_add:mesos.CSIPluginContainerInfo.resources)
  return resources_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
CSIPluginContainerInfo::mutable_resources() {
  // @@protoc_insertion_point(field_mutable_list:mesos.CSIPluginContainerInfo.resources)
  return &resources_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
CSIPluginContainerInfo::resources() const {
  // @@protoc_insertion_point(field_list:mesos.CSIPluginContainerInfo.resources)
  return resources_;
}

// optional .mesos.ContainerInfo container = 4;
inline bool CSIPluginContainerInfo::has_container() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSIPluginContainerInfo::set_has_container() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSIPluginContainerInfo::clear_has_container() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSIPluginContainerInfo::clear_container() {
  if (container_ != NULL) container_->Clear();
  clear_has_container();
}
inline const ::mesos::ContainerInfo& CSIPluginContainerInfo::container() const {
  const ::mesos::ContainerInfo* p = container_;
  // @@protoc_insertion_point(field_get:mesos.CSIPluginContainerInfo.container)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ContainerInfo*>(
      &::mesos::_ContainerInfo_default_instance_);
}
inline ::mesos::ContainerInfo* CSIPluginContainerInfo::release_container() {
  // @@protoc_insertion_point(field_release:mesos.CSIPluginContainerInfo.container)
  clear_has_container();
  ::mesos::ContainerInfo* temp = container_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  container_ = NULL;
  return temp;
}
inline ::mesos::ContainerInfo* CSIPluginContainerInfo::unsafe_arena_release_container() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.CSIPluginContainerInfo.container)
  clear_has_container();
  ::mesos::ContainerInfo* temp = container_;
  container_ = NULL;
  return temp;
}
inline ::mesos::ContainerInfo* CSIPluginContainerInfo::mutable_container() {
  set_has_container();
  if (container_ == NULL) {
    _slow_mutable_container();
  }
  // @@protoc_insertion_point(field_mutable:mesos.CSIPluginContainerInfo.container)
  return container_;
}
inline void CSIPluginContainerInfo::set_allocated_container(::mesos::ContainerInfo* container) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete container_;
  }
  if (container) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(container);
    if (message_arena != submessage_arena) {
      container = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, container, submessage_arena);
    }
    set_has_container();
  } else {
    clear_has_container();
  }
  container_ = container;
  // @@protoc_insertion_point(field_set_allocated:mesos.CSIPluginContainerInfo.container)
}

// -------------------------------------------------------------------

// CSIPluginInfo

// required string type = 1;
inline bool CSIPluginInfo::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSIPluginInfo::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSIPluginInfo::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSIPluginInfo::clear_type() {
  type_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_type();
}
inline const ::std::string& CSIPluginInfo::type() const {
  // @@protoc_insertion_point(field_get:mesos.CSIPluginInfo.type)
  return type_.Get();
}
inline void CSIPluginInfo::set_type(const ::std::string& value) {
  set_has_type();
  type_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.CSIPluginInfo.type)
}
#if LANG_CXX11
inline void CSIPluginInfo::set_type(::std::string&& value) {
  set_has_type();
  type_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.CSIPluginInfo.type)
}
#endif
inline void CSIPluginInfo::set_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_type();
  type_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.CSIPluginInfo.type)
}
inline void CSIPluginInfo::set_type(const char* value,
    size_t size) {
  set_has_type();
  type_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.CSIPluginInfo.type)
}
inline ::std::string* CSIPluginInfo::mutable_type() {
  set_has_type();
  // @@protoc_insertion_point(field_mutable:mesos.CSIPluginInfo.type)
  return type_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* CSIPluginInfo::release_type() {
  // @@protoc_insertion_point(field_release:mesos.CSIPluginInfo.type)
  clear_has_type();
  return type_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void CSIPluginInfo::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    set_has_type();
  } else {
    clear_has_type();
  }
  type_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.CSIPluginInfo.type)
}
inline ::std::string* CSIPluginInfo::unsafe_arena_release_type() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.CSIPluginInfo.type)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_type();
  return type_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void CSIPluginInfo::unsafe_arena_set_allocated_type(
    ::std::string* type) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (type != NULL) {
    set_has_type();
  } else {
    clear_has_type();
  }
  type_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      type, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.CSIPluginInfo.type)
}

// required string name = 2;
inline bool CSIPluginInfo::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSIPluginInfo::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSIPluginInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSIPluginInfo::clear_name() {
  name_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_name();
}
inline const ::std::string& CSIPluginInfo::name() const {
  // @@protoc_insertion_point(field_get:mesos.CSIPluginInfo.name)
  return name_.Get();
}
inline void CSIPluginInfo::set_name(const ::std::string& value) {
  set_has_name();
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.CSIPluginInfo.name)
}
#if LANG_CXX11
inline void CSIPluginInfo::set_name(::std::string&& value) {
  set_has_name();
  name_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.CSIPluginInfo.name)
}
#endif
inline void CSIPluginInfo::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.CSIPluginInfo.name)
}
inline void CSIPluginInfo::set_name(const char* value,
    size_t size) {
  set_has_name();
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.CSIPluginInfo.name)
}
inline ::std::string* CSIPluginInfo::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:mesos.CSIPluginInfo.name)
  return name_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* CSIPluginInfo::release_name() {
  // @@protoc_insertion_point(field_release:mesos.CSIPluginInfo.name)
  clear_has_name();
  return name_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void CSIPluginInfo::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.CSIPluginInfo.name)
}
inline ::std::string* CSIPluginInfo::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.CSIPluginInfo.name)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_name();
  return name_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void CSIPluginInfo::unsafe_arena_set_allocated_name(
    ::std::string* name) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      name, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.CSIPluginInfo.name)
}

// repeated .mesos.CSIPluginContainerInfo containers = 3;
inline int CSIPluginInfo::containers_size() const {
  return containers_.size();
}
inline void CSIPluginInfo::clear_containers() {
  containers_.Clear();
}
inline const ::mesos::CSIPluginContainerInfo& CSIPluginInfo::containers(int index) const {
  // @@protoc_insertion_point(field_get:mesos.CSIPluginInfo.containers)
  return containers_.Get(index);
}
inline ::mesos::CSIPluginContainerInfo* CSIPluginInfo::mutable_containers(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.CSIPluginInfo.containers)
  return containers_.Mutable(index);
}
inline ::mesos::CSIPluginContainerInfo* CSIPluginInfo::add_containers() {
  // @@protoc_insertion_point(field_add:mesos.CSIPluginInfo.containers)
  return containers_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::CSIPluginContainerInfo >*
CSIPluginInfo::mutable_containers() {
  // @@protoc_insertion_point(field_mutable_list:mesos.CSIPluginInfo.containers)
  return &containers_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::CSIPluginContainerInfo >&
CSIPluginInfo::containers() const {
  // @@protoc_insertion_point(field_list:mesos.CSIPluginInfo.containers)
  return containers_;
}

// -------------------------------------------------------------------

// ResourceProviderInfo_Storage

// required .mesos.CSIPluginInfo plugin = 1;
inline bool ResourceProviderInfo_Storage::has_plugin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResourceProviderInfo_Storage::set_has_plugin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResourceProviderInfo_Storage::clear_has_plugin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResourceProviderInfo_Storage::clear_plugin() {
  if (plugin_ != NULL) plugin_->Clear();
  clear_has_plugin();
}
inline const ::mesos::CSIPluginInfo& ResourceProviderInfo_Storage::plugin() const {
  const ::mesos::CSIPluginInfo* p = plugin_;
  // @@protoc_insertion_point(field_get:mesos.ResourceProviderInfo.Storage.plugin)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::CSIPluginInfo*>(
      &::mesos::_CSIPluginInfo_default_instance_);
}
inline ::mesos::CSIPluginInfo* ResourceProviderInfo_Storage::release_plugin() {
  // @@protoc_insertion_point(field_release:mesos.ResourceProviderInfo.Storage.plugin)
  clear_has_plugin();
  ::mesos::CSIPluginInfo* temp = plugin_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  plugin_ = NULL;
  return temp;
}
inline ::mesos::CSIPluginInfo* ResourceProviderInfo_Storage::unsafe_arena_release_plugin() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.ResourceProviderInfo.Storage.plugin)
  clear_has_plugin();
  ::mesos::CSIPluginInfo* temp = plugin_;
  plugin_ = NULL;
  return temp;
}
inline ::mesos::CSIPluginInfo* ResourceProviderInfo_Storage::mutable_plugin() {
  set_has_plugin();
  if (plugin_ == NULL) {
    _slow_mutable_plugin();
  }
  // @@protoc_insertion_point(field_mutable:mesos.ResourceProviderInfo.Storage.plugin)
  return plugin_;
}
inline void ResourceProviderInfo_Storage::set_allocated_plugin(::mesos::CSIPluginInfo* plugin) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete plugin_;
  }
  if (plugin) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(plugin);
    if (message_arena != submessage_arena) {
      plugin = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, plugin, submessage_arena);
    }
    set_has_plugin();
  } else {
    clear_has_plugin();
  }
  plugin_ = plugin;
  // @@protoc_insertion_point(field_set_allocated:mesos.ResourceProviderInfo.Storage.plugin)
}

// -------------------------------------------------------------------

// ResourceProviderInfo

// optional .mesos.ResourceProviderID id = 1;
inline bool ResourceProviderInfo::has_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResourceProviderInfo::set_has_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResourceProviderInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResourceProviderInfo::clear_id() {
  if (id_ != NULL) id_->Clear();
  clear_has_id();
}
inline const ::mesos::ResourceProviderID& ResourceProviderInfo::id() const {
  const ::mesos::ResourceProviderID* p = id_;
  // @@protoc_insertion_point(field_get:mesos.ResourceProviderInfo.id)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ResourceProviderID*>(
      &::mesos::_ResourceProviderID_default_instance_);
}
inline ::mesos::ResourceProviderID* ResourceProviderInfo::release_id() {
  // @@protoc_insertion_point(field_release:mesos.ResourceProviderInfo.id)
  clear_has_id();
  ::mesos::ResourceProviderID* temp = id_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  id_ = NULL;
  return temp;
}
inline ::mesos::ResourceProviderID* ResourceProviderInfo::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.ResourceProviderInfo.id)
  clear_has_id();
  ::mesos::ResourceProviderID* temp = id_;
  id_ = NULL;
  return temp;
}
inline ::mesos::ResourceProviderID* ResourceProviderInfo::mutable_id() {
  set_has_id();
  if (id_ == NULL) {
    _slow_mutable_id();
  }
  // @@protoc_insertion_point(field_mutable:mesos.ResourceProviderInfo.id)
  return id_;
}
inline void ResourceProviderInfo::set_allocated_id(::mesos::ResourceProviderID* id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete id_;
  }
  if (id) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(id);
    if (message_arena != submessage_arena) {
      id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    set_has_id();
  } else {
    clear_has_id();
  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:mesos.ResourceProviderInfo.id)
}

// repeated .mesos.Attribute attributes = 2;
inline int ResourceProviderInfo::attributes_size() const {
  return attributes_.size();
}
inline void ResourceProviderInfo::clear_attributes() {
  attributes_.Clear();
}
inline const ::mesos::Attribute& ResourceProviderInfo::attributes(int index) const {
  // @@protoc_insertion_point(field_get:mesos.ResourceProviderInfo.attributes)
  return attributes_.Get(index);
}
inline ::mesos::Attribute* ResourceProviderInfo::mutable_attributes(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.ResourceProviderInfo.attributes)
  return attributes_.Mutable(index);
}
inline ::mesos::Attribute* ResourceProviderInfo::add_attributes() {
  // @@protoc_insertion_point(field_add:mesos.ResourceProviderInfo.attributes)
  return attributes_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Attribute >*
ResourceProviderInfo::mutable_attributes() {
  // @@protoc_insertion_point(field_mutable_list:mesos.ResourceProviderInfo.attributes)
  return &attributes_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Attribute >&
ResourceProviderInfo::attributes() const {
  // @@protoc_insertion_point(field_list:mesos.ResourceProviderInfo.attributes)
  return attributes_;
}

// required string type = 3;
inline bool ResourceProviderInfo::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResourceProviderInfo::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResourceProviderInfo::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResourceProviderInfo::clear_type() {
  type_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_type();
}
inline const ::std::string& ResourceProviderInfo::type() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceProviderInfo.type)
  return type_.Get();
}
inline void ResourceProviderInfo::set_type(const ::std::string& value) {
  set_has_type();
  type_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.ResourceProviderInfo.type)
}
#if LANG_CXX11
inline void ResourceProviderInfo::set_type(::std::string&& value) {
  set_has_type();
  type_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.ResourceProviderInfo.type)
}
#endif
inline void ResourceProviderInfo::set_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_type();
  type_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.ResourceProviderInfo.type)
}
inline void ResourceProviderInfo::set_type(const char* value,
    size_t size) {
  set_has_type();
  type_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.ResourceProviderInfo.type)
}
inline ::std::string* ResourceProviderInfo::mutable_type() {
  set_has_type();
  // @@protoc_insertion_point(field_mutable:mesos.ResourceProviderInfo.type)
  return type_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* ResourceProviderInfo::release_type() {
  // @@protoc_insertion_point(field_release:mesos.ResourceProviderInfo.type)
  clear_has_type();
  return type_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void ResourceProviderInfo::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    set_has_type();
  } else {
    clear_has_type();
  }
  type_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.ResourceProviderInfo.type)
}
inline ::std::string* ResourceProviderInfo::unsafe_arena_release_type() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.ResourceProviderInfo.type)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_type();
  return type_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void ResourceProviderInfo::unsafe_arena_set_allocated_type(
    ::std::string* type) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (type != NULL) {
    set_has_type();
  } else {
    clear_has_type();
  }
  type_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      type, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.ResourceProviderInfo.type)
}

// required string name = 4;
inline bool ResourceProviderInfo::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResourceProviderInfo::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResourceProviderInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResourceProviderInfo::clear_name() {
  name_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_name();
}
inline const ::std::string& ResourceProviderInfo::name() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceProviderInfo.name)
  return name_.Get();
}
inline void ResourceProviderInfo::set_name(const ::std::string& value) {
  set_has_name();
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.ResourceProviderInfo.name)
}
#if LANG_CXX11
inline void ResourceProviderInfo::set_name(::std::string&& value) {
  set_has_name();
  name_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.ResourceProviderInfo.name)
}
#endif
inline void ResourceProviderInfo::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.ResourceProviderInfo.name)
}
inline void ResourceProviderInfo::set_name(const char* value,
    size_t size) {
  set_has_name();
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.ResourceProviderInfo.name)
}
inline ::std::string* ResourceProviderInfo::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:mesos.ResourceProviderInfo.name)
  return name_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* ResourceProviderInfo::release_name() {
  // @@protoc_insertion_point(field_release:mesos.ResourceProviderInfo.name)
  clear_has_name();
  return name_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void ResourceProviderInfo::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.ResourceProviderInfo.name)
}
inline ::std::string* ResourceProviderInfo::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.ResourceProviderInfo.name)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_name();
  return name_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void ResourceProviderInfo::unsafe_arena_set_allocated_name(
    ::std::string* name) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      name, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.ResourceProviderInfo.name)
}

// repeated .mesos.Resource.ReservationInfo default_reservations = 5;
inline int ResourceProviderInfo::default_reservations_size() const {
  return default_reservations_.size();
}
inline void ResourceProviderInfo::clear_default_reservations() {
  default_reservations_.Clear();
}
inline const ::mesos::Resource_ReservationInfo& ResourceProviderInfo::default_reservations(int index) const {
  // @@protoc_insertion_point(field_get:mesos.ResourceProviderInfo.default_reservations)
  return default_reservations_.Get(index);
}
inline ::mesos::Resource_ReservationInfo* ResourceProviderInfo::mutable_default_reservations(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.ResourceProviderInfo.default_reservations)
  return default_reservations_.Mutable(index);
}
inline ::mesos::Resource_ReservationInfo* ResourceProviderInfo::add_default_reservations() {
  // @@protoc_insertion_point(field_add:mesos.ResourceProviderInfo.default_reservations)
  return default_reservations_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource_ReservationInfo >*
ResourceProviderInfo::mutable_default_reservations() {
  // @@protoc_insertion_point(field_mutable_list:mesos.ResourceProviderInfo.default_reservations)
  return &default_reservations_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource_ReservationInfo >&
ResourceProviderInfo::default_reservations() const {
  // @@protoc_insertion_point(field_list:mesos.ResourceProviderInfo.default_reservations)
  return default_reservations_;
}

// optional .mesos.ResourceProviderInfo.Storage storage = 6;
inline bool ResourceProviderInfo::has_storage() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ResourceProviderInfo::set_has_storage() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ResourceProviderInfo::clear_has_storage() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ResourceProviderInfo::clear_storage() {
  if (storage_ != NULL) storage_->Clear();
  clear_has_storage();
}
inline const ::mesos::ResourceProviderInfo_Storage& ResourceProviderInfo::storage() const {
  const ::mesos::ResourceProviderInfo_Storage* p = storage_;
  // @@protoc_insertion_point(field_get:mesos.ResourceProviderInfo.storage)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ResourceProviderInfo_Storage*>(
      &::mesos::_ResourceProviderInfo_Storage_default_instance_);
}
inline ::mesos::ResourceProviderInfo_Storage* ResourceProviderInfo::release_storage() {
  // @@protoc_insertion_point(field_release:mesos.ResourceProviderInfo.storage)
  clear_has_storage();
  ::mesos::ResourceProviderInfo_Storage* temp = storage_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  storage_ = NULL;
  return temp;
}
inline ::mesos::ResourceProviderInfo_Storage* ResourceProviderInfo::unsafe_arena_release_storage() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.ResourceProviderInfo.storage)
  clear_has_storage();
  ::mesos::ResourceProviderInfo_Storage* temp = storage_;
  storage_ = NULL;
  return temp;
}
inline ::mesos::ResourceProviderInfo_Storage* ResourceProviderInfo::mutable_storage() {
  set_has_storage();
  if (storage_ == NULL) {
    _slow_mutable_storage();
  }
  // @@protoc_insertion_point(field_mutable:mesos.ResourceProviderInfo.storage)
  return storage_;
}
inline void ResourceProviderInfo::set_allocated_storage(::mesos::ResourceProviderInfo_Storage* storage) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete storage_;
  }
  if (storage) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(storage);
    if (message_arena != submessage_arena) {
      storage = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, storage, submessage_arena);
    }
    set_has_storage();
  } else {
    clear_has_storage();
  }
  storage_ = storage;
  // @@protoc_insertion_point(field_set_allocated:mesos.ResourceProviderInfo.storage)
}

// -------------------------------------------------------------------

// Value_Scalar

// required double value = 1;
inline bool Value_Scalar::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Value_Scalar::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Value_Scalar::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Value_Scalar::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline double Value_Scalar::value() const {
  // @@protoc_insertion_point(field_get:mesos.Value.Scalar.value)
  return value_;
}
inline void Value_Scalar::set_value(double value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:mesos.Value.Scalar.value)
}

// -------------------------------------------------------------------

// Value_Range

// required uint64 begin = 1;
inline bool Value_Range::has_begin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Value_Range::set_has_begin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Value_Range::clear_has_begin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Value_Range::clear_begin() {
  begin_ = GOOGLE_ULONGLONG(0);
  clear_has_begin();
}
inline ::google::protobuf::uint64 Value_Range::begin() const {
  // @@protoc_insertion_point(field_get:mesos.Value.Range.begin)
  return begin_;
}
inline void Value_Range::set_begin(::google::protobuf::uint64 value) {
  set_has_begin();
  begin_ = value;
  // @@protoc_insertion_point(field_set:mesos.Value.Range.begin)
}

// required uint64 end = 2;
inline bool Value_Range::has_end() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Value_Range::set_has_end() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Value_Range::clear_has_end() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Value_Range::clear_end() {
  end_ = GOOGLE_ULONGLONG(0);
  clear_has_end();
}
inline ::google::protobuf::uint64 Value_Range::end() const {
  // @@protoc_insertion_point(field_get:mesos.Value.Range.end)
  return end_;
}
inline void Value_Range::set_end(::google::protobuf::uint64 value) {
  set_has_end();
  end_ = value;
  // @@protoc_insertion_point(field_set:mesos.Value.Range.end)
}

// -------------------------------------------------------------------

// Value_Ranges

// repeated .mesos.Value.Range range = 1;
inline int Value_Ranges::range_size() const {
  return range_.size();
}
inline void Value_Ranges::clear_range() {
  range_.Clear();
}
inline const ::mesos::Value_Range& Value_Ranges::range(int index) const {
  // @@protoc_insertion_point(field_get:mesos.Value.Ranges.range)
  return range_.Get(index);
}
inline ::mesos::Value_Range* Value_Ranges::mutable_range(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.Value.Ranges.range)
  return range_.Mutable(index);
}
inline ::mesos::Value_Range* Value_Ranges::add_range() {
  // @@protoc_insertion_point(field_add:mesos.Value.Ranges.range)
  return range_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Value_Range >*
Value_Ranges::mutable_range() {
  // @@protoc_insertion_point(field_mutable_list:mesos.Value.Ranges.range)
  return &range_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Value_Range >&
Value_Ranges::range() const {
  // @@protoc_insertion_point(field_list:mesos.Value.Ranges.range)
  return range_;
}

// -------------------------------------------------------------------

// Value_Set

// repeated string item = 1;
inline int Value_Set::item_size() const {
  return item_.size();
}
inline void Value_Set::clear_item() {
  item_.Clear();
}
inline const ::std::string& Value_Set::item(int index) const {
  // @@protoc_insertion_point(field_get:mesos.Value.Set.item)
  return item_.Get(index);
}
inline ::std::string* Value_Set::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.Value.Set.item)
  return item_.Mutable(index);
}
inline void Value_Set::set_item(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:mesos.Value.Set.item)
  item_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Value_Set::set_item(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:mesos.Value.Set.item)
  item_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Value_Set::set_item(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  item_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.Value.Set.item)
}
inline void Value_Set::set_item(int index, const char* value, size_t size) {
  item_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.Value.Set.item)
}
inline ::std::string* Value_Set::add_item() {
  // @@protoc_insertion_point(field_add_mutable:mesos.Value.Set.item)
  return item_.Add();
}
inline void Value_Set::add_item(const ::std::string& value) {
  item_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:mesos.Value.Set.item)
}
#if LANG_CXX11
inline void Value_Set::add_item(::std::string&& value) {
  item_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:mesos.Value.Set.item)
}
#endif
inline void Value_Set::add_item(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  item_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:mesos.Value.Set.item)
}
inline void Value_Set::add_item(const char* value, size_t size) {
  item_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:mesos.Value.Set.item)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Value_Set::item() const {
  // @@protoc_insertion_point(field_list:mesos.Value.Set.item)
  return item_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Value_Set::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:mesos.Value.Set.item)
  return &item_;
}

// -------------------------------------------------------------------

// Value_Text

// required string value = 1;
inline bool Value_Text::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Value_Text::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Value_Text::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Value_Text::clear_value() {
  value_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_value();
}
inline const ::std::string& Value_Text::value() const {
  // @@protoc_insertion_point(field_get:mesos.Value.Text.value)
  return value_.Get();
}
inline void Value_Text::set_value(const ::std::string& value) {
  set_has_value();
  value_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.Value.Text.value)
}
#if LANG_CXX11
inline void Value_Text::set_value(::std::string&& value) {
  set_has_value();
  value_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.Value.Text.value)
}
#endif
inline void Value_Text::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_value();
  value_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.Value.Text.value)
}
inline void Value_Text::set_value(const char* value,
    size_t size) {
  set_has_value();
  value_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.Value.Text.value)
}
inline ::std::string* Value_Text::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:mesos.Value.Text.value)
  return value_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* Value_Text::release_value() {
  // @@protoc_insertion_point(field_release:mesos.Value.Text.value)
  clear_has_value();
  return value_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void Value_Text::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.Value.Text.value)
}
inline ::std::string* Value_Text::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Value.Text.value)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_value();
  return value_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void Value_Text::unsafe_arena_set_allocated_value(
    ::std::string* value) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.Value.Text.value)
}

// -------------------------------------------------------------------

// Value

// required .mesos.Value.Type type = 1;
inline bool Value::has_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Value::set_has_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Value::clear_has_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Value::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::mesos::Value_Type Value::type() const {
  // @@protoc_insertion_point(field_get:mesos.Value.type)
  return static_cast< ::mesos::Value_Type >(type_);
}
inline void Value::set_type(::mesos::Value_Type value) {
  assert(::mesos::Value_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:mesos.Value.type)
}

// optional .mesos.Value.Scalar scalar = 2;
inline bool Value::has_scalar() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Value::set_has_scalar() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Value::clear_has_scalar() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Value::clear_scalar() {
  if (scalar_ != NULL) scalar_->Clear();
  clear_has_scalar();
}
inline const ::mesos::Value_Scalar& Value::scalar() const {
  const ::mesos::Value_Scalar* p = scalar_;
  // @@protoc_insertion_point(field_get:mesos.Value.scalar)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::Value_Scalar*>(
      &::mesos::_Value_Scalar_default_instance_);
}
inline ::mesos::Value_Scalar* Value::release_scalar() {
  // @@protoc_insertion_point(field_release:mesos.Value.scalar)
  clear_has_scalar();
  ::mesos::Value_Scalar* temp = scalar_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  scalar_ = NULL;
  return temp;
}
inline ::mesos::Value_Scalar* Value::unsafe_arena_release_scalar() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Value.scalar)
  clear_has_scalar();
  ::mesos::Value_Scalar* temp = scalar_;
  scalar_ = NULL;
  return temp;
}
inline ::mesos::Value_Scalar* Value::mutable_scalar() {
  set_has_scalar();
  if (scalar_ == NULL) {
    _slow_mutable_scalar();
  }
  // @@protoc_insertion_point(field_mutable:mesos.Value.scalar)
  return scalar_;
}
inline void Value::set_allocated_scalar(::mesos::Value_Scalar* scalar) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete scalar_;
  }
  if (scalar) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(scalar);
    if (message_arena != submessage_arena) {
      scalar = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, scalar, submessage_arena);
    }
    set_has_scalar();
  } else {
    clear_has_scalar();
  }
  scalar_ = scalar;
  // @@protoc_insertion_point(field_set_allocated:mesos.Value.scalar)
}

// optional .mesos.Value.Ranges ranges = 3;
inline bool Value::has_ranges() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Value::set_has_ranges() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Value::clear_has_ranges() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Value::clear_ranges() {
  if (ranges_ != NULL) ranges_->Clear();
  clear_has_ranges();
}
inline const ::mesos::Value_Ranges& Value::ranges() const {
  const ::mesos::Value_Ranges* p = ranges_;
  // @@protoc_insertion_point(field_get:mesos.Value.ranges)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::Value_Ranges*>(
      &::mesos::_Value_Ranges_default_instance_);
}
inline ::mesos::Value_Ranges* Value::release_ranges() {
  // @@protoc_insertion_point(field_release:mesos.Value.ranges)
  clear_has_ranges();
  ::mesos::Value_Ranges* temp = ranges_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  ranges_ = NULL;
  return temp;
}
inline ::mesos::Value_Ranges* Value::unsafe_arena_release_ranges() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Value.ranges)
  clear_has_ranges();
  ::mesos::Value_Ranges* temp = ranges_;
  ranges_ = NULL;
  return temp;
}
inline ::mesos::Value_Ranges* Value::mutable_ranges() {
  set_has_ranges();
  if (ranges_ == NULL) {
    _slow_mutable_ranges();
  }
  // @@protoc_insertion_point(field_mutable:mesos.Value.ranges)
  return ranges_;
}
inline void Value::set_allocated_ranges(::mesos::Value_Ranges* ranges) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete ranges_;
  }
  if (ranges) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(ranges);
    if (message_arena != submessage_arena) {
      ranges = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ranges, submessage_arena);
    }
    set_has_ranges();
  } else {
    clear_has_ranges();
  }
  ranges_ = ranges;
  // @@protoc_insertion_point(field_set_allocated:mesos.Value.ranges)
}

// optional .mesos.Value.Set set = 4;
inline bool Value::has_set() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Value::set_has_set() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Value::clear_has_set() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Value::clear_set() {
  if (set_ != NULL) set_->Clear();
  clear_has_set();
}
inline const ::mesos::Value_Set& Value::set() const {
  const ::mesos::Value_Set* p = set_;
  // @@protoc_insertion_point(field_get:mesos.Value.set)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::Value_Set*>(
      &::mesos::_Value_Set_default_instance_);
}
inline ::mesos::Value_Set* Value::release_set() {
  // @@protoc_insertion_point(field_release:mesos.Value.set)
  clear_has_set();
  ::mesos::Value_Set* temp = set_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  set_ = NULL;
  return temp;
}
inline ::mesos::Value_Set* Value::unsafe_arena_release_set() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Value.set)
  clear_has_set();
  ::mesos::Value_Set* temp = set_;
  set_ = NULL;
  return temp;
}
inline ::mesos::Value_Set* Value::mutable_set() {
  set_has_set();
  if (set_ == NULL) {
    _slow_mutable_set();
  }
  // @@protoc_insertion_point(field_mutable:mesos.Value.set)
  return set_;
}
inline void Value::set_allocated_set(::mesos::Value_Set* set) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete set_;
  }
  if (set) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(set);
    if (message_arena != submessage_arena) {
      set = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, set, submessage_arena);
    }
    set_has_set();
  } else {
    clear_has_set();
  }
  set_ = set;
  // @@protoc_insertion_point(field_set_allocated:mesos.Value.set)
}

// optional .mesos.Value.Text text = 5;
inline bool Value::has_text() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Value::set_has_text() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Value::clear_has_text() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Value::clear_text() {
  if (text_ != NULL) text_->Clear();
  clear_has_text();
}
inline const ::mesos::Value_Text& Value::text() const {
  const ::mesos::Value_Text* p = text_;
  // @@protoc_insertion_point(field_get:mesos.Value.text)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::Value_Text*>(
      &::mesos::_Value_Text_default_instance_);
}
inline ::mesos::Value_Text* Value::release_text() {
  // @@protoc_insertion_point(field_release:mesos.Value.text)
  clear_has_text();
  ::mesos::Value_Text* temp = text_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  text_ = NULL;
  return temp;
}
inline ::mesos::Value_Text* Value::unsafe_arena_release_text() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Value.text)
  clear_has_text();
  ::mesos::Value_Text* temp = text_;
  text_ = NULL;
  return temp;
}
inline ::mesos::Value_Text* Value::mutable_text() {
  set_has_text();
  if (text_ == NULL) {
    _slow_mutable_text();
  }
  // @@protoc_insertion_point(field_mutable:mesos.Value.text)
  return text_;
}
inline void Value::set_allocated_text(::mesos::Value_Text* text) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete text_;
  }
  if (text) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(text);
    if (message_arena != submessage_arena) {
      text = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, text, submessage_arena);
    }
    set_has_text();
  } else {
    clear_has_text();
  }
  text_ = text;
  // @@protoc_insertion_point(field_set_allocated:mesos.Value.text)
}

// -------------------------------------------------------------------

// Attribute

// required string name = 1;
inline bool Attribute::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Attribute::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Attribute::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Attribute::clear_name() {
  name_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_name();
}
inline const ::std::string& Attribute::name() const {
  // @@protoc_insertion_point(field_get:mesos.Attribute.name)
  return name_.Get();
}
inline void Attribute::set_name(const ::std::string& value) {
  set_has_name();
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.Attribute.name)
}
#if LANG_CXX11
inline void Attribute::set_name(::std::string&& value) {
  set_has_name();
  name_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.Attribute.name)
}
#endif
inline void Attribute::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.Attribute.name)
}
inline void Attribute::set_name(const char* value,
    size_t size) {
  set_has_name();
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.Attribute.name)
}
inline ::std::string* Attribute::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:mesos.Attribute.name)
  return name_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* Attribute::release_name() {
  // @@protoc_insertion_point(field_release:mesos.Attribute.name)
  clear_has_name();
  return name_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void Attribute::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.Attribute.name)
}
inline ::std::string* Attribute::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Attribute.name)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_name();
  return name_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void Attribute::unsafe_arena_set_allocated_name(
    ::std::string* name) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      name, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.Attribute.name)
}

// required .mesos.Value.Type type = 2;
inline bool Attribute::has_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Attribute::set_has_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Attribute::clear_has_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Attribute::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::mesos::Value_Type Attribute::type() const {
  // @@protoc_insertion_point(field_get:mesos.Attribute.type)
  return static_cast< ::mesos::Value_Type >(type_);
}
inline void Attribute::set_type(::mesos::Value_Type value) {
  assert(::mesos::Value_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:mesos.Attribute.type)
}

// optional .mesos.Value.Scalar scalar = 3;
inline bool Attribute::has_scalar() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Attribute::set_has_scalar() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Attribute::clear_has_scalar() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Attribute::clear_scalar() {
  if (scalar_ != NULL) scalar_->Clear();
  clear_has_scalar();
}
inline const ::mesos::Value_Scalar& Attribute::scalar() const {
  const ::mesos::Value_Scalar* p = scalar_;
  // @@protoc_insertion_point(field_get:mesos.Attribute.scalar)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::Value_Scalar*>(
      &::mesos::_Value_Scalar_default_instance_);
}
inline ::mesos::Value_Scalar* Attribute::release_scalar() {
  // @@protoc_insertion_point(field_release:mesos.Attribute.scalar)
  clear_has_scalar();
  ::mesos::Value_Scalar* temp = scalar_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  scalar_ = NULL;
  return temp;
}
inline ::mesos::Value_Scalar* Attribute::unsafe_arena_release_scalar() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Attribute.scalar)
  clear_has_scalar();
  ::mesos::Value_Scalar* temp = scalar_;
  scalar_ = NULL;
  return temp;
}
inline ::mesos::Value_Scalar* Attribute::mutable_scalar() {
  set_has_scalar();
  if (scalar_ == NULL) {
    _slow_mutable_scalar();
  }
  // @@protoc_insertion_point(field_mutable:mesos.Attribute.scalar)
  return scalar_;
}
inline void Attribute::set_allocated_scalar(::mesos::Value_Scalar* scalar) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete scalar_;
  }
  if (scalar) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(scalar);
    if (message_arena != submessage_arena) {
      scalar = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, scalar, submessage_arena);
    }
    set_has_scalar();
  } else {
    clear_has_scalar();
  }
  scalar_ = scalar;
  // @@protoc_insertion_point(field_set_allocated:mesos.Attribute.scalar)
}

// optional .mesos.Value.Ranges ranges = 4;
inline bool Attribute::has_ranges() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Attribute::set_has_ranges() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Attribute::clear_has_ranges() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Attribute::clear_ranges() {
  if (ranges_ != NULL) ranges_->Clear();
  clear_has_ranges();
}
inline const ::mesos::Value_Ranges& Attribute::ranges() const {
  const ::mesos::Value_Ranges* p = ranges_;
  // @@protoc_insertion_point(field_get:mesos.Attribute.ranges)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::Value_Ranges*>(
      &::mesos::_Value_Ranges_default_instance_);
}
inline ::mesos::Value_Ranges* Attribute::release_ranges() {
  // @@protoc_insertion_point(field_release:mesos.Attribute.ranges)
  clear_has_ranges();
  ::mesos::Value_Ranges* temp = ranges_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  ranges_ = NULL;
  return temp;
}
inline ::mesos::Value_Ranges* Attribute::unsafe_arena_release_ranges() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Attribute.ranges)
  clear_has_ranges();
  ::mesos::Value_Ranges* temp = ranges_;
  ranges_ = NULL;
  return temp;
}
inline ::mesos::Value_Ranges* Attribute::mutable_ranges() {
  set_has_ranges();
  if (ranges_ == NULL) {
    _slow_mutable_ranges();
  }
  // @@protoc_insertion_point(field_mutable:mesos.Attribute.ranges)
  return ranges_;
}
inline void Attribute::set_allocated_ranges(::mesos::Value_Ranges* ranges) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete ranges_;
  }
  if (ranges) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(ranges);
    if (message_arena != submessage_arena) {
      ranges = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ranges, submessage_arena);
    }
    set_has_ranges();
  } else {
    clear_has_ranges();
  }
  ranges_ = ranges;
  // @@protoc_insertion_point(field_set_allocated:mesos.Attribute.ranges)
}

// optional .mesos.Value.Set set = 6;
inline bool Attribute::has_set() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Attribute::set_has_set() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Attribute::clear_has_set() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Attribute::clear_set() {
  if (set_ != NULL) set_->Clear();
  clear_has_set();
}
inline const ::mesos::Value_Set& Attribute::set() const {
  const ::mesos::Value_Set* p = set_;
  // @@protoc_insertion_point(field_get:mesos.Attribute.set)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::Value_Set*>(
      &::mesos::_Value_Set_default_instance_);
}
inline ::mesos::Value_Set* Attribute::release_set() {
  // @@protoc_insertion_point(field_release:mesos.Attribute.set)
  clear_has_set();
  ::mesos::Value_Set* temp = set_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  set_ = NULL;
  return temp;
}
inline ::mesos::Value_Set* Attribute::unsafe_arena_release_set() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Attribute.set)
  clear_has_set();
  ::mesos::Value_Set* temp = set_;
  set_ = NULL;
  return temp;
}
inline ::mesos::Value_Set* Attribute::mutable_set() {
  set_has_set();
  if (set_ == NULL) {
    _slow_mutable_set();
  }
  // @@protoc_insertion_point(field_mutable:mesos.Attribute.set)
  return set_;
}
inline void Attribute::set_allocated_set(::mesos::Value_Set* set) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete set_;
  }
  if (set) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(set);
    if (message_arena != submessage_arena) {
      set = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, set, submessage_arena);
    }
    set_has_set();
  } else {
    clear_has_set();
  }
  set_ = set;
  // @@protoc_insertion_point(field_set_allocated:mesos.Attribute.set)
}

// optional .mesos.Value.Text text = 5;
inline bool Attribute::has_text() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Attribute::set_has_text() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Attribute::clear_has_text() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Attribute::clear_text() {
  if (text_ != NULL) text_->Clear();
  clear_has_text();
}
inline const ::mesos::Value_Text& Attribute::text() const {
  const ::mesos::Value_Text* p = text_;
  // @@protoc_insertion_point(field_get:mesos.Attribute.text)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::Value_Text*>(
      &::mesos::_Value_Text_default_instance_);
}
inline ::mesos::Value_Text* Attribute::release_text() {
  // @@protoc_insertion_point(field_release:mesos.Attribute.text)
  clear_has_text();
  ::mesos::Value_Text* temp = text_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  text_ = NULL;
  return temp;
}
inline ::mesos::Value_Text* Attribute::unsafe_arena_release_text() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Attribute.text)
  clear_has_text();
  ::mesos::Value_Text* temp = text_;
  text_ = NULL;
  return temp;
}
inline ::mesos::Value_Text* Attribute::mutable_text() {
  set_has_text();
  if (text_ == NULL) {
    _slow_mutable_text();
  }
  // @@protoc_insertion_point(field_mutable:mesos.Attribute.text)
  return text_;
}
inline void Attribute::set_allocated_text(::mesos::Value_Text* text) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete text_;
  }
  if (text) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(text);
    if (message_arena != submessage_arena) {
      text = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, text, submessage_arena);
    }
    set_has_text();
  } else {
    clear_has_text();
  }
  text_ = text;
  // @@protoc_insertion_point(field_set_allocated:mesos.Attribute.text)
}

// -------------------------------------------------------------------

// Resource_AllocationInfo

// optional string role = 1;
inline bool Resource_AllocationInfo::has_role() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Resource_AllocationInfo::set_has_role() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Resource_AllocationInfo::clear_has_role() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Resource_AllocationInfo::clear_role() {
  role_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_role();
}
inline const ::std::string& Resource_AllocationInfo::role() const {
  // @@protoc_insertion_point(field_get:mesos.Resource.AllocationInfo.role)
  return role_.Get();
}
inline void Resource_AllocationInfo::set_role(const ::std::string& value) {
  set_has_role();
  role_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.Resource.AllocationInfo.role)
}
#if LANG_CXX11
inline void Resource_AllocationInfo::set_role(::std::string&& value) {
  set_has_role();
  role_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.Resource.AllocationInfo.role)
}
#endif
inline void Resource_AllocationInfo::set_role(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_role();
  role_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.Resource.AllocationInfo.role)
}
inline void Resource_AllocationInfo::set_role(const char* value,
    size_t size) {
  set_has_role();
  role_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.Resource.AllocationInfo.role)
}
inline ::std::string* Resource_AllocationInfo::mutable_role() {
  set_has_role();
  // @@protoc_insertion_point(field_mutable:mesos.Resource.AllocationInfo.role)
  return role_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* Resource_AllocationInfo::release_role() {
  // @@protoc_insertion_point(field_release:mesos.Resource.AllocationInfo.role)
  clear_has_role();
  return role_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void Resource_AllocationInfo::set_allocated_role(::std::string* role) {
  if (role != NULL) {
    set_has_role();
  } else {
    clear_has_role();
  }
  role_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), role,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.Resource.AllocationInfo.role)
}
inline ::std::string* Resource_AllocationInfo::unsafe_arena_release_role() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Resource.AllocationInfo.role)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_role();
  return role_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void Resource_AllocationInfo::unsafe_arena_set_allocated_role(
    ::std::string* role) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (role != NULL) {
    set_has_role();
  } else {
    clear_has_role();
  }
  role_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      role, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.Resource.AllocationInfo.role)
}

// -------------------------------------------------------------------

// Resource_ReservationInfo

// optional .mesos.Resource.ReservationInfo.Type type = 4;
inline bool Resource_ReservationInfo::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Resource_ReservationInfo::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Resource_ReservationInfo::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Resource_ReservationInfo::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::mesos::Resource_ReservationInfo_Type Resource_ReservationInfo::type() const {
  // @@protoc_insertion_point(field_get:mesos.Resource.ReservationInfo.type)
  return static_cast< ::mesos::Resource_ReservationInfo_Type >(type_);
}
inline void Resource_ReservationInfo::set_type(::mesos::Resource_ReservationInfo_Type value) {
  assert(::mesos::Resource_ReservationInfo_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:mesos.Resource.ReservationInfo.type)
}

// optional string role = 3;
inline bool Resource_ReservationInfo::has_role() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Resource_ReservationInfo::set_has_role() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Resource_ReservationInfo::clear_has_role() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Resource_ReservationInfo::clear_role() {
  role_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_role();
}
inline const ::std::string& Resource_ReservationInfo::role() const {
  // @@protoc_insertion_point(field_get:mesos.Resource.ReservationInfo.role)
  return role_.Get();
}
inline void Resource_ReservationInfo::set_role(const ::std::string& value) {
  set_has_role();
  role_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.Resource.ReservationInfo.role)
}
#if LANG_CXX11
inline void Resource_ReservationInfo::set_role(::std::string&& value) {
  set_has_role();
  role_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.Resource.ReservationInfo.role)
}
#endif
inline void Resource_ReservationInfo::set_role(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_role();
  role_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.Resource.ReservationInfo.role)
}
inline void Resource_ReservationInfo::set_role(const char* value,
    size_t size) {
  set_has_role();
  role_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.Resource.ReservationInfo.role)
}
inline ::std::string* Resource_ReservationInfo::mutable_role() {
  set_has_role();
  // @@protoc_insertion_point(field_mutable:mesos.Resource.ReservationInfo.role)
  return role_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* Resource_ReservationInfo::release_role() {
  // @@protoc_insertion_point(field_release:mesos.Resource.ReservationInfo.role)
  clear_has_role();
  return role_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void Resource_ReservationInfo::set_allocated_role(::std::string* role) {
  if (role != NULL) {
    set_has_role();
  } else {
    clear_has_role();
  }
  role_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), role,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.Resource.ReservationInfo.role)
}
inline ::std::string* Resource_ReservationInfo::unsafe_arena_release_role() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Resource.ReservationInfo.role)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_role();
  return role_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void Resource_ReservationInfo::unsafe_arena_set_allocated_role(
    ::std::string* role) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (role != NULL) {
    set_has_role();
  } else {
    clear_has_role();
  }
  role_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      role, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.Resource.ReservationInfo.role)
}

// optional string principal = 1;
inline bool Resource_ReservationInfo::has_principal() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Resource_ReservationInfo::set_has_principal() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Resource_ReservationInfo::clear_has_principal() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Resource_ReservationInfo::clear_principal() {
  principal_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_principal();
}
inline const ::std::string& Resource_ReservationInfo::principal() const {
  // @@protoc_insertion_point(field_get:mesos.Resource.ReservationInfo.principal)
  return principal_.Get();
}
inline void Resource_ReservationInfo::set_principal(const ::std::string& value) {
  set_has_principal();
  principal_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.Resource.ReservationInfo.principal)
}
#if LANG_CXX11
inline void Resource_ReservationInfo::set_principal(::std::string&& value) {
  set_has_principal();
  principal_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.Resource.ReservationInfo.principal)
}
#endif
inline void Resource_ReservationInfo::set_principal(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_principal();
  principal_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.Resource.ReservationInfo.principal)
}
inline void Resource_ReservationInfo::set_principal(const char* value,
    size_t size) {
  set_has_principal();
  principal_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.Resource.ReservationInfo.principal)
}
inline ::std::string* Resource_ReservationInfo::mutable_principal() {
  set_has_principal();
  // @@protoc_insertion_point(field_mutable:mesos.Resource.ReservationInfo.principal)
  return principal_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* Resource_ReservationInfo::release_principal() {
  // @@protoc_insertion_point(field_release:mesos.Resource.ReservationInfo.principal)
  clear_has_principal();
  return principal_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void Resource_ReservationInfo::set_allocated_principal(::std::string* principal) {
  if (principal != NULL) {
    set_has_principal();
  } else {
    clear_has_principal();
  }
  principal_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), principal,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.Resource.ReservationInfo.principal)
}
inline ::std::string* Resource_ReservationInfo::unsafe_arena_release_principal() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Resource.ReservationInfo.principal)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_principal();
  return principal_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void Resource_ReservationInfo::unsafe_arena_set_allocated_principal(
    ::std::string* principal) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (principal != NULL) {
    set_has_principal();
  } else {
    clear_has_principal();
  }
  principal_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      principal, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.Resource.ReservationInfo.principal)
}

// optional .mesos.Labels labels = 2;
inline bool Resource_ReservationInfo::has_labels() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Resource_ReservationInfo::set_has_labels() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Resource_ReservationInfo::clear_has_labels() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Resource_ReservationInfo::clear_labels() {
  if (labels_ != NULL) labels_->Clear();
  clear_has_labels();
}
inline const ::mesos::Labels& Resource_ReservationInfo::labels() const {
  const ::mesos::Labels* p = labels_;
  // @@protoc_insertion_point(field_get:mesos.Resource.ReservationInfo.labels)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::Labels*>(
      &::mesos::_Labels_default_instance_);
}
inline ::mesos::Labels* Resource_ReservationInfo::release_labels() {
  // @@protoc_insertion_point(field_release:mesos.Resource.ReservationInfo.labels)
  clear_has_labels();
  ::mesos::Labels* temp = labels_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  labels_ = NULL;
  return temp;
}
inline ::mesos::Labels* Resource_ReservationInfo::unsafe_arena_release_labels() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Resource.ReservationInfo.labels)
  clear_has_labels();
  ::mesos::Labels* temp = labels_;
  labels_ = NULL;
  return temp;
}
inline ::mesos::Labels* Resource_ReservationInfo::mutable_labels() {
  set_has_labels();
  if (labels_ == NULL) {
    _slow_mutable_labels();
  }
  // @@protoc_insertion_point(field_mutable:mesos.Resource.ReservationInfo.labels)
  return labels_;
}
inline void Resource_ReservationInfo::set_allocated_labels(::mesos::Labels* labels) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete labels_;
  }
  if (labels) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(labels);
    if (message_arena != submessage_arena) {
      labels = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, labels, submessage_arena);
    }
    set_has_labels();
  } else {
    clear_has_labels();
  }
  labels_ = labels;
  // @@protoc_insertion_point(field_set_allocated:mesos.Resource.ReservationInfo.labels)
}

// -------------------------------------------------------------------

// Resource_DiskInfo_Persistence

// required string id = 1;
inline bool Resource_DiskInfo_Persistence::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Resource_DiskInfo_Persistence::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Resource_DiskInfo_Persistence::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Resource_DiskInfo_Persistence::clear_id() {
  id_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_id();
}
inline const ::std::string& Resource_DiskInfo_Persistence::id() const {
  // @@protoc_insertion_point(field_get:mesos.Resource.DiskInfo.Persistence.id)
  return id_.Get();
}
inline void Resource_DiskInfo_Persistence::set_id(const ::std::string& value) {
  set_has_id();
  id_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.Resource.DiskInfo.Persistence.id)
}
#if LANG_CXX11
inline void Resource_DiskInfo_Persistence::set_id(::std::string&& value) {
  set_has_id();
  id_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.Resource.DiskInfo.Persistence.id)
}
#endif
inline void Resource_DiskInfo_Persistence::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_id();
  id_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.Resource.DiskInfo.Persistence.id)
}
inline void Resource_DiskInfo_Persistence::set_id(const char* value,
    size_t size) {
  set_has_id();
  id_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.Resource.DiskInfo.Persistence.id)
}
inline ::std::string* Resource_DiskInfo_Persistence::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:mesos.Resource.DiskInfo.Persistence.id)
  return id_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* Resource_DiskInfo_Persistence::release_id() {
  // @@protoc_insertion_point(field_release:mesos.Resource.DiskInfo.Persistence.id)
  clear_has_id();
  return id_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void Resource_DiskInfo_Persistence::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.Resource.DiskInfo.Persistence.id)
}
inline ::std::string* Resource_DiskInfo_Persistence::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Resource.DiskInfo.Persistence.id)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_id();
  return id_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void Resource_DiskInfo_Persistence::unsafe_arena_set_allocated_id(
    ::std::string* id) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      id, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.Resource.DiskInfo.Persistence.id)
}

// optional string principal = 2;
inline bool Resource_DiskInfo_Persistence::has_principal() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Resource_DiskInfo_Persistence::set_has_principal() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Resource_DiskInfo_Persistence::clear_has_principal() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Resource_DiskInfo_Persistence::clear_principal() {
  principal_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_principal();
}
inline const ::std::string& Resource_DiskInfo_Persistence::principal() const {
  // @@protoc_insertion_point(field_get:mesos.Resource.DiskInfo.Persistence.principal)
  return principal_.Get();
}
inline void Resource_DiskInfo_Persistence::set_principal(const ::std::string& value) {
  set_has_principal();
  principal_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.Resource.DiskInfo.Persistence.principal)
}
#if LANG_CXX11
inline void Resource_DiskInfo_Persistence::set_principal(::std::string&& value) {
  set_has_principal();
  principal_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.Resource.DiskInfo.Persistence.principal)
}
#endif
inline void Resource_DiskInfo_Persistence::set_principal(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_principal();
  principal_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.Resource.DiskInfo.Persistence.principal)
}
inline void Resource_DiskInfo_Persistence::set_principal(const char* value,
    size_t size) {
  set_has_principal();
  principal_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.Resource.DiskInfo.Persistence.principal)
}
inline ::std::string* Resource_DiskInfo_Persistence::mutable_principal() {
  set_has_principal();
  // @@protoc_insertion_point(field_mutable:mesos.Resource.DiskInfo.Persistence.principal)
  return principal_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* Resource_DiskInfo_Persistence::release_principal() {
  // @@protoc_insertion_point(field_release:mesos.Resource.DiskInfo.Persistence.principal)
  clear_has_principal();
  return principal_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void Resource_DiskInfo_Persistence::set_allocated_principal(::std::string* principal) {
  if (principal != NULL) {
    set_has_principal();
  } else {
    clear_has_principal();
  }
  principal_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), principal,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.Resource.DiskInfo.Persistence.principal)
}
inline ::std::string* Resource_DiskInfo_Persistence::unsafe_arena_release_principal() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Resource.DiskInfo.Persistence.principal)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_principal();
  return principal_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void Resource_DiskInfo_Persistence::unsafe_arena_set_allocated_principal(
    ::std::string* principal) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (principal != NULL) {
    set_has_principal();
  } else {
    clear_has_principal();
  }
  principal_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      principal, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.Resource.DiskInfo.Persistence.principal)
}

// -------------------------------------------------------------------

// Resource_DiskInfo_Source_Path

// optional string root = 1;
inline bool Resource_DiskInfo_Source_Path::has_root() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Resource_DiskInfo_Source_Path::set_has_root() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Resource_DiskInfo_Source_Path::clear_has_root() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Resource_DiskInfo_Source_Path::clear_root() {
  root_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_root();
}
inline const ::std::string& Resource_DiskInfo_Source_Path::root() const {
  // @@protoc_insertion_point(field_get:mesos.Resource.DiskInfo.Source.Path.root)
  return root_.Get();
}
inline void Resource_DiskInfo_Source_Path::set_root(const ::std::string& value) {
  set_has_root();
  root_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.Resource.DiskInfo.Source.Path.root)
}
#if LANG_CXX11
inline void Resource_DiskInfo_Source_Path::set_root(::std::string&& value) {
  set_has_root();
  root_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.Resource.DiskInfo.Source.Path.root)
}
#endif
inline void Resource_DiskInfo_Source_Path::set_root(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_root();
  root_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.Resource.DiskInfo.Source.Path.root)
}
inline void Resource_DiskInfo_Source_Path::set_root(const char* value,
    size_t size) {
  set_has_root();
  root_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.Resource.DiskInfo.Source.Path.root)
}
inline ::std::string* Resource_DiskInfo_Source_Path::mutable_root() {
  set_has_root();
  // @@protoc_insertion_point(field_mutable:mesos.Resource.DiskInfo.Source.Path.root)
  return root_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* Resource_DiskInfo_Source_Path::release_root() {
  // @@protoc_insertion_point(field_release:mesos.Resource.DiskInfo.Source.Path.root)
  clear_has_root();
  return root_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void Resource_DiskInfo_Source_Path::set_allocated_root(::std::string* root) {
  if (root != NULL) {
    set_has_root();
  } else {
    clear_has_root();
  }
  root_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), root,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.Resource.DiskInfo.Source.Path.root)
}
inline ::std::string* Resource_DiskInfo_Source_Path::unsafe_arena_release_root() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Resource.DiskInfo.Source.Path.root)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_root();
  return root_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void Resource_DiskInfo_Source_Path::unsafe_arena_set_allocated_root(
    ::std::string* root) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (root != NULL) {
    set_has_root();
  } else {
    clear_has_root();
  }
  root_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      root, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.Resource.DiskInfo.Source.Path.root)
}

// -------------------------------------------------------------------

// Resource_DiskInfo_Source_Mount

// optional string root = 1;
inline bool Resource_DiskInfo_Source_Mount::has_root() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Resource_DiskInfo_Source_Mount::set_has_root() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Resource_DiskInfo_Source_Mount::clear_has_root() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Resource_DiskInfo_Source_Mount::clear_root() {
  root_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_root();
}
inline const ::std::string& Resource_DiskInfo_Source_Mount::root() const {
  // @@protoc_insertion_point(field_get:mesos.Resource.DiskInfo.Source.Mount.root)
  return root_.Get();
}
inline void Resource_DiskInfo_Source_Mount::set_root(const ::std::string& value) {
  set_has_root();
  root_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.Resource.DiskInfo.Source.Mount.root)
}
#if LANG_CXX11
inline void Resource_DiskInfo_Source_Mount::set_root(::std::string&& value) {
  set_has_root();
  root_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.Resource.DiskInfo.Source.Mount.root)
}
#endif
inline void Resource_DiskInfo_Source_Mount::set_root(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_root();
  root_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.Resource.DiskInfo.Source.Mount.root)
}
inline void Resource_DiskInfo_Source_Mount::set_root(const char* value,
    size_t size) {
  set_has_root();
  root_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.Resource.DiskInfo.Source.Mount.root)
}
inline ::std::string* Resource_DiskInfo_Source_Mount::mutable_root() {
  set_has_root();
  // @@protoc_insertion_point(field_mutable:mesos.Resource.DiskInfo.Source.Mount.root)
  return root_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* Resource_DiskInfo_Source_Mount::release_root() {
  // @@protoc_insertion_point(field_release:mesos.Resource.DiskInfo.Source.Mount.root)
  clear_has_root();
  return root_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void Resource_DiskInfo_Source_Mount::set_allocated_root(::std::string* root) {
  if (root != NULL) {
    set_has_root();
  } else {
    clear_has_root();
  }
  root_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), root,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.Resource.DiskInfo.Source.Mount.root)
}
inline ::std::string* Resource_DiskInfo_Source_Mount::unsafe_arena_release_root() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Resource.DiskInfo.Source.Mount.root)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_root();
  return root_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void Resource_DiskInfo_Source_Mount::unsafe_arena_set_allocated_root(
    ::std::string* root) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (root != NULL) {
    set_has_root();
  } else {
    clear_has_root();
  }
  root_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      root, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.Resource.DiskInfo.Source.Mount.root)
}

// -------------------------------------------------------------------

// Resource_DiskInfo_Source

// required .mesos.Resource.DiskInfo.Source.Type type = 1;
inline bool Resource_DiskInfo_Source::has_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Resource_DiskInfo_Source::set_has_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Resource_DiskInfo_Source::clear_has_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Resource_DiskInfo_Source::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::mesos::Resource_DiskInfo_Source_Type Resource_DiskInfo_Source::type() const {
  // @@protoc_insertion_point(field_get:mesos.Resource.DiskInfo.Source.type)
  return static_cast< ::mesos::Resource_DiskInfo_Source_Type >(type_);
}
inline void Resource_DiskInfo_Source::set_type(::mesos::Resource_DiskInfo_Source_Type value) {
  assert(::mesos::Resource_DiskInfo_Source_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:mesos.Resource.DiskInfo.Source.type)
}

// optional .mesos.Resource.DiskInfo.Source.Path path = 2;
inline bool Resource_DiskInfo_Source::has_path() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Resource_DiskInfo_Source::set_has_path() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Resource_DiskInfo_Source::clear_has_path() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Resource_DiskInfo_Source::clear_path() {
  if (path_ != NULL) path_->Clear();
  clear_has_path();
}
inline const ::mesos::Resource_DiskInfo_Source_Path& Resource_DiskInfo_Source::path() const {
  const ::mesos::Resource_DiskInfo_Source_Path* p = path_;
  // @@protoc_insertion_point(field_get:mesos.Resource.DiskInfo.Source.path)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::Resource_DiskInfo_Source_Path*>(
      &::mesos::_Resource_DiskInfo_Source_Path_default_instance_);
}
inline ::mesos::Resource_DiskInfo_Source_Path* Resource_DiskInfo_Source::release_path() {
  // @@protoc_insertion_point(field_release:mesos.Resource.DiskInfo.Source.path)
  clear_has_path();
  ::mesos::Resource_DiskInfo_Source_Path* temp = path_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  path_ = NULL;
  return temp;
}
inline ::mesos::Resource_DiskInfo_Source_Path* Resource_DiskInfo_Source::unsafe_arena_release_path() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Resource.DiskInfo.Source.path)
  clear_has_path();
  ::mesos::Resource_DiskInfo_Source_Path* temp = path_;
  path_ = NULL;
  return temp;
}
inline ::mesos::Resource_DiskInfo_Source_Path* Resource_DiskInfo_Source::mutable_path() {
  set_has_path();
  if (path_ == NULL) {
    _slow_mutable_path();
  }
  // @@protoc_insertion_point(field_mutable:mesos.Resource.DiskInfo.Source.path)
  return path_;
}
inline void Resource_DiskInfo_Source::set_allocated_path(::mesos::Resource_DiskInfo_Source_Path* path) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete path_;
  }
  if (path) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(path);
    if (message_arena != submessage_arena) {
      path = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, path, submessage_arena);
    }
    set_has_path();
  } else {
    clear_has_path();
  }
  path_ = path;
  // @@protoc_insertion_point(field_set_allocated:mesos.Resource.DiskInfo.Source.path)
}

// optional .mesos.Resource.DiskInfo.Source.Mount mount = 3;
inline bool Resource_DiskInfo_Source::has_mount() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Resource_DiskInfo_Source::set_has_mount() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Resource_DiskInfo_Source::clear_has_mount() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Resource_DiskInfo_Source::clear_mount() {
  if (mount_ != NULL) mount_->Clear();
  clear_has_mount();
}
inline const ::mesos::Resource_DiskInfo_Source_Mount& Resource_DiskInfo_Source::mount() const {
  const ::mesos::Resource_DiskInfo_Source_Mount* p = mount_;
  // @@protoc_insertion_point(field_get:mesos.Resource.DiskInfo.Source.mount)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::Resource_DiskInfo_Source_Mount*>(
      &::mesos::_Resource_DiskInfo_Source_Mount_default_instance_);
}
inline ::mesos::Resource_DiskInfo_Source_Mount* Resource_DiskInfo_Source::release_mount() {
  // @@protoc_insertion_point(field_release:mesos.Resource.DiskInfo.Source.mount)
  clear_has_mount();
  ::mesos::Resource_DiskInfo_Source_Mount* temp = mount_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  mount_ = NULL;
  return temp;
}
inline ::mesos::Resource_DiskInfo_Source_Mount* Resource_DiskInfo_Source::unsafe_arena_release_mount() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Resource.DiskInfo.Source.mount)
  clear_has_mount();
  ::mesos::Resource_DiskInfo_Source_Mount* temp = mount_;
  mount_ = NULL;
  return temp;
}
inline ::mesos::Resource_DiskInfo_Source_Mount* Resource_DiskInfo_Source::mutable_mount() {
  set_has_mount();
  if (mount_ == NULL) {
    _slow_mutable_mount();
  }
  // @@protoc_insertion_point(field_mutable:mesos.Resource.DiskInfo.Source.mount)
  return mount_;
}
inline void Resource_DiskInfo_Source::set_allocated_mount(::mesos::Resource_DiskInfo_Source_Mount* mount) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete mount_;
  }
  if (mount) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(mount);
    if (message_arena != submessage_arena) {
      mount = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, mount, submessage_arena);
    }
    set_has_mount();
  } else {
    clear_has_mount();
  }
  mount_ = mount;
  // @@protoc_insertion_point(field_set_allocated:mesos.Resource.DiskInfo.Source.mount)
}

// optional string id = 4;
inline bool Resource_DiskInfo_Source::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Resource_DiskInfo_Source::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Resource_DiskInfo_Source::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Resource_DiskInfo_Source::clear_id() {
  id_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_id();
}
inline const ::std::string& Resource_DiskInfo_Source::id() const {
  // @@protoc_insertion_point(field_get:mesos.Resource.DiskInfo.Source.id)
  return id_.Get();
}
inline void Resource_DiskInfo_Source::set_id(const ::std::string& value) {
  set_has_id();
  id_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.Resource.DiskInfo.Source.id)
}
#if LANG_CXX11
inline void Resource_DiskInfo_Source::set_id(::std::string&& value) {
  set_has_id();
  id_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.Resource.DiskInfo.Source.id)
}
#endif
inline void Resource_DiskInfo_Source::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_id();
  id_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.Resource.DiskInfo.Source.id)
}
inline void Resource_DiskInfo_Source::set_id(const char* value,
    size_t size) {
  set_has_id();
  id_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.Resource.DiskInfo.Source.id)
}
inline ::std::string* Resource_DiskInfo_Source::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:mesos.Resource.DiskInfo.Source.id)
  return id_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* Resource_DiskInfo_Source::release_id() {
  // @@protoc_insertion_point(field_release:mesos.Resource.DiskInfo.Source.id)
  clear_has_id();
  return id_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void Resource_DiskInfo_Source::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.Resource.DiskInfo.Source.id)
}
inline ::std::string* Resource_DiskInfo_Source::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Resource.DiskInfo.Source.id)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_id();
  return id_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void Resource_DiskInfo_Source::unsafe_arena_set_allocated_id(
    ::std::string* id) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      id, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.Resource.DiskInfo.Source.id)
}

// optional .mesos.Labels metadata = 5;
inline bool Resource_DiskInfo_Source::has_metadata() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Resource_DiskInfo_Source::set_has_metadata() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Resource_DiskInfo_Source::clear_has_metadata() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Resource_DiskInfo_Source::clear_metadata() {
  if (metadata_ != NULL) metadata_->Clear();
  clear_has_metadata();
}
inline const ::mesos::Labels& Resource_DiskInfo_Source::metadata() const {
  const ::mesos::Labels* p = metadata_;
  // @@protoc_insertion_point(field_get:mesos.Resource.DiskInfo.Source.metadata)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::Labels*>(
      &::mesos::_Labels_default_instance_);
}
inline ::mesos::Labels* Resource_DiskInfo_Source::release_metadata() {
  // @@protoc_insertion_point(field_release:mesos.Resource.DiskInfo.Source.metadata)
  clear_has_metadata();
  ::mesos::Labels* temp = metadata_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  metadata_ = NULL;
  return temp;
}
inline ::mesos::Labels* Resource_DiskInfo_Source::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Resource.DiskInfo.Source.metadata)
  clear_has_metadata();
  ::mesos::Labels* temp = metadata_;
  metadata_ = NULL;
  return temp;
}
inline ::mesos::Labels* Resource_DiskInfo_Source::mutable_metadata() {
  set_has_metadata();
  if (metadata_ == NULL) {
    _slow_mutable_metadata();
  }
  // @@protoc_insertion_point(field_mutable:mesos.Resource.DiskInfo.Source.metadata)
  return metadata_;
}
inline void Resource_DiskInfo_Source::set_allocated_metadata(::mesos::Labels* metadata) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete metadata_;
  }
  if (metadata) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(metadata);
    if (message_arena != submessage_arena) {
      metadata = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    set_has_metadata();
  } else {
    clear_has_metadata();
  }
  metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:mesos.Resource.DiskInfo.Source.metadata)
}

// optional string profile = 6;
inline bool Resource_DiskInfo_Source::has_profile() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Resource_DiskInfo_Source::set_has_profile() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Resource_DiskInfo_Source::clear_has_profile() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Resource_DiskInfo_Source::clear_profile() {
  profile_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_profile();
}
inline const ::std::string& Resource_DiskInfo_Source::profile() const {
  // @@protoc_insertion_point(field_get:mesos.Resource.DiskInfo.Source.profile)
  return profile_.Get();
}
inline void Resource_DiskInfo_Source::set_profile(const ::std::string& value) {
  set_has_profile();
  profile_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.Resource.DiskInfo.Source.profile)
}
#if LANG_CXX11
inline void Resource_DiskInfo_Source::set_profile(::std::string&& value) {
  set_has_profile();
  profile_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.Resource.DiskInfo.Source.profile)
}
#endif
inline void Resource_DiskInfo_Source::set_profile(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_profile();
  profile_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.Resource.DiskInfo.Source.profile)
}
inline void Resource_DiskInfo_Source::set_profile(const char* value,
    size_t size) {
  set_has_profile();
  profile_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.Resource.DiskInfo.Source.profile)
}
inline ::std::string* Resource_DiskInfo_Source::mutable_profile() {
  set_has_profile();
  // @@protoc_insertion_point(field_mutable:mesos.Resource.DiskInfo.Source.profile)
  return profile_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* Resource_DiskInfo_Source::release_profile() {
  // @@protoc_insertion_point(field_release:mesos.Resource.DiskInfo.Source.profile)
  clear_has_profile();
  return profile_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void Resource_DiskInfo_Source::set_allocated_profile(::std::string* profile) {
  if (profile != NULL) {
    set_has_profile();
  } else {
    clear_has_profile();
  }
  profile_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), profile,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.Resource.DiskInfo.Source.profile)
}
inline ::std::string* Resource_DiskInfo_Source::unsafe_arena_release_profile() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Resource.DiskInfo.Source.profile)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_profile();
  return profile_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void Resource_DiskInfo_Source::unsafe_arena_set_allocated_profile(
    ::std::string* profile) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (profile != NULL) {
    set_has_profile();
  } else {
    clear_has_profile();
  }
  profile_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      profile, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.Resource.DiskInfo.Source.profile)
}

// -------------------------------------------------------------------

// Resource_DiskInfo

// optional .mesos.Resource.DiskInfo.Persistence persistence = 1;
inline bool Resource_DiskInfo::has_persistence() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Resource_DiskInfo::set_has_persistence() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Resource_DiskInfo::clear_has_persistence() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Resource_DiskInfo::clear_persistence() {
  if (persistence_ != NULL) persistence_->Clear();
  clear_has_persistence();
}
inline const ::mesos::Resource_DiskInfo_Persistence& Resource_DiskInfo::persistence() const {
  const ::mesos::Resource_DiskInfo_Persistence* p = persistence_;
  // @@protoc_insertion_point(field_get:mesos.Resource.DiskInfo.persistence)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::Resource_DiskInfo_Persistence*>(
      &::mesos::_Resource_DiskInfo_Persistence_default_instance_);
}
inline ::mesos::Resource_DiskInfo_Persistence* Resource_DiskInfo::release_persistence() {
  // @@protoc_insertion_point(field_release:mesos.Resource.DiskInfo.persistence)
  clear_has_persistence();
  ::mesos::Resource_DiskInfo_Persistence* temp = persistence_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  persistence_ = NULL;
  return temp;
}
inline ::mesos::Resource_DiskInfo_Persistence* Resource_DiskInfo::unsafe_arena_release_persistence() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Resource.DiskInfo.persistence)
  clear_has_persistence();
  ::mesos::Resource_DiskInfo_Persistence* temp = persistence_;
  persistence_ = NULL;
  return temp;
}
inline ::mesos::Resource_DiskInfo_Persistence* Resource_DiskInfo::mutable_persistence() {
  set_has_persistence();
  if (persistence_ == NULL) {
    _slow_mutable_persistence();
  }
  // @@protoc_insertion_point(field_mutable:mesos.Resource.DiskInfo.persistence)
  return persistence_;
}
inline void Resource_DiskInfo::set_allocated_persistence(::mesos::Resource_DiskInfo_Persistence* persistence) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete persistence_;
  }
  if (persistence) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(persistence);
    if (message_arena != submessage_arena) {
      persistence = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, persistence, submessage_arena);
    }
    set_has_persistence();
  } else {
    clear_has_persistence();
  }
  persistence_ = persistence;
  // @@protoc_insertion_point(field_set_allocated:mesos.Resource.DiskInfo.persistence)
}

// optional .mesos.Volume volume = 2;
inline bool Resource_DiskInfo::has_volume() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Resource_DiskInfo::set_has_volume() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Resource_DiskInfo::clear_has_volume() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Resource_DiskInfo::clear_volume() {
  if (volume_ != NULL) volume_->Clear();
  clear_has_volume();
}
inline const ::mesos::Volume& Resource_DiskInfo::volume() const {
  const ::mesos::Volume* p = volume_;
  // @@protoc_insertion_point(field_get:mesos.Resource.DiskInfo.volume)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::Volume*>(
      &::mesos::_Volume_default_instance_);
}
inline ::mesos::Volume* Resource_DiskInfo::release_volume() {
  // @@protoc_insertion_point(field_release:mesos.Resource.DiskInfo.volume)
  clear_has_volume();
  ::mesos::Volume* temp = volume_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  volume_ = NULL;
  return temp;
}
inline ::mesos::Volume* Resource_DiskInfo::unsafe_arena_release_volume() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Resource.DiskInfo.volume)
  clear_has_volume();
  ::mesos::Volume* temp = volume_;
  volume_ = NULL;
  return temp;
}
inline ::mesos::Volume* Resource_DiskInfo::mutable_volume() {
  set_has_volume();
  if (volume_ == NULL) {
    _slow_mutable_volume();
  }
  // @@protoc_insertion_point(field_mutable:mesos.Resource.DiskInfo.volume)
  return volume_;
}
inline void Resource_DiskInfo::set_allocated_volume(::mesos::Volume* volume) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete volume_;
  }
  if (volume) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(volume);
    if (message_arena != submessage_arena) {
      volume = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, volume, submessage_arena);
    }
    set_has_volume();
  } else {
    clear_has_volume();
  }
  volume_ = volume;
  // @@protoc_insertion_point(field_set_allocated:mesos.Resource.DiskInfo.volume)
}

// optional .mesos.Resource.DiskInfo.Source source = 3;
inline bool Resource_DiskInfo::has_source() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Resource_DiskInfo::set_has_source() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Resource_DiskInfo::clear_has_source() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Resource_DiskInfo::clear_source() {
  if (source_ != NULL) source_->Clear();
  clear_has_source();
}
inline const ::mesos::Resource_DiskInfo_Source& Resource_DiskInfo::source() const {
  const ::mesos::Resource_DiskInfo_Source* p = source_;
  // @@protoc_insertion_point(field_get:mesos.Resource.DiskInfo.source)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::Resource_DiskInfo_Source*>(
      &::mesos::_Resource_DiskInfo_Source_default_instance_);
}
inline ::mesos::Resource_DiskInfo_Source* Resource_DiskInfo::release_source() {
  // @@protoc_insertion_point(field_release:mesos.Resource.DiskInfo.source)
  clear_has_source();
  ::mesos::Resource_DiskInfo_Source* temp = source_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  source_ = NULL;
  return temp;
}
inline ::mesos::Resource_DiskInfo_Source* Resource_DiskInfo::unsafe_arena_release_source() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Resource.DiskInfo.source)
  clear_has_source();
  ::mesos::Resource_DiskInfo_Source* temp = source_;
  source_ = NULL;
  return temp;
}
inline ::mesos::Resource_DiskInfo_Source* Resource_DiskInfo::mutable_source() {
  set_has_source();
  if (source_ == NULL) {
    _slow_mutable_source();
  }
  // @@protoc_insertion_point(field_mutable:mesos.Resource.DiskInfo.source)
  return source_;
}
inline void Resource_DiskInfo::set_allocated_source(::mesos::Resource_DiskInfo_Source* source) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete source_;
  }
  if (source) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(source);
    if (message_arena != submessage_arena) {
      source = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, source, submessage_arena);
    }
    set_has_source();
  } else {
    clear_has_source();
  }
  source_ = source;
  // @@protoc_insertion_point(field_set_allocated:mesos.Resource.DiskInfo.source)
}

// -------------------------------------------------------------------

// Resource_RevocableInfo

// -------------------------------------------------------------------

// Resource_SharedInfo

// -------------------------------------------------------------------

// Resource

// optional .mesos.ResourceProviderID provider_id = 12;
inline bool Resource::has_provider_id() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Resource::set_has_provider_id() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Resource::clear_has_provider_id() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Resource::clear_provider_id() {
  if (provider_id_ != NULL) provider_id_->Clear();
  clear_has_provider_id();
}
inline const ::mesos::ResourceProviderID& Resource::provider_id() const {
  const ::mesos::ResourceProviderID* p = provider_id_;
  // @@protoc_insertion_point(field_get:mesos.Resource.provider_id)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ResourceProviderID*>(
      &::mesos::_ResourceProviderID_default_instance_);
}
inline ::mesos::ResourceProviderID* Resource::release_provider_id() {
  // @@protoc_insertion_point(field_release:mesos.Resource.provider_id)
  clear_has_provider_id();
  ::mesos::ResourceProviderID* temp = provider_id_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  provider_id_ = NULL;
  return temp;
}
inline ::mesos::ResourceProviderID* Resource::unsafe_arena_release_provider_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Resource.provider_id)
  clear_has_provider_id();
  ::mesos::ResourceProviderID* temp = provider_id_;
  provider_id_ = NULL;
  return temp;
}
inline ::mesos::ResourceProviderID* Resource::mutable_provider_id() {
  set_has_provider_id();
  if (provider_id_ == NULL) {
    _slow_mutable_provider_id();
  }
  // @@protoc_insertion_point(field_mutable:mesos.Resource.provider_id)
  return provider_id_;
}
inline void Resource::set_allocated_provider_id(::mesos::ResourceProviderID* provider_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete provider_id_;
  }
  if (provider_id) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(provider_id);
    if (message_arena != submessage_arena) {
      provider_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, provider_id, submessage_arena);
    }
    set_has_provider_id();
  } else {
    clear_has_provider_id();
  }
  provider_id_ = provider_id;
  // @@protoc_insertion_point(field_set_allocated:mesos.Resource.provider_id)
}

// required string name = 1;
inline bool Resource::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Resource::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Resource::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Resource::clear_name() {
  name_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_name();
}
inline const ::std::string& Resource::name() const {
  // @@protoc_insertion_point(field_get:mesos.Resource.name)
  return name_.Get();
}
inline void Resource::set_name(const ::std::string& value) {
  set_has_name();
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.Resource.name)
}
#if LANG_CXX11
inline void Resource::set_name(::std::string&& value) {
  set_has_name();
  name_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.Resource.name)
}
#endif
inline void Resource::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.Resource.name)
}
inline void Resource::set_name(const char* value,
    size_t size) {
  set_has_name();
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.Resource.name)
}
inline ::std::string* Resource::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:mesos.Resource.name)
  return name_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* Resource::release_name() {
  // @@protoc_insertion_point(field_release:mesos.Resource.name)
  clear_has_name();
  return name_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void Resource::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.Resource.name)
}
inline ::std::string* Resource::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Resource.name)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_name();
  return name_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void Resource::unsafe_arena_set_allocated_name(
    ::std::string* name) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      name, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.Resource.name)
}

// required .mesos.Value.Type type = 2;
inline bool Resource::has_type() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Resource::set_has_type() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Resource::clear_has_type() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Resource::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::mesos::Value_Type Resource::type() const {
  // @@protoc_insertion_point(field_get:mesos.Resource.type)
  return static_cast< ::mesos::Value_Type >(type_);
}
inline void Resource::set_type(::mesos::Value_Type value) {
  assert(::mesos::Value_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:mesos.Resource.type)
}

// optional .mesos.Value.Scalar scalar = 3;
inline bool Resource::has_scalar() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Resource::set_has_scalar() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Resource::clear_has_scalar() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Resource::clear_scalar() {
  if (scalar_ != NULL) scalar_->Clear();
  clear_has_scalar();
}
inline const ::mesos::Value_Scalar& Resource::scalar() const {
  const ::mesos::Value_Scalar* p = scalar_;
  // @@protoc_insertion_point(field_get:mesos.Resource.scalar)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::Value_Scalar*>(
      &::mesos::_Value_Scalar_default_instance_);
}
inline ::mesos::Value_Scalar* Resource::release_scalar() {
  // @@protoc_insertion_point(field_release:mesos.Resource.scalar)
  clear_has_scalar();
  ::mesos::Value_Scalar* temp = scalar_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  scalar_ = NULL;
  return temp;
}
inline ::mesos::Value_Scalar* Resource::unsafe_arena_release_scalar() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Resource.scalar)
  clear_has_scalar();
  ::mesos::Value_Scalar* temp = scalar_;
  scalar_ = NULL;
  return temp;
}
inline ::mesos::Value_Scalar* Resource::mutable_scalar() {
  set_has_scalar();
  if (scalar_ == NULL) {
    _slow_mutable_scalar();
  }
  // @@protoc_insertion_point(field_mutable:mesos.Resource.scalar)
  return scalar_;
}
inline void Resource::set_allocated_scalar(::mesos::Value_Scalar* scalar) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete scalar_;
  }
  if (scalar) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(scalar);
    if (message_arena != submessage_arena) {
      scalar = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, scalar, submessage_arena);
    }
    set_has_scalar();
  } else {
    clear_has_scalar();
  }
  scalar_ = scalar;
  // @@protoc_insertion_point(field_set_allocated:mesos.Resource.scalar)
}

// optional .mesos.Value.Ranges ranges = 4;
inline bool Resource::has_ranges() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Resource::set_has_ranges() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Resource::clear_has_ranges() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Resource::clear_ranges() {
  if (ranges_ != NULL) ranges_->Clear();
  clear_has_ranges();
}
inline const ::mesos::Value_Ranges& Resource::ranges() const {
  const ::mesos::Value_Ranges* p = ranges_;
  // @@protoc_insertion_point(field_get:mesos.Resource.ranges)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::Value_Ranges*>(
      &::mesos::_Value_Ranges_default_instance_);
}
inline ::mesos::Value_Ranges* Resource::release_ranges() {
  // @@protoc_insertion_point(field_release:mesos.Resource.ranges)
  clear_has_ranges();
  ::mesos::Value_Ranges* temp = ranges_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  ranges_ = NULL;
  return temp;
}
inline ::mesos::Value_Ranges* Resource::unsafe_arena_release_ranges() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Resource.ranges)
  clear_has_ranges();
  ::mesos::Value_Ranges* temp = ranges_;
  ranges_ = NULL;
  return temp;
}
inline ::mesos::Value_Ranges* Resource::mutable_ranges() {
  set_has_ranges();
  if (ranges_ == NULL) {
    _slow_mutable_ranges();
  }
  // @@protoc_insertion_point(field_mutable:mesos.Resource.ranges)
  return ranges_;
}
inline void Resource::set_allocated_ranges(::mesos::Value_Ranges* ranges) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete ranges_;
  }
  if (ranges) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(ranges);
    if (message_arena != submessage_arena) {
      ranges = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ranges, submessage_arena);
    }
    set_has_ranges();
  } else {
    clear_has_ranges();
  }
  ranges_ = ranges;
  // @@protoc_insertion_point(field_set_allocated:mesos.Resource.ranges)
}

// optional .mesos.Value.Set set = 5;
inline bool Resource::has_set() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Resource::set_has_set() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Resource::clear_has_set() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Resource::clear_set() {
  if (set_ != NULL) set_->Clear();
  clear_has_set();
}
inline const ::mesos::Value_Set& Resource::set() const {
  const ::mesos::Value_Set* p = set_;
  // @@protoc_insertion_point(field_get:mesos.Resource.set)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::Value_Set*>(
      &::mesos::_Value_Set_default_instance_);
}
inline ::mesos::Value_Set* Resource::release_set() {
  // @@protoc_insertion_point(field_release:mesos.Resource.set)
  clear_has_set();
  ::mesos::Value_Set* temp = set_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  set_ = NULL;
  return temp;
}
inline ::mesos::Value_Set* Resource::unsafe_arena_release_set() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Resource.set)
  clear_has_set();
  ::mesos::Value_Set* temp = set_;
  set_ = NULL;
  return temp;
}
inline ::mesos::Value_Set* Resource::mutable_set() {
  set_has_set();
  if (set_ == NULL) {
    _slow_mutable_set();
  }
  // @@protoc_insertion_point(field_mutable:mesos.Resource.set)
  return set_;
}
inline void Resource::set_allocated_set(::mesos::Value_Set* set) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete set_;
  }
  if (set) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(set);
    if (message_arena != submessage_arena) {
      set = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, set, submessage_arena);
    }
    set_has_set();
  } else {
    clear_has_set();
  }
  set_ = set;
  // @@protoc_insertion_point(field_set_allocated:mesos.Resource.set)
}

// optional string role = 6 [default = "*", deprecated = true];
inline bool Resource::has_role() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Resource::set_has_role() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Resource::clear_has_role() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Resource::clear_role() {
  role_.ClearToDefault(&::mesos::Resource::_default_role_.get(), GetArenaNoVirtual());
  clear_has_role();
}
inline const ::std::string& Resource::role() const {
  // @@protoc_insertion_point(field_get:mesos.Resource.role)
  return role_.Get();
}
inline void Resource::set_role(const ::std::string& value) {
  set_has_role();
  role_.Set(&::mesos::Resource::_default_role_.get(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.Resource.role)
}
#if LANG_CXX11
inline void Resource::set_role(::std::string&& value) {
  set_has_role();
  role_.Set(
    &::mesos::Resource::_default_role_.get(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.Resource.role)
}
#endif
inline void Resource::set_role(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_role();
  role_.Set(&::mesos::Resource::_default_role_.get(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.Resource.role)
}
inline void Resource::set_role(const char* value,
    size_t size) {
  set_has_role();
  role_.Set(&::mesos::Resource::_default_role_.get(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.Resource.role)
}
inline ::std::string* Resource::mutable_role() {
  set_has_role();
  // @@protoc_insertion_point(field_mutable:mesos.Resource.role)
  return role_.Mutable(&::mesos::Resource::_default_role_.get(), GetArenaNoVirtual());
}
inline ::std::string* Resource::release_role() {
  // @@protoc_insertion_point(field_release:mesos.Resource.role)
  clear_has_role();
  return role_.Release(&::mesos::Resource::_default_role_.get(), GetArenaNoVirtual());
}
inline void Resource::set_allocated_role(::std::string* role) {
  if (role != NULL) {
    set_has_role();
  } else {
    clear_has_role();
  }
  role_.SetAllocated(&::mesos::Resource::_default_role_.get(), role,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.Resource.role)
}
inline ::std::string* Resource::unsafe_arena_release_role() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Resource.role)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_role();
  return role_.UnsafeArenaRelease(&::mesos::Resource::_default_role_.get(),
      GetArenaNoVirtual());
}
inline void Resource::unsafe_arena_set_allocated_role(
    ::std::string* role) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (role != NULL) {
    set_has_role();
  } else {
    clear_has_role();
  }
  role_.UnsafeArenaSetAllocated(&::mesos::Resource::_default_role_.get(),
      role, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.Resource.role)
}

// optional .mesos.Resource.AllocationInfo allocation_info = 11;
inline bool Resource::has_allocation_info() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Resource::set_has_allocation_info() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Resource::clear_has_allocation_info() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Resource::clear_allocation_info() {
  if (allocation_info_ != NULL) allocation_info_->Clear();
  clear_has_allocation_info();
}
inline const ::mesos::Resource_AllocationInfo& Resource::allocation_info() const {
  const ::mesos::Resource_AllocationInfo* p = allocation_info_;
  // @@protoc_insertion_point(field_get:mesos.Resource.allocation_info)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::Resource_AllocationInfo*>(
      &::mesos::_Resource_AllocationInfo_default_instance_);
}
inline ::mesos::Resource_AllocationInfo* Resource::release_allocation_info() {
  // @@protoc_insertion_point(field_release:mesos.Resource.allocation_info)
  clear_has_allocation_info();
  ::mesos::Resource_AllocationInfo* temp = allocation_info_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  allocation_info_ = NULL;
  return temp;
}
inline ::mesos::Resource_AllocationInfo* Resource::unsafe_arena_release_allocation_info() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Resource.allocation_info)
  clear_has_allocation_info();
  ::mesos::Resource_AllocationInfo* temp = allocation_info_;
  allocation_info_ = NULL;
  return temp;
}
inline ::mesos::Resource_AllocationInfo* Resource::mutable_allocation_info() {
  set_has_allocation_info();
  if (allocation_info_ == NULL) {
    _slow_mutable_allocation_info();
  }
  // @@protoc_insertion_point(field_mutable:mesos.Resource.allocation_info)
  return allocation_info_;
}
inline void Resource::set_allocated_allocation_info(::mesos::Resource_AllocationInfo* allocation_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete allocation_info_;
  }
  if (allocation_info) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(allocation_info);
    if (message_arena != submessage_arena) {
      allocation_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, allocation_info, submessage_arena);
    }
    set_has_allocation_info();
  } else {
    clear_has_allocation_info();
  }
  allocation_info_ = allocation_info;
  // @@protoc_insertion_point(field_set_allocated:mesos.Resource.allocation_info)
}

// optional .mesos.Resource.ReservationInfo reservation = 8;
inline bool Resource::has_reservation() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Resource::set_has_reservation() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Resource::clear_has_reservation() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Resource::clear_reservation() {
  if (reservation_ != NULL) reservation_->Clear();
  clear_has_reservation();
}
inline const ::mesos::Resource_ReservationInfo& Resource::reservation() const {
  const ::mesos::Resource_ReservationInfo* p = reservation_;
  // @@protoc_insertion_point(field_get:mesos.Resource.reservation)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::Resource_ReservationInfo*>(
      &::mesos::_Resource_ReservationInfo_default_instance_);
}
inline ::mesos::Resource_ReservationInfo* Resource::release_reservation() {
  // @@protoc_insertion_point(field_release:mesos.Resource.reservation)
  clear_has_reservation();
  ::mesos::Resource_ReservationInfo* temp = reservation_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  reservation_ = NULL;
  return temp;
}
inline ::mesos::Resource_ReservationInfo* Resource::unsafe_arena_release_reservation() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Resource.reservation)
  clear_has_reservation();
  ::mesos::Resource_ReservationInfo* temp = reservation_;
  reservation_ = NULL;
  return temp;
}
inline ::mesos::Resource_ReservationInfo* Resource::mutable_reservation() {
  set_has_reservation();
  if (reservation_ == NULL) {
    _slow_mutable_reservation();
  }
  // @@protoc_insertion_point(field_mutable:mesos.Resource.reservation)
  return reservation_;
}
inline void Resource::set_allocated_reservation(::mesos::Resource_ReservationInfo* reservation) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reservation_;
  }
  if (reservation) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(reservation);
    if (message_arena != submessage_arena) {
      reservation = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, reservation, submessage_arena);
    }
    set_has_reservation();
  } else {
    clear_has_reservation();
  }
  reservation_ = reservation;
  // @@protoc_insertion_point(field_set_allocated:mesos.Resource.reservation)
}

// repeated .mesos.Resource.ReservationInfo reservations = 13;
inline int Resource::reservations_size() const {
  return reservations_.size();
}
inline void Resource::clear_reservations() {
  reservations_.Clear();
}
inline const ::mesos::Resource_ReservationInfo& Resource::reservations(int index) const {
  // @@protoc_insertion_point(field_get:mesos.Resource.reservations)
  return reservations_.Get(index);
}
inline ::mesos::Resource_ReservationInfo* Resource::mutable_reservations(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.Resource.reservations)
  return reservations_.Mutable(index);
}
inline ::mesos::Resource_ReservationInfo* Resource::add_reservations() {
  // @@protoc_insertion_point(field_add:mesos.Resource.reservations)
  return reservations_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource_ReservationInfo >*
Resource::mutable_reservations() {
  // @@protoc_insertion_point(field_mutable_list:mesos.Resource.reservations)
  return &reservations_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource_ReservationInfo >&
Resource::reservations() const {
  // @@protoc_insertion_point(field_list:mesos.Resource.reservations)
  return reservations_;
}

// optional .mesos.Resource.DiskInfo disk = 7;
inline bool Resource::has_disk() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Resource::set_has_disk() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Resource::clear_has_disk() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Resource::clear_disk() {
  if (disk_ != NULL) disk_->Clear();
  clear_has_disk();
}
inline const ::mesos::Resource_DiskInfo& Resource::disk() const {
  const ::mesos::Resource_DiskInfo* p = disk_;
  // @@protoc_insertion_point(field_get:mesos.Resource.disk)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::Resource_DiskInfo*>(
      &::mesos::_Resource_DiskInfo_default_instance_);
}
inline ::mesos::Resource_DiskInfo* Resource::release_disk() {
  // @@protoc_insertion_point(field_release:mesos.Resource.disk)
  clear_has_disk();
  ::mesos::Resource_DiskInfo* temp = disk_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  disk_ = NULL;
  return temp;
}
inline ::mesos::Resource_DiskInfo* Resource::unsafe_arena_release_disk() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Resource.disk)
  clear_has_disk();
  ::mesos::Resource_DiskInfo* temp = disk_;
  disk_ = NULL;
  return temp;
}
inline ::mesos::Resource_DiskInfo* Resource::mutable_disk() {
  set_has_disk();
  if (disk_ == NULL) {
    _slow_mutable_disk();
  }
  // @@protoc_insertion_point(field_mutable:mesos.Resource.disk)
  return disk_;
}
inline void Resource::set_allocated_disk(::mesos::Resource_DiskInfo* disk) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete disk_;
  }
  if (disk) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(disk);
    if (message_arena != submessage_arena) {
      disk = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, disk, submessage_arena);
    }
    set_has_disk();
  } else {
    clear_has_disk();
  }
  disk_ = disk;
  // @@protoc_insertion_point(field_set_allocated:mesos.Resource.disk)
}

// optional .mesos.Resource.RevocableInfo revocable = 9;
inline bool Resource::has_revocable() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Resource::set_has_revocable() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Resource::clear_has_revocable() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Resource::clear_revocable() {
  if (revocable_ != NULL) revocable_->Clear();
  clear_has_revocable();
}
inline const ::mesos::Resource_RevocableInfo& Resource::revocable() const {
  const ::mesos::Resource_RevocableInfo* p = revocable_;
  // @@protoc_insertion_point(field_get:mesos.Resource.revocable)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::Resource_RevocableInfo*>(
      &::mesos::_Resource_RevocableInfo_default_instance_);
}
inline ::mesos::Resource_RevocableInfo* Resource::release_revocable() {
  // @@protoc_insertion_point(field_release:mesos.Resource.revocable)
  clear_has_revocable();
  ::mesos::Resource_RevocableInfo* temp = revocable_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  revocable_ = NULL;
  return temp;
}
inline ::mesos::Resource_RevocableInfo* Resource::unsafe_arena_release_revocable() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Resource.revocable)
  clear_has_revocable();
  ::mesos::Resource_RevocableInfo* temp = revocable_;
  revocable_ = NULL;
  return temp;
}
inline ::mesos::Resource_RevocableInfo* Resource::mutable_revocable() {
  set_has_revocable();
  if (revocable_ == NULL) {
    _slow_mutable_revocable();
  }
  // @@protoc_insertion_point(field_mutable:mesos.Resource.revocable)
  return revocable_;
}
inline void Resource::set_allocated_revocable(::mesos::Resource_RevocableInfo* revocable) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete revocable_;
  }
  if (revocable) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(revocable);
    if (message_arena != submessage_arena) {
      revocable = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, revocable, submessage_arena);
    }
    set_has_revocable();
  } else {
    clear_has_revocable();
  }
  revocable_ = revocable;
  // @@protoc_insertion_point(field_set_allocated:mesos.Resource.revocable)
}

// optional .mesos.Resource.SharedInfo shared = 10;
inline bool Resource::has_shared() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Resource::set_has_shared() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Resource::clear_has_shared() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Resource::clear_shared() {
  if (shared_ != NULL) shared_->Clear();
  clear_has_shared();
}
inline const ::mesos::Resource_SharedInfo& Resource::shared() const {
  const ::mesos::Resource_SharedInfo* p = shared_;
  // @@protoc_insertion_point(field_get:mesos.Resource.shared)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::Resource_SharedInfo*>(
      &::mesos::_Resource_SharedInfo_default_instance_);
}
inline ::mesos::Resource_SharedInfo* Resource::release_shared() {
  // @@protoc_insertion_point(field_release:mesos.Resource.shared)
  clear_has_shared();
  ::mesos::Resource_SharedInfo* temp = shared_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  shared_ = NULL;
  return temp;
}
inline ::mesos::Resource_SharedInfo* Resource::unsafe_arena_release_shared() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Resource.shared)
  clear_has_shared();
  ::mesos::Resource_SharedInfo* temp = shared_;
  shared_ = NULL;
  return temp;
}
inline ::mesos::Resource_SharedInfo* Resource::mutable_shared() {
  set_has_shared();
  if (shared_ == NULL) {
    _slow_mutable_shared();
  }
  // @@protoc_insertion_point(field_mutable:mesos.Resource.shared)
  return shared_;
}
inline void Resource::set_allocated_shared(::mesos::Resource_SharedInfo* shared) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete shared_;
  }
  if (shared) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(shared);
    if (message_arena != submessage_arena) {
      shared = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, shared, submessage_arena);
    }
    set_has_shared();
  } else {
    clear_has_shared();
  }
  shared_ = shared;
  // @@protoc_insertion_point(field_set_allocated:mesos.Resource.shared)
}

// -------------------------------------------------------------------

// TrafficControlStatistics

// required string id = 1;
inline bool TrafficControlStatistics::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TrafficControlStatistics::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TrafficControlStatistics::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TrafficControlStatistics::clear_id() {
  id_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_id();
}
inline const ::std::string& TrafficControlStatistics::id() const {
  // @@protoc_insertion_point(field_get:mesos.TrafficControlStatistics.id)
  return id_.Get();
}
inline void TrafficControlStatistics::set_id(const ::std::string& value) {
  set_has_id();
  id_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.TrafficControlStatistics.id)
}
#if LANG_CXX11
inline void TrafficControlStatistics::set_id(::std::string&& value) {
  set_has_id();
  id_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.TrafficControlStatistics.id)
}
#endif
inline void TrafficControlStatistics::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_id();
  id_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.TrafficControlStatistics.id)
}
inline void TrafficControlStatistics::set_id(const char* value,
    size_t size) {
  set_has_id();
  id_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.TrafficControlStatistics.id)
}
inline ::std::string* TrafficControlStatistics::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:mesos.TrafficControlStatistics.id)
  return id_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* TrafficControlStatistics::release_id() {
  // @@protoc_insertion_point(field_release:mesos.TrafficControlStatistics.id)
  clear_has_id();
  return id_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void TrafficControlStatistics::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.TrafficControlStatistics.id)
}
inline ::std::string* TrafficControlStatistics::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.TrafficControlStatistics.id)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_id();
  return id_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void TrafficControlStatistics::unsafe_arena_set_allocated_id(
    ::std::string* id) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      id, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.TrafficControlStatistics.id)
}

// optional uint64 backlog = 2;
inline bool TrafficControlStatistics::has_backlog() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TrafficControlStatistics::set_has_backlog() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TrafficControlStatistics::clear_has_backlog() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TrafficControlStatistics::clear_backlog() {
  backlog_ = GOOGLE_ULONGLONG(0);
  clear_has_backlog();
}
inline ::google::protobuf::uint64 TrafficControlStatistics::backlog() const {
  // @@protoc_insertion_point(field_get:mesos.TrafficControlStatistics.backlog)
  return backlog_;
}
inline void TrafficControlStatistics::set_backlog(::google::protobuf::uint64 value) {
  set_has_backlog();
  backlog_ = value;
  // @@protoc_insertion_point(field_set:mesos.TrafficControlStatistics.backlog)
}

// optional uint64 bytes = 3;
inline bool TrafficControlStatistics::has_bytes() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TrafficControlStatistics::set_has_bytes() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TrafficControlStatistics::clear_has_bytes() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TrafficControlStatistics::clear_bytes() {
  bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_bytes();
}
inline ::google::protobuf::uint64 TrafficControlStatistics::bytes() const {
  // @@protoc_insertion_point(field_get:mesos.TrafficControlStatistics.bytes)
  return bytes_;
}
inline void TrafficControlStatistics::set_bytes(::google::protobuf::uint64 value) {
  set_has_bytes();
  bytes_ = value;
  // @@protoc_insertion_point(field_set:mesos.TrafficControlStatistics.bytes)
}

// optional uint64 drops = 4;
inline bool TrafficControlStatistics::has_drops() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TrafficControlStatistics::set_has_drops() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TrafficControlStatistics::clear_has_drops() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TrafficControlStatistics::clear_drops() {
  drops_ = GOOGLE_ULONGLONG(0);
  clear_has_drops();
}
inline ::google::protobuf::uint64 TrafficControlStatistics::drops() const {
  // @@protoc_insertion_point(field_get:mesos.TrafficControlStatistics.drops)
  return drops_;
}
inline void TrafficControlStatistics::set_drops(::google::protobuf::uint64 value) {
  set_has_drops();
  drops_ = value;
  // @@protoc_insertion_point(field_set:mesos.TrafficControlStatistics.drops)
}

// optional uint64 overlimits = 5;
inline bool TrafficControlStatistics::has_overlimits() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TrafficControlStatistics::set_has_overlimits() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TrafficControlStatistics::clear_has_overlimits() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TrafficControlStatistics::clear_overlimits() {
  overlimits_ = GOOGLE_ULONGLONG(0);
  clear_has_overlimits();
}
inline ::google::protobuf::uint64 TrafficControlStatistics::overlimits() const {
  // @@protoc_insertion_point(field_get:mesos.TrafficControlStatistics.overlimits)
  return overlimits_;
}
inline void TrafficControlStatistics::set_overlimits(::google::protobuf::uint64 value) {
  set_has_overlimits();
  overlimits_ = value;
  // @@protoc_insertion_point(field_set:mesos.TrafficControlStatistics.overlimits)
}

// optional uint64 packets = 6;
inline bool TrafficControlStatistics::has_packets() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TrafficControlStatistics::set_has_packets() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TrafficControlStatistics::clear_has_packets() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TrafficControlStatistics::clear_packets() {
  packets_ = GOOGLE_ULONGLONG(0);
  clear_has_packets();
}
inline ::google::protobuf::uint64 TrafficControlStatistics::packets() const {
  // @@protoc_insertion_point(field_get:mesos.TrafficControlStatistics.packets)
  return packets_;
}
inline void TrafficControlStatistics::set_packets(::google::protobuf::uint64 value) {
  set_has_packets();
  packets_ = value;
  // @@protoc_insertion_point(field_set:mesos.TrafficControlStatistics.packets)
}

// optional uint64 qlen = 7;
inline bool TrafficControlStatistics::has_qlen() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TrafficControlStatistics::set_has_qlen() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TrafficControlStatistics::clear_has_qlen() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TrafficControlStatistics::clear_qlen() {
  qlen_ = GOOGLE_ULONGLONG(0);
  clear_has_qlen();
}
inline ::google::protobuf::uint64 TrafficControlStatistics::qlen() const {
  // @@protoc_insertion_point(field_get:mesos.TrafficControlStatistics.qlen)
  return qlen_;
}
inline void TrafficControlStatistics::set_qlen(::google::protobuf::uint64 value) {
  set_has_qlen();
  qlen_ = value;
  // @@protoc_insertion_point(field_set:mesos.TrafficControlStatistics.qlen)
}

// optional uint64 ratebps = 8;
inline bool TrafficControlStatistics::has_ratebps() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TrafficControlStatistics::set_has_ratebps() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TrafficControlStatistics::clear_has_ratebps() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TrafficControlStatistics::clear_ratebps() {
  ratebps_ = GOOGLE_ULONGLONG(0);
  clear_has_ratebps();
}
inline ::google::protobuf::uint64 TrafficControlStatistics::ratebps() const {
  // @@protoc_insertion_point(field_get:mesos.TrafficControlStatistics.ratebps)
  return ratebps_;
}
inline void TrafficControlStatistics::set_ratebps(::google::protobuf::uint64 value) {
  set_has_ratebps();
  ratebps_ = value;
  // @@protoc_insertion_point(field_set:mesos.TrafficControlStatistics.ratebps)
}

// optional uint64 ratepps = 9;
inline bool TrafficControlStatistics::has_ratepps() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TrafficControlStatistics::set_has_ratepps() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TrafficControlStatistics::clear_has_ratepps() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TrafficControlStatistics::clear_ratepps() {
  ratepps_ = GOOGLE_ULONGLONG(0);
  clear_has_ratepps();
}
inline ::google::protobuf::uint64 TrafficControlStatistics::ratepps() const {
  // @@protoc_insertion_point(field_get:mesos.TrafficControlStatistics.ratepps)
  return ratepps_;
}
inline void TrafficControlStatistics::set_ratepps(::google::protobuf::uint64 value) {
  set_has_ratepps();
  ratepps_ = value;
  // @@protoc_insertion_point(field_set:mesos.TrafficControlStatistics.ratepps)
}

// optional uint64 requeues = 10;
inline bool TrafficControlStatistics::has_requeues() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TrafficControlStatistics::set_has_requeues() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TrafficControlStatistics::clear_has_requeues() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TrafficControlStatistics::clear_requeues() {
  requeues_ = GOOGLE_ULONGLONG(0);
  clear_has_requeues();
}
inline ::google::protobuf::uint64 TrafficControlStatistics::requeues() const {
  // @@protoc_insertion_point(field_get:mesos.TrafficControlStatistics.requeues)
  return requeues_;
}
inline void TrafficControlStatistics::set_requeues(::google::protobuf::uint64 value) {
  set_has_requeues();
  requeues_ = value;
  // @@protoc_insertion_point(field_set:mesos.TrafficControlStatistics.requeues)
}

// -------------------------------------------------------------------

// IpStatistics

// optional int64 Forwarding = 1;
inline bool IpStatistics::has_forwarding() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IpStatistics::set_has_forwarding() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IpStatistics::clear_has_forwarding() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IpStatistics::clear_forwarding() {
  forwarding_ = GOOGLE_LONGLONG(0);
  clear_has_forwarding();
}
inline ::google::protobuf::int64 IpStatistics::forwarding() const {
  // @@protoc_insertion_point(field_get:mesos.IpStatistics.Forwarding)
  return forwarding_;
}
inline void IpStatistics::set_forwarding(::google::protobuf::int64 value) {
  set_has_forwarding();
  forwarding_ = value;
  // @@protoc_insertion_point(field_set:mesos.IpStatistics.Forwarding)
}

// optional int64 DefaultTTL = 2;
inline bool IpStatistics::has_defaultttl() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IpStatistics::set_has_defaultttl() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IpStatistics::clear_has_defaultttl() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IpStatistics::clear_defaultttl() {
  defaultttl_ = GOOGLE_LONGLONG(0);
  clear_has_defaultttl();
}
inline ::google::protobuf::int64 IpStatistics::defaultttl() const {
  // @@protoc_insertion_point(field_get:mesos.IpStatistics.DefaultTTL)
  return defaultttl_;
}
inline void IpStatistics::set_defaultttl(::google::protobuf::int64 value) {
  set_has_defaultttl();
  defaultttl_ = value;
  // @@protoc_insertion_point(field_set:mesos.IpStatistics.DefaultTTL)
}

// optional int64 InReceives = 3;
inline bool IpStatistics::has_inreceives() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IpStatistics::set_has_inreceives() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IpStatistics::clear_has_inreceives() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IpStatistics::clear_inreceives() {
  inreceives_ = GOOGLE_LONGLONG(0);
  clear_has_inreceives();
}
inline ::google::protobuf::int64 IpStatistics::inreceives() const {
  // @@protoc_insertion_point(field_get:mesos.IpStatistics.InReceives)
  return inreceives_;
}
inline void IpStatistics::set_inreceives(::google::protobuf::int64 value) {
  set_has_inreceives();
  inreceives_ = value;
  // @@protoc_insertion_point(field_set:mesos.IpStatistics.InReceives)
}

// optional int64 InHdrErrors = 4;
inline bool IpStatistics::has_inhdrerrors() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IpStatistics::set_has_inhdrerrors() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IpStatistics::clear_has_inhdrerrors() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IpStatistics::clear_inhdrerrors() {
  inhdrerrors_ = GOOGLE_LONGLONG(0);
  clear_has_inhdrerrors();
}
inline ::google::protobuf::int64 IpStatistics::inhdrerrors() const {
  // @@protoc_insertion_point(field_get:mesos.IpStatistics.InHdrErrors)
  return inhdrerrors_;
}
inline void IpStatistics::set_inhdrerrors(::google::protobuf::int64 value) {
  set_has_inhdrerrors();
  inhdrerrors_ = value;
  // @@protoc_insertion_point(field_set:mesos.IpStatistics.InHdrErrors)
}

// optional int64 InAddrErrors = 5;
inline bool IpStatistics::has_inaddrerrors() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void IpStatistics::set_has_inaddrerrors() {
  _has_bits_[0] |= 0x00000010u;
}
inline void IpStatistics::clear_has_inaddrerrors() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void IpStatistics::clear_inaddrerrors() {
  inaddrerrors_ = GOOGLE_LONGLONG(0);
  clear_has_inaddrerrors();
}
inline ::google::protobuf::int64 IpStatistics::inaddrerrors() const {
  // @@protoc_insertion_point(field_get:mesos.IpStatistics.InAddrErrors)
  return inaddrerrors_;
}
inline void IpStatistics::set_inaddrerrors(::google::protobuf::int64 value) {
  set_has_inaddrerrors();
  inaddrerrors_ = value;
  // @@protoc_insertion_point(field_set:mesos.IpStatistics.InAddrErrors)
}

// optional int64 ForwDatagrams = 6;
inline bool IpStatistics::has_forwdatagrams() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void IpStatistics::set_has_forwdatagrams() {
  _has_bits_[0] |= 0x00000020u;
}
inline void IpStatistics::clear_has_forwdatagrams() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void IpStatistics::clear_forwdatagrams() {
  forwdatagrams_ = GOOGLE_LONGLONG(0);
  clear_has_forwdatagrams();
}
inline ::google::protobuf::int64 IpStatistics::forwdatagrams() const {
  // @@protoc_insertion_point(field_get:mesos.IpStatistics.ForwDatagrams)
  return forwdatagrams_;
}
inline void IpStatistics::set_forwdatagrams(::google::protobuf::int64 value) {
  set_has_forwdatagrams();
  forwdatagrams_ = value;
  // @@protoc_insertion_point(field_set:mesos.IpStatistics.ForwDatagrams)
}

// optional int64 InUnknownProtos = 7;
inline bool IpStatistics::has_inunknownprotos() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void IpStatistics::set_has_inunknownprotos() {
  _has_bits_[0] |= 0x00000040u;
}
inline void IpStatistics::clear_has_inunknownprotos() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void IpStatistics::clear_inunknownprotos() {
  inunknownprotos_ = GOOGLE_LONGLONG(0);
  clear_has_inunknownprotos();
}
inline ::google::protobuf::int64 IpStatistics::inunknownprotos() const {
  // @@protoc_insertion_point(field_get:mesos.IpStatistics.InUnknownProtos)
  return inunknownprotos_;
}
inline void IpStatistics::set_inunknownprotos(::google::protobuf::int64 value) {
  set_has_inunknownprotos();
  inunknownprotos_ = value;
  // @@protoc_insertion_point(field_set:mesos.IpStatistics.InUnknownProtos)
}

// optional int64 InDiscards = 8;
inline bool IpStatistics::has_indiscards() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void IpStatistics::set_has_indiscards() {
  _has_bits_[0] |= 0x00000080u;
}
inline void IpStatistics::clear_has_indiscards() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void IpStatistics::clear_indiscards() {
  indiscards_ = GOOGLE_LONGLONG(0);
  clear_has_indiscards();
}
inline ::google::protobuf::int64 IpStatistics::indiscards() const {
  // @@protoc_insertion_point(field_get:mesos.IpStatistics.InDiscards)
  return indiscards_;
}
inline void IpStatistics::set_indiscards(::google::protobuf::int64 value) {
  set_has_indiscards();
  indiscards_ = value;
  // @@protoc_insertion_point(field_set:mesos.IpStatistics.InDiscards)
}

// optional int64 InDelivers = 9;
inline bool IpStatistics::has_indelivers() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void IpStatistics::set_has_indelivers() {
  _has_bits_[0] |= 0x00000100u;
}
inline void IpStatistics::clear_has_indelivers() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void IpStatistics::clear_indelivers() {
  indelivers_ = GOOGLE_LONGLONG(0);
  clear_has_indelivers();
}
inline ::google::protobuf::int64 IpStatistics::indelivers() const {
  // @@protoc_insertion_point(field_get:mesos.IpStatistics.InDelivers)
  return indelivers_;
}
inline void IpStatistics::set_indelivers(::google::protobuf::int64 value) {
  set_has_indelivers();
  indelivers_ = value;
  // @@protoc_insertion_point(field_set:mesos.IpStatistics.InDelivers)
}

// optional int64 OutRequests = 10;
inline bool IpStatistics::has_outrequests() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void IpStatistics::set_has_outrequests() {
  _has_bits_[0] |= 0x00000200u;
}
inline void IpStatistics::clear_has_outrequests() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void IpStatistics::clear_outrequests() {
  outrequests_ = GOOGLE_LONGLONG(0);
  clear_has_outrequests();
}
inline ::google::protobuf::int64 IpStatistics::outrequests() const {
  // @@protoc_insertion_point(field_get:mesos.IpStatistics.OutRequests)
  return outrequests_;
}
inline void IpStatistics::set_outrequests(::google::protobuf::int64 value) {
  set_has_outrequests();
  outrequests_ = value;
  // @@protoc_insertion_point(field_set:mesos.IpStatistics.OutRequests)
}

// optional int64 OutDiscards = 11;
inline bool IpStatistics::has_outdiscards() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void IpStatistics::set_has_outdiscards() {
  _has_bits_[0] |= 0x00000400u;
}
inline void IpStatistics::clear_has_outdiscards() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void IpStatistics::clear_outdiscards() {
  outdiscards_ = GOOGLE_LONGLONG(0);
  clear_has_outdiscards();
}
inline ::google::protobuf::int64 IpStatistics::outdiscards() const {
  // @@protoc_insertion_point(field_get:mesos.IpStatistics.OutDiscards)
  return outdiscards_;
}
inline void IpStatistics::set_outdiscards(::google::protobuf::int64 value) {
  set_has_outdiscards();
  outdiscards_ = value;
  // @@protoc_insertion_point(field_set:mesos.IpStatistics.OutDiscards)
}

// optional int64 OutNoRoutes = 12;
inline bool IpStatistics::has_outnoroutes() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void IpStatistics::set_has_outnoroutes() {
  _has_bits_[0] |= 0x00000800u;
}
inline void IpStatistics::clear_has_outnoroutes() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void IpStatistics::clear_outnoroutes() {
  outnoroutes_ = GOOGLE_LONGLONG(0);
  clear_has_outnoroutes();
}
inline ::google::protobuf::int64 IpStatistics::outnoroutes() const {
  // @@protoc_insertion_point(field_get:mesos.IpStatistics.OutNoRoutes)
  return outnoroutes_;
}
inline void IpStatistics::set_outnoroutes(::google::protobuf::int64 value) {
  set_has_outnoroutes();
  outnoroutes_ = value;
  // @@protoc_insertion_point(field_set:mesos.IpStatistics.OutNoRoutes)
}

// optional int64 ReasmTimeout = 13;
inline bool IpStatistics::has_reasmtimeout() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void IpStatistics::set_has_reasmtimeout() {
  _has_bits_[0] |= 0x00001000u;
}
inline void IpStatistics::clear_has_reasmtimeout() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void IpStatistics::clear_reasmtimeout() {
  reasmtimeout_ = GOOGLE_LONGLONG(0);
  clear_has_reasmtimeout();
}
inline ::google::protobuf::int64 IpStatistics::reasmtimeout() const {
  // @@protoc_insertion_point(field_get:mesos.IpStatistics.ReasmTimeout)
  return reasmtimeout_;
}
inline void IpStatistics::set_reasmtimeout(::google::protobuf::int64 value) {
  set_has_reasmtimeout();
  reasmtimeout_ = value;
  // @@protoc_insertion_point(field_set:mesos.IpStatistics.ReasmTimeout)
}

// optional int64 ReasmReqds = 14;
inline bool IpStatistics::has_reasmreqds() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void IpStatistics::set_has_reasmreqds() {
  _has_bits_[0] |= 0x00002000u;
}
inline void IpStatistics::clear_has_reasmreqds() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void IpStatistics::clear_reasmreqds() {
  reasmreqds_ = GOOGLE_LONGLONG(0);
  clear_has_reasmreqds();
}
inline ::google::protobuf::int64 IpStatistics::reasmreqds() const {
  // @@protoc_insertion_point(field_get:mesos.IpStatistics.ReasmReqds)
  return reasmreqds_;
}
inline void IpStatistics::set_reasmreqds(::google::protobuf::int64 value) {
  set_has_reasmreqds();
  reasmreqds_ = value;
  // @@protoc_insertion_point(field_set:mesos.IpStatistics.ReasmReqds)
}

// optional int64 ReasmOKs = 15;
inline bool IpStatistics::has_reasmoks() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void IpStatistics::set_has_reasmoks() {
  _has_bits_[0] |= 0x00004000u;
}
inline void IpStatistics::clear_has_reasmoks() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void IpStatistics::clear_reasmoks() {
  reasmoks_ = GOOGLE_LONGLONG(0);
  clear_has_reasmoks();
}
inline ::google::protobuf::int64 IpStatistics::reasmoks() const {
  // @@protoc_insertion_point(field_get:mesos.IpStatistics.ReasmOKs)
  return reasmoks_;
}
inline void IpStatistics::set_reasmoks(::google::protobuf::int64 value) {
  set_has_reasmoks();
  reasmoks_ = value;
  // @@protoc_insertion_point(field_set:mesos.IpStatistics.ReasmOKs)
}

// optional int64 ReasmFails = 16;
inline bool IpStatistics::has_reasmfails() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void IpStatistics::set_has_reasmfails() {
  _has_bits_[0] |= 0x00008000u;
}
inline void IpStatistics::clear_has_reasmfails() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void IpStatistics::clear_reasmfails() {
  reasmfails_ = GOOGLE_LONGLONG(0);
  clear_has_reasmfails();
}
inline ::google::protobuf::int64 IpStatistics::reasmfails() const {
  // @@protoc_insertion_point(field_get:mesos.IpStatistics.ReasmFails)
  return reasmfails_;
}
inline void IpStatistics::set_reasmfails(::google::protobuf::int64 value) {
  set_has_reasmfails();
  reasmfails_ = value;
  // @@protoc_insertion_point(field_set:mesos.IpStatistics.ReasmFails)
}

// optional int64 FragOKs = 17;
inline bool IpStatistics::has_fragoks() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void IpStatistics::set_has_fragoks() {
  _has_bits_[0] |= 0x00010000u;
}
inline void IpStatistics::clear_has_fragoks() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void IpStatistics::clear_fragoks() {
  fragoks_ = GOOGLE_LONGLONG(0);
  clear_has_fragoks();
}
inline ::google::protobuf::int64 IpStatistics::fragoks() const {
  // @@protoc_insertion_point(field_get:mesos.IpStatistics.FragOKs)
  return fragoks_;
}
inline void IpStatistics::set_fragoks(::google::protobuf::int64 value) {
  set_has_fragoks();
  fragoks_ = value;
  // @@protoc_insertion_point(field_set:mesos.IpStatistics.FragOKs)
}

// optional int64 FragFails = 18;
inline bool IpStatistics::has_fragfails() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void IpStatistics::set_has_fragfails() {
  _has_bits_[0] |= 0x00020000u;
}
inline void IpStatistics::clear_has_fragfails() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void IpStatistics::clear_fragfails() {
  fragfails_ = GOOGLE_LONGLONG(0);
  clear_has_fragfails();
}
inline ::google::protobuf::int64 IpStatistics::fragfails() const {
  // @@protoc_insertion_point(field_get:mesos.IpStatistics.FragFails)
  return fragfails_;
}
inline void IpStatistics::set_fragfails(::google::protobuf::int64 value) {
  set_has_fragfails();
  fragfails_ = value;
  // @@protoc_insertion_point(field_set:mesos.IpStatistics.FragFails)
}

// optional int64 FragCreates = 19;
inline bool IpStatistics::has_fragcreates() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void IpStatistics::set_has_fragcreates() {
  _has_bits_[0] |= 0x00040000u;
}
inline void IpStatistics::clear_has_fragcreates() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void IpStatistics::clear_fragcreates() {
  fragcreates_ = GOOGLE_LONGLONG(0);
  clear_has_fragcreates();
}
inline ::google::protobuf::int64 IpStatistics::fragcreates() const {
  // @@protoc_insertion_point(field_get:mesos.IpStatistics.FragCreates)
  return fragcreates_;
}
inline void IpStatistics::set_fragcreates(::google::protobuf::int64 value) {
  set_has_fragcreates();
  fragcreates_ = value;
  // @@protoc_insertion_point(field_set:mesos.IpStatistics.FragCreates)
}

// -------------------------------------------------------------------

// IcmpStatistics

// optional int64 InMsgs = 1;
inline bool IcmpStatistics::has_inmsgs() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IcmpStatistics::set_has_inmsgs() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IcmpStatistics::clear_has_inmsgs() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IcmpStatistics::clear_inmsgs() {
  inmsgs_ = GOOGLE_LONGLONG(0);
  clear_has_inmsgs();
}
inline ::google::protobuf::int64 IcmpStatistics::inmsgs() const {
  // @@protoc_insertion_point(field_get:mesos.IcmpStatistics.InMsgs)
  return inmsgs_;
}
inline void IcmpStatistics::set_inmsgs(::google::protobuf::int64 value) {
  set_has_inmsgs();
  inmsgs_ = value;
  // @@protoc_insertion_point(field_set:mesos.IcmpStatistics.InMsgs)
}

// optional int64 InErrors = 2;
inline bool IcmpStatistics::has_inerrors() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IcmpStatistics::set_has_inerrors() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IcmpStatistics::clear_has_inerrors() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IcmpStatistics::clear_inerrors() {
  inerrors_ = GOOGLE_LONGLONG(0);
  clear_has_inerrors();
}
inline ::google::protobuf::int64 IcmpStatistics::inerrors() const {
  // @@protoc_insertion_point(field_get:mesos.IcmpStatistics.InErrors)
  return inerrors_;
}
inline void IcmpStatistics::set_inerrors(::google::protobuf::int64 value) {
  set_has_inerrors();
  inerrors_ = value;
  // @@protoc_insertion_point(field_set:mesos.IcmpStatistics.InErrors)
}

// optional int64 InCsumErrors = 3;
inline bool IcmpStatistics::has_incsumerrors() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IcmpStatistics::set_has_incsumerrors() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IcmpStatistics::clear_has_incsumerrors() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IcmpStatistics::clear_incsumerrors() {
  incsumerrors_ = GOOGLE_LONGLONG(0);
  clear_has_incsumerrors();
}
inline ::google::protobuf::int64 IcmpStatistics::incsumerrors() const {
  // @@protoc_insertion_point(field_get:mesos.IcmpStatistics.InCsumErrors)
  return incsumerrors_;
}
inline void IcmpStatistics::set_incsumerrors(::google::protobuf::int64 value) {
  set_has_incsumerrors();
  incsumerrors_ = value;
  // @@protoc_insertion_point(field_set:mesos.IcmpStatistics.InCsumErrors)
}

// optional int64 InDestUnreachs = 4;
inline bool IcmpStatistics::has_indestunreachs() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IcmpStatistics::set_has_indestunreachs() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IcmpStatistics::clear_has_indestunreachs() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IcmpStatistics::clear_indestunreachs() {
  indestunreachs_ = GOOGLE_LONGLONG(0);
  clear_has_indestunreachs();
}
inline ::google::protobuf::int64 IcmpStatistics::indestunreachs() const {
  // @@protoc_insertion_point(field_get:mesos.IcmpStatistics.InDestUnreachs)
  return indestunreachs_;
}
inline void IcmpStatistics::set_indestunreachs(::google::protobuf::int64 value) {
  set_has_indestunreachs();
  indestunreachs_ = value;
  // @@protoc_insertion_point(field_set:mesos.IcmpStatistics.InDestUnreachs)
}

// optional int64 InTimeExcds = 5;
inline bool IcmpStatistics::has_intimeexcds() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void IcmpStatistics::set_has_intimeexcds() {
  _has_bits_[0] |= 0x00000010u;
}
inline void IcmpStatistics::clear_has_intimeexcds() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void IcmpStatistics::clear_intimeexcds() {
  intimeexcds_ = GOOGLE_LONGLONG(0);
  clear_has_intimeexcds();
}
inline ::google::protobuf::int64 IcmpStatistics::intimeexcds() const {
  // @@protoc_insertion_point(field_get:mesos.IcmpStatistics.InTimeExcds)
  return intimeexcds_;
}
inline void IcmpStatistics::set_intimeexcds(::google::protobuf::int64 value) {
  set_has_intimeexcds();
  intimeexcds_ = value;
  // @@protoc_insertion_point(field_set:mesos.IcmpStatistics.InTimeExcds)
}

// optional int64 InParmProbs = 6;
inline bool IcmpStatistics::has_inparmprobs() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void IcmpStatistics::set_has_inparmprobs() {
  _has_bits_[0] |= 0x00000020u;
}
inline void IcmpStatistics::clear_has_inparmprobs() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void IcmpStatistics::clear_inparmprobs() {
  inparmprobs_ = GOOGLE_LONGLONG(0);
  clear_has_inparmprobs();
}
inline ::google::protobuf::int64 IcmpStatistics::inparmprobs() const {
  // @@protoc_insertion_point(field_get:mesos.IcmpStatistics.InParmProbs)
  return inparmprobs_;
}
inline void IcmpStatistics::set_inparmprobs(::google::protobuf::int64 value) {
  set_has_inparmprobs();
  inparmprobs_ = value;
  // @@protoc_insertion_point(field_set:mesos.IcmpStatistics.InParmProbs)
}

// optional int64 InSrcQuenchs = 7;
inline bool IcmpStatistics::has_insrcquenchs() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void IcmpStatistics::set_has_insrcquenchs() {
  _has_bits_[0] |= 0x00000040u;
}
inline void IcmpStatistics::clear_has_insrcquenchs() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void IcmpStatistics::clear_insrcquenchs() {
  insrcquenchs_ = GOOGLE_LONGLONG(0);
  clear_has_insrcquenchs();
}
inline ::google::protobuf::int64 IcmpStatistics::insrcquenchs() const {
  // @@protoc_insertion_point(field_get:mesos.IcmpStatistics.InSrcQuenchs)
  return insrcquenchs_;
}
inline void IcmpStatistics::set_insrcquenchs(::google::protobuf::int64 value) {
  set_has_insrcquenchs();
  insrcquenchs_ = value;
  // @@protoc_insertion_point(field_set:mesos.IcmpStatistics.InSrcQuenchs)
}

// optional int64 InRedirects = 8;
inline bool IcmpStatistics::has_inredirects() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void IcmpStatistics::set_has_inredirects() {
  _has_bits_[0] |= 0x00000080u;
}
inline void IcmpStatistics::clear_has_inredirects() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void IcmpStatistics::clear_inredirects() {
  inredirects_ = GOOGLE_LONGLONG(0);
  clear_has_inredirects();
}
inline ::google::protobuf::int64 IcmpStatistics::inredirects() const {
  // @@protoc_insertion_point(field_get:mesos.IcmpStatistics.InRedirects)
  return inredirects_;
}
inline void IcmpStatistics::set_inredirects(::google::protobuf::int64 value) {
  set_has_inredirects();
  inredirects_ = value;
  // @@protoc_insertion_point(field_set:mesos.IcmpStatistics.InRedirects)
}

// optional int64 InEchos = 9;
inline bool IcmpStatistics::has_inechos() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void IcmpStatistics::set_has_inechos() {
  _has_bits_[0] |= 0x00000100u;
}
inline void IcmpStatistics::clear_has_inechos() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void IcmpStatistics::clear_inechos() {
  inechos_ = GOOGLE_LONGLONG(0);
  clear_has_inechos();
}
inline ::google::protobuf::int64 IcmpStatistics::inechos() const {
  // @@protoc_insertion_point(field_get:mesos.IcmpStatistics.InEchos)
  return inechos_;
}
inline void IcmpStatistics::set_inechos(::google::protobuf::int64 value) {
  set_has_inechos();
  inechos_ = value;
  // @@protoc_insertion_point(field_set:mesos.IcmpStatistics.InEchos)
}

// optional int64 InEchoReps = 10;
inline bool IcmpStatistics::has_inechoreps() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void IcmpStatistics::set_has_inechoreps() {
  _has_bits_[0] |= 0x00000200u;
}
inline void IcmpStatistics::clear_has_inechoreps() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void IcmpStatistics::clear_inechoreps() {
  inechoreps_ = GOOGLE_LONGLONG(0);
  clear_has_inechoreps();
}
inline ::google::protobuf::int64 IcmpStatistics::inechoreps() const {
  // @@protoc_insertion_point(field_get:mesos.IcmpStatistics.InEchoReps)
  return inechoreps_;
}
inline void IcmpStatistics::set_inechoreps(::google::protobuf::int64 value) {
  set_has_inechoreps();
  inechoreps_ = value;
  // @@protoc_insertion_point(field_set:mesos.IcmpStatistics.InEchoReps)
}

// optional int64 InTimestamps = 11;
inline bool IcmpStatistics::has_intimestamps() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void IcmpStatistics::set_has_intimestamps() {
  _has_bits_[0] |= 0x00000400u;
}
inline void IcmpStatistics::clear_has_intimestamps() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void IcmpStatistics::clear_intimestamps() {
  intimestamps_ = GOOGLE_LONGLONG(0);
  clear_has_intimestamps();
}
inline ::google::protobuf::int64 IcmpStatistics::intimestamps() const {
  // @@protoc_insertion_point(field_get:mesos.IcmpStatistics.InTimestamps)
  return intimestamps_;
}
inline void IcmpStatistics::set_intimestamps(::google::protobuf::int64 value) {
  set_has_intimestamps();
  intimestamps_ = value;
  // @@protoc_insertion_point(field_set:mesos.IcmpStatistics.InTimestamps)
}

// optional int64 InTimestampReps = 12;
inline bool IcmpStatistics::has_intimestampreps() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void IcmpStatistics::set_has_intimestampreps() {
  _has_bits_[0] |= 0x00000800u;
}
inline void IcmpStatistics::clear_has_intimestampreps() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void IcmpStatistics::clear_intimestampreps() {
  intimestampreps_ = GOOGLE_LONGLONG(0);
  clear_has_intimestampreps();
}
inline ::google::protobuf::int64 IcmpStatistics::intimestampreps() const {
  // @@protoc_insertion_point(field_get:mesos.IcmpStatistics.InTimestampReps)
  return intimestampreps_;
}
inline void IcmpStatistics::set_intimestampreps(::google::protobuf::int64 value) {
  set_has_intimestampreps();
  intimestampreps_ = value;
  // @@protoc_insertion_point(field_set:mesos.IcmpStatistics.InTimestampReps)
}

// optional int64 InAddrMasks = 13;
inline bool IcmpStatistics::has_inaddrmasks() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void IcmpStatistics::set_has_inaddrmasks() {
  _has_bits_[0] |= 0x00001000u;
}
inline void IcmpStatistics::clear_has_inaddrmasks() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void IcmpStatistics::clear_inaddrmasks() {
  inaddrmasks_ = GOOGLE_LONGLONG(0);
  clear_has_inaddrmasks();
}
inline ::google::protobuf::int64 IcmpStatistics::inaddrmasks() const {
  // @@protoc_insertion_point(field_get:mesos.IcmpStatistics.InAddrMasks)
  return inaddrmasks_;
}
inline void IcmpStatistics::set_inaddrmasks(::google::protobuf::int64 value) {
  set_has_inaddrmasks();
  inaddrmasks_ = value;
  // @@protoc_insertion_point(field_set:mesos.IcmpStatistics.InAddrMasks)
}

// optional int64 InAddrMaskReps = 14;
inline bool IcmpStatistics::has_inaddrmaskreps() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void IcmpStatistics::set_has_inaddrmaskreps() {
  _has_bits_[0] |= 0x00002000u;
}
inline void IcmpStatistics::clear_has_inaddrmaskreps() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void IcmpStatistics::clear_inaddrmaskreps() {
  inaddrmaskreps_ = GOOGLE_LONGLONG(0);
  clear_has_inaddrmaskreps();
}
inline ::google::protobuf::int64 IcmpStatistics::inaddrmaskreps() const {
  // @@protoc_insertion_point(field_get:mesos.IcmpStatistics.InAddrMaskReps)
  return inaddrmaskreps_;
}
inline void IcmpStatistics::set_inaddrmaskreps(::google::protobuf::int64 value) {
  set_has_inaddrmaskreps();
  inaddrmaskreps_ = value;
  // @@protoc_insertion_point(field_set:mesos.IcmpStatistics.InAddrMaskReps)
}

// optional int64 OutMsgs = 15;
inline bool IcmpStatistics::has_outmsgs() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void IcmpStatistics::set_has_outmsgs() {
  _has_bits_[0] |= 0x00004000u;
}
inline void IcmpStatistics::clear_has_outmsgs() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void IcmpStatistics::clear_outmsgs() {
  outmsgs_ = GOOGLE_LONGLONG(0);
  clear_has_outmsgs();
}
inline ::google::protobuf::int64 IcmpStatistics::outmsgs() const {
  // @@protoc_insertion_point(field_get:mesos.IcmpStatistics.OutMsgs)
  return outmsgs_;
}
inline void IcmpStatistics::set_outmsgs(::google::protobuf::int64 value) {
  set_has_outmsgs();
  outmsgs_ = value;
  // @@protoc_insertion_point(field_set:mesos.IcmpStatistics.OutMsgs)
}

// optional int64 OutErrors = 16;
inline bool IcmpStatistics::has_outerrors() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void IcmpStatistics::set_has_outerrors() {
  _has_bits_[0] |= 0x00008000u;
}
inline void IcmpStatistics::clear_has_outerrors() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void IcmpStatistics::clear_outerrors() {
  outerrors_ = GOOGLE_LONGLONG(0);
  clear_has_outerrors();
}
inline ::google::protobuf::int64 IcmpStatistics::outerrors() const {
  // @@protoc_insertion_point(field_get:mesos.IcmpStatistics.OutErrors)
  return outerrors_;
}
inline void IcmpStatistics::set_outerrors(::google::protobuf::int64 value) {
  set_has_outerrors();
  outerrors_ = value;
  // @@protoc_insertion_point(field_set:mesos.IcmpStatistics.OutErrors)
}

// optional int64 OutDestUnreachs = 17;
inline bool IcmpStatistics::has_outdestunreachs() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void IcmpStatistics::set_has_outdestunreachs() {
  _has_bits_[0] |= 0x00010000u;
}
inline void IcmpStatistics::clear_has_outdestunreachs() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void IcmpStatistics::clear_outdestunreachs() {
  outdestunreachs_ = GOOGLE_LONGLONG(0);
  clear_has_outdestunreachs();
}
inline ::google::protobuf::int64 IcmpStatistics::outdestunreachs() const {
  // @@protoc_insertion_point(field_get:mesos.IcmpStatistics.OutDestUnreachs)
  return outdestunreachs_;
}
inline void IcmpStatistics::set_outdestunreachs(::google::protobuf::int64 value) {
  set_has_outdestunreachs();
  outdestunreachs_ = value;
  // @@protoc_insertion_point(field_set:mesos.IcmpStatistics.OutDestUnreachs)
}

// optional int64 OutTimeExcds = 18;
inline bool IcmpStatistics::has_outtimeexcds() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void IcmpStatistics::set_has_outtimeexcds() {
  _has_bits_[0] |= 0x00020000u;
}
inline void IcmpStatistics::clear_has_outtimeexcds() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void IcmpStatistics::clear_outtimeexcds() {
  outtimeexcds_ = GOOGLE_LONGLONG(0);
  clear_has_outtimeexcds();
}
inline ::google::protobuf::int64 IcmpStatistics::outtimeexcds() const {
  // @@protoc_insertion_point(field_get:mesos.IcmpStatistics.OutTimeExcds)
  return outtimeexcds_;
}
inline void IcmpStatistics::set_outtimeexcds(::google::protobuf::int64 value) {
  set_has_outtimeexcds();
  outtimeexcds_ = value;
  // @@protoc_insertion_point(field_set:mesos.IcmpStatistics.OutTimeExcds)
}

// optional int64 OutParmProbs = 19;
inline bool IcmpStatistics::has_outparmprobs() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void IcmpStatistics::set_has_outparmprobs() {
  _has_bits_[0] |= 0x00040000u;
}
inline void IcmpStatistics::clear_has_outparmprobs() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void IcmpStatistics::clear_outparmprobs() {
  outparmprobs_ = GOOGLE_LONGLONG(0);
  clear_has_outparmprobs();
}
inline ::google::protobuf::int64 IcmpStatistics::outparmprobs() const {
  // @@protoc_insertion_point(field_get:mesos.IcmpStatistics.OutParmProbs)
  return outparmprobs_;
}
inline void IcmpStatistics::set_outparmprobs(::google::protobuf::int64 value) {
  set_has_outparmprobs();
  outparmprobs_ = value;
  // @@protoc_insertion_point(field_set:mesos.IcmpStatistics.OutParmProbs)
}

// optional int64 OutSrcQuenchs = 20;
inline bool IcmpStatistics::has_outsrcquenchs() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void IcmpStatistics::set_has_outsrcquenchs() {
  _has_bits_[0] |= 0x00080000u;
}
inline void IcmpStatistics::clear_has_outsrcquenchs() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void IcmpStatistics::clear_outsrcquenchs() {
  outsrcquenchs_ = GOOGLE_LONGLONG(0);
  clear_has_outsrcquenchs();
}
inline ::google::protobuf::int64 IcmpStatistics::outsrcquenchs() const {
  // @@protoc_insertion_point(field_get:mesos.IcmpStatistics.OutSrcQuenchs)
  return outsrcquenchs_;
}
inline void IcmpStatistics::set_outsrcquenchs(::google::protobuf::int64 value) {
  set_has_outsrcquenchs();
  outsrcquenchs_ = value;
  // @@protoc_insertion_point(field_set:mesos.IcmpStatistics.OutSrcQuenchs)
}

// optional int64 OutRedirects = 21;
inline bool IcmpStatistics::has_outredirects() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void IcmpStatistics::set_has_outredirects() {
  _has_bits_[0] |= 0x00100000u;
}
inline void IcmpStatistics::clear_has_outredirects() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void IcmpStatistics::clear_outredirects() {
  outredirects_ = GOOGLE_LONGLONG(0);
  clear_has_outredirects();
}
inline ::google::protobuf::int64 IcmpStatistics::outredirects() const {
  // @@protoc_insertion_point(field_get:mesos.IcmpStatistics.OutRedirects)
  return outredirects_;
}
inline void IcmpStatistics::set_outredirects(::google::protobuf::int64 value) {
  set_has_outredirects();
  outredirects_ = value;
  // @@protoc_insertion_point(field_set:mesos.IcmpStatistics.OutRedirects)
}

// optional int64 OutEchos = 22;
inline bool IcmpStatistics::has_outechos() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void IcmpStatistics::set_has_outechos() {
  _has_bits_[0] |= 0x00200000u;
}
inline void IcmpStatistics::clear_has_outechos() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void IcmpStatistics::clear_outechos() {
  outechos_ = GOOGLE_LONGLONG(0);
  clear_has_outechos();
}
inline ::google::protobuf::int64 IcmpStatistics::outechos() const {
  // @@protoc_insertion_point(field_get:mesos.IcmpStatistics.OutEchos)
  return outechos_;
}
inline void IcmpStatistics::set_outechos(::google::protobuf::int64 value) {
  set_has_outechos();
  outechos_ = value;
  // @@protoc_insertion_point(field_set:mesos.IcmpStatistics.OutEchos)
}

// optional int64 OutEchoReps = 23;
inline bool IcmpStatistics::has_outechoreps() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void IcmpStatistics::set_has_outechoreps() {
  _has_bits_[0] |= 0x00400000u;
}
inline void IcmpStatistics::clear_has_outechoreps() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void IcmpStatistics::clear_outechoreps() {
  outechoreps_ = GOOGLE_LONGLONG(0);
  clear_has_outechoreps();
}
inline ::google::protobuf::int64 IcmpStatistics::outechoreps() const {
  // @@protoc_insertion_point(field_get:mesos.IcmpStatistics.OutEchoReps)
  return outechoreps_;
}
inline void IcmpStatistics::set_outechoreps(::google::protobuf::int64 value) {
  set_has_outechoreps();
  outechoreps_ = value;
  // @@protoc_insertion_point(field_set:mesos.IcmpStatistics.OutEchoReps)
}

// optional int64 OutTimestamps = 24;
inline bool IcmpStatistics::has_outtimestamps() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void IcmpStatistics::set_has_outtimestamps() {
  _has_bits_[0] |= 0x00800000u;
}
inline void IcmpStatistics::clear_has_outtimestamps() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void IcmpStatistics::clear_outtimestamps() {
  outtimestamps_ = GOOGLE_LONGLONG(0);
  clear_has_outtimestamps();
}
inline ::google::protobuf::int64 IcmpStatistics::outtimestamps() const {
  // @@protoc_insertion_point(field_get:mesos.IcmpStatistics.OutTimestamps)
  return outtimestamps_;
}
inline void IcmpStatistics::set_outtimestamps(::google::protobuf::int64 value) {
  set_has_outtimestamps();
  outtimestamps_ = value;
  // @@protoc_insertion_point(field_set:mesos.IcmpStatistics.OutTimestamps)
}

// optional int64 OutTimestampReps = 25;
inline bool IcmpStatistics::has_outtimestampreps() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void IcmpStatistics::set_has_outtimestampreps() {
  _has_bits_[0] |= 0x01000000u;
}
inline void IcmpStatistics::clear_has_outtimestampreps() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void IcmpStatistics::clear_outtimestampreps() {
  outtimestampreps_ = GOOGLE_LONGLONG(0);
  clear_has_outtimestampreps();
}
inline ::google::protobuf::int64 IcmpStatistics::outtimestampreps() const {
  // @@protoc_insertion_point(field_get:mesos.IcmpStatistics.OutTimestampReps)
  return outtimestampreps_;
}
inline void IcmpStatistics::set_outtimestampreps(::google::protobuf::int64 value) {
  set_has_outtimestampreps();
  outtimestampreps_ = value;
  // @@protoc_insertion_point(field_set:mesos.IcmpStatistics.OutTimestampReps)
}

// optional int64 OutAddrMasks = 26;
inline bool IcmpStatistics::has_outaddrmasks() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void IcmpStatistics::set_has_outaddrmasks() {
  _has_bits_[0] |= 0x02000000u;
}
inline void IcmpStatistics::clear_has_outaddrmasks() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void IcmpStatistics::clear_outaddrmasks() {
  outaddrmasks_ = GOOGLE_LONGLONG(0);
  clear_has_outaddrmasks();
}
inline ::google::protobuf::int64 IcmpStatistics::outaddrmasks() const {
  // @@protoc_insertion_point(field_get:mesos.IcmpStatistics.OutAddrMasks)
  return outaddrmasks_;
}
inline void IcmpStatistics::set_outaddrmasks(::google::protobuf::int64 value) {
  set_has_outaddrmasks();
  outaddrmasks_ = value;
  // @@protoc_insertion_point(field_set:mesos.IcmpStatistics.OutAddrMasks)
}

// optional int64 OutAddrMaskReps = 27;
inline bool IcmpStatistics::has_outaddrmaskreps() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void IcmpStatistics::set_has_outaddrmaskreps() {
  _has_bits_[0] |= 0x04000000u;
}
inline void IcmpStatistics::clear_has_outaddrmaskreps() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void IcmpStatistics::clear_outaddrmaskreps() {
  outaddrmaskreps_ = GOOGLE_LONGLONG(0);
  clear_has_outaddrmaskreps();
}
inline ::google::protobuf::int64 IcmpStatistics::outaddrmaskreps() const {
  // @@protoc_insertion_point(field_get:mesos.IcmpStatistics.OutAddrMaskReps)
  return outaddrmaskreps_;
}
inline void IcmpStatistics::set_outaddrmaskreps(::google::protobuf::int64 value) {
  set_has_outaddrmaskreps();
  outaddrmaskreps_ = value;
  // @@protoc_insertion_point(field_set:mesos.IcmpStatistics.OutAddrMaskReps)
}

// -------------------------------------------------------------------

// TcpStatistics

// optional int64 RtoAlgorithm = 1;
inline bool TcpStatistics::has_rtoalgorithm() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TcpStatistics::set_has_rtoalgorithm() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TcpStatistics::clear_has_rtoalgorithm() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TcpStatistics::clear_rtoalgorithm() {
  rtoalgorithm_ = GOOGLE_LONGLONG(0);
  clear_has_rtoalgorithm();
}
inline ::google::protobuf::int64 TcpStatistics::rtoalgorithm() const {
  // @@protoc_insertion_point(field_get:mesos.TcpStatistics.RtoAlgorithm)
  return rtoalgorithm_;
}
inline void TcpStatistics::set_rtoalgorithm(::google::protobuf::int64 value) {
  set_has_rtoalgorithm();
  rtoalgorithm_ = value;
  // @@protoc_insertion_point(field_set:mesos.TcpStatistics.RtoAlgorithm)
}

// optional int64 RtoMin = 2;
inline bool TcpStatistics::has_rtomin() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TcpStatistics::set_has_rtomin() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TcpStatistics::clear_has_rtomin() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TcpStatistics::clear_rtomin() {
  rtomin_ = GOOGLE_LONGLONG(0);
  clear_has_rtomin();
}
inline ::google::protobuf::int64 TcpStatistics::rtomin() const {
  // @@protoc_insertion_point(field_get:mesos.TcpStatistics.RtoMin)
  return rtomin_;
}
inline void TcpStatistics::set_rtomin(::google::protobuf::int64 value) {
  set_has_rtomin();
  rtomin_ = value;
  // @@protoc_insertion_point(field_set:mesos.TcpStatistics.RtoMin)
}

// optional int64 RtoMax = 3;
inline bool TcpStatistics::has_rtomax() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TcpStatistics::set_has_rtomax() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TcpStatistics::clear_has_rtomax() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TcpStatistics::clear_rtomax() {
  rtomax_ = GOOGLE_LONGLONG(0);
  clear_has_rtomax();
}
inline ::google::protobuf::int64 TcpStatistics::rtomax() const {
  // @@protoc_insertion_point(field_get:mesos.TcpStatistics.RtoMax)
  return rtomax_;
}
inline void TcpStatistics::set_rtomax(::google::protobuf::int64 value) {
  set_has_rtomax();
  rtomax_ = value;
  // @@protoc_insertion_point(field_set:mesos.TcpStatistics.RtoMax)
}

// optional int64 MaxConn = 4;
inline bool TcpStatistics::has_maxconn() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TcpStatistics::set_has_maxconn() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TcpStatistics::clear_has_maxconn() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TcpStatistics::clear_maxconn() {
  maxconn_ = GOOGLE_LONGLONG(0);
  clear_has_maxconn();
}
inline ::google::protobuf::int64 TcpStatistics::maxconn() const {
  // @@protoc_insertion_point(field_get:mesos.TcpStatistics.MaxConn)
  return maxconn_;
}
inline void TcpStatistics::set_maxconn(::google::protobuf::int64 value) {
  set_has_maxconn();
  maxconn_ = value;
  // @@protoc_insertion_point(field_set:mesos.TcpStatistics.MaxConn)
}

// optional int64 ActiveOpens = 5;
inline bool TcpStatistics::has_activeopens() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TcpStatistics::set_has_activeopens() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TcpStatistics::clear_has_activeopens() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TcpStatistics::clear_activeopens() {
  activeopens_ = GOOGLE_LONGLONG(0);
  clear_has_activeopens();
}
inline ::google::protobuf::int64 TcpStatistics::activeopens() const {
  // @@protoc_insertion_point(field_get:mesos.TcpStatistics.ActiveOpens)
  return activeopens_;
}
inline void TcpStatistics::set_activeopens(::google::protobuf::int64 value) {
  set_has_activeopens();
  activeopens_ = value;
  // @@protoc_insertion_point(field_set:mesos.TcpStatistics.ActiveOpens)
}

// optional int64 PassiveOpens = 6;
inline bool TcpStatistics::has_passiveopens() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TcpStatistics::set_has_passiveopens() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TcpStatistics::clear_has_passiveopens() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TcpStatistics::clear_passiveopens() {
  passiveopens_ = GOOGLE_LONGLONG(0);
  clear_has_passiveopens();
}
inline ::google::protobuf::int64 TcpStatistics::passiveopens() const {
  // @@protoc_insertion_point(field_get:mesos.TcpStatistics.PassiveOpens)
  return passiveopens_;
}
inline void TcpStatistics::set_passiveopens(::google::protobuf::int64 value) {
  set_has_passiveopens();
  passiveopens_ = value;
  // @@protoc_insertion_point(field_set:mesos.TcpStatistics.PassiveOpens)
}

// optional int64 AttemptFails = 7;
inline bool TcpStatistics::has_attemptfails() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TcpStatistics::set_has_attemptfails() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TcpStatistics::clear_has_attemptfails() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TcpStatistics::clear_attemptfails() {
  attemptfails_ = GOOGLE_LONGLONG(0);
  clear_has_attemptfails();
}
inline ::google::protobuf::int64 TcpStatistics::attemptfails() const {
  // @@protoc_insertion_point(field_get:mesos.TcpStatistics.AttemptFails)
  return attemptfails_;
}
inline void TcpStatistics::set_attemptfails(::google::protobuf::int64 value) {
  set_has_attemptfails();
  attemptfails_ = value;
  // @@protoc_insertion_point(field_set:mesos.TcpStatistics.AttemptFails)
}

// optional int64 EstabResets = 8;
inline bool TcpStatistics::has_estabresets() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TcpStatistics::set_has_estabresets() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TcpStatistics::clear_has_estabresets() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TcpStatistics::clear_estabresets() {
  estabresets_ = GOOGLE_LONGLONG(0);
  clear_has_estabresets();
}
inline ::google::protobuf::int64 TcpStatistics::estabresets() const {
  // @@protoc_insertion_point(field_get:mesos.TcpStatistics.EstabResets)
  return estabresets_;
}
inline void TcpStatistics::set_estabresets(::google::protobuf::int64 value) {
  set_has_estabresets();
  estabresets_ = value;
  // @@protoc_insertion_point(field_set:mesos.TcpStatistics.EstabResets)
}

// optional int64 CurrEstab = 9;
inline bool TcpStatistics::has_currestab() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TcpStatistics::set_has_currestab() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TcpStatistics::clear_has_currestab() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TcpStatistics::clear_currestab() {
  currestab_ = GOOGLE_LONGLONG(0);
  clear_has_currestab();
}
inline ::google::protobuf::int64 TcpStatistics::currestab() const {
  // @@protoc_insertion_point(field_get:mesos.TcpStatistics.CurrEstab)
  return currestab_;
}
inline void TcpStatistics::set_currestab(::google::protobuf::int64 value) {
  set_has_currestab();
  currestab_ = value;
  // @@protoc_insertion_point(field_set:mesos.TcpStatistics.CurrEstab)
}

// optional int64 InSegs = 10;
inline bool TcpStatistics::has_insegs() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TcpStatistics::set_has_insegs() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TcpStatistics::clear_has_insegs() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TcpStatistics::clear_insegs() {
  insegs_ = GOOGLE_LONGLONG(0);
  clear_has_insegs();
}
inline ::google::protobuf::int64 TcpStatistics::insegs() const {
  // @@protoc_insertion_point(field_get:mesos.TcpStatistics.InSegs)
  return insegs_;
}
inline void TcpStatistics::set_insegs(::google::protobuf::int64 value) {
  set_has_insegs();
  insegs_ = value;
  // @@protoc_insertion_point(field_set:mesos.TcpStatistics.InSegs)
}

// optional int64 OutSegs = 11;
inline bool TcpStatistics::has_outsegs() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TcpStatistics::set_has_outsegs() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TcpStatistics::clear_has_outsegs() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TcpStatistics::clear_outsegs() {
  outsegs_ = GOOGLE_LONGLONG(0);
  clear_has_outsegs();
}
inline ::google::protobuf::int64 TcpStatistics::outsegs() const {
  // @@protoc_insertion_point(field_get:mesos.TcpStatistics.OutSegs)
  return outsegs_;
}
inline void TcpStatistics::set_outsegs(::google::protobuf::int64 value) {
  set_has_outsegs();
  outsegs_ = value;
  // @@protoc_insertion_point(field_set:mesos.TcpStatistics.OutSegs)
}

// optional int64 RetransSegs = 12;
inline bool TcpStatistics::has_retranssegs() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TcpStatistics::set_has_retranssegs() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TcpStatistics::clear_has_retranssegs() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TcpStatistics::clear_retranssegs() {
  retranssegs_ = GOOGLE_LONGLONG(0);
  clear_has_retranssegs();
}
inline ::google::protobuf::int64 TcpStatistics::retranssegs() const {
  // @@protoc_insertion_point(field_get:mesos.TcpStatistics.RetransSegs)
  return retranssegs_;
}
inline void TcpStatistics::set_retranssegs(::google::protobuf::int64 value) {
  set_has_retranssegs();
  retranssegs_ = value;
  // @@protoc_insertion_point(field_set:mesos.TcpStatistics.RetransSegs)
}

// optional int64 InErrs = 13;
inline bool TcpStatistics::has_inerrs() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void TcpStatistics::set_has_inerrs() {
  _has_bits_[0] |= 0x00001000u;
}
inline void TcpStatistics::clear_has_inerrs() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void TcpStatistics::clear_inerrs() {
  inerrs_ = GOOGLE_LONGLONG(0);
  clear_has_inerrs();
}
inline ::google::protobuf::int64 TcpStatistics::inerrs() const {
  // @@protoc_insertion_point(field_get:mesos.TcpStatistics.InErrs)
  return inerrs_;
}
inline void TcpStatistics::set_inerrs(::google::protobuf::int64 value) {
  set_has_inerrs();
  inerrs_ = value;
  // @@protoc_insertion_point(field_set:mesos.TcpStatistics.InErrs)
}

// optional int64 OutRsts = 14;
inline bool TcpStatistics::has_outrsts() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void TcpStatistics::set_has_outrsts() {
  _has_bits_[0] |= 0x00002000u;
}
inline void TcpStatistics::clear_has_outrsts() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void TcpStatistics::clear_outrsts() {
  outrsts_ = GOOGLE_LONGLONG(0);
  clear_has_outrsts();
}
inline ::google::protobuf::int64 TcpStatistics::outrsts() const {
  // @@protoc_insertion_point(field_get:mesos.TcpStatistics.OutRsts)
  return outrsts_;
}
inline void TcpStatistics::set_outrsts(::google::protobuf::int64 value) {
  set_has_outrsts();
  outrsts_ = value;
  // @@protoc_insertion_point(field_set:mesos.TcpStatistics.OutRsts)
}

// optional int64 InCsumErrors = 15;
inline bool TcpStatistics::has_incsumerrors() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void TcpStatistics::set_has_incsumerrors() {
  _has_bits_[0] |= 0x00004000u;
}
inline void TcpStatistics::clear_has_incsumerrors() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void TcpStatistics::clear_incsumerrors() {
  incsumerrors_ = GOOGLE_LONGLONG(0);
  clear_has_incsumerrors();
}
inline ::google::protobuf::int64 TcpStatistics::incsumerrors() const {
  // @@protoc_insertion_point(field_get:mesos.TcpStatistics.InCsumErrors)
  return incsumerrors_;
}
inline void TcpStatistics::set_incsumerrors(::google::protobuf::int64 value) {
  set_has_incsumerrors();
  incsumerrors_ = value;
  // @@protoc_insertion_point(field_set:mesos.TcpStatistics.InCsumErrors)
}

// -------------------------------------------------------------------

// UdpStatistics

// optional int64 InDatagrams = 1;
inline bool UdpStatistics::has_indatagrams() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UdpStatistics::set_has_indatagrams() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UdpStatistics::clear_has_indatagrams() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UdpStatistics::clear_indatagrams() {
  indatagrams_ = GOOGLE_LONGLONG(0);
  clear_has_indatagrams();
}
inline ::google::protobuf::int64 UdpStatistics::indatagrams() const {
  // @@protoc_insertion_point(field_get:mesos.UdpStatistics.InDatagrams)
  return indatagrams_;
}
inline void UdpStatistics::set_indatagrams(::google::protobuf::int64 value) {
  set_has_indatagrams();
  indatagrams_ = value;
  // @@protoc_insertion_point(field_set:mesos.UdpStatistics.InDatagrams)
}

// optional int64 NoPorts = 2;
inline bool UdpStatistics::has_noports() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UdpStatistics::set_has_noports() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UdpStatistics::clear_has_noports() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UdpStatistics::clear_noports() {
  noports_ = GOOGLE_LONGLONG(0);
  clear_has_noports();
}
inline ::google::protobuf::int64 UdpStatistics::noports() const {
  // @@protoc_insertion_point(field_get:mesos.UdpStatistics.NoPorts)
  return noports_;
}
inline void UdpStatistics::set_noports(::google::protobuf::int64 value) {
  set_has_noports();
  noports_ = value;
  // @@protoc_insertion_point(field_set:mesos.UdpStatistics.NoPorts)
}

// optional int64 InErrors = 3;
inline bool UdpStatistics::has_inerrors() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UdpStatistics::set_has_inerrors() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UdpStatistics::clear_has_inerrors() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UdpStatistics::clear_inerrors() {
  inerrors_ = GOOGLE_LONGLONG(0);
  clear_has_inerrors();
}
inline ::google::protobuf::int64 UdpStatistics::inerrors() const {
  // @@protoc_insertion_point(field_get:mesos.UdpStatistics.InErrors)
  return inerrors_;
}
inline void UdpStatistics::set_inerrors(::google::protobuf::int64 value) {
  set_has_inerrors();
  inerrors_ = value;
  // @@protoc_insertion_point(field_set:mesos.UdpStatistics.InErrors)
}

// optional int64 OutDatagrams = 4;
inline bool UdpStatistics::has_outdatagrams() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UdpStatistics::set_has_outdatagrams() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UdpStatistics::clear_has_outdatagrams() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UdpStatistics::clear_outdatagrams() {
  outdatagrams_ = GOOGLE_LONGLONG(0);
  clear_has_outdatagrams();
}
inline ::google::protobuf::int64 UdpStatistics::outdatagrams() const {
  // @@protoc_insertion_point(field_get:mesos.UdpStatistics.OutDatagrams)
  return outdatagrams_;
}
inline void UdpStatistics::set_outdatagrams(::google::protobuf::int64 value) {
  set_has_outdatagrams();
  outdatagrams_ = value;
  // @@protoc_insertion_point(field_set:mesos.UdpStatistics.OutDatagrams)
}

// optional int64 RcvbufErrors = 5;
inline bool UdpStatistics::has_rcvbuferrors() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UdpStatistics::set_has_rcvbuferrors() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UdpStatistics::clear_has_rcvbuferrors() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UdpStatistics::clear_rcvbuferrors() {
  rcvbuferrors_ = GOOGLE_LONGLONG(0);
  clear_has_rcvbuferrors();
}
inline ::google::protobuf::int64 UdpStatistics::rcvbuferrors() const {
  // @@protoc_insertion_point(field_get:mesos.UdpStatistics.RcvbufErrors)
  return rcvbuferrors_;
}
inline void UdpStatistics::set_rcvbuferrors(::google::protobuf::int64 value) {
  set_has_rcvbuferrors();
  rcvbuferrors_ = value;
  // @@protoc_insertion_point(field_set:mesos.UdpStatistics.RcvbufErrors)
}

// optional int64 SndbufErrors = 6;
inline bool UdpStatistics::has_sndbuferrors() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UdpStatistics::set_has_sndbuferrors() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UdpStatistics::clear_has_sndbuferrors() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UdpStatistics::clear_sndbuferrors() {
  sndbuferrors_ = GOOGLE_LONGLONG(0);
  clear_has_sndbuferrors();
}
inline ::google::protobuf::int64 UdpStatistics::sndbuferrors() const {
  // @@protoc_insertion_point(field_get:mesos.UdpStatistics.SndbufErrors)
  return sndbuferrors_;
}
inline void UdpStatistics::set_sndbuferrors(::google::protobuf::int64 value) {
  set_has_sndbuferrors();
  sndbuferrors_ = value;
  // @@protoc_insertion_point(field_set:mesos.UdpStatistics.SndbufErrors)
}

// optional int64 InCsumErrors = 7;
inline bool UdpStatistics::has_incsumerrors() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UdpStatistics::set_has_incsumerrors() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UdpStatistics::clear_has_incsumerrors() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UdpStatistics::clear_incsumerrors() {
  incsumerrors_ = GOOGLE_LONGLONG(0);
  clear_has_incsumerrors();
}
inline ::google::protobuf::int64 UdpStatistics::incsumerrors() const {
  // @@protoc_insertion_point(field_get:mesos.UdpStatistics.InCsumErrors)
  return incsumerrors_;
}
inline void UdpStatistics::set_incsumerrors(::google::protobuf::int64 value) {
  set_has_incsumerrors();
  incsumerrors_ = value;
  // @@protoc_insertion_point(field_set:mesos.UdpStatistics.InCsumErrors)
}

// optional int64 IgnoredMulti = 8;
inline bool UdpStatistics::has_ignoredmulti() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void UdpStatistics::set_has_ignoredmulti() {
  _has_bits_[0] |= 0x00000080u;
}
inline void UdpStatistics::clear_has_ignoredmulti() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void UdpStatistics::clear_ignoredmulti() {
  ignoredmulti_ = GOOGLE_LONGLONG(0);
  clear_has_ignoredmulti();
}
inline ::google::protobuf::int64 UdpStatistics::ignoredmulti() const {
  // @@protoc_insertion_point(field_get:mesos.UdpStatistics.IgnoredMulti)
  return ignoredmulti_;
}
inline void UdpStatistics::set_ignoredmulti(::google::protobuf::int64 value) {
  set_has_ignoredmulti();
  ignoredmulti_ = value;
  // @@protoc_insertion_point(field_set:mesos.UdpStatistics.IgnoredMulti)
}

// -------------------------------------------------------------------

// SNMPStatistics

// optional .mesos.IpStatistics ip_stats = 1;
inline bool SNMPStatistics::has_ip_stats() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SNMPStatistics::set_has_ip_stats() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SNMPStatistics::clear_has_ip_stats() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SNMPStatistics::clear_ip_stats() {
  if (ip_stats_ != NULL) ip_stats_->Clear();
  clear_has_ip_stats();
}
inline const ::mesos::IpStatistics& SNMPStatistics::ip_stats() const {
  const ::mesos::IpStatistics* p = ip_stats_;
  // @@protoc_insertion_point(field_get:mesos.SNMPStatistics.ip_stats)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::IpStatistics*>(
      &::mesos::_IpStatistics_default_instance_);
}
inline ::mesos::IpStatistics* SNMPStatistics::release_ip_stats() {
  // @@protoc_insertion_point(field_release:mesos.SNMPStatistics.ip_stats)
  clear_has_ip_stats();
  ::mesos::IpStatistics* temp = ip_stats_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  ip_stats_ = NULL;
  return temp;
}
inline ::mesos::IpStatistics* SNMPStatistics::unsafe_arena_release_ip_stats() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.SNMPStatistics.ip_stats)
  clear_has_ip_stats();
  ::mesos::IpStatistics* temp = ip_stats_;
  ip_stats_ = NULL;
  return temp;
}
inline ::mesos::IpStatistics* SNMPStatistics::mutable_ip_stats() {
  set_has_ip_stats();
  if (ip_stats_ == NULL) {
    _slow_mutable_ip_stats();
  }
  // @@protoc_insertion_point(field_mutable:mesos.SNMPStatistics.ip_stats)
  return ip_stats_;
}
inline void SNMPStatistics::set_allocated_ip_stats(::mesos::IpStatistics* ip_stats) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete ip_stats_;
  }
  if (ip_stats) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(ip_stats);
    if (message_arena != submessage_arena) {
      ip_stats = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ip_stats, submessage_arena);
    }
    set_has_ip_stats();
  } else {
    clear_has_ip_stats();
  }
  ip_stats_ = ip_stats;
  // @@protoc_insertion_point(field_set_allocated:mesos.SNMPStatistics.ip_stats)
}

// optional .mesos.IcmpStatistics icmp_stats = 2;
inline bool SNMPStatistics::has_icmp_stats() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SNMPStatistics::set_has_icmp_stats() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SNMPStatistics::clear_has_icmp_stats() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SNMPStatistics::clear_icmp_stats() {
  if (icmp_stats_ != NULL) icmp_stats_->Clear();
  clear_has_icmp_stats();
}
inline const ::mesos::IcmpStatistics& SNMPStatistics::icmp_stats() const {
  const ::mesos::IcmpStatistics* p = icmp_stats_;
  // @@protoc_insertion_point(field_get:mesos.SNMPStatistics.icmp_stats)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::IcmpStatistics*>(
      &::mesos::_IcmpStatistics_default_instance_);
}
inline ::mesos::IcmpStatistics* SNMPStatistics::release_icmp_stats() {
  // @@protoc_insertion_point(field_release:mesos.SNMPStatistics.icmp_stats)
  clear_has_icmp_stats();
  ::mesos::IcmpStatistics* temp = icmp_stats_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  icmp_stats_ = NULL;
  return temp;
}
inline ::mesos::IcmpStatistics* SNMPStatistics::unsafe_arena_release_icmp_stats() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.SNMPStatistics.icmp_stats)
  clear_has_icmp_stats();
  ::mesos::IcmpStatistics* temp = icmp_stats_;
  icmp_stats_ = NULL;
  return temp;
}
inline ::mesos::IcmpStatistics* SNMPStatistics::mutable_icmp_stats() {
  set_has_icmp_stats();
  if (icmp_stats_ == NULL) {
    _slow_mutable_icmp_stats();
  }
  // @@protoc_insertion_point(field_mutable:mesos.SNMPStatistics.icmp_stats)
  return icmp_stats_;
}
inline void SNMPStatistics::set_allocated_icmp_stats(::mesos::IcmpStatistics* icmp_stats) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete icmp_stats_;
  }
  if (icmp_stats) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(icmp_stats);
    if (message_arena != submessage_arena) {
      icmp_stats = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, icmp_stats, submessage_arena);
    }
    set_has_icmp_stats();
  } else {
    clear_has_icmp_stats();
  }
  icmp_stats_ = icmp_stats;
  // @@protoc_insertion_point(field_set_allocated:mesos.SNMPStatistics.icmp_stats)
}

// optional .mesos.TcpStatistics tcp_stats = 3;
inline bool SNMPStatistics::has_tcp_stats() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SNMPStatistics::set_has_tcp_stats() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SNMPStatistics::clear_has_tcp_stats() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SNMPStatistics::clear_tcp_stats() {
  if (tcp_stats_ != NULL) tcp_stats_->Clear();
  clear_has_tcp_stats();
}
inline const ::mesos::TcpStatistics& SNMPStatistics::tcp_stats() const {
  const ::mesos::TcpStatistics* p = tcp_stats_;
  // @@protoc_insertion_point(field_get:mesos.SNMPStatistics.tcp_stats)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::TcpStatistics*>(
      &::mesos::_TcpStatistics_default_instance_);
}
inline ::mesos::TcpStatistics* SNMPStatistics::release_tcp_stats() {
  // @@protoc_insertion_point(field_release:mesos.SNMPStatistics.tcp_stats)
  clear_has_tcp_stats();
  ::mesos::TcpStatistics* temp = tcp_stats_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  tcp_stats_ = NULL;
  return temp;
}
inline ::mesos::TcpStatistics* SNMPStatistics::unsafe_arena_release_tcp_stats() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.SNMPStatistics.tcp_stats)
  clear_has_tcp_stats();
  ::mesos::TcpStatistics* temp = tcp_stats_;
  tcp_stats_ = NULL;
  return temp;
}
inline ::mesos::TcpStatistics* SNMPStatistics::mutable_tcp_stats() {
  set_has_tcp_stats();
  if (tcp_stats_ == NULL) {
    _slow_mutable_tcp_stats();
  }
  // @@protoc_insertion_point(field_mutable:mesos.SNMPStatistics.tcp_stats)
  return tcp_stats_;
}
inline void SNMPStatistics::set_allocated_tcp_stats(::mesos::TcpStatistics* tcp_stats) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete tcp_stats_;
  }
  if (tcp_stats) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(tcp_stats);
    if (message_arena != submessage_arena) {
      tcp_stats = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, tcp_stats, submessage_arena);
    }
    set_has_tcp_stats();
  } else {
    clear_has_tcp_stats();
  }
  tcp_stats_ = tcp_stats;
  // @@protoc_insertion_point(field_set_allocated:mesos.SNMPStatistics.tcp_stats)
}

// optional .mesos.UdpStatistics udp_stats = 4;
inline bool SNMPStatistics::has_udp_stats() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SNMPStatistics::set_has_udp_stats() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SNMPStatistics::clear_has_udp_stats() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SNMPStatistics::clear_udp_stats() {
  if (udp_stats_ != NULL) udp_stats_->Clear();
  clear_has_udp_stats();
}
inline const ::mesos::UdpStatistics& SNMPStatistics::udp_stats() const {
  const ::mesos::UdpStatistics* p = udp_stats_;
  // @@protoc_insertion_point(field_get:mesos.SNMPStatistics.udp_stats)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::UdpStatistics*>(
      &::mesos::_UdpStatistics_default_instance_);
}
inline ::mesos::UdpStatistics* SNMPStatistics::release_udp_stats() {
  // @@protoc_insertion_point(field_release:mesos.SNMPStatistics.udp_stats)
  clear_has_udp_stats();
  ::mesos::UdpStatistics* temp = udp_stats_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  udp_stats_ = NULL;
  return temp;
}
inline ::mesos::UdpStatistics* SNMPStatistics::unsafe_arena_release_udp_stats() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.SNMPStatistics.udp_stats)
  clear_has_udp_stats();
  ::mesos::UdpStatistics* temp = udp_stats_;
  udp_stats_ = NULL;
  return temp;
}
inline ::mesos::UdpStatistics* SNMPStatistics::mutable_udp_stats() {
  set_has_udp_stats();
  if (udp_stats_ == NULL) {
    _slow_mutable_udp_stats();
  }
  // @@protoc_insertion_point(field_mutable:mesos.SNMPStatistics.udp_stats)
  return udp_stats_;
}
inline void SNMPStatistics::set_allocated_udp_stats(::mesos::UdpStatistics* udp_stats) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete udp_stats_;
  }
  if (udp_stats) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(udp_stats);
    if (message_arena != submessage_arena) {
      udp_stats = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, udp_stats, submessage_arena);
    }
    set_has_udp_stats();
  } else {
    clear_has_udp_stats();
  }
  udp_stats_ = udp_stats;
  // @@protoc_insertion_point(field_set_allocated:mesos.SNMPStatistics.udp_stats)
}

// -------------------------------------------------------------------

// DiskStatistics

// optional .mesos.Resource.DiskInfo.Source source = 1;
inline bool DiskStatistics::has_source() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DiskStatistics::set_has_source() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DiskStatistics::clear_has_source() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DiskStatistics::clear_source() {
  if (source_ != NULL) source_->Clear();
  clear_has_source();
}
inline const ::mesos::Resource_DiskInfo_Source& DiskStatistics::source() const {
  const ::mesos::Resource_DiskInfo_Source* p = source_;
  // @@protoc_insertion_point(field_get:mesos.DiskStatistics.source)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::Resource_DiskInfo_Source*>(
      &::mesos::_Resource_DiskInfo_Source_default_instance_);
}
inline ::mesos::Resource_DiskInfo_Source* DiskStatistics::release_source() {
  // @@protoc_insertion_point(field_release:mesos.DiskStatistics.source)
  clear_has_source();
  ::mesos::Resource_DiskInfo_Source* temp = source_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  source_ = NULL;
  return temp;
}
inline ::mesos::Resource_DiskInfo_Source* DiskStatistics::unsafe_arena_release_source() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.DiskStatistics.source)
  clear_has_source();
  ::mesos::Resource_DiskInfo_Source* temp = source_;
  source_ = NULL;
  return temp;
}
inline ::mesos::Resource_DiskInfo_Source* DiskStatistics::mutable_source() {
  set_has_source();
  if (source_ == NULL) {
    _slow_mutable_source();
  }
  // @@protoc_insertion_point(field_mutable:mesos.DiskStatistics.source)
  return source_;
}
inline void DiskStatistics::set_allocated_source(::mesos::Resource_DiskInfo_Source* source) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete source_;
  }
  if (source) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(source);
    if (message_arena != submessage_arena) {
      source = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, source, submessage_arena);
    }
    set_has_source();
  } else {
    clear_has_source();
  }
  source_ = source;
  // @@protoc_insertion_point(field_set_allocated:mesos.DiskStatistics.source)
}

// optional .mesos.Resource.DiskInfo.Persistence persistence = 2;
inline bool DiskStatistics::has_persistence() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DiskStatistics::set_has_persistence() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DiskStatistics::clear_has_persistence() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DiskStatistics::clear_persistence() {
  if (persistence_ != NULL) persistence_->Clear();
  clear_has_persistence();
}
inline const ::mesos::Resource_DiskInfo_Persistence& DiskStatistics::persistence() const {
  const ::mesos::Resource_DiskInfo_Persistence* p = persistence_;
  // @@protoc_insertion_point(field_get:mesos.DiskStatistics.persistence)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::Resource_DiskInfo_Persistence*>(
      &::mesos::_Resource_DiskInfo_Persistence_default_instance_);
}
inline ::mesos::Resource_DiskInfo_Persistence* DiskStatistics::release_persistence() {
  // @@protoc_insertion_point(field_release:mesos.DiskStatistics.persistence)
  clear_has_persistence();
  ::mesos::Resource_DiskInfo_Persistence* temp = persistence_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  persistence_ = NULL;
  return temp;
}
inline ::mesos::Resource_DiskInfo_Persistence* DiskStatistics::unsafe_arena_release_persistence() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.DiskStatistics.persistence)
  clear_has_persistence();
  ::mesos::Resource_DiskInfo_Persistence* temp = persistence_;
  persistence_ = NULL;
  return temp;
}
inline ::mesos::Resource_DiskInfo_Persistence* DiskStatistics::mutable_persistence() {
  set_has_persistence();
  if (persistence_ == NULL) {
    _slow_mutable_persistence();
  }
  // @@protoc_insertion_point(field_mutable:mesos.DiskStatistics.persistence)
  return persistence_;
}
inline void DiskStatistics::set_allocated_persistence(::mesos::Resource_DiskInfo_Persistence* persistence) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete persistence_;
  }
  if (persistence) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(persistence);
    if (message_arena != submessage_arena) {
      persistence = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, persistence, submessage_arena);
    }
    set_has_persistence();
  } else {
    clear_has_persistence();
  }
  persistence_ = persistence;
  // @@protoc_insertion_point(field_set_allocated:mesos.DiskStatistics.persistence)
}

// optional uint64 limit_bytes = 3;
inline bool DiskStatistics::has_limit_bytes() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DiskStatistics::set_has_limit_bytes() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DiskStatistics::clear_has_limit_bytes() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DiskStatistics::clear_limit_bytes() {
  limit_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_limit_bytes();
}
inline ::google::protobuf::uint64 DiskStatistics::limit_bytes() const {
  // @@protoc_insertion_point(field_get:mesos.DiskStatistics.limit_bytes)
  return limit_bytes_;
}
inline void DiskStatistics::set_limit_bytes(::google::protobuf::uint64 value) {
  set_has_limit_bytes();
  limit_bytes_ = value;
  // @@protoc_insertion_point(field_set:mesos.DiskStatistics.limit_bytes)
}

// optional uint64 used_bytes = 4;
inline bool DiskStatistics::has_used_bytes() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DiskStatistics::set_has_used_bytes() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DiskStatistics::clear_has_used_bytes() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DiskStatistics::clear_used_bytes() {
  used_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_used_bytes();
}
inline ::google::protobuf::uint64 DiskStatistics::used_bytes() const {
  // @@protoc_insertion_point(field_get:mesos.DiskStatistics.used_bytes)
  return used_bytes_;
}
inline void DiskStatistics::set_used_bytes(::google::protobuf::uint64 value) {
  set_has_used_bytes();
  used_bytes_ = value;
  // @@protoc_insertion_point(field_set:mesos.DiskStatistics.used_bytes)
}

// -------------------------------------------------------------------

// ResourceStatistics

// required double timestamp = 1;
inline bool ResourceStatistics::has_timestamp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ResourceStatistics::set_has_timestamp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ResourceStatistics::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ResourceStatistics::clear_timestamp() {
  timestamp_ = 0;
  clear_has_timestamp();
}
inline double ResourceStatistics::timestamp() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.timestamp)
  return timestamp_;
}
inline void ResourceStatistics::set_timestamp(double value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.timestamp)
}

// optional uint32 processes = 30;
inline bool ResourceStatistics::has_processes() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void ResourceStatistics::set_has_processes() {
  _has_bits_[0] |= 0x80000000u;
}
inline void ResourceStatistics::clear_has_processes() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void ResourceStatistics::clear_processes() {
  processes_ = 0u;
  clear_has_processes();
}
inline ::google::protobuf::uint32 ResourceStatistics::processes() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.processes)
  return processes_;
}
inline void ResourceStatistics::set_processes(::google::protobuf::uint32 value) {
  set_has_processes();
  processes_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.processes)
}

// optional uint32 threads = 31;
inline bool ResourceStatistics::has_threads() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void ResourceStatistics::set_has_threads() {
  _has_bits_[1] |= 0x00000001u;
}
inline void ResourceStatistics::clear_has_threads() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void ResourceStatistics::clear_threads() {
  threads_ = 0u;
  clear_has_threads();
}
inline ::google::protobuf::uint32 ResourceStatistics::threads() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.threads)
  return threads_;
}
inline void ResourceStatistics::set_threads(::google::protobuf::uint32 value) {
  set_has_threads();
  threads_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.threads)
}

// optional double cpus_user_time_secs = 2;
inline bool ResourceStatistics::has_cpus_user_time_secs() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ResourceStatistics::set_has_cpus_user_time_secs() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ResourceStatistics::clear_has_cpus_user_time_secs() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ResourceStatistics::clear_cpus_user_time_secs() {
  cpus_user_time_secs_ = 0;
  clear_has_cpus_user_time_secs();
}
inline double ResourceStatistics::cpus_user_time_secs() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.cpus_user_time_secs)
  return cpus_user_time_secs_;
}
inline void ResourceStatistics::set_cpus_user_time_secs(double value) {
  set_has_cpus_user_time_secs();
  cpus_user_time_secs_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.cpus_user_time_secs)
}

// optional double cpus_system_time_secs = 3;
inline bool ResourceStatistics::has_cpus_system_time_secs() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ResourceStatistics::set_has_cpus_system_time_secs() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ResourceStatistics::clear_has_cpus_system_time_secs() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ResourceStatistics::clear_cpus_system_time_secs() {
  cpus_system_time_secs_ = 0;
  clear_has_cpus_system_time_secs();
}
inline double ResourceStatistics::cpus_system_time_secs() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.cpus_system_time_secs)
  return cpus_system_time_secs_;
}
inline void ResourceStatistics::set_cpus_system_time_secs(double value) {
  set_has_cpus_system_time_secs();
  cpus_system_time_secs_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.cpus_system_time_secs)
}

// optional double cpus_limit = 4;
inline bool ResourceStatistics::has_cpus_limit() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ResourceStatistics::set_has_cpus_limit() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ResourceStatistics::clear_has_cpus_limit() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ResourceStatistics::clear_cpus_limit() {
  cpus_limit_ = 0;
  clear_has_cpus_limit();
}
inline double ResourceStatistics::cpus_limit() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.cpus_limit)
  return cpus_limit_;
}
inline void ResourceStatistics::set_cpus_limit(double value) {
  set_has_cpus_limit();
  cpus_limit_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.cpus_limit)
}

// optional uint32 cpus_nr_periods = 7;
inline bool ResourceStatistics::has_cpus_nr_periods() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ResourceStatistics::set_has_cpus_nr_periods() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ResourceStatistics::clear_has_cpus_nr_periods() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ResourceStatistics::clear_cpus_nr_periods() {
  cpus_nr_periods_ = 0u;
  clear_has_cpus_nr_periods();
}
inline ::google::protobuf::uint32 ResourceStatistics::cpus_nr_periods() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.cpus_nr_periods)
  return cpus_nr_periods_;
}
inline void ResourceStatistics::set_cpus_nr_periods(::google::protobuf::uint32 value) {
  set_has_cpus_nr_periods();
  cpus_nr_periods_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.cpus_nr_periods)
}

// optional uint32 cpus_nr_throttled = 8;
inline bool ResourceStatistics::has_cpus_nr_throttled() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ResourceStatistics::set_has_cpus_nr_throttled() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ResourceStatistics::clear_has_cpus_nr_throttled() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ResourceStatistics::clear_cpus_nr_throttled() {
  cpus_nr_throttled_ = 0u;
  clear_has_cpus_nr_throttled();
}
inline ::google::protobuf::uint32 ResourceStatistics::cpus_nr_throttled() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.cpus_nr_throttled)
  return cpus_nr_throttled_;
}
inline void ResourceStatistics::set_cpus_nr_throttled(::google::protobuf::uint32 value) {
  set_has_cpus_nr_throttled();
  cpus_nr_throttled_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.cpus_nr_throttled)
}

// optional double cpus_throttled_time_secs = 9;
inline bool ResourceStatistics::has_cpus_throttled_time_secs() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ResourceStatistics::set_has_cpus_throttled_time_secs() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ResourceStatistics::clear_has_cpus_throttled_time_secs() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ResourceStatistics::clear_cpus_throttled_time_secs() {
  cpus_throttled_time_secs_ = 0;
  clear_has_cpus_throttled_time_secs();
}
inline double ResourceStatistics::cpus_throttled_time_secs() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.cpus_throttled_time_secs)
  return cpus_throttled_time_secs_;
}
inline void ResourceStatistics::set_cpus_throttled_time_secs(double value) {
  set_has_cpus_throttled_time_secs();
  cpus_throttled_time_secs_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.cpus_throttled_time_secs)
}

// optional uint64 mem_total_bytes = 36;
inline bool ResourceStatistics::has_mem_total_bytes() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void ResourceStatistics::set_has_mem_total_bytes() {
  _has_bits_[1] |= 0x00000010u;
}
inline void ResourceStatistics::clear_has_mem_total_bytes() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void ResourceStatistics::clear_mem_total_bytes() {
  mem_total_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_mem_total_bytes();
}
inline ::google::protobuf::uint64 ResourceStatistics::mem_total_bytes() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.mem_total_bytes)
  return mem_total_bytes_;
}
inline void ResourceStatistics::set_mem_total_bytes(::google::protobuf::uint64 value) {
  set_has_mem_total_bytes();
  mem_total_bytes_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.mem_total_bytes)
}

// optional uint64 mem_total_memsw_bytes = 37;
inline bool ResourceStatistics::has_mem_total_memsw_bytes() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void ResourceStatistics::set_has_mem_total_memsw_bytes() {
  _has_bits_[1] |= 0x00000020u;
}
inline void ResourceStatistics::clear_has_mem_total_memsw_bytes() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void ResourceStatistics::clear_mem_total_memsw_bytes() {
  mem_total_memsw_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_mem_total_memsw_bytes();
}
inline ::google::protobuf::uint64 ResourceStatistics::mem_total_memsw_bytes() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.mem_total_memsw_bytes)
  return mem_total_memsw_bytes_;
}
inline void ResourceStatistics::set_mem_total_memsw_bytes(::google::protobuf::uint64 value) {
  set_has_mem_total_memsw_bytes();
  mem_total_memsw_bytes_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.mem_total_memsw_bytes)
}

// optional uint64 mem_limit_bytes = 6;
inline bool ResourceStatistics::has_mem_limit_bytes() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ResourceStatistics::set_has_mem_limit_bytes() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ResourceStatistics::clear_has_mem_limit_bytes() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ResourceStatistics::clear_mem_limit_bytes() {
  mem_limit_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_mem_limit_bytes();
}
inline ::google::protobuf::uint64 ResourceStatistics::mem_limit_bytes() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.mem_limit_bytes)
  return mem_limit_bytes_;
}
inline void ResourceStatistics::set_mem_limit_bytes(::google::protobuf::uint64 value) {
  set_has_mem_limit_bytes();
  mem_limit_bytes_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.mem_limit_bytes)
}

// optional uint64 mem_soft_limit_bytes = 38;
inline bool ResourceStatistics::has_mem_soft_limit_bytes() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void ResourceStatistics::set_has_mem_soft_limit_bytes() {
  _has_bits_[1] |= 0x00000040u;
}
inline void ResourceStatistics::clear_has_mem_soft_limit_bytes() {
  _has_bits_[1] &= ~0x00000040u;
}
inline void ResourceStatistics::clear_mem_soft_limit_bytes() {
  mem_soft_limit_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_mem_soft_limit_bytes();
}
inline ::google::protobuf::uint64 ResourceStatistics::mem_soft_limit_bytes() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.mem_soft_limit_bytes)
  return mem_soft_limit_bytes_;
}
inline void ResourceStatistics::set_mem_soft_limit_bytes(::google::protobuf::uint64 value) {
  set_has_mem_soft_limit_bytes();
  mem_soft_limit_bytes_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.mem_soft_limit_bytes)
}

// optional uint64 mem_file_bytes = 10;
inline bool ResourceStatistics::has_mem_file_bytes() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void ResourceStatistics::set_has_mem_file_bytes() {
  _has_bits_[0] |= 0x00001000u;
}
inline void ResourceStatistics::clear_has_mem_file_bytes() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void ResourceStatistics::clear_mem_file_bytes() {
  mem_file_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_mem_file_bytes();
}
inline ::google::protobuf::uint64 ResourceStatistics::mem_file_bytes() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.mem_file_bytes)
  return mem_file_bytes_;
}
inline void ResourceStatistics::set_mem_file_bytes(::google::protobuf::uint64 value) {
  set_has_mem_file_bytes();
  mem_file_bytes_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.mem_file_bytes)
}

// optional uint64 mem_anon_bytes = 11;
inline bool ResourceStatistics::has_mem_anon_bytes() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void ResourceStatistics::set_has_mem_anon_bytes() {
  _has_bits_[0] |= 0x00002000u;
}
inline void ResourceStatistics::clear_has_mem_anon_bytes() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void ResourceStatistics::clear_mem_anon_bytes() {
  mem_anon_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_mem_anon_bytes();
}
inline ::google::protobuf::uint64 ResourceStatistics::mem_anon_bytes() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.mem_anon_bytes)
  return mem_anon_bytes_;
}
inline void ResourceStatistics::set_mem_anon_bytes(::google::protobuf::uint64 value) {
  set_has_mem_anon_bytes();
  mem_anon_bytes_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.mem_anon_bytes)
}

// optional uint64 mem_cache_bytes = 39;
inline bool ResourceStatistics::has_mem_cache_bytes() const {
  return (_has_bits_[1] & 0x00000080u) != 0;
}
inline void ResourceStatistics::set_has_mem_cache_bytes() {
  _has_bits_[1] |= 0x00000080u;
}
inline void ResourceStatistics::clear_has_mem_cache_bytes() {
  _has_bits_[1] &= ~0x00000080u;
}
inline void ResourceStatistics::clear_mem_cache_bytes() {
  mem_cache_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_mem_cache_bytes();
}
inline ::google::protobuf::uint64 ResourceStatistics::mem_cache_bytes() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.mem_cache_bytes)
  return mem_cache_bytes_;
}
inline void ResourceStatistics::set_mem_cache_bytes(::google::protobuf::uint64 value) {
  set_has_mem_cache_bytes();
  mem_cache_bytes_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.mem_cache_bytes)
}

// optional uint64 mem_rss_bytes = 5;
inline bool ResourceStatistics::has_mem_rss_bytes() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ResourceStatistics::set_has_mem_rss_bytes() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ResourceStatistics::clear_has_mem_rss_bytes() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ResourceStatistics::clear_mem_rss_bytes() {
  mem_rss_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_mem_rss_bytes();
}
inline ::google::protobuf::uint64 ResourceStatistics::mem_rss_bytes() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.mem_rss_bytes)
  return mem_rss_bytes_;
}
inline void ResourceStatistics::set_mem_rss_bytes(::google::protobuf::uint64 value) {
  set_has_mem_rss_bytes();
  mem_rss_bytes_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.mem_rss_bytes)
}

// optional uint64 mem_mapped_file_bytes = 12;
inline bool ResourceStatistics::has_mem_mapped_file_bytes() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void ResourceStatistics::set_has_mem_mapped_file_bytes() {
  _has_bits_[0] |= 0x00004000u;
}
inline void ResourceStatistics::clear_has_mem_mapped_file_bytes() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void ResourceStatistics::clear_mem_mapped_file_bytes() {
  mem_mapped_file_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_mem_mapped_file_bytes();
}
inline ::google::protobuf::uint64 ResourceStatistics::mem_mapped_file_bytes() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.mem_mapped_file_bytes)
  return mem_mapped_file_bytes_;
}
inline void ResourceStatistics::set_mem_mapped_file_bytes(::google::protobuf::uint64 value) {
  set_has_mem_mapped_file_bytes();
  mem_mapped_file_bytes_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.mem_mapped_file_bytes)
}

// optional uint64 mem_swap_bytes = 40;
inline bool ResourceStatistics::has_mem_swap_bytes() const {
  return (_has_bits_[1] & 0x00000100u) != 0;
}
inline void ResourceStatistics::set_has_mem_swap_bytes() {
  _has_bits_[1] |= 0x00000100u;
}
inline void ResourceStatistics::clear_has_mem_swap_bytes() {
  _has_bits_[1] &= ~0x00000100u;
}
inline void ResourceStatistics::clear_mem_swap_bytes() {
  mem_swap_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_mem_swap_bytes();
}
inline ::google::protobuf::uint64 ResourceStatistics::mem_swap_bytes() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.mem_swap_bytes)
  return mem_swap_bytes_;
}
inline void ResourceStatistics::set_mem_swap_bytes(::google::protobuf::uint64 value) {
  set_has_mem_swap_bytes();
  mem_swap_bytes_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.mem_swap_bytes)
}

// optional uint64 mem_unevictable_bytes = 41;
inline bool ResourceStatistics::has_mem_unevictable_bytes() const {
  return (_has_bits_[1] & 0x00000200u) != 0;
}
inline void ResourceStatistics::set_has_mem_unevictable_bytes() {
  _has_bits_[1] |= 0x00000200u;
}
inline void ResourceStatistics::clear_has_mem_unevictable_bytes() {
  _has_bits_[1] &= ~0x00000200u;
}
inline void ResourceStatistics::clear_mem_unevictable_bytes() {
  mem_unevictable_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_mem_unevictable_bytes();
}
inline ::google::protobuf::uint64 ResourceStatistics::mem_unevictable_bytes() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.mem_unevictable_bytes)
  return mem_unevictable_bytes_;
}
inline void ResourceStatistics::set_mem_unevictable_bytes(::google::protobuf::uint64 value) {
  set_has_mem_unevictable_bytes();
  mem_unevictable_bytes_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.mem_unevictable_bytes)
}

// optional uint64 mem_low_pressure_counter = 32;
inline bool ResourceStatistics::has_mem_low_pressure_counter() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void ResourceStatistics::set_has_mem_low_pressure_counter() {
  _has_bits_[1] |= 0x00000002u;
}
inline void ResourceStatistics::clear_has_mem_low_pressure_counter() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void ResourceStatistics::clear_mem_low_pressure_counter() {
  mem_low_pressure_counter_ = GOOGLE_ULONGLONG(0);
  clear_has_mem_low_pressure_counter();
}
inline ::google::protobuf::uint64 ResourceStatistics::mem_low_pressure_counter() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.mem_low_pressure_counter)
  return mem_low_pressure_counter_;
}
inline void ResourceStatistics::set_mem_low_pressure_counter(::google::protobuf::uint64 value) {
  set_has_mem_low_pressure_counter();
  mem_low_pressure_counter_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.mem_low_pressure_counter)
}

// optional uint64 mem_medium_pressure_counter = 33;
inline bool ResourceStatistics::has_mem_medium_pressure_counter() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void ResourceStatistics::set_has_mem_medium_pressure_counter() {
  _has_bits_[1] |= 0x00000004u;
}
inline void ResourceStatistics::clear_has_mem_medium_pressure_counter() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void ResourceStatistics::clear_mem_medium_pressure_counter() {
  mem_medium_pressure_counter_ = GOOGLE_ULONGLONG(0);
  clear_has_mem_medium_pressure_counter();
}
inline ::google::protobuf::uint64 ResourceStatistics::mem_medium_pressure_counter() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.mem_medium_pressure_counter)
  return mem_medium_pressure_counter_;
}
inline void ResourceStatistics::set_mem_medium_pressure_counter(::google::protobuf::uint64 value) {
  set_has_mem_medium_pressure_counter();
  mem_medium_pressure_counter_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.mem_medium_pressure_counter)
}

// optional uint64 mem_critical_pressure_counter = 34;
inline bool ResourceStatistics::has_mem_critical_pressure_counter() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void ResourceStatistics::set_has_mem_critical_pressure_counter() {
  _has_bits_[1] |= 0x00000008u;
}
inline void ResourceStatistics::clear_has_mem_critical_pressure_counter() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void ResourceStatistics::clear_mem_critical_pressure_counter() {
  mem_critical_pressure_counter_ = GOOGLE_ULONGLONG(0);
  clear_has_mem_critical_pressure_counter();
}
inline ::google::protobuf::uint64 ResourceStatistics::mem_critical_pressure_counter() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.mem_critical_pressure_counter)
  return mem_critical_pressure_counter_;
}
inline void ResourceStatistics::set_mem_critical_pressure_counter(::google::protobuf::uint64 value) {
  set_has_mem_critical_pressure_counter();
  mem_critical_pressure_counter_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.mem_critical_pressure_counter)
}

// optional uint64 disk_limit_bytes = 26;
inline bool ResourceStatistics::has_disk_limit_bytes() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void ResourceStatistics::set_has_disk_limit_bytes() {
  _has_bits_[0] |= 0x08000000u;
}
inline void ResourceStatistics::clear_has_disk_limit_bytes() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void ResourceStatistics::clear_disk_limit_bytes() {
  disk_limit_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_disk_limit_bytes();
}
inline ::google::protobuf::uint64 ResourceStatistics::disk_limit_bytes() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.disk_limit_bytes)
  return disk_limit_bytes_;
}
inline void ResourceStatistics::set_disk_limit_bytes(::google::protobuf::uint64 value) {
  set_has_disk_limit_bytes();
  disk_limit_bytes_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.disk_limit_bytes)
}

// optional uint64 disk_used_bytes = 27;
inline bool ResourceStatistics::has_disk_used_bytes() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void ResourceStatistics::set_has_disk_used_bytes() {
  _has_bits_[0] |= 0x10000000u;
}
inline void ResourceStatistics::clear_has_disk_used_bytes() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void ResourceStatistics::clear_disk_used_bytes() {
  disk_used_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_disk_used_bytes();
}
inline ::google::protobuf::uint64 ResourceStatistics::disk_used_bytes() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.disk_used_bytes)
  return disk_used_bytes_;
}
inline void ResourceStatistics::set_disk_used_bytes(::google::protobuf::uint64 value) {
  set_has_disk_used_bytes();
  disk_used_bytes_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.disk_used_bytes)
}

// repeated .mesos.DiskStatistics disk_statistics = 43;
inline int ResourceStatistics::disk_statistics_size() const {
  return disk_statistics_.size();
}
inline void ResourceStatistics::clear_disk_statistics() {
  disk_statistics_.Clear();
}
inline const ::mesos::DiskStatistics& ResourceStatistics::disk_statistics(int index) const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.disk_statistics)
  return disk_statistics_.Get(index);
}
inline ::mesos::DiskStatistics* ResourceStatistics::mutable_disk_statistics(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.ResourceStatistics.disk_statistics)
  return disk_statistics_.Mutable(index);
}
inline ::mesos::DiskStatistics* ResourceStatistics::add_disk_statistics() {
  // @@protoc_insertion_point(field_add:mesos.ResourceStatistics.disk_statistics)
  return disk_statistics_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::DiskStatistics >*
ResourceStatistics::mutable_disk_statistics() {
  // @@protoc_insertion_point(field_mutable_list:mesos.ResourceStatistics.disk_statistics)
  return &disk_statistics_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::DiskStatistics >&
ResourceStatistics::disk_statistics() const {
  // @@protoc_insertion_point(field_list:mesos.ResourceStatistics.disk_statistics)
  return disk_statistics_;
}

// optional .mesos.CgroupInfo.Blkio.Statistics blkio_statistics = 44;
inline bool ResourceStatistics::has_blkio_statistics() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResourceStatistics::set_has_blkio_statistics() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResourceStatistics::clear_has_blkio_statistics() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResourceStatistics::clear_blkio_statistics() {
  if (blkio_statistics_ != NULL) blkio_statistics_->Clear();
  clear_has_blkio_statistics();
}
inline const ::mesos::CgroupInfo_Blkio_Statistics& ResourceStatistics::blkio_statistics() const {
  const ::mesos::CgroupInfo_Blkio_Statistics* p = blkio_statistics_;
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.blkio_statistics)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::CgroupInfo_Blkio_Statistics*>(
      &::mesos::_CgroupInfo_Blkio_Statistics_default_instance_);
}
inline ::mesos::CgroupInfo_Blkio_Statistics* ResourceStatistics::release_blkio_statistics() {
  // @@protoc_insertion_point(field_release:mesos.ResourceStatistics.blkio_statistics)
  clear_has_blkio_statistics();
  ::mesos::CgroupInfo_Blkio_Statistics* temp = blkio_statistics_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  blkio_statistics_ = NULL;
  return temp;
}
inline ::mesos::CgroupInfo_Blkio_Statistics* ResourceStatistics::unsafe_arena_release_blkio_statistics() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.ResourceStatistics.blkio_statistics)
  clear_has_blkio_statistics();
  ::mesos::CgroupInfo_Blkio_Statistics* temp = blkio_statistics_;
  blkio_statistics_ = NULL;
  return temp;
}
inline ::mesos::CgroupInfo_Blkio_Statistics* ResourceStatistics::mutable_blkio_statistics() {
  set_has_blkio_statistics();
  if (blkio_statistics_ == NULL) {
    _slow_mutable_blkio_statistics();
  }
  // @@protoc_insertion_point(field_mutable:mesos.ResourceStatistics.blkio_statistics)
  return blkio_statistics_;
}
inline void ResourceStatistics::set_allocated_blkio_statistics(::mesos::CgroupInfo_Blkio_Statistics* blkio_statistics) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete blkio_statistics_;
  }
  if (blkio_statistics) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(blkio_statistics);
    if (message_arena != submessage_arena) {
      blkio_statistics = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, blkio_statistics, submessage_arena);
    }
    set_has_blkio_statistics();
  } else {
    clear_has_blkio_statistics();
  }
  blkio_statistics_ = blkio_statistics;
  // @@protoc_insertion_point(field_set_allocated:mesos.ResourceStatistics.blkio_statistics)
}

// optional .mesos.PerfStatistics perf = 13;
inline bool ResourceStatistics::has_perf() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResourceStatistics::set_has_perf() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResourceStatistics::clear_has_perf() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResourceStatistics::clear_perf() {
  if (perf_ != NULL) perf_->Clear();
  clear_has_perf();
}
inline const ::mesos::PerfStatistics& ResourceStatistics::perf() const {
  const ::mesos::PerfStatistics* p = perf_;
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.perf)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::PerfStatistics*>(
      &::mesos::_PerfStatistics_default_instance_);
}
inline ::mesos::PerfStatistics* ResourceStatistics::release_perf() {
  // @@protoc_insertion_point(field_release:mesos.ResourceStatistics.perf)
  clear_has_perf();
  ::mesos::PerfStatistics* temp = perf_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  perf_ = NULL;
  return temp;
}
inline ::mesos::PerfStatistics* ResourceStatistics::unsafe_arena_release_perf() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.ResourceStatistics.perf)
  clear_has_perf();
  ::mesos::PerfStatistics* temp = perf_;
  perf_ = NULL;
  return temp;
}
inline ::mesos::PerfStatistics* ResourceStatistics::mutable_perf() {
  set_has_perf();
  if (perf_ == NULL) {
    _slow_mutable_perf();
  }
  // @@protoc_insertion_point(field_mutable:mesos.ResourceStatistics.perf)
  return perf_;
}
inline void ResourceStatistics::set_allocated_perf(::mesos::PerfStatistics* perf) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete perf_;
  }
  if (perf) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(perf);
    if (message_arena != submessage_arena) {
      perf = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, perf, submessage_arena);
    }
    set_has_perf();
  } else {
    clear_has_perf();
  }
  perf_ = perf;
  // @@protoc_insertion_point(field_set_allocated:mesos.ResourceStatistics.perf)
}

// optional uint64 net_rx_packets = 14;
inline bool ResourceStatistics::has_net_rx_packets() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void ResourceStatistics::set_has_net_rx_packets() {
  _has_bits_[0] |= 0x00008000u;
}
inline void ResourceStatistics::clear_has_net_rx_packets() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void ResourceStatistics::clear_net_rx_packets() {
  net_rx_packets_ = GOOGLE_ULONGLONG(0);
  clear_has_net_rx_packets();
}
inline ::google::protobuf::uint64 ResourceStatistics::net_rx_packets() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.net_rx_packets)
  return net_rx_packets_;
}
inline void ResourceStatistics::set_net_rx_packets(::google::protobuf::uint64 value) {
  set_has_net_rx_packets();
  net_rx_packets_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.net_rx_packets)
}

// optional uint64 net_rx_bytes = 15;
inline bool ResourceStatistics::has_net_rx_bytes() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void ResourceStatistics::set_has_net_rx_bytes() {
  _has_bits_[0] |= 0x00010000u;
}
inline void ResourceStatistics::clear_has_net_rx_bytes() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void ResourceStatistics::clear_net_rx_bytes() {
  net_rx_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_net_rx_bytes();
}
inline ::google::protobuf::uint64 ResourceStatistics::net_rx_bytes() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.net_rx_bytes)
  return net_rx_bytes_;
}
inline void ResourceStatistics::set_net_rx_bytes(::google::protobuf::uint64 value) {
  set_has_net_rx_bytes();
  net_rx_bytes_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.net_rx_bytes)
}

// optional uint64 net_rx_errors = 16;
inline bool ResourceStatistics::has_net_rx_errors() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void ResourceStatistics::set_has_net_rx_errors() {
  _has_bits_[0] |= 0x00020000u;
}
inline void ResourceStatistics::clear_has_net_rx_errors() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void ResourceStatistics::clear_net_rx_errors() {
  net_rx_errors_ = GOOGLE_ULONGLONG(0);
  clear_has_net_rx_errors();
}
inline ::google::protobuf::uint64 ResourceStatistics::net_rx_errors() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.net_rx_errors)
  return net_rx_errors_;
}
inline void ResourceStatistics::set_net_rx_errors(::google::protobuf::uint64 value) {
  set_has_net_rx_errors();
  net_rx_errors_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.net_rx_errors)
}

// optional uint64 net_rx_dropped = 17;
inline bool ResourceStatistics::has_net_rx_dropped() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void ResourceStatistics::set_has_net_rx_dropped() {
  _has_bits_[0] |= 0x00040000u;
}
inline void ResourceStatistics::clear_has_net_rx_dropped() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void ResourceStatistics::clear_net_rx_dropped() {
  net_rx_dropped_ = GOOGLE_ULONGLONG(0);
  clear_has_net_rx_dropped();
}
inline ::google::protobuf::uint64 ResourceStatistics::net_rx_dropped() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.net_rx_dropped)
  return net_rx_dropped_;
}
inline void ResourceStatistics::set_net_rx_dropped(::google::protobuf::uint64 value) {
  set_has_net_rx_dropped();
  net_rx_dropped_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.net_rx_dropped)
}

// optional uint64 net_tx_packets = 18;
inline bool ResourceStatistics::has_net_tx_packets() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void ResourceStatistics::set_has_net_tx_packets() {
  _has_bits_[0] |= 0x00080000u;
}
inline void ResourceStatistics::clear_has_net_tx_packets() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void ResourceStatistics::clear_net_tx_packets() {
  net_tx_packets_ = GOOGLE_ULONGLONG(0);
  clear_has_net_tx_packets();
}
inline ::google::protobuf::uint64 ResourceStatistics::net_tx_packets() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.net_tx_packets)
  return net_tx_packets_;
}
inline void ResourceStatistics::set_net_tx_packets(::google::protobuf::uint64 value) {
  set_has_net_tx_packets();
  net_tx_packets_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.net_tx_packets)
}

// optional uint64 net_tx_bytes = 19;
inline bool ResourceStatistics::has_net_tx_bytes() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void ResourceStatistics::set_has_net_tx_bytes() {
  _has_bits_[0] |= 0x00100000u;
}
inline void ResourceStatistics::clear_has_net_tx_bytes() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void ResourceStatistics::clear_net_tx_bytes() {
  net_tx_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_net_tx_bytes();
}
inline ::google::protobuf::uint64 ResourceStatistics::net_tx_bytes() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.net_tx_bytes)
  return net_tx_bytes_;
}
inline void ResourceStatistics::set_net_tx_bytes(::google::protobuf::uint64 value) {
  set_has_net_tx_bytes();
  net_tx_bytes_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.net_tx_bytes)
}

// optional uint64 net_tx_errors = 20;
inline bool ResourceStatistics::has_net_tx_errors() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void ResourceStatistics::set_has_net_tx_errors() {
  _has_bits_[0] |= 0x00200000u;
}
inline void ResourceStatistics::clear_has_net_tx_errors() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void ResourceStatistics::clear_net_tx_errors() {
  net_tx_errors_ = GOOGLE_ULONGLONG(0);
  clear_has_net_tx_errors();
}
inline ::google::protobuf::uint64 ResourceStatistics::net_tx_errors() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.net_tx_errors)
  return net_tx_errors_;
}
inline void ResourceStatistics::set_net_tx_errors(::google::protobuf::uint64 value) {
  set_has_net_tx_errors();
  net_tx_errors_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.net_tx_errors)
}

// optional uint64 net_tx_dropped = 21;
inline bool ResourceStatistics::has_net_tx_dropped() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void ResourceStatistics::set_has_net_tx_dropped() {
  _has_bits_[0] |= 0x00400000u;
}
inline void ResourceStatistics::clear_has_net_tx_dropped() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void ResourceStatistics::clear_net_tx_dropped() {
  net_tx_dropped_ = GOOGLE_ULONGLONG(0);
  clear_has_net_tx_dropped();
}
inline ::google::protobuf::uint64 ResourceStatistics::net_tx_dropped() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.net_tx_dropped)
  return net_tx_dropped_;
}
inline void ResourceStatistics::set_net_tx_dropped(::google::protobuf::uint64 value) {
  set_has_net_tx_dropped();
  net_tx_dropped_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.net_tx_dropped)
}

// optional double net_tcp_rtt_microsecs_p50 = 22;
inline bool ResourceStatistics::has_net_tcp_rtt_microsecs_p50() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void ResourceStatistics::set_has_net_tcp_rtt_microsecs_p50() {
  _has_bits_[0] |= 0x00800000u;
}
inline void ResourceStatistics::clear_has_net_tcp_rtt_microsecs_p50() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void ResourceStatistics::clear_net_tcp_rtt_microsecs_p50() {
  net_tcp_rtt_microsecs_p50_ = 0;
  clear_has_net_tcp_rtt_microsecs_p50();
}
inline double ResourceStatistics::net_tcp_rtt_microsecs_p50() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.net_tcp_rtt_microsecs_p50)
  return net_tcp_rtt_microsecs_p50_;
}
inline void ResourceStatistics::set_net_tcp_rtt_microsecs_p50(double value) {
  set_has_net_tcp_rtt_microsecs_p50();
  net_tcp_rtt_microsecs_p50_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.net_tcp_rtt_microsecs_p50)
}

// optional double net_tcp_rtt_microsecs_p90 = 23;
inline bool ResourceStatistics::has_net_tcp_rtt_microsecs_p90() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void ResourceStatistics::set_has_net_tcp_rtt_microsecs_p90() {
  _has_bits_[0] |= 0x01000000u;
}
inline void ResourceStatistics::clear_has_net_tcp_rtt_microsecs_p90() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void ResourceStatistics::clear_net_tcp_rtt_microsecs_p90() {
  net_tcp_rtt_microsecs_p90_ = 0;
  clear_has_net_tcp_rtt_microsecs_p90();
}
inline double ResourceStatistics::net_tcp_rtt_microsecs_p90() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.net_tcp_rtt_microsecs_p90)
  return net_tcp_rtt_microsecs_p90_;
}
inline void ResourceStatistics::set_net_tcp_rtt_microsecs_p90(double value) {
  set_has_net_tcp_rtt_microsecs_p90();
  net_tcp_rtt_microsecs_p90_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.net_tcp_rtt_microsecs_p90)
}

// optional double net_tcp_rtt_microsecs_p95 = 24;
inline bool ResourceStatistics::has_net_tcp_rtt_microsecs_p95() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void ResourceStatistics::set_has_net_tcp_rtt_microsecs_p95() {
  _has_bits_[0] |= 0x02000000u;
}
inline void ResourceStatistics::clear_has_net_tcp_rtt_microsecs_p95() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void ResourceStatistics::clear_net_tcp_rtt_microsecs_p95() {
  net_tcp_rtt_microsecs_p95_ = 0;
  clear_has_net_tcp_rtt_microsecs_p95();
}
inline double ResourceStatistics::net_tcp_rtt_microsecs_p95() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.net_tcp_rtt_microsecs_p95)
  return net_tcp_rtt_microsecs_p95_;
}
inline void ResourceStatistics::set_net_tcp_rtt_microsecs_p95(double value) {
  set_has_net_tcp_rtt_microsecs_p95();
  net_tcp_rtt_microsecs_p95_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.net_tcp_rtt_microsecs_p95)
}

// optional double net_tcp_rtt_microsecs_p99 = 25;
inline bool ResourceStatistics::has_net_tcp_rtt_microsecs_p99() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void ResourceStatistics::set_has_net_tcp_rtt_microsecs_p99() {
  _has_bits_[0] |= 0x04000000u;
}
inline void ResourceStatistics::clear_has_net_tcp_rtt_microsecs_p99() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void ResourceStatistics::clear_net_tcp_rtt_microsecs_p99() {
  net_tcp_rtt_microsecs_p99_ = 0;
  clear_has_net_tcp_rtt_microsecs_p99();
}
inline double ResourceStatistics::net_tcp_rtt_microsecs_p99() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.net_tcp_rtt_microsecs_p99)
  return net_tcp_rtt_microsecs_p99_;
}
inline void ResourceStatistics::set_net_tcp_rtt_microsecs_p99(double value) {
  set_has_net_tcp_rtt_microsecs_p99();
  net_tcp_rtt_microsecs_p99_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.net_tcp_rtt_microsecs_p99)
}

// optional double net_tcp_active_connections = 28;
inline bool ResourceStatistics::has_net_tcp_active_connections() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void ResourceStatistics::set_has_net_tcp_active_connections() {
  _has_bits_[0] |= 0x20000000u;
}
inline void ResourceStatistics::clear_has_net_tcp_active_connections() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void ResourceStatistics::clear_net_tcp_active_connections() {
  net_tcp_active_connections_ = 0;
  clear_has_net_tcp_active_connections();
}
inline double ResourceStatistics::net_tcp_active_connections() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.net_tcp_active_connections)
  return net_tcp_active_connections_;
}
inline void ResourceStatistics::set_net_tcp_active_connections(double value) {
  set_has_net_tcp_active_connections();
  net_tcp_active_connections_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.net_tcp_active_connections)
}

// optional double net_tcp_time_wait_connections = 29;
inline bool ResourceStatistics::has_net_tcp_time_wait_connections() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void ResourceStatistics::set_has_net_tcp_time_wait_connections() {
  _has_bits_[0] |= 0x40000000u;
}
inline void ResourceStatistics::clear_has_net_tcp_time_wait_connections() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void ResourceStatistics::clear_net_tcp_time_wait_connections() {
  net_tcp_time_wait_connections_ = 0;
  clear_has_net_tcp_time_wait_connections();
}
inline double ResourceStatistics::net_tcp_time_wait_connections() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.net_tcp_time_wait_connections)
  return net_tcp_time_wait_connections_;
}
inline void ResourceStatistics::set_net_tcp_time_wait_connections(double value) {
  set_has_net_tcp_time_wait_connections();
  net_tcp_time_wait_connections_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.net_tcp_time_wait_connections)
}

// repeated .mesos.TrafficControlStatistics net_traffic_control_statistics = 35;
inline int ResourceStatistics::net_traffic_control_statistics_size() const {
  return net_traffic_control_statistics_.size();
}
inline void ResourceStatistics::clear_net_traffic_control_statistics() {
  net_traffic_control_statistics_.Clear();
}
inline const ::mesos::TrafficControlStatistics& ResourceStatistics::net_traffic_control_statistics(int index) const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.net_traffic_control_statistics)
  return net_traffic_control_statistics_.Get(index);
}
inline ::mesos::TrafficControlStatistics* ResourceStatistics::mutable_net_traffic_control_statistics(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.ResourceStatistics.net_traffic_control_statistics)
  return net_traffic_control_statistics_.Mutable(index);
}
inline ::mesos::TrafficControlStatistics* ResourceStatistics::add_net_traffic_control_statistics() {
  // @@protoc_insertion_point(field_add:mesos.ResourceStatistics.net_traffic_control_statistics)
  return net_traffic_control_statistics_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::TrafficControlStatistics >*
ResourceStatistics::mutable_net_traffic_control_statistics() {
  // @@protoc_insertion_point(field_mutable_list:mesos.ResourceStatistics.net_traffic_control_statistics)
  return &net_traffic_control_statistics_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::TrafficControlStatistics >&
ResourceStatistics::net_traffic_control_statistics() const {
  // @@protoc_insertion_point(field_list:mesos.ResourceStatistics.net_traffic_control_statistics)
  return net_traffic_control_statistics_;
}

// optional .mesos.SNMPStatistics net_snmp_statistics = 42;
inline bool ResourceStatistics::has_net_snmp_statistics() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResourceStatistics::set_has_net_snmp_statistics() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResourceStatistics::clear_has_net_snmp_statistics() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResourceStatistics::clear_net_snmp_statistics() {
  if (net_snmp_statistics_ != NULL) net_snmp_statistics_->Clear();
  clear_has_net_snmp_statistics();
}
inline const ::mesos::SNMPStatistics& ResourceStatistics::net_snmp_statistics() const {
  const ::mesos::SNMPStatistics* p = net_snmp_statistics_;
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.net_snmp_statistics)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::SNMPStatistics*>(
      &::mesos::_SNMPStatistics_default_instance_);
}
inline ::mesos::SNMPStatistics* ResourceStatistics::release_net_snmp_statistics() {
  // @@protoc_insertion_point(field_release:mesos.ResourceStatistics.net_snmp_statistics)
  clear_has_net_snmp_statistics();
  ::mesos::SNMPStatistics* temp = net_snmp_statistics_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  net_snmp_statistics_ = NULL;
  return temp;
}
inline ::mesos::SNMPStatistics* ResourceStatistics::unsafe_arena_release_net_snmp_statistics() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.ResourceStatistics.net_snmp_statistics)
  clear_has_net_snmp_statistics();
  ::mesos::SNMPStatistics* temp = net_snmp_statistics_;
  net_snmp_statistics_ = NULL;
  return temp;
}
inline ::mesos::SNMPStatistics* ResourceStatistics::mutable_net_snmp_statistics() {
  set_has_net_snmp_statistics();
  if (net_snmp_statistics_ == NULL) {
    _slow_mutable_net_snmp_statistics();
  }
  // @@protoc_insertion_point(field_mutable:mesos.ResourceStatistics.net_snmp_statistics)
  return net_snmp_statistics_;
}
inline void ResourceStatistics::set_allocated_net_snmp_statistics(::mesos::SNMPStatistics* net_snmp_statistics) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete net_snmp_statistics_;
  }
  if (net_snmp_statistics) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(net_snmp_statistics);
    if (message_arena != submessage_arena) {
      net_snmp_statistics = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, net_snmp_statistics, submessage_arena);
    }
    set_has_net_snmp_statistics();
  } else {
    clear_has_net_snmp_statistics();
  }
  net_snmp_statistics_ = net_snmp_statistics;
  // @@protoc_insertion_point(field_set_allocated:mesos.ResourceStatistics.net_snmp_statistics)
}

// -------------------------------------------------------------------

// ResourceUsage_Executor_Task

// required string name = 1;
inline bool ResourceUsage_Executor_Task::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResourceUsage_Executor_Task::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResourceUsage_Executor_Task::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResourceUsage_Executor_Task::clear_name() {
  name_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_name();
}
inline const ::std::string& ResourceUsage_Executor_Task::name() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceUsage.Executor.Task.name)
  return name_.Get();
}
inline void ResourceUsage_Executor_Task::set_name(const ::std::string& value) {
  set_has_name();
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.ResourceUsage.Executor.Task.name)
}
#if LANG_CXX11
inline void ResourceUsage_Executor_Task::set_name(::std::string&& value) {
  set_has_name();
  name_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.ResourceUsage.Executor.Task.name)
}
#endif
inline void ResourceUsage_Executor_Task::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.ResourceUsage.Executor.Task.name)
}
inline void ResourceUsage_Executor_Task::set_name(const char* value,
    size_t size) {
  set_has_name();
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.ResourceUsage.Executor.Task.name)
}
inline ::std::string* ResourceUsage_Executor_Task::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:mesos.ResourceUsage.Executor.Task.name)
  return name_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* ResourceUsage_Executor_Task::release_name() {
  // @@protoc_insertion_point(field_release:mesos.ResourceUsage.Executor.Task.name)
  clear_has_name();
  return name_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void ResourceUsage_Executor_Task::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.ResourceUsage.Executor.Task.name)
}
inline ::std::string* ResourceUsage_Executor_Task::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.ResourceUsage.Executor.Task.name)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_name();
  return name_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void ResourceUsage_Executor_Task::unsafe_arena_set_allocated_name(
    ::std::string* name) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      name, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.ResourceUsage.Executor.Task.name)
}

// required .mesos.TaskID id = 2;
inline bool ResourceUsage_Executor_Task::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResourceUsage_Executor_Task::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResourceUsage_Executor_Task::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResourceUsage_Executor_Task::clear_id() {
  if (id_ != NULL) id_->Clear();
  clear_has_id();
}
inline const ::mesos::TaskID& ResourceUsage_Executor_Task::id() const {
  const ::mesos::TaskID* p = id_;
  // @@protoc_insertion_point(field_get:mesos.ResourceUsage.Executor.Task.id)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::TaskID*>(
      &::mesos::_TaskID_default_instance_);
}
inline ::mesos::TaskID* ResourceUsage_Executor_Task::release_id() {
  // @@protoc_insertion_point(field_release:mesos.ResourceUsage.Executor.Task.id)
  clear_has_id();
  ::mesos::TaskID* temp = id_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  id_ = NULL;
  return temp;
}
inline ::mesos::TaskID* ResourceUsage_Executor_Task::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.ResourceUsage.Executor.Task.id)
  clear_has_id();
  ::mesos::TaskID* temp = id_;
  id_ = NULL;
  return temp;
}
inline ::mesos::TaskID* ResourceUsage_Executor_Task::mutable_id() {
  set_has_id();
  if (id_ == NULL) {
    _slow_mutable_id();
  }
  // @@protoc_insertion_point(field_mutable:mesos.ResourceUsage.Executor.Task.id)
  return id_;
}
inline void ResourceUsage_Executor_Task::set_allocated_id(::mesos::TaskID* id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete id_;
  }
  if (id) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(id);
    if (message_arena != submessage_arena) {
      id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    set_has_id();
  } else {
    clear_has_id();
  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:mesos.ResourceUsage.Executor.Task.id)
}

// repeated .mesos.Resource resources = 3;
inline int ResourceUsage_Executor_Task::resources_size() const {
  return resources_.size();
}
inline void ResourceUsage_Executor_Task::clear_resources() {
  resources_.Clear();
}
inline const ::mesos::Resource& ResourceUsage_Executor_Task::resources(int index) const {
  // @@protoc_insertion_point(field_get:mesos.ResourceUsage.Executor.Task.resources)
  return resources_.Get(index);
}
inline ::mesos::Resource* ResourceUsage_Executor_Task::mutable_resources(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.ResourceUsage.Executor.Task.resources)
  return resources_.Mutable(index);
}
inline ::mesos::Resource* ResourceUsage_Executor_Task::add_resources() {
  // @@protoc_insertion_point(field_add:mesos.ResourceUsage.Executor.Task.resources)
  return resources_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
ResourceUsage_Executor_Task::mutable_resources() {
  // @@protoc_insertion_point(field_mutable_list:mesos.ResourceUsage.Executor.Task.resources)
  return &resources_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
ResourceUsage_Executor_Task::resources() const {
  // @@protoc_insertion_point(field_list:mesos.ResourceUsage.Executor.Task.resources)
  return resources_;
}

// optional .mesos.Labels labels = 4;
inline bool ResourceUsage_Executor_Task::has_labels() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResourceUsage_Executor_Task::set_has_labels() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResourceUsage_Executor_Task::clear_has_labels() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResourceUsage_Executor_Task::clear_labels() {
  if (labels_ != NULL) labels_->Clear();
  clear_has_labels();
}
inline const ::mesos::Labels& ResourceUsage_Executor_Task::labels() const {
  const ::mesos::Labels* p = labels_;
  // @@protoc_insertion_point(field_get:mesos.ResourceUsage.Executor.Task.labels)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::Labels*>(
      &::mesos::_Labels_default_instance_);
}
inline ::mesos::Labels* ResourceUsage_Executor_Task::release_labels() {
  // @@protoc_insertion_point(field_release:mesos.ResourceUsage.Executor.Task.labels)
  clear_has_labels();
  ::mesos::Labels* temp = labels_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  labels_ = NULL;
  return temp;
}
inline ::mesos::Labels* ResourceUsage_Executor_Task::unsafe_arena_release_labels() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.ResourceUsage.Executor.Task.labels)
  clear_has_labels();
  ::mesos::Labels* temp = labels_;
  labels_ = NULL;
  return temp;
}
inline ::mesos::Labels* ResourceUsage_Executor_Task::mutable_labels() {
  set_has_labels();
  if (labels_ == NULL) {
    _slow_mutable_labels();
  }
  // @@protoc_insertion_point(field_mutable:mesos.ResourceUsage.Executor.Task.labels)
  return labels_;
}
inline void ResourceUsage_Executor_Task::set_allocated_labels(::mesos::Labels* labels) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete labels_;
  }
  if (labels) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(labels);
    if (message_arena != submessage_arena) {
      labels = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, labels, submessage_arena);
    }
    set_has_labels();
  } else {
    clear_has_labels();
  }
  labels_ = labels;
  // @@protoc_insertion_point(field_set_allocated:mesos.ResourceUsage.Executor.Task.labels)
}

// -------------------------------------------------------------------

// ResourceUsage_Executor

// required .mesos.ExecutorInfo executor_info = 1;
inline bool ResourceUsage_Executor::has_executor_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResourceUsage_Executor::set_has_executor_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResourceUsage_Executor::clear_has_executor_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResourceUsage_Executor::clear_executor_info() {
  if (executor_info_ != NULL) executor_info_->Clear();
  clear_has_executor_info();
}
inline const ::mesos::ExecutorInfo& ResourceUsage_Executor::executor_info() const {
  const ::mesos::ExecutorInfo* p = executor_info_;
  // @@protoc_insertion_point(field_get:mesos.ResourceUsage.Executor.executor_info)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ExecutorInfo*>(
      &::mesos::_ExecutorInfo_default_instance_);
}
inline ::mesos::ExecutorInfo* ResourceUsage_Executor::release_executor_info() {
  // @@protoc_insertion_point(field_release:mesos.ResourceUsage.Executor.executor_info)
  clear_has_executor_info();
  ::mesos::ExecutorInfo* temp = executor_info_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  executor_info_ = NULL;
  return temp;
}
inline ::mesos::ExecutorInfo* ResourceUsage_Executor::unsafe_arena_release_executor_info() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.ResourceUsage.Executor.executor_info)
  clear_has_executor_info();
  ::mesos::ExecutorInfo* temp = executor_info_;
  executor_info_ = NULL;
  return temp;
}
inline ::mesos::ExecutorInfo* ResourceUsage_Executor::mutable_executor_info() {
  set_has_executor_info();
  if (executor_info_ == NULL) {
    _slow_mutable_executor_info();
  }
  // @@protoc_insertion_point(field_mutable:mesos.ResourceUsage.Executor.executor_info)
  return executor_info_;
}
inline void ResourceUsage_Executor::set_allocated_executor_info(::mesos::ExecutorInfo* executor_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete executor_info_;
  }
  if (executor_info) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(executor_info);
    if (message_arena != submessage_arena) {
      executor_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, executor_info, submessage_arena);
    }
    set_has_executor_info();
  } else {
    clear_has_executor_info();
  }
  executor_info_ = executor_info;
  // @@protoc_insertion_point(field_set_allocated:mesos.ResourceUsage.Executor.executor_info)
}

// repeated .mesos.Resource allocated = 2;
inline int ResourceUsage_Executor::allocated_size() const {
  return allocated_.size();
}
inline void ResourceUsage_Executor::clear_allocated() {
  allocated_.Clear();
}
inline const ::mesos::Resource& ResourceUsage_Executor::allocated(int index) const {
  // @@protoc_insertion_point(field_get:mesos.ResourceUsage.Executor.allocated)
  return allocated_.Get(index);
}
inline ::mesos::Resource* ResourceUsage_Executor::mutable_allocated(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.ResourceUsage.Executor.allocated)
  return allocated_.Mutable(index);
}
inline ::mesos::Resource* ResourceUsage_Executor::add_allocated() {
  // @@protoc_insertion_point(field_add:mesos.ResourceUsage.Executor.allocated)
  return allocated_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
ResourceUsage_Executor::mutable_allocated() {
  // @@protoc_insertion_point(field_mutable_list:mesos.ResourceUsage.Executor.allocated)
  return &allocated_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
ResourceUsage_Executor::allocated() const {
  // @@protoc_insertion_point(field_list:mesos.ResourceUsage.Executor.allocated)
  return allocated_;
}

// optional .mesos.ResourceStatistics statistics = 3;
inline bool ResourceUsage_Executor::has_statistics() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResourceUsage_Executor::set_has_statistics() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResourceUsage_Executor::clear_has_statistics() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResourceUsage_Executor::clear_statistics() {
  if (statistics_ != NULL) statistics_->Clear();
  clear_has_statistics();
}
inline const ::mesos::ResourceStatistics& ResourceUsage_Executor::statistics() const {
  const ::mesos::ResourceStatistics* p = statistics_;
  // @@protoc_insertion_point(field_get:mesos.ResourceUsage.Executor.statistics)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ResourceStatistics*>(
      &::mesos::_ResourceStatistics_default_instance_);
}
inline ::mesos::ResourceStatistics* ResourceUsage_Executor::release_statistics() {
  // @@protoc_insertion_point(field_release:mesos.ResourceUsage.Executor.statistics)
  clear_has_statistics();
  ::mesos::ResourceStatistics* temp = statistics_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  statistics_ = NULL;
  return temp;
}
inline ::mesos::ResourceStatistics* ResourceUsage_Executor::unsafe_arena_release_statistics() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.ResourceUsage.Executor.statistics)
  clear_has_statistics();
  ::mesos::ResourceStatistics* temp = statistics_;
  statistics_ = NULL;
  return temp;
}
inline ::mesos::ResourceStatistics* ResourceUsage_Executor::mutable_statistics() {
  set_has_statistics();
  if (statistics_ == NULL) {
    _slow_mutable_statistics();
  }
  // @@protoc_insertion_point(field_mutable:mesos.ResourceUsage.Executor.statistics)
  return statistics_;
}
inline void ResourceUsage_Executor::set_allocated_statistics(::mesos::ResourceStatistics* statistics) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete statistics_;
  }
  if (statistics) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(statistics);
    if (message_arena != submessage_arena) {
      statistics = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, statistics, submessage_arena);
    }
    set_has_statistics();
  } else {
    clear_has_statistics();
  }
  statistics_ = statistics;
  // @@protoc_insertion_point(field_set_allocated:mesos.ResourceUsage.Executor.statistics)
}

// required .mesos.ContainerID container_id = 4;
inline bool ResourceUsage_Executor::has_container_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResourceUsage_Executor::set_has_container_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResourceUsage_Executor::clear_has_container_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResourceUsage_Executor::clear_container_id() {
  if (container_id_ != NULL) container_id_->Clear();
  clear_has_container_id();
}
inline const ::mesos::ContainerID& ResourceUsage_Executor::container_id() const {
  const ::mesos::ContainerID* p = container_id_;
  // @@protoc_insertion_point(field_get:mesos.ResourceUsage.Executor.container_id)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ContainerID*>(
      &::mesos::_ContainerID_default_instance_);
}
inline ::mesos::ContainerID* ResourceUsage_Executor::release_container_id() {
  // @@protoc_insertion_point(field_release:mesos.ResourceUsage.Executor.container_id)
  clear_has_container_id();
  ::mesos::ContainerID* temp = container_id_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  container_id_ = NULL;
  return temp;
}
inline ::mesos::ContainerID* ResourceUsage_Executor::unsafe_arena_release_container_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.ResourceUsage.Executor.container_id)
  clear_has_container_id();
  ::mesos::ContainerID* temp = container_id_;
  container_id_ = NULL;
  return temp;
}
inline ::mesos::ContainerID* ResourceUsage_Executor::mutable_container_id() {
  set_has_container_id();
  if (container_id_ == NULL) {
    _slow_mutable_container_id();
  }
  // @@protoc_insertion_point(field_mutable:mesos.ResourceUsage.Executor.container_id)
  return container_id_;
}
inline void ResourceUsage_Executor::set_allocated_container_id(::mesos::ContainerID* container_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete container_id_;
  }
  if (container_id) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(container_id);
    if (message_arena != submessage_arena) {
      container_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, container_id, submessage_arena);
    }
    set_has_container_id();
  } else {
    clear_has_container_id();
  }
  container_id_ = container_id;
  // @@protoc_insertion_point(field_set_allocated:mesos.ResourceUsage.Executor.container_id)
}

// repeated .mesos.ResourceUsage.Executor.Task tasks = 5;
inline int ResourceUsage_Executor::tasks_size() const {
  return tasks_.size();
}
inline void ResourceUsage_Executor::clear_tasks() {
  tasks_.Clear();
}
inline const ::mesos::ResourceUsage_Executor_Task& ResourceUsage_Executor::tasks(int index) const {
  // @@protoc_insertion_point(field_get:mesos.ResourceUsage.Executor.tasks)
  return tasks_.Get(index);
}
inline ::mesos::ResourceUsage_Executor_Task* ResourceUsage_Executor::mutable_tasks(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.ResourceUsage.Executor.tasks)
  return tasks_.Mutable(index);
}
inline ::mesos::ResourceUsage_Executor_Task* ResourceUsage_Executor::add_tasks() {
  // @@protoc_insertion_point(field_add:mesos.ResourceUsage.Executor.tasks)
  return tasks_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::ResourceUsage_Executor_Task >*
ResourceUsage_Executor::mutable_tasks() {
  // @@protoc_insertion_point(field_mutable_list:mesos.ResourceUsage.Executor.tasks)
  return &tasks_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::ResourceUsage_Executor_Task >&
ResourceUsage_Executor::tasks() const {
  // @@protoc_insertion_point(field_list:mesos.ResourceUsage.Executor.tasks)
  return tasks_;
}

// -------------------------------------------------------------------

// ResourceUsage

// repeated .mesos.ResourceUsage.Executor executors = 1;
inline int ResourceUsage::executors_size() const {
  return executors_.size();
}
inline void ResourceUsage::clear_executors() {
  executors_.Clear();
}
inline const ::mesos::ResourceUsage_Executor& ResourceUsage::executors(int index) const {
  // @@protoc_insertion_point(field_get:mesos.ResourceUsage.executors)
  return executors_.Get(index);
}
inline ::mesos::ResourceUsage_Executor* ResourceUsage::mutable_executors(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.ResourceUsage.executors)
  return executors_.Mutable(index);
}
inline ::mesos::ResourceUsage_Executor* ResourceUsage::add_executors() {
  // @@protoc_insertion_point(field_add:mesos.ResourceUsage.executors)
  return executors_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::ResourceUsage_Executor >*
ResourceUsage::mutable_executors() {
  // @@protoc_insertion_point(field_mutable_list:mesos.ResourceUsage.executors)
  return &executors_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::ResourceUsage_Executor >&
ResourceUsage::executors() const {
  // @@protoc_insertion_point(field_list:mesos.ResourceUsage.executors)
  return executors_;
}

// repeated .mesos.Resource total = 2;
inline int ResourceUsage::total_size() const {
  return total_.size();
}
inline void ResourceUsage::clear_total() {
  total_.Clear();
}
inline const ::mesos::Resource& ResourceUsage::total(int index) const {
  // @@protoc_insertion_point(field_get:mesos.ResourceUsage.total)
  return total_.Get(index);
}
inline ::mesos::Resource* ResourceUsage::mutable_total(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.ResourceUsage.total)
  return total_.Mutable(index);
}
inline ::mesos::Resource* ResourceUsage::add_total() {
  // @@protoc_insertion_point(field_add:mesos.ResourceUsage.total)
  return total_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
ResourceUsage::mutable_total() {
  // @@protoc_insertion_point(field_mutable_list:mesos.ResourceUsage.total)
  return &total_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
ResourceUsage::total() const {
  // @@protoc_insertion_point(field_list:mesos.ResourceUsage.total)
  return total_;
}

// -------------------------------------------------------------------

// PerfStatistics

// required double timestamp = 1;
inline bool PerfStatistics::has_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PerfStatistics::set_has_timestamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PerfStatistics::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PerfStatistics::clear_timestamp() {
  timestamp_ = 0;
  clear_has_timestamp();
}
inline double PerfStatistics::timestamp() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.timestamp)
  return timestamp_;
}
inline void PerfStatistics::set_timestamp(double value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.timestamp)
}

// required double duration = 2;
inline bool PerfStatistics::has_duration() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PerfStatistics::set_has_duration() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PerfStatistics::clear_has_duration() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PerfStatistics::clear_duration() {
  duration_ = 0;
  clear_has_duration();
}
inline double PerfStatistics::duration() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.duration)
  return duration_;
}
inline void PerfStatistics::set_duration(double value) {
  set_has_duration();
  duration_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.duration)
}

// optional uint64 cycles = 3;
inline bool PerfStatistics::has_cycles() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PerfStatistics::set_has_cycles() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PerfStatistics::clear_has_cycles() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PerfStatistics::clear_cycles() {
  cycles_ = GOOGLE_ULONGLONG(0);
  clear_has_cycles();
}
inline ::google::protobuf::uint64 PerfStatistics::cycles() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.cycles)
  return cycles_;
}
inline void PerfStatistics::set_cycles(::google::protobuf::uint64 value) {
  set_has_cycles();
  cycles_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.cycles)
}

// optional uint64 stalled_cycles_frontend = 4;
inline bool PerfStatistics::has_stalled_cycles_frontend() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PerfStatistics::set_has_stalled_cycles_frontend() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PerfStatistics::clear_has_stalled_cycles_frontend() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PerfStatistics::clear_stalled_cycles_frontend() {
  stalled_cycles_frontend_ = GOOGLE_ULONGLONG(0);
  clear_has_stalled_cycles_frontend();
}
inline ::google::protobuf::uint64 PerfStatistics::stalled_cycles_frontend() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.stalled_cycles_frontend)
  return stalled_cycles_frontend_;
}
inline void PerfStatistics::set_stalled_cycles_frontend(::google::protobuf::uint64 value) {
  set_has_stalled_cycles_frontend();
  stalled_cycles_frontend_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.stalled_cycles_frontend)
}

// optional uint64 stalled_cycles_backend = 5;
inline bool PerfStatistics::has_stalled_cycles_backend() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PerfStatistics::set_has_stalled_cycles_backend() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PerfStatistics::clear_has_stalled_cycles_backend() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PerfStatistics::clear_stalled_cycles_backend() {
  stalled_cycles_backend_ = GOOGLE_ULONGLONG(0);
  clear_has_stalled_cycles_backend();
}
inline ::google::protobuf::uint64 PerfStatistics::stalled_cycles_backend() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.stalled_cycles_backend)
  return stalled_cycles_backend_;
}
inline void PerfStatistics::set_stalled_cycles_backend(::google::protobuf::uint64 value) {
  set_has_stalled_cycles_backend();
  stalled_cycles_backend_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.stalled_cycles_backend)
}

// optional uint64 instructions = 6;
inline bool PerfStatistics::has_instructions() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PerfStatistics::set_has_instructions() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PerfStatistics::clear_has_instructions() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PerfStatistics::clear_instructions() {
  instructions_ = GOOGLE_ULONGLONG(0);
  clear_has_instructions();
}
inline ::google::protobuf::uint64 PerfStatistics::instructions() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.instructions)
  return instructions_;
}
inline void PerfStatistics::set_instructions(::google::protobuf::uint64 value) {
  set_has_instructions();
  instructions_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.instructions)
}

// optional uint64 cache_references = 7;
inline bool PerfStatistics::has_cache_references() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PerfStatistics::set_has_cache_references() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PerfStatistics::clear_has_cache_references() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PerfStatistics::clear_cache_references() {
  cache_references_ = GOOGLE_ULONGLONG(0);
  clear_has_cache_references();
}
inline ::google::protobuf::uint64 PerfStatistics::cache_references() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.cache_references)
  return cache_references_;
}
inline void PerfStatistics::set_cache_references(::google::protobuf::uint64 value) {
  set_has_cache_references();
  cache_references_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.cache_references)
}

// optional uint64 cache_misses = 8;
inline bool PerfStatistics::has_cache_misses() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PerfStatistics::set_has_cache_misses() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PerfStatistics::clear_has_cache_misses() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PerfStatistics::clear_cache_misses() {
  cache_misses_ = GOOGLE_ULONGLONG(0);
  clear_has_cache_misses();
}
inline ::google::protobuf::uint64 PerfStatistics::cache_misses() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.cache_misses)
  return cache_misses_;
}
inline void PerfStatistics::set_cache_misses(::google::protobuf::uint64 value) {
  set_has_cache_misses();
  cache_misses_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.cache_misses)
}

// optional uint64 branches = 9;
inline bool PerfStatistics::has_branches() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PerfStatistics::set_has_branches() {
  _has_bits_[0] |= 0x00000100u;
}
inline void PerfStatistics::clear_has_branches() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void PerfStatistics::clear_branches() {
  branches_ = GOOGLE_ULONGLONG(0);
  clear_has_branches();
}
inline ::google::protobuf::uint64 PerfStatistics::branches() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.branches)
  return branches_;
}
inline void PerfStatistics::set_branches(::google::protobuf::uint64 value) {
  set_has_branches();
  branches_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.branches)
}

// optional uint64 branch_misses = 10;
inline bool PerfStatistics::has_branch_misses() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void PerfStatistics::set_has_branch_misses() {
  _has_bits_[0] |= 0x00000200u;
}
inline void PerfStatistics::clear_has_branch_misses() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void PerfStatistics::clear_branch_misses() {
  branch_misses_ = GOOGLE_ULONGLONG(0);
  clear_has_branch_misses();
}
inline ::google::protobuf::uint64 PerfStatistics::branch_misses() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.branch_misses)
  return branch_misses_;
}
inline void PerfStatistics::set_branch_misses(::google::protobuf::uint64 value) {
  set_has_branch_misses();
  branch_misses_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.branch_misses)
}

// optional uint64 bus_cycles = 11;
inline bool PerfStatistics::has_bus_cycles() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void PerfStatistics::set_has_bus_cycles() {
  _has_bits_[0] |= 0x00000400u;
}
inline void PerfStatistics::clear_has_bus_cycles() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void PerfStatistics::clear_bus_cycles() {
  bus_cycles_ = GOOGLE_ULONGLONG(0);
  clear_has_bus_cycles();
}
inline ::google::protobuf::uint64 PerfStatistics::bus_cycles() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.bus_cycles)
  return bus_cycles_;
}
inline void PerfStatistics::set_bus_cycles(::google::protobuf::uint64 value) {
  set_has_bus_cycles();
  bus_cycles_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.bus_cycles)
}

// optional uint64 ref_cycles = 12;
inline bool PerfStatistics::has_ref_cycles() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void PerfStatistics::set_has_ref_cycles() {
  _has_bits_[0] |= 0x00000800u;
}
inline void PerfStatistics::clear_has_ref_cycles() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void PerfStatistics::clear_ref_cycles() {
  ref_cycles_ = GOOGLE_ULONGLONG(0);
  clear_has_ref_cycles();
}
inline ::google::protobuf::uint64 PerfStatistics::ref_cycles() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.ref_cycles)
  return ref_cycles_;
}
inline void PerfStatistics::set_ref_cycles(::google::protobuf::uint64 value) {
  set_has_ref_cycles();
  ref_cycles_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.ref_cycles)
}

// optional double cpu_clock = 13;
inline bool PerfStatistics::has_cpu_clock() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void PerfStatistics::set_has_cpu_clock() {
  _has_bits_[0] |= 0x00001000u;
}
inline void PerfStatistics::clear_has_cpu_clock() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void PerfStatistics::clear_cpu_clock() {
  cpu_clock_ = 0;
  clear_has_cpu_clock();
}
inline double PerfStatistics::cpu_clock() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.cpu_clock)
  return cpu_clock_;
}
inline void PerfStatistics::set_cpu_clock(double value) {
  set_has_cpu_clock();
  cpu_clock_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.cpu_clock)
}

// optional double task_clock = 14;
inline bool PerfStatistics::has_task_clock() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void PerfStatistics::set_has_task_clock() {
  _has_bits_[0] |= 0x00002000u;
}
inline void PerfStatistics::clear_has_task_clock() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void PerfStatistics::clear_task_clock() {
  task_clock_ = 0;
  clear_has_task_clock();
}
inline double PerfStatistics::task_clock() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.task_clock)
  return task_clock_;
}
inline void PerfStatistics::set_task_clock(double value) {
  set_has_task_clock();
  task_clock_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.task_clock)
}

// optional uint64 page_faults = 15;
inline bool PerfStatistics::has_page_faults() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void PerfStatistics::set_has_page_faults() {
  _has_bits_[0] |= 0x00004000u;
}
inline void PerfStatistics::clear_has_page_faults() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void PerfStatistics::clear_page_faults() {
  page_faults_ = GOOGLE_ULONGLONG(0);
  clear_has_page_faults();
}
inline ::google::protobuf::uint64 PerfStatistics::page_faults() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.page_faults)
  return page_faults_;
}
inline void PerfStatistics::set_page_faults(::google::protobuf::uint64 value) {
  set_has_page_faults();
  page_faults_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.page_faults)
}

// optional uint64 minor_faults = 16;
inline bool PerfStatistics::has_minor_faults() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void PerfStatistics::set_has_minor_faults() {
  _has_bits_[0] |= 0x00008000u;
}
inline void PerfStatistics::clear_has_minor_faults() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void PerfStatistics::clear_minor_faults() {
  minor_faults_ = GOOGLE_ULONGLONG(0);
  clear_has_minor_faults();
}
inline ::google::protobuf::uint64 PerfStatistics::minor_faults() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.minor_faults)
  return minor_faults_;
}
inline void PerfStatistics::set_minor_faults(::google::protobuf::uint64 value) {
  set_has_minor_faults();
  minor_faults_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.minor_faults)
}

// optional uint64 major_faults = 17;
inline bool PerfStatistics::has_major_faults() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void PerfStatistics::set_has_major_faults() {
  _has_bits_[0] |= 0x00010000u;
}
inline void PerfStatistics::clear_has_major_faults() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void PerfStatistics::clear_major_faults() {
  major_faults_ = GOOGLE_ULONGLONG(0);
  clear_has_major_faults();
}
inline ::google::protobuf::uint64 PerfStatistics::major_faults() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.major_faults)
  return major_faults_;
}
inline void PerfStatistics::set_major_faults(::google::protobuf::uint64 value) {
  set_has_major_faults();
  major_faults_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.major_faults)
}

// optional uint64 context_switches = 18;
inline bool PerfStatistics::has_context_switches() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void PerfStatistics::set_has_context_switches() {
  _has_bits_[0] |= 0x00020000u;
}
inline void PerfStatistics::clear_has_context_switches() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void PerfStatistics::clear_context_switches() {
  context_switches_ = GOOGLE_ULONGLONG(0);
  clear_has_context_switches();
}
inline ::google::protobuf::uint64 PerfStatistics::context_switches() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.context_switches)
  return context_switches_;
}
inline void PerfStatistics::set_context_switches(::google::protobuf::uint64 value) {
  set_has_context_switches();
  context_switches_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.context_switches)
}

// optional uint64 cpu_migrations = 19;
inline bool PerfStatistics::has_cpu_migrations() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void PerfStatistics::set_has_cpu_migrations() {
  _has_bits_[0] |= 0x00040000u;
}
inline void PerfStatistics::clear_has_cpu_migrations() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void PerfStatistics::clear_cpu_migrations() {
  cpu_migrations_ = GOOGLE_ULONGLONG(0);
  clear_has_cpu_migrations();
}
inline ::google::protobuf::uint64 PerfStatistics::cpu_migrations() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.cpu_migrations)
  return cpu_migrations_;
}
inline void PerfStatistics::set_cpu_migrations(::google::protobuf::uint64 value) {
  set_has_cpu_migrations();
  cpu_migrations_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.cpu_migrations)
}

// optional uint64 alignment_faults = 20;
inline bool PerfStatistics::has_alignment_faults() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void PerfStatistics::set_has_alignment_faults() {
  _has_bits_[0] |= 0x00080000u;
}
inline void PerfStatistics::clear_has_alignment_faults() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void PerfStatistics::clear_alignment_faults() {
  alignment_faults_ = GOOGLE_ULONGLONG(0);
  clear_has_alignment_faults();
}
inline ::google::protobuf::uint64 PerfStatistics::alignment_faults() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.alignment_faults)
  return alignment_faults_;
}
inline void PerfStatistics::set_alignment_faults(::google::protobuf::uint64 value) {
  set_has_alignment_faults();
  alignment_faults_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.alignment_faults)
}

// optional uint64 emulation_faults = 21;
inline bool PerfStatistics::has_emulation_faults() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void PerfStatistics::set_has_emulation_faults() {
  _has_bits_[0] |= 0x00100000u;
}
inline void PerfStatistics::clear_has_emulation_faults() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void PerfStatistics::clear_emulation_faults() {
  emulation_faults_ = GOOGLE_ULONGLONG(0);
  clear_has_emulation_faults();
}
inline ::google::protobuf::uint64 PerfStatistics::emulation_faults() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.emulation_faults)
  return emulation_faults_;
}
inline void PerfStatistics::set_emulation_faults(::google::protobuf::uint64 value) {
  set_has_emulation_faults();
  emulation_faults_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.emulation_faults)
}

// optional uint64 l1_dcache_loads = 22;
inline bool PerfStatistics::has_l1_dcache_loads() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void PerfStatistics::set_has_l1_dcache_loads() {
  _has_bits_[0] |= 0x00200000u;
}
inline void PerfStatistics::clear_has_l1_dcache_loads() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void PerfStatistics::clear_l1_dcache_loads() {
  l1_dcache_loads_ = GOOGLE_ULONGLONG(0);
  clear_has_l1_dcache_loads();
}
inline ::google::protobuf::uint64 PerfStatistics::l1_dcache_loads() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.l1_dcache_loads)
  return l1_dcache_loads_;
}
inline void PerfStatistics::set_l1_dcache_loads(::google::protobuf::uint64 value) {
  set_has_l1_dcache_loads();
  l1_dcache_loads_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.l1_dcache_loads)
}

// optional uint64 l1_dcache_load_misses = 23;
inline bool PerfStatistics::has_l1_dcache_load_misses() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void PerfStatistics::set_has_l1_dcache_load_misses() {
  _has_bits_[0] |= 0x00400000u;
}
inline void PerfStatistics::clear_has_l1_dcache_load_misses() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void PerfStatistics::clear_l1_dcache_load_misses() {
  l1_dcache_load_misses_ = GOOGLE_ULONGLONG(0);
  clear_has_l1_dcache_load_misses();
}
inline ::google::protobuf::uint64 PerfStatistics::l1_dcache_load_misses() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.l1_dcache_load_misses)
  return l1_dcache_load_misses_;
}
inline void PerfStatistics::set_l1_dcache_load_misses(::google::protobuf::uint64 value) {
  set_has_l1_dcache_load_misses();
  l1_dcache_load_misses_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.l1_dcache_load_misses)
}

// optional uint64 l1_dcache_stores = 24;
inline bool PerfStatistics::has_l1_dcache_stores() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void PerfStatistics::set_has_l1_dcache_stores() {
  _has_bits_[0] |= 0x00800000u;
}
inline void PerfStatistics::clear_has_l1_dcache_stores() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void PerfStatistics::clear_l1_dcache_stores() {
  l1_dcache_stores_ = GOOGLE_ULONGLONG(0);
  clear_has_l1_dcache_stores();
}
inline ::google::protobuf::uint64 PerfStatistics::l1_dcache_stores() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.l1_dcache_stores)
  return l1_dcache_stores_;
}
inline void PerfStatistics::set_l1_dcache_stores(::google::protobuf::uint64 value) {
  set_has_l1_dcache_stores();
  l1_dcache_stores_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.l1_dcache_stores)
}

// optional uint64 l1_dcache_store_misses = 25;
inline bool PerfStatistics::has_l1_dcache_store_misses() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void PerfStatistics::set_has_l1_dcache_store_misses() {
  _has_bits_[0] |= 0x01000000u;
}
inline void PerfStatistics::clear_has_l1_dcache_store_misses() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void PerfStatistics::clear_l1_dcache_store_misses() {
  l1_dcache_store_misses_ = GOOGLE_ULONGLONG(0);
  clear_has_l1_dcache_store_misses();
}
inline ::google::protobuf::uint64 PerfStatistics::l1_dcache_store_misses() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.l1_dcache_store_misses)
  return l1_dcache_store_misses_;
}
inline void PerfStatistics::set_l1_dcache_store_misses(::google::protobuf::uint64 value) {
  set_has_l1_dcache_store_misses();
  l1_dcache_store_misses_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.l1_dcache_store_misses)
}

// optional uint64 l1_dcache_prefetches = 26;
inline bool PerfStatistics::has_l1_dcache_prefetches() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void PerfStatistics::set_has_l1_dcache_prefetches() {
  _has_bits_[0] |= 0x02000000u;
}
inline void PerfStatistics::clear_has_l1_dcache_prefetches() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void PerfStatistics::clear_l1_dcache_prefetches() {
  l1_dcache_prefetches_ = GOOGLE_ULONGLONG(0);
  clear_has_l1_dcache_prefetches();
}
inline ::google::protobuf::uint64 PerfStatistics::l1_dcache_prefetches() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.l1_dcache_prefetches)
  return l1_dcache_prefetches_;
}
inline void PerfStatistics::set_l1_dcache_prefetches(::google::protobuf::uint64 value) {
  set_has_l1_dcache_prefetches();
  l1_dcache_prefetches_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.l1_dcache_prefetches)
}

// optional uint64 l1_dcache_prefetch_misses = 27;
inline bool PerfStatistics::has_l1_dcache_prefetch_misses() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void PerfStatistics::set_has_l1_dcache_prefetch_misses() {
  _has_bits_[0] |= 0x04000000u;
}
inline void PerfStatistics::clear_has_l1_dcache_prefetch_misses() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void PerfStatistics::clear_l1_dcache_prefetch_misses() {
  l1_dcache_prefetch_misses_ = GOOGLE_ULONGLONG(0);
  clear_has_l1_dcache_prefetch_misses();
}
inline ::google::protobuf::uint64 PerfStatistics::l1_dcache_prefetch_misses() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.l1_dcache_prefetch_misses)
  return l1_dcache_prefetch_misses_;
}
inline void PerfStatistics::set_l1_dcache_prefetch_misses(::google::protobuf::uint64 value) {
  set_has_l1_dcache_prefetch_misses();
  l1_dcache_prefetch_misses_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.l1_dcache_prefetch_misses)
}

// optional uint64 l1_icache_loads = 28;
inline bool PerfStatistics::has_l1_icache_loads() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void PerfStatistics::set_has_l1_icache_loads() {
  _has_bits_[0] |= 0x08000000u;
}
inline void PerfStatistics::clear_has_l1_icache_loads() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void PerfStatistics::clear_l1_icache_loads() {
  l1_icache_loads_ = GOOGLE_ULONGLONG(0);
  clear_has_l1_icache_loads();
}
inline ::google::protobuf::uint64 PerfStatistics::l1_icache_loads() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.l1_icache_loads)
  return l1_icache_loads_;
}
inline void PerfStatistics::set_l1_icache_loads(::google::protobuf::uint64 value) {
  set_has_l1_icache_loads();
  l1_icache_loads_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.l1_icache_loads)
}

// optional uint64 l1_icache_load_misses = 29;
inline bool PerfStatistics::has_l1_icache_load_misses() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void PerfStatistics::set_has_l1_icache_load_misses() {
  _has_bits_[0] |= 0x10000000u;
}
inline void PerfStatistics::clear_has_l1_icache_load_misses() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void PerfStatistics::clear_l1_icache_load_misses() {
  l1_icache_load_misses_ = GOOGLE_ULONGLONG(0);
  clear_has_l1_icache_load_misses();
}
inline ::google::protobuf::uint64 PerfStatistics::l1_icache_load_misses() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.l1_icache_load_misses)
  return l1_icache_load_misses_;
}
inline void PerfStatistics::set_l1_icache_load_misses(::google::protobuf::uint64 value) {
  set_has_l1_icache_load_misses();
  l1_icache_load_misses_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.l1_icache_load_misses)
}

// optional uint64 l1_icache_prefetches = 30;
inline bool PerfStatistics::has_l1_icache_prefetches() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void PerfStatistics::set_has_l1_icache_prefetches() {
  _has_bits_[0] |= 0x20000000u;
}
inline void PerfStatistics::clear_has_l1_icache_prefetches() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void PerfStatistics::clear_l1_icache_prefetches() {
  l1_icache_prefetches_ = GOOGLE_ULONGLONG(0);
  clear_has_l1_icache_prefetches();
}
inline ::google::protobuf::uint64 PerfStatistics::l1_icache_prefetches() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.l1_icache_prefetches)
  return l1_icache_prefetches_;
}
inline void PerfStatistics::set_l1_icache_prefetches(::google::protobuf::uint64 value) {
  set_has_l1_icache_prefetches();
  l1_icache_prefetches_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.l1_icache_prefetches)
}

// optional uint64 l1_icache_prefetch_misses = 31;
inline bool PerfStatistics::has_l1_icache_prefetch_misses() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void PerfStatistics::set_has_l1_icache_prefetch_misses() {
  _has_bits_[0] |= 0x40000000u;
}
inline void PerfStatistics::clear_has_l1_icache_prefetch_misses() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void PerfStatistics::clear_l1_icache_prefetch_misses() {
  l1_icache_prefetch_misses_ = GOOGLE_ULONGLONG(0);
  clear_has_l1_icache_prefetch_misses();
}
inline ::google::protobuf::uint64 PerfStatistics::l1_icache_prefetch_misses() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.l1_icache_prefetch_misses)
  return l1_icache_prefetch_misses_;
}
inline void PerfStatistics::set_l1_icache_prefetch_misses(::google::protobuf::uint64 value) {
  set_has_l1_icache_prefetch_misses();
  l1_icache_prefetch_misses_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.l1_icache_prefetch_misses)
}

// optional uint64 llc_loads = 32;
inline bool PerfStatistics::has_llc_loads() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void PerfStatistics::set_has_llc_loads() {
  _has_bits_[0] |= 0x80000000u;
}
inline void PerfStatistics::clear_has_llc_loads() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void PerfStatistics::clear_llc_loads() {
  llc_loads_ = GOOGLE_ULONGLONG(0);
  clear_has_llc_loads();
}
inline ::google::protobuf::uint64 PerfStatistics::llc_loads() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.llc_loads)
  return llc_loads_;
}
inline void PerfStatistics::set_llc_loads(::google::protobuf::uint64 value) {
  set_has_llc_loads();
  llc_loads_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.llc_loads)
}

// optional uint64 llc_load_misses = 33;
inline bool PerfStatistics::has_llc_load_misses() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void PerfStatistics::set_has_llc_load_misses() {
  _has_bits_[1] |= 0x00000001u;
}
inline void PerfStatistics::clear_has_llc_load_misses() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void PerfStatistics::clear_llc_load_misses() {
  llc_load_misses_ = GOOGLE_ULONGLONG(0);
  clear_has_llc_load_misses();
}
inline ::google::protobuf::uint64 PerfStatistics::llc_load_misses() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.llc_load_misses)
  return llc_load_misses_;
}
inline void PerfStatistics::set_llc_load_misses(::google::protobuf::uint64 value) {
  set_has_llc_load_misses();
  llc_load_misses_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.llc_load_misses)
}

// optional uint64 llc_stores = 34;
inline bool PerfStatistics::has_llc_stores() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void PerfStatistics::set_has_llc_stores() {
  _has_bits_[1] |= 0x00000002u;
}
inline void PerfStatistics::clear_has_llc_stores() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void PerfStatistics::clear_llc_stores() {
  llc_stores_ = GOOGLE_ULONGLONG(0);
  clear_has_llc_stores();
}
inline ::google::protobuf::uint64 PerfStatistics::llc_stores() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.llc_stores)
  return llc_stores_;
}
inline void PerfStatistics::set_llc_stores(::google::protobuf::uint64 value) {
  set_has_llc_stores();
  llc_stores_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.llc_stores)
}

// optional uint64 llc_store_misses = 35;
inline bool PerfStatistics::has_llc_store_misses() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void PerfStatistics::set_has_llc_store_misses() {
  _has_bits_[1] |= 0x00000004u;
}
inline void PerfStatistics::clear_has_llc_store_misses() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void PerfStatistics::clear_llc_store_misses() {
  llc_store_misses_ = GOOGLE_ULONGLONG(0);
  clear_has_llc_store_misses();
}
inline ::google::protobuf::uint64 PerfStatistics::llc_store_misses() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.llc_store_misses)
  return llc_store_misses_;
}
inline void PerfStatistics::set_llc_store_misses(::google::protobuf::uint64 value) {
  set_has_llc_store_misses();
  llc_store_misses_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.llc_store_misses)
}

// optional uint64 llc_prefetches = 36;
inline bool PerfStatistics::has_llc_prefetches() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void PerfStatistics::set_has_llc_prefetches() {
  _has_bits_[1] |= 0x00000008u;
}
inline void PerfStatistics::clear_has_llc_prefetches() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void PerfStatistics::clear_llc_prefetches() {
  llc_prefetches_ = GOOGLE_ULONGLONG(0);
  clear_has_llc_prefetches();
}
inline ::google::protobuf::uint64 PerfStatistics::llc_prefetches() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.llc_prefetches)
  return llc_prefetches_;
}
inline void PerfStatistics::set_llc_prefetches(::google::protobuf::uint64 value) {
  set_has_llc_prefetches();
  llc_prefetches_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.llc_prefetches)
}

// optional uint64 llc_prefetch_misses = 37;
inline bool PerfStatistics::has_llc_prefetch_misses() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void PerfStatistics::set_has_llc_prefetch_misses() {
  _has_bits_[1] |= 0x00000010u;
}
inline void PerfStatistics::clear_has_llc_prefetch_misses() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void PerfStatistics::clear_llc_prefetch_misses() {
  llc_prefetch_misses_ = GOOGLE_ULONGLONG(0);
  clear_has_llc_prefetch_misses();
}
inline ::google::protobuf::uint64 PerfStatistics::llc_prefetch_misses() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.llc_prefetch_misses)
  return llc_prefetch_misses_;
}
inline void PerfStatistics::set_llc_prefetch_misses(::google::protobuf::uint64 value) {
  set_has_llc_prefetch_misses();
  llc_prefetch_misses_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.llc_prefetch_misses)
}

// optional uint64 dtlb_loads = 38;
inline bool PerfStatistics::has_dtlb_loads() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void PerfStatistics::set_has_dtlb_loads() {
  _has_bits_[1] |= 0x00000020u;
}
inline void PerfStatistics::clear_has_dtlb_loads() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void PerfStatistics::clear_dtlb_loads() {
  dtlb_loads_ = GOOGLE_ULONGLONG(0);
  clear_has_dtlb_loads();
}
inline ::google::protobuf::uint64 PerfStatistics::dtlb_loads() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.dtlb_loads)
  return dtlb_loads_;
}
inline void PerfStatistics::set_dtlb_loads(::google::protobuf::uint64 value) {
  set_has_dtlb_loads();
  dtlb_loads_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.dtlb_loads)
}

// optional uint64 dtlb_load_misses = 39;
inline bool PerfStatistics::has_dtlb_load_misses() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void PerfStatistics::set_has_dtlb_load_misses() {
  _has_bits_[1] |= 0x00000040u;
}
inline void PerfStatistics::clear_has_dtlb_load_misses() {
  _has_bits_[1] &= ~0x00000040u;
}
inline void PerfStatistics::clear_dtlb_load_misses() {
  dtlb_load_misses_ = GOOGLE_ULONGLONG(0);
  clear_has_dtlb_load_misses();
}
inline ::google::protobuf::uint64 PerfStatistics::dtlb_load_misses() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.dtlb_load_misses)
  return dtlb_load_misses_;
}
inline void PerfStatistics::set_dtlb_load_misses(::google::protobuf::uint64 value) {
  set_has_dtlb_load_misses();
  dtlb_load_misses_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.dtlb_load_misses)
}

// optional uint64 dtlb_stores = 40;
inline bool PerfStatistics::has_dtlb_stores() const {
  return (_has_bits_[1] & 0x00000080u) != 0;
}
inline void PerfStatistics::set_has_dtlb_stores() {
  _has_bits_[1] |= 0x00000080u;
}
inline void PerfStatistics::clear_has_dtlb_stores() {
  _has_bits_[1] &= ~0x00000080u;
}
inline void PerfStatistics::clear_dtlb_stores() {
  dtlb_stores_ = GOOGLE_ULONGLONG(0);
  clear_has_dtlb_stores();
}
inline ::google::protobuf::uint64 PerfStatistics::dtlb_stores() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.dtlb_stores)
  return dtlb_stores_;
}
inline void PerfStatistics::set_dtlb_stores(::google::protobuf::uint64 value) {
  set_has_dtlb_stores();
  dtlb_stores_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.dtlb_stores)
}

// optional uint64 dtlb_store_misses = 41;
inline bool PerfStatistics::has_dtlb_store_misses() const {
  return (_has_bits_[1] & 0x00000100u) != 0;
}
inline void PerfStatistics::set_has_dtlb_store_misses() {
  _has_bits_[1] |= 0x00000100u;
}
inline void PerfStatistics::clear_has_dtlb_store_misses() {
  _has_bits_[1] &= ~0x00000100u;
}
inline void PerfStatistics::clear_dtlb_store_misses() {
  dtlb_store_misses_ = GOOGLE_ULONGLONG(0);
  clear_has_dtlb_store_misses();
}
inline ::google::protobuf::uint64 PerfStatistics::dtlb_store_misses() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.dtlb_store_misses)
  return dtlb_store_misses_;
}
inline void PerfStatistics::set_dtlb_store_misses(::google::protobuf::uint64 value) {
  set_has_dtlb_store_misses();
  dtlb_store_misses_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.dtlb_store_misses)
}

// optional uint64 dtlb_prefetches = 42;
inline bool PerfStatistics::has_dtlb_prefetches() const {
  return (_has_bits_[1] & 0x00000200u) != 0;
}
inline void PerfStatistics::set_has_dtlb_prefetches() {
  _has_bits_[1] |= 0x00000200u;
}
inline void PerfStatistics::clear_has_dtlb_prefetches() {
  _has_bits_[1] &= ~0x00000200u;
}
inline void PerfStatistics::clear_dtlb_prefetches() {
  dtlb_prefetches_ = GOOGLE_ULONGLONG(0);
  clear_has_dtlb_prefetches();
}
inline ::google::protobuf::uint64 PerfStatistics::dtlb_prefetches() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.dtlb_prefetches)
  return dtlb_prefetches_;
}
inline void PerfStatistics::set_dtlb_prefetches(::google::protobuf::uint64 value) {
  set_has_dtlb_prefetches();
  dtlb_prefetches_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.dtlb_prefetches)
}

// optional uint64 dtlb_prefetch_misses = 43;
inline bool PerfStatistics::has_dtlb_prefetch_misses() const {
  return (_has_bits_[1] & 0x00000400u) != 0;
}
inline void PerfStatistics::set_has_dtlb_prefetch_misses() {
  _has_bits_[1] |= 0x00000400u;
}
inline void PerfStatistics::clear_has_dtlb_prefetch_misses() {
  _has_bits_[1] &= ~0x00000400u;
}
inline void PerfStatistics::clear_dtlb_prefetch_misses() {
  dtlb_prefetch_misses_ = GOOGLE_ULONGLONG(0);
  clear_has_dtlb_prefetch_misses();
}
inline ::google::protobuf::uint64 PerfStatistics::dtlb_prefetch_misses() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.dtlb_prefetch_misses)
  return dtlb_prefetch_misses_;
}
inline void PerfStatistics::set_dtlb_prefetch_misses(::google::protobuf::uint64 value) {
  set_has_dtlb_prefetch_misses();
  dtlb_prefetch_misses_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.dtlb_prefetch_misses)
}

// optional uint64 itlb_loads = 44;
inline bool PerfStatistics::has_itlb_loads() const {
  return (_has_bits_[1] & 0x00000800u) != 0;
}
inline void PerfStatistics::set_has_itlb_loads() {
  _has_bits_[1] |= 0x00000800u;
}
inline void PerfStatistics::clear_has_itlb_loads() {
  _has_bits_[1] &= ~0x00000800u;
}
inline void PerfStatistics::clear_itlb_loads() {
  itlb_loads_ = GOOGLE_ULONGLONG(0);
  clear_has_itlb_loads();
}
inline ::google::protobuf::uint64 PerfStatistics::itlb_loads() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.itlb_loads)
  return itlb_loads_;
}
inline void PerfStatistics::set_itlb_loads(::google::protobuf::uint64 value) {
  set_has_itlb_loads();
  itlb_loads_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.itlb_loads)
}

// optional uint64 itlb_load_misses = 45;
inline bool PerfStatistics::has_itlb_load_misses() const {
  return (_has_bits_[1] & 0x00001000u) != 0;
}
inline void PerfStatistics::set_has_itlb_load_misses() {
  _has_bits_[1] |= 0x00001000u;
}
inline void PerfStatistics::clear_has_itlb_load_misses() {
  _has_bits_[1] &= ~0x00001000u;
}
inline void PerfStatistics::clear_itlb_load_misses() {
  itlb_load_misses_ = GOOGLE_ULONGLONG(0);
  clear_has_itlb_load_misses();
}
inline ::google::protobuf::uint64 PerfStatistics::itlb_load_misses() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.itlb_load_misses)
  return itlb_load_misses_;
}
inline void PerfStatistics::set_itlb_load_misses(::google::protobuf::uint64 value) {
  set_has_itlb_load_misses();
  itlb_load_misses_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.itlb_load_misses)
}

// optional uint64 branch_loads = 46;
inline bool PerfStatistics::has_branch_loads() const {
  return (_has_bits_[1] & 0x00002000u) != 0;
}
inline void PerfStatistics::set_has_branch_loads() {
  _has_bits_[1] |= 0x00002000u;
}
inline void PerfStatistics::clear_has_branch_loads() {
  _has_bits_[1] &= ~0x00002000u;
}
inline void PerfStatistics::clear_branch_loads() {
  branch_loads_ = GOOGLE_ULONGLONG(0);
  clear_has_branch_loads();
}
inline ::google::protobuf::uint64 PerfStatistics::branch_loads() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.branch_loads)
  return branch_loads_;
}
inline void PerfStatistics::set_branch_loads(::google::protobuf::uint64 value) {
  set_has_branch_loads();
  branch_loads_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.branch_loads)
}

// optional uint64 branch_load_misses = 47;
inline bool PerfStatistics::has_branch_load_misses() const {
  return (_has_bits_[1] & 0x00004000u) != 0;
}
inline void PerfStatistics::set_has_branch_load_misses() {
  _has_bits_[1] |= 0x00004000u;
}
inline void PerfStatistics::clear_has_branch_load_misses() {
  _has_bits_[1] &= ~0x00004000u;
}
inline void PerfStatistics::clear_branch_load_misses() {
  branch_load_misses_ = GOOGLE_ULONGLONG(0);
  clear_has_branch_load_misses();
}
inline ::google::protobuf::uint64 PerfStatistics::branch_load_misses() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.branch_load_misses)
  return branch_load_misses_;
}
inline void PerfStatistics::set_branch_load_misses(::google::protobuf::uint64 value) {
  set_has_branch_load_misses();
  branch_load_misses_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.branch_load_misses)
}

// optional uint64 node_loads = 48;
inline bool PerfStatistics::has_node_loads() const {
  return (_has_bits_[1] & 0x00008000u) != 0;
}
inline void PerfStatistics::set_has_node_loads() {
  _has_bits_[1] |= 0x00008000u;
}
inline void PerfStatistics::clear_has_node_loads() {
  _has_bits_[1] &= ~0x00008000u;
}
inline void PerfStatistics::clear_node_loads() {
  node_loads_ = GOOGLE_ULONGLONG(0);
  clear_has_node_loads();
}
inline ::google::protobuf::uint64 PerfStatistics::node_loads() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.node_loads)
  return node_loads_;
}
inline void PerfStatistics::set_node_loads(::google::protobuf::uint64 value) {
  set_has_node_loads();
  node_loads_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.node_loads)
}

// optional uint64 node_load_misses = 49;
inline bool PerfStatistics::has_node_load_misses() const {
  return (_has_bits_[1] & 0x00010000u) != 0;
}
inline void PerfStatistics::set_has_node_load_misses() {
  _has_bits_[1] |= 0x00010000u;
}
inline void PerfStatistics::clear_has_node_load_misses() {
  _has_bits_[1] &= ~0x00010000u;
}
inline void PerfStatistics::clear_node_load_misses() {
  node_load_misses_ = GOOGLE_ULONGLONG(0);
  clear_has_node_load_misses();
}
inline ::google::protobuf::uint64 PerfStatistics::node_load_misses() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.node_load_misses)
  return node_load_misses_;
}
inline void PerfStatistics::set_node_load_misses(::google::protobuf::uint64 value) {
  set_has_node_load_misses();
  node_load_misses_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.node_load_misses)
}

// optional uint64 node_stores = 50;
inline bool PerfStatistics::has_node_stores() const {
  return (_has_bits_[1] & 0x00020000u) != 0;
}
inline void PerfStatistics::set_has_node_stores() {
  _has_bits_[1] |= 0x00020000u;
}
inline void PerfStatistics::clear_has_node_stores() {
  _has_bits_[1] &= ~0x00020000u;
}
inline void PerfStatistics::clear_node_stores() {
  node_stores_ = GOOGLE_ULONGLONG(0);
  clear_has_node_stores();
}
inline ::google::protobuf::uint64 PerfStatistics::node_stores() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.node_stores)
  return node_stores_;
}
inline void PerfStatistics::set_node_stores(::google::protobuf::uint64 value) {
  set_has_node_stores();
  node_stores_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.node_stores)
}

// optional uint64 node_store_misses = 51;
inline bool PerfStatistics::has_node_store_misses() const {
  return (_has_bits_[1] & 0x00040000u) != 0;
}
inline void PerfStatistics::set_has_node_store_misses() {
  _has_bits_[1] |= 0x00040000u;
}
inline void PerfStatistics::clear_has_node_store_misses() {
  _has_bits_[1] &= ~0x00040000u;
}
inline void PerfStatistics::clear_node_store_misses() {
  node_store_misses_ = GOOGLE_ULONGLONG(0);
  clear_has_node_store_misses();
}
inline ::google::protobuf::uint64 PerfStatistics::node_store_misses() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.node_store_misses)
  return node_store_misses_;
}
inline void PerfStatistics::set_node_store_misses(::google::protobuf::uint64 value) {
  set_has_node_store_misses();
  node_store_misses_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.node_store_misses)
}

// optional uint64 node_prefetches = 52;
inline bool PerfStatistics::has_node_prefetches() const {
  return (_has_bits_[1] & 0x00080000u) != 0;
}
inline void PerfStatistics::set_has_node_prefetches() {
  _has_bits_[1] |= 0x00080000u;
}
inline void PerfStatistics::clear_has_node_prefetches() {
  _has_bits_[1] &= ~0x00080000u;
}
inline void PerfStatistics::clear_node_prefetches() {
  node_prefetches_ = GOOGLE_ULONGLONG(0);
  clear_has_node_prefetches();
}
inline ::google::protobuf::uint64 PerfStatistics::node_prefetches() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.node_prefetches)
  return node_prefetches_;
}
inline void PerfStatistics::set_node_prefetches(::google::protobuf::uint64 value) {
  set_has_node_prefetches();
  node_prefetches_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.node_prefetches)
}

// optional uint64 node_prefetch_misses = 53;
inline bool PerfStatistics::has_node_prefetch_misses() const {
  return (_has_bits_[1] & 0x00100000u) != 0;
}
inline void PerfStatistics::set_has_node_prefetch_misses() {
  _has_bits_[1] |= 0x00100000u;
}
inline void PerfStatistics::clear_has_node_prefetch_misses() {
  _has_bits_[1] &= ~0x00100000u;
}
inline void PerfStatistics::clear_node_prefetch_misses() {
  node_prefetch_misses_ = GOOGLE_ULONGLONG(0);
  clear_has_node_prefetch_misses();
}
inline ::google::protobuf::uint64 PerfStatistics::node_prefetch_misses() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.node_prefetch_misses)
  return node_prefetch_misses_;
}
inline void PerfStatistics::set_node_prefetch_misses(::google::protobuf::uint64 value) {
  set_has_node_prefetch_misses();
  node_prefetch_misses_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.node_prefetch_misses)
}

// -------------------------------------------------------------------

// Request

// optional .mesos.SlaveID slave_id = 1;
inline bool Request::has_slave_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Request::set_has_slave_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Request::clear_has_slave_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Request::clear_slave_id() {
  if (slave_id_ != NULL) slave_id_->Clear();
  clear_has_slave_id();
}
inline const ::mesos::SlaveID& Request::slave_id() const {
  const ::mesos::SlaveID* p = slave_id_;
  // @@protoc_insertion_point(field_get:mesos.Request.slave_id)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::SlaveID*>(
      &::mesos::_SlaveID_default_instance_);
}
inline ::mesos::SlaveID* Request::release_slave_id() {
  // @@protoc_insertion_point(field_release:mesos.Request.slave_id)
  clear_has_slave_id();
  ::mesos::SlaveID* temp = slave_id_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  slave_id_ = NULL;
  return temp;
}
inline ::mesos::SlaveID* Request::unsafe_arena_release_slave_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Request.slave_id)
  clear_has_slave_id();
  ::mesos::SlaveID* temp = slave_id_;
  slave_id_ = NULL;
  return temp;
}
inline ::mesos::SlaveID* Request::mutable_slave_id() {
  set_has_slave_id();
  if (slave_id_ == NULL) {
    _slow_mutable_slave_id();
  }
  // @@protoc_insertion_point(field_mutable:mesos.Request.slave_id)
  return slave_id_;
}
inline void Request::set_allocated_slave_id(::mesos::SlaveID* slave_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete slave_id_;
  }
  if (slave_id) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(slave_id);
    if (message_arena != submessage_arena) {
      slave_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, slave_id, submessage_arena);
    }
    set_has_slave_id();
  } else {
    clear_has_slave_id();
  }
  slave_id_ = slave_id;
  // @@protoc_insertion_point(field_set_allocated:mesos.Request.slave_id)
}

// repeated .mesos.Resource resources = 2;
inline int Request::resources_size() const {
  return resources_.size();
}
inline void Request::clear_resources() {
  resources_.Clear();
}
inline const ::mesos::Resource& Request::resources(int index) const {
  // @@protoc_insertion_point(field_get:mesos.Request.resources)
  return resources_.Get(index);
}
inline ::mesos::Resource* Request::mutable_resources(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.Request.resources)
  return resources_.Mutable(index);
}
inline ::mesos::Resource* Request::add_resources() {
  // @@protoc_insertion_point(field_add:mesos.Request.resources)
  return resources_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
Request::mutable_resources() {
  // @@protoc_insertion_point(field_mutable_list:mesos.Request.resources)
  return &resources_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
Request::resources() const {
  // @@protoc_insertion_point(field_list:mesos.Request.resources)
  return resources_;
}

// -------------------------------------------------------------------

// Offer_Operation_Launch

// repeated .mesos.TaskInfo task_infos = 1;
inline int Offer_Operation_Launch::task_infos_size() const {
  return task_infos_.size();
}
inline void Offer_Operation_Launch::clear_task_infos() {
  task_infos_.Clear();
}
inline const ::mesos::TaskInfo& Offer_Operation_Launch::task_infos(int index) const {
  // @@protoc_insertion_point(field_get:mesos.Offer.Operation.Launch.task_infos)
  return task_infos_.Get(index);
}
inline ::mesos::TaskInfo* Offer_Operation_Launch::mutable_task_infos(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.Offer.Operation.Launch.task_infos)
  return task_infos_.Mutable(index);
}
inline ::mesos::TaskInfo* Offer_Operation_Launch::add_task_infos() {
  // @@protoc_insertion_point(field_add:mesos.Offer.Operation.Launch.task_infos)
  return task_infos_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::TaskInfo >*
Offer_Operation_Launch::mutable_task_infos() {
  // @@protoc_insertion_point(field_mutable_list:mesos.Offer.Operation.Launch.task_infos)
  return &task_infos_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::TaskInfo >&
Offer_Operation_Launch::task_infos() const {
  // @@protoc_insertion_point(field_list:mesos.Offer.Operation.Launch.task_infos)
  return task_infos_;
}

// -------------------------------------------------------------------

// Offer_Operation_LaunchGroup

// required .mesos.ExecutorInfo executor = 1;
inline bool Offer_Operation_LaunchGroup::has_executor() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Offer_Operation_LaunchGroup::set_has_executor() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Offer_Operation_LaunchGroup::clear_has_executor() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Offer_Operation_LaunchGroup::clear_executor() {
  if (executor_ != NULL) executor_->Clear();
  clear_has_executor();
}
inline const ::mesos::ExecutorInfo& Offer_Operation_LaunchGroup::executor() const {
  const ::mesos::ExecutorInfo* p = executor_;
  // @@protoc_insertion_point(field_get:mesos.Offer.Operation.LaunchGroup.executor)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ExecutorInfo*>(
      &::mesos::_ExecutorInfo_default_instance_);
}
inline ::mesos::ExecutorInfo* Offer_Operation_LaunchGroup::release_executor() {
  // @@protoc_insertion_point(field_release:mesos.Offer.Operation.LaunchGroup.executor)
  clear_has_executor();
  ::mesos::ExecutorInfo* temp = executor_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  executor_ = NULL;
  return temp;
}
inline ::mesos::ExecutorInfo* Offer_Operation_LaunchGroup::unsafe_arena_release_executor() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Offer.Operation.LaunchGroup.executor)
  clear_has_executor();
  ::mesos::ExecutorInfo* temp = executor_;
  executor_ = NULL;
  return temp;
}
inline ::mesos::ExecutorInfo* Offer_Operation_LaunchGroup::mutable_executor() {
  set_has_executor();
  if (executor_ == NULL) {
    _slow_mutable_executor();
  }
  // @@protoc_insertion_point(field_mutable:mesos.Offer.Operation.LaunchGroup.executor)
  return executor_;
}
inline void Offer_Operation_LaunchGroup::set_allocated_executor(::mesos::ExecutorInfo* executor) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete executor_;
  }
  if (executor) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(executor);
    if (message_arena != submessage_arena) {
      executor = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, executor, submessage_arena);
    }
    set_has_executor();
  } else {
    clear_has_executor();
  }
  executor_ = executor;
  // @@protoc_insertion_point(field_set_allocated:mesos.Offer.Operation.LaunchGroup.executor)
}

// required .mesos.TaskGroupInfo task_group = 2;
inline bool Offer_Operation_LaunchGroup::has_task_group() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Offer_Operation_LaunchGroup::set_has_task_group() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Offer_Operation_LaunchGroup::clear_has_task_group() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Offer_Operation_LaunchGroup::clear_task_group() {
  if (task_group_ != NULL) task_group_->Clear();
  clear_has_task_group();
}
inline const ::mesos::TaskGroupInfo& Offer_Operation_LaunchGroup::task_group() const {
  const ::mesos::TaskGroupInfo* p = task_group_;
  // @@protoc_insertion_point(field_get:mesos.Offer.Operation.LaunchGroup.task_group)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::TaskGroupInfo*>(
      &::mesos::_TaskGroupInfo_default_instance_);
}
inline ::mesos::TaskGroupInfo* Offer_Operation_LaunchGroup::release_task_group() {
  // @@protoc_insertion_point(field_release:mesos.Offer.Operation.LaunchGroup.task_group)
  clear_has_task_group();
  ::mesos::TaskGroupInfo* temp = task_group_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  task_group_ = NULL;
  return temp;
}
inline ::mesos::TaskGroupInfo* Offer_Operation_LaunchGroup::unsafe_arena_release_task_group() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Offer.Operation.LaunchGroup.task_group)
  clear_has_task_group();
  ::mesos::TaskGroupInfo* temp = task_group_;
  task_group_ = NULL;
  return temp;
}
inline ::mesos::TaskGroupInfo* Offer_Operation_LaunchGroup::mutable_task_group() {
  set_has_task_group();
  if (task_group_ == NULL) {
    _slow_mutable_task_group();
  }
  // @@protoc_insertion_point(field_mutable:mesos.Offer.Operation.LaunchGroup.task_group)
  return task_group_;
}
inline void Offer_Operation_LaunchGroup::set_allocated_task_group(::mesos::TaskGroupInfo* task_group) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete task_group_;
  }
  if (task_group) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(task_group);
    if (message_arena != submessage_arena) {
      task_group = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, task_group, submessage_arena);
    }
    set_has_task_group();
  } else {
    clear_has_task_group();
  }
  task_group_ = task_group;
  // @@protoc_insertion_point(field_set_allocated:mesos.Offer.Operation.LaunchGroup.task_group)
}

// -------------------------------------------------------------------

// Offer_Operation_Reserve

// repeated .mesos.Resource resources = 1;
inline int Offer_Operation_Reserve::resources_size() const {
  return resources_.size();
}
inline void Offer_Operation_Reserve::clear_resources() {
  resources_.Clear();
}
inline const ::mesos::Resource& Offer_Operation_Reserve::resources(int index) const {
  // @@protoc_insertion_point(field_get:mesos.Offer.Operation.Reserve.resources)
  return resources_.Get(index);
}
inline ::mesos::Resource* Offer_Operation_Reserve::mutable_resources(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.Offer.Operation.Reserve.resources)
  return resources_.Mutable(index);
}
inline ::mesos::Resource* Offer_Operation_Reserve::add_resources() {
  // @@protoc_insertion_point(field_add:mesos.Offer.Operation.Reserve.resources)
  return resources_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
Offer_Operation_Reserve::mutable_resources() {
  // @@protoc_insertion_point(field_mutable_list:mesos.Offer.Operation.Reserve.resources)
  return &resources_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
Offer_Operation_Reserve::resources() const {
  // @@protoc_insertion_point(field_list:mesos.Offer.Operation.Reserve.resources)
  return resources_;
}

// -------------------------------------------------------------------

// Offer_Operation_Unreserve

// repeated .mesos.Resource resources = 1;
inline int Offer_Operation_Unreserve::resources_size() const {
  return resources_.size();
}
inline void Offer_Operation_Unreserve::clear_resources() {
  resources_.Clear();
}
inline const ::mesos::Resource& Offer_Operation_Unreserve::resources(int index) const {
  // @@protoc_insertion_point(field_get:mesos.Offer.Operation.Unreserve.resources)
  return resources_.Get(index);
}
inline ::mesos::Resource* Offer_Operation_Unreserve::mutable_resources(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.Offer.Operation.Unreserve.resources)
  return resources_.Mutable(index);
}
inline ::mesos::Resource* Offer_Operation_Unreserve::add_resources() {
  // @@protoc_insertion_point(field_add:mesos.Offer.Operation.Unreserve.resources)
  return resources_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
Offer_Operation_Unreserve::mutable_resources() {
  // @@protoc_insertion_point(field_mutable_list:mesos.Offer.Operation.Unreserve.resources)
  return &resources_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
Offer_Operation_Unreserve::resources() const {
  // @@protoc_insertion_point(field_list:mesos.Offer.Operation.Unreserve.resources)
  return resources_;
}

// -------------------------------------------------------------------

// Offer_Operation_Create

// repeated .mesos.Resource volumes = 1;
inline int Offer_Operation_Create::volumes_size() const {
  return volumes_.size();
}
inline void Offer_Operation_Create::clear_volumes() {
  volumes_.Clear();
}
inline const ::mesos::Resource& Offer_Operation_Create::volumes(int index) const {
  // @@protoc_insertion_point(field_get:mesos.Offer.Operation.Create.volumes)
  return volumes_.Get(index);
}
inline ::mesos::Resource* Offer_Operation_Create::mutable_volumes(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.Offer.Operation.Create.volumes)
  return volumes_.Mutable(index);
}
inline ::mesos::Resource* Offer_Operation_Create::add_volumes() {
  // @@protoc_insertion_point(field_add:mesos.Offer.Operation.Create.volumes)
  return volumes_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
Offer_Operation_Create::mutable_volumes() {
  // @@protoc_insertion_point(field_mutable_list:mesos.Offer.Operation.Create.volumes)
  return &volumes_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
Offer_Operation_Create::volumes() const {
  // @@protoc_insertion_point(field_list:mesos.Offer.Operation.Create.volumes)
  return volumes_;
}

// -------------------------------------------------------------------

// Offer_Operation_Destroy

// repeated .mesos.Resource volumes = 1;
inline int Offer_Operation_Destroy::volumes_size() const {
  return volumes_.size();
}
inline void Offer_Operation_Destroy::clear_volumes() {
  volumes_.Clear();
}
inline const ::mesos::Resource& Offer_Operation_Destroy::volumes(int index) const {
  // @@protoc_insertion_point(field_get:mesos.Offer.Operation.Destroy.volumes)
  return volumes_.Get(index);
}
inline ::mesos::Resource* Offer_Operation_Destroy::mutable_volumes(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.Offer.Operation.Destroy.volumes)
  return volumes_.Mutable(index);
}
inline ::mesos::Resource* Offer_Operation_Destroy::add_volumes() {
  // @@protoc_insertion_point(field_add:mesos.Offer.Operation.Destroy.volumes)
  return volumes_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
Offer_Operation_Destroy::mutable_volumes() {
  // @@protoc_insertion_point(field_mutable_list:mesos.Offer.Operation.Destroy.volumes)
  return &volumes_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
Offer_Operation_Destroy::volumes() const {
  // @@protoc_insertion_point(field_list:mesos.Offer.Operation.Destroy.volumes)
  return volumes_;
}

// -------------------------------------------------------------------

// Offer_Operation_GrowVolume

// required .mesos.Resource volume = 1;
inline bool Offer_Operation_GrowVolume::has_volume() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Offer_Operation_GrowVolume::set_has_volume() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Offer_Operation_GrowVolume::clear_has_volume() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Offer_Operation_GrowVolume::clear_volume() {
  if (volume_ != NULL) volume_->Clear();
  clear_has_volume();
}
inline const ::mesos::Resource& Offer_Operation_GrowVolume::volume() const {
  const ::mesos::Resource* p = volume_;
  // @@protoc_insertion_point(field_get:mesos.Offer.Operation.GrowVolume.volume)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::Resource*>(
      &::mesos::_Resource_default_instance_);
}
inline ::mesos::Resource* Offer_Operation_GrowVolume::release_volume() {
  // @@protoc_insertion_point(field_release:mesos.Offer.Operation.GrowVolume.volume)
  clear_has_volume();
  ::mesos::Resource* temp = volume_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  volume_ = NULL;
  return temp;
}
inline ::mesos::Resource* Offer_Operation_GrowVolume::unsafe_arena_release_volume() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Offer.Operation.GrowVolume.volume)
  clear_has_volume();
  ::mesos::Resource* temp = volume_;
  volume_ = NULL;
  return temp;
}
inline ::mesos::Resource* Offer_Operation_GrowVolume::mutable_volume() {
  set_has_volume();
  if (volume_ == NULL) {
    _slow_mutable_volume();
  }
  // @@protoc_insertion_point(field_mutable:mesos.Offer.Operation.GrowVolume.volume)
  return volume_;
}
inline void Offer_Operation_GrowVolume::set_allocated_volume(::mesos::Resource* volume) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete volume_;
  }
  if (volume) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(volume);
    if (message_arena != submessage_arena) {
      volume = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, volume, submessage_arena);
    }
    set_has_volume();
  } else {
    clear_has_volume();
  }
  volume_ = volume;
  // @@protoc_insertion_point(field_set_allocated:mesos.Offer.Operation.GrowVolume.volume)
}

// required .mesos.Resource addition = 2;
inline bool Offer_Operation_GrowVolume::has_addition() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Offer_Operation_GrowVolume::set_has_addition() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Offer_Operation_GrowVolume::clear_has_addition() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Offer_Operation_GrowVolume::clear_addition() {
  if (addition_ != NULL) addition_->Clear();
  clear_has_addition();
}
inline const ::mesos::Resource& Offer_Operation_GrowVolume::addition() const {
  const ::mesos::Resource* p = addition_;
  // @@protoc_insertion_point(field_get:mesos.Offer.Operation.GrowVolume.addition)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::Resource*>(
      &::mesos::_Resource_default_instance_);
}
inline ::mesos::Resource* Offer_Operation_GrowVolume::release_addition() {
  // @@protoc_insertion_point(field_release:mesos.Offer.Operation.GrowVolume.addition)
  clear_has_addition();
  ::mesos::Resource* temp = addition_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  addition_ = NULL;
  return temp;
}
inline ::mesos::Resource* Offer_Operation_GrowVolume::unsafe_arena_release_addition() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Offer.Operation.GrowVolume.addition)
  clear_has_addition();
  ::mesos::Resource* temp = addition_;
  addition_ = NULL;
  return temp;
}
inline ::mesos::Resource* Offer_Operation_GrowVolume::mutable_addition() {
  set_has_addition();
  if (addition_ == NULL) {
    _slow_mutable_addition();
  }
  // @@protoc_insertion_point(field_mutable:mesos.Offer.Operation.GrowVolume.addition)
  return addition_;
}
inline void Offer_Operation_GrowVolume::set_allocated_addition(::mesos::Resource* addition) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete addition_;
  }
  if (addition) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(addition);
    if (message_arena != submessage_arena) {
      addition = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, addition, submessage_arena);
    }
    set_has_addition();
  } else {
    clear_has_addition();
  }
  addition_ = addition;
  // @@protoc_insertion_point(field_set_allocated:mesos.Offer.Operation.GrowVolume.addition)
}

// -------------------------------------------------------------------

// Offer_Operation_ShrinkVolume

// required .mesos.Resource volume = 1;
inline bool Offer_Operation_ShrinkVolume::has_volume() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Offer_Operation_ShrinkVolume::set_has_volume() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Offer_Operation_ShrinkVolume::clear_has_volume() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Offer_Operation_ShrinkVolume::clear_volume() {
  if (volume_ != NULL) volume_->Clear();
  clear_has_volume();
}
inline const ::mesos::Resource& Offer_Operation_ShrinkVolume::volume() const {
  const ::mesos::Resource* p = volume_;
  // @@protoc_insertion_point(field_get:mesos.Offer.Operation.ShrinkVolume.volume)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::Resource*>(
      &::mesos::_Resource_default_instance_);
}
inline ::mesos::Resource* Offer_Operation_ShrinkVolume::release_volume() {
  // @@protoc_insertion_point(field_release:mesos.Offer.Operation.ShrinkVolume.volume)
  clear_has_volume();
  ::mesos::Resource* temp = volume_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  volume_ = NULL;
  return temp;
}
inline ::mesos::Resource* Offer_Operation_ShrinkVolume::unsafe_arena_release_volume() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Offer.Operation.ShrinkVolume.volume)
  clear_has_volume();
  ::mesos::Resource* temp = volume_;
  volume_ = NULL;
  return temp;
}
inline ::mesos::Resource* Offer_Operation_ShrinkVolume::mutable_volume() {
  set_has_volume();
  if (volume_ == NULL) {
    _slow_mutable_volume();
  }
  // @@protoc_insertion_point(field_mutable:mesos.Offer.Operation.ShrinkVolume.volume)
  return volume_;
}
inline void Offer_Operation_ShrinkVolume::set_allocated_volume(::mesos::Resource* volume) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete volume_;
  }
  if (volume) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(volume);
    if (message_arena != submessage_arena) {
      volume = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, volume, submessage_arena);
    }
    set_has_volume();
  } else {
    clear_has_volume();
  }
  volume_ = volume;
  // @@protoc_insertion_point(field_set_allocated:mesos.Offer.Operation.ShrinkVolume.volume)
}

// required .mesos.Value.Scalar subtract = 2;
inline bool Offer_Operation_ShrinkVolume::has_subtract() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Offer_Operation_ShrinkVolume::set_has_subtract() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Offer_Operation_ShrinkVolume::clear_has_subtract() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Offer_Operation_ShrinkVolume::clear_subtract() {
  if (subtract_ != NULL) subtract_->Clear();
  clear_has_subtract();
}
inline const ::mesos::Value_Scalar& Offer_Operation_ShrinkVolume::subtract() const {
  const ::mesos::Value_Scalar* p = subtract_;
  // @@protoc_insertion_point(field_get:mesos.Offer.Operation.ShrinkVolume.subtract)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::Value_Scalar*>(
      &::mesos::_Value_Scalar_default_instance_);
}
inline ::mesos::Value_Scalar* Offer_Operation_ShrinkVolume::release_subtract() {
  // @@protoc_insertion_point(field_release:mesos.Offer.Operation.ShrinkVolume.subtract)
  clear_has_subtract();
  ::mesos::Value_Scalar* temp = subtract_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  subtract_ = NULL;
  return temp;
}
inline ::mesos::Value_Scalar* Offer_Operation_ShrinkVolume::unsafe_arena_release_subtract() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Offer.Operation.ShrinkVolume.subtract)
  clear_has_subtract();
  ::mesos::Value_Scalar* temp = subtract_;
  subtract_ = NULL;
  return temp;
}
inline ::mesos::Value_Scalar* Offer_Operation_ShrinkVolume::mutable_subtract() {
  set_has_subtract();
  if (subtract_ == NULL) {
    _slow_mutable_subtract();
  }
  // @@protoc_insertion_point(field_mutable:mesos.Offer.Operation.ShrinkVolume.subtract)
  return subtract_;
}
inline void Offer_Operation_ShrinkVolume::set_allocated_subtract(::mesos::Value_Scalar* subtract) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete subtract_;
  }
  if (subtract) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(subtract);
    if (message_arena != submessage_arena) {
      subtract = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, subtract, submessage_arena);
    }
    set_has_subtract();
  } else {
    clear_has_subtract();
  }
  subtract_ = subtract;
  // @@protoc_insertion_point(field_set_allocated:mesos.Offer.Operation.ShrinkVolume.subtract)
}

// -------------------------------------------------------------------

// Offer_Operation_CreateVolume

// required .mesos.Resource source = 1;
inline bool Offer_Operation_CreateVolume::has_source() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Offer_Operation_CreateVolume::set_has_source() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Offer_Operation_CreateVolume::clear_has_source() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Offer_Operation_CreateVolume::clear_source() {
  if (source_ != NULL) source_->Clear();
  clear_has_source();
}
inline const ::mesos::Resource& Offer_Operation_CreateVolume::source() const {
  const ::mesos::Resource* p = source_;
  // @@protoc_insertion_point(field_get:mesos.Offer.Operation.CreateVolume.source)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::Resource*>(
      &::mesos::_Resource_default_instance_);
}
inline ::mesos::Resource* Offer_Operation_CreateVolume::release_source() {
  // @@protoc_insertion_point(field_release:mesos.Offer.Operation.CreateVolume.source)
  clear_has_source();
  ::mesos::Resource* temp = source_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  source_ = NULL;
  return temp;
}
inline ::mesos::Resource* Offer_Operation_CreateVolume::unsafe_arena_release_source() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Offer.Operation.CreateVolume.source)
  clear_has_source();
  ::mesos::Resource* temp = source_;
  source_ = NULL;
  return temp;
}
inline ::mesos::Resource* Offer_Operation_CreateVolume::mutable_source() {
  set_has_source();
  if (source_ == NULL) {
    _slow_mutable_source();
  }
  // @@protoc_insertion_point(field_mutable:mesos.Offer.Operation.CreateVolume.source)
  return source_;
}
inline void Offer_Operation_CreateVolume::set_allocated_source(::mesos::Resource* source) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete source_;
  }
  if (source) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(source);
    if (message_arena != submessage_arena) {
      source = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, source, submessage_arena);
    }
    set_has_source();
  } else {
    clear_has_source();
  }
  source_ = source;
  // @@protoc_insertion_point(field_set_allocated:mesos.Offer.Operation.CreateVolume.source)
}

// required .mesos.Resource.DiskInfo.Source.Type target_type = 2;
inline bool Offer_Operation_CreateVolume::has_target_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Offer_Operation_CreateVolume::set_has_target_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Offer_Operation_CreateVolume::clear_has_target_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Offer_Operation_CreateVolume::clear_target_type() {
  target_type_ = 0;
  clear_has_target_type();
}
inline ::mesos::Resource_DiskInfo_Source_Type Offer_Operation_CreateVolume::target_type() const {
  // @@protoc_insertion_point(field_get:mesos.Offer.Operation.CreateVolume.target_type)
  return static_cast< ::mesos::Resource_DiskInfo_Source_Type >(target_type_);
}
inline void Offer_Operation_CreateVolume::set_target_type(::mesos::Resource_DiskInfo_Source_Type value) {
  assert(::mesos::Resource_DiskInfo_Source_Type_IsValid(value));
  set_has_target_type();
  target_type_ = value;
  // @@protoc_insertion_point(field_set:mesos.Offer.Operation.CreateVolume.target_type)
}

// -------------------------------------------------------------------

// Offer_Operation_DestroyVolume

// required .mesos.Resource volume = 1;
inline bool Offer_Operation_DestroyVolume::has_volume() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Offer_Operation_DestroyVolume::set_has_volume() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Offer_Operation_DestroyVolume::clear_has_volume() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Offer_Operation_DestroyVolume::clear_volume() {
  if (volume_ != NULL) volume_->Clear();
  clear_has_volume();
}
inline const ::mesos::Resource& Offer_Operation_DestroyVolume::volume() const {
  const ::mesos::Resource* p = volume_;
  // @@protoc_insertion_point(field_get:mesos.Offer.Operation.DestroyVolume.volume)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::Resource*>(
      &::mesos::_Resource_default_instance_);
}
inline ::mesos::Resource* Offer_Operation_DestroyVolume::release_volume() {
  // @@protoc_insertion_point(field_release:mesos.Offer.Operation.DestroyVolume.volume)
  clear_has_volume();
  ::mesos::Resource* temp = volume_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  volume_ = NULL;
  return temp;
}
inline ::mesos::Resource* Offer_Operation_DestroyVolume::unsafe_arena_release_volume() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Offer.Operation.DestroyVolume.volume)
  clear_has_volume();
  ::mesos::Resource* temp = volume_;
  volume_ = NULL;
  return temp;
}
inline ::mesos::Resource* Offer_Operation_DestroyVolume::mutable_volume() {
  set_has_volume();
  if (volume_ == NULL) {
    _slow_mutable_volume();
  }
  // @@protoc_insertion_point(field_mutable:mesos.Offer.Operation.DestroyVolume.volume)
  return volume_;
}
inline void Offer_Operation_DestroyVolume::set_allocated_volume(::mesos::Resource* volume) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete volume_;
  }
  if (volume) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(volume);
    if (message_arena != submessage_arena) {
      volume = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, volume, submessage_arena);
    }
    set_has_volume();
  } else {
    clear_has_volume();
  }
  volume_ = volume;
  // @@protoc_insertion_point(field_set_allocated:mesos.Offer.Operation.DestroyVolume.volume)
}

// -------------------------------------------------------------------

// Offer_Operation_CreateBlock

// required .mesos.Resource source = 1;
inline bool Offer_Operation_CreateBlock::has_source() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Offer_Operation_CreateBlock::set_has_source() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Offer_Operation_CreateBlock::clear_has_source() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Offer_Operation_CreateBlock::clear_source() {
  if (source_ != NULL) source_->Clear();
  clear_has_source();
}
inline const ::mesos::Resource& Offer_Operation_CreateBlock::source() const {
  const ::mesos::Resource* p = source_;
  // @@protoc_insertion_point(field_get:mesos.Offer.Operation.CreateBlock.source)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::Resource*>(
      &::mesos::_Resource_default_instance_);
}
inline ::mesos::Resource* Offer_Operation_CreateBlock::release_source() {
  // @@protoc_insertion_point(field_release:mesos.Offer.Operation.CreateBlock.source)
  clear_has_source();
  ::mesos::Resource* temp = source_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  source_ = NULL;
  return temp;
}
inline ::mesos::Resource* Offer_Operation_CreateBlock::unsafe_arena_release_source() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Offer.Operation.CreateBlock.source)
  clear_has_source();
  ::mesos::Resource* temp = source_;
  source_ = NULL;
  return temp;
}
inline ::mesos::Resource* Offer_Operation_CreateBlock::mutable_source() {
  set_has_source();
  if (source_ == NULL) {
    _slow_mutable_source();
  }
  // @@protoc_insertion_point(field_mutable:mesos.Offer.Operation.CreateBlock.source)
  return source_;
}
inline void Offer_Operation_CreateBlock::set_allocated_source(::mesos::Resource* source) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete source_;
  }
  if (source) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(source);
    if (message_arena != submessage_arena) {
      source = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, source, submessage_arena);
    }
    set_has_source();
  } else {
    clear_has_source();
  }
  source_ = source;
  // @@protoc_insertion_point(field_set_allocated:mesos.Offer.Operation.CreateBlock.source)
}

// -------------------------------------------------------------------

// Offer_Operation_DestroyBlock

// required .mesos.Resource block = 1;
inline bool Offer_Operation_DestroyBlock::has_block() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Offer_Operation_DestroyBlock::set_has_block() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Offer_Operation_DestroyBlock::clear_has_block() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Offer_Operation_DestroyBlock::clear_block() {
  if (block_ != NULL) block_->Clear();
  clear_has_block();
}
inline const ::mesos::Resource& Offer_Operation_DestroyBlock::block() const {
  const ::mesos::Resource* p = block_;
  // @@protoc_insertion_point(field_get:mesos.Offer.Operation.DestroyBlock.block)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::Resource*>(
      &::mesos::_Resource_default_instance_);
}
inline ::mesos::Resource* Offer_Operation_DestroyBlock::release_block() {
  // @@protoc_insertion_point(field_release:mesos.Offer.Operation.DestroyBlock.block)
  clear_has_block();
  ::mesos::Resource* temp = block_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  block_ = NULL;
  return temp;
}
inline ::mesos::Resource* Offer_Operation_DestroyBlock::unsafe_arena_release_block() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Offer.Operation.DestroyBlock.block)
  clear_has_block();
  ::mesos::Resource* temp = block_;
  block_ = NULL;
  return temp;
}
inline ::mesos::Resource* Offer_Operation_DestroyBlock::mutable_block() {
  set_has_block();
  if (block_ == NULL) {
    _slow_mutable_block();
  }
  // @@protoc_insertion_point(field_mutable:mesos.Offer.Operation.DestroyBlock.block)
  return block_;
}
inline void Offer_Operation_DestroyBlock::set_allocated_block(::mesos::Resource* block) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete block_;
  }
  if (block) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(block);
    if (message_arena != submessage_arena) {
      block = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, block, submessage_arena);
    }
    set_has_block();
  } else {
    clear_has_block();
  }
  block_ = block;
  // @@protoc_insertion_point(field_set_allocated:mesos.Offer.Operation.DestroyBlock.block)
}

// -------------------------------------------------------------------

// Offer_Operation

// optional .mesos.Offer.Operation.Type type = 1;
inline bool Offer_Operation::has_type() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Offer_Operation::set_has_type() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Offer_Operation::clear_has_type() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Offer_Operation::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::mesos::Offer_Operation_Type Offer_Operation::type() const {
  // @@protoc_insertion_point(field_get:mesos.Offer.Operation.type)
  return static_cast< ::mesos::Offer_Operation_Type >(type_);
}
inline void Offer_Operation::set_type(::mesos::Offer_Operation_Type value) {
  assert(::mesos::Offer_Operation_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:mesos.Offer.Operation.type)
}

// optional .mesos.OperationID id = 12;
inline bool Offer_Operation::has_id() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Offer_Operation::set_has_id() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Offer_Operation::clear_has_id() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Offer_Operation::clear_id() {
  if (id_ != NULL) id_->Clear();
  clear_has_id();
}
inline const ::mesos::OperationID& Offer_Operation::id() const {
  const ::mesos::OperationID* p = id_;
  // @@protoc_insertion_point(field_get:mesos.Offer.Operation.id)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::OperationID*>(
      &::mesos::_OperationID_default_instance_);
}
inline ::mesos::OperationID* Offer_Operation::release_id() {
  // @@protoc_insertion_point(field_release:mesos.Offer.Operation.id)
  clear_has_id();
  ::mesos::OperationID* temp = id_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  id_ = NULL;
  return temp;
}
inline ::mesos::OperationID* Offer_Operation::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Offer.Operation.id)
  clear_has_id();
  ::mesos::OperationID* temp = id_;
  id_ = NULL;
  return temp;
}
inline ::mesos::OperationID* Offer_Operation::mutable_id() {
  set_has_id();
  if (id_ == NULL) {
    _slow_mutable_id();
  }
  // @@protoc_insertion_point(field_mutable:mesos.Offer.Operation.id)
  return id_;
}
inline void Offer_Operation::set_allocated_id(::mesos::OperationID* id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete id_;
  }
  if (id) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(id);
    if (message_arena != submessage_arena) {
      id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    set_has_id();
  } else {
    clear_has_id();
  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:mesos.Offer.Operation.id)
}

// optional .mesos.Offer.Operation.Launch launch = 2;
inline bool Offer_Operation::has_launch() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Offer_Operation::set_has_launch() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Offer_Operation::clear_has_launch() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Offer_Operation::clear_launch() {
  if (launch_ != NULL) launch_->Clear();
  clear_has_launch();
}
inline const ::mesos::Offer_Operation_Launch& Offer_Operation::launch() const {
  const ::mesos::Offer_Operation_Launch* p = launch_;
  // @@protoc_insertion_point(field_get:mesos.Offer.Operation.launch)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::Offer_Operation_Launch*>(
      &::mesos::_Offer_Operation_Launch_default_instance_);
}
inline ::mesos::Offer_Operation_Launch* Offer_Operation::release_launch() {
  // @@protoc_insertion_point(field_release:mesos.Offer.Operation.launch)
  clear_has_launch();
  ::mesos::Offer_Operation_Launch* temp = launch_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  launch_ = NULL;
  return temp;
}
inline ::mesos::Offer_Operation_Launch* Offer_Operation::unsafe_arena_release_launch() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Offer.Operation.launch)
  clear_has_launch();
  ::mesos::Offer_Operation_Launch* temp = launch_;
  launch_ = NULL;
  return temp;
}
inline ::mesos::Offer_Operation_Launch* Offer_Operation::mutable_launch() {
  set_has_launch();
  if (launch_ == NULL) {
    _slow_mutable_launch();
  }
  // @@protoc_insertion_point(field_mutable:mesos.Offer.Operation.launch)
  return launch_;
}
inline void Offer_Operation::set_allocated_launch(::mesos::Offer_Operation_Launch* launch) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete launch_;
  }
  if (launch) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(launch);
    if (message_arena != submessage_arena) {
      launch = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, launch, submessage_arena);
    }
    set_has_launch();
  } else {
    clear_has_launch();
  }
  launch_ = launch;
  // @@protoc_insertion_point(field_set_allocated:mesos.Offer.Operation.launch)
}

// optional .mesos.Offer.Operation.LaunchGroup launch_group = 7;
inline bool Offer_Operation::has_launch_group() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Offer_Operation::set_has_launch_group() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Offer_Operation::clear_has_launch_group() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Offer_Operation::clear_launch_group() {
  if (launch_group_ != NULL) launch_group_->Clear();
  clear_has_launch_group();
}
inline const ::mesos::Offer_Operation_LaunchGroup& Offer_Operation::launch_group() const {
  const ::mesos::Offer_Operation_LaunchGroup* p = launch_group_;
  // @@protoc_insertion_point(field_get:mesos.Offer.Operation.launch_group)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::Offer_Operation_LaunchGroup*>(
      &::mesos::_Offer_Operation_LaunchGroup_default_instance_);
}
inline ::mesos::Offer_Operation_LaunchGroup* Offer_Operation::release_launch_group() {
  // @@protoc_insertion_point(field_release:mesos.Offer.Operation.launch_group)
  clear_has_launch_group();
  ::mesos::Offer_Operation_LaunchGroup* temp = launch_group_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  launch_group_ = NULL;
  return temp;
}
inline ::mesos::Offer_Operation_LaunchGroup* Offer_Operation::unsafe_arena_release_launch_group() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Offer.Operation.launch_group)
  clear_has_launch_group();
  ::mesos::Offer_Operation_LaunchGroup* temp = launch_group_;
  launch_group_ = NULL;
  return temp;
}
inline ::mesos::Offer_Operation_LaunchGroup* Offer_Operation::mutable_launch_group() {
  set_has_launch_group();
  if (launch_group_ == NULL) {
    _slow_mutable_launch_group();
  }
  // @@protoc_insertion_point(field_mutable:mesos.Offer.Operation.launch_group)
  return launch_group_;
}
inline void Offer_Operation::set_allocated_launch_group(::mesos::Offer_Operation_LaunchGroup* launch_group) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete launch_group_;
  }
  if (launch_group) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(launch_group);
    if (message_arena != submessage_arena) {
      launch_group = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, launch_group, submessage_arena);
    }
    set_has_launch_group();
  } else {
    clear_has_launch_group();
  }
  launch_group_ = launch_group;
  // @@protoc_insertion_point(field_set_allocated:mesos.Offer.Operation.launch_group)
}

// optional .mesos.Offer.Operation.Reserve reserve = 3;
inline bool Offer_Operation::has_reserve() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Offer_Operation::set_has_reserve() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Offer_Operation::clear_has_reserve() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Offer_Operation::clear_reserve() {
  if (reserve_ != NULL) reserve_->Clear();
  clear_has_reserve();
}
inline const ::mesos::Offer_Operation_Reserve& Offer_Operation::reserve() const {
  const ::mesos::Offer_Operation_Reserve* p = reserve_;
  // @@protoc_insertion_point(field_get:mesos.Offer.Operation.reserve)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::Offer_Operation_Reserve*>(
      &::mesos::_Offer_Operation_Reserve_default_instance_);
}
inline ::mesos::Offer_Operation_Reserve* Offer_Operation::release_reserve() {
  // @@protoc_insertion_point(field_release:mesos.Offer.Operation.reserve)
  clear_has_reserve();
  ::mesos::Offer_Operation_Reserve* temp = reserve_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  reserve_ = NULL;
  return temp;
}
inline ::mesos::Offer_Operation_Reserve* Offer_Operation::unsafe_arena_release_reserve() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Offer.Operation.reserve)
  clear_has_reserve();
  ::mesos::Offer_Operation_Reserve* temp = reserve_;
  reserve_ = NULL;
  return temp;
}
inline ::mesos::Offer_Operation_Reserve* Offer_Operation::mutable_reserve() {
  set_has_reserve();
  if (reserve_ == NULL) {
    _slow_mutable_reserve();
  }
  // @@protoc_insertion_point(field_mutable:mesos.Offer.Operation.reserve)
  return reserve_;
}
inline void Offer_Operation::set_allocated_reserve(::mesos::Offer_Operation_Reserve* reserve) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reserve_;
  }
  if (reserve) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(reserve);
    if (message_arena != submessage_arena) {
      reserve = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, reserve, submessage_arena);
    }
    set_has_reserve();
  } else {
    clear_has_reserve();
  }
  reserve_ = reserve;
  // @@protoc_insertion_point(field_set_allocated:mesos.Offer.Operation.reserve)
}

// optional .mesos.Offer.Operation.Unreserve unreserve = 4;
inline bool Offer_Operation::has_unreserve() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Offer_Operation::set_has_unreserve() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Offer_Operation::clear_has_unreserve() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Offer_Operation::clear_unreserve() {
  if (unreserve_ != NULL) unreserve_->Clear();
  clear_has_unreserve();
}
inline const ::mesos::Offer_Operation_Unreserve& Offer_Operation::unreserve() const {
  const ::mesos::Offer_Operation_Unreserve* p = unreserve_;
  // @@protoc_insertion_point(field_get:mesos.Offer.Operation.unreserve)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::Offer_Operation_Unreserve*>(
      &::mesos::_Offer_Operation_Unreserve_default_instance_);
}
inline ::mesos::Offer_Operation_Unreserve* Offer_Operation::release_unreserve() {
  // @@protoc_insertion_point(field_release:mesos.Offer.Operation.unreserve)
  clear_has_unreserve();
  ::mesos::Offer_Operation_Unreserve* temp = unreserve_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  unreserve_ = NULL;
  return temp;
}
inline ::mesos::Offer_Operation_Unreserve* Offer_Operation::unsafe_arena_release_unreserve() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Offer.Operation.unreserve)
  clear_has_unreserve();
  ::mesos::Offer_Operation_Unreserve* temp = unreserve_;
  unreserve_ = NULL;
  return temp;
}
inline ::mesos::Offer_Operation_Unreserve* Offer_Operation::mutable_unreserve() {
  set_has_unreserve();
  if (unreserve_ == NULL) {
    _slow_mutable_unreserve();
  }
  // @@protoc_insertion_point(field_mutable:mesos.Offer.Operation.unreserve)
  return unreserve_;
}
inline void Offer_Operation::set_allocated_unreserve(::mesos::Offer_Operation_Unreserve* unreserve) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete unreserve_;
  }
  if (unreserve) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(unreserve);
    if (message_arena != submessage_arena) {
      unreserve = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, unreserve, submessage_arena);
    }
    set_has_unreserve();
  } else {
    clear_has_unreserve();
  }
  unreserve_ = unreserve;
  // @@protoc_insertion_point(field_set_allocated:mesos.Offer.Operation.unreserve)
}

// optional .mesos.Offer.Operation.Create create = 5;
inline bool Offer_Operation::has_create() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Offer_Operation::set_has_create() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Offer_Operation::clear_has_create() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Offer_Operation::clear_create() {
  if (create_ != NULL) create_->Clear();
  clear_has_create();
}
inline const ::mesos::Offer_Operation_Create& Offer_Operation::create() const {
  const ::mesos::Offer_Operation_Create* p = create_;
  // @@protoc_insertion_point(field_get:mesos.Offer.Operation.create)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::Offer_Operation_Create*>(
      &::mesos::_Offer_Operation_Create_default_instance_);
}
inline ::mesos::Offer_Operation_Create* Offer_Operation::release_create() {
  // @@protoc_insertion_point(field_release:mesos.Offer.Operation.create)
  clear_has_create();
  ::mesos::Offer_Operation_Create* temp = create_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  create_ = NULL;
  return temp;
}
inline ::mesos::Offer_Operation_Create* Offer_Operation::unsafe_arena_release_create() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Offer.Operation.create)
  clear_has_create();
  ::mesos::Offer_Operation_Create* temp = create_;
  create_ = NULL;
  return temp;
}
inline ::mesos::Offer_Operation_Create* Offer_Operation::mutable_create() {
  set_has_create();
  if (create_ == NULL) {
    _slow_mutable_create();
  }
  // @@protoc_insertion_point(field_mutable:mesos.Offer.Operation.create)
  return create_;
}
inline void Offer_Operation::set_allocated_create(::mesos::Offer_Operation_Create* create) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete create_;
  }
  if (create) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(create);
    if (message_arena != submessage_arena) {
      create = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, create, submessage_arena);
    }
    set_has_create();
  } else {
    clear_has_create();
  }
  create_ = create;
  // @@protoc_insertion_point(field_set_allocated:mesos.Offer.Operation.create)
}

// optional .mesos.Offer.Operation.Destroy destroy = 6;
inline bool Offer_Operation::has_destroy() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Offer_Operation::set_has_destroy() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Offer_Operation::clear_has_destroy() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Offer_Operation::clear_destroy() {
  if (destroy_ != NULL) destroy_->Clear();
  clear_has_destroy();
}
inline const ::mesos::Offer_Operation_Destroy& Offer_Operation::destroy() const {
  const ::mesos::Offer_Operation_Destroy* p = destroy_;
  // @@protoc_insertion_point(field_get:mesos.Offer.Operation.destroy)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::Offer_Operation_Destroy*>(
      &::mesos::_Offer_Operation_Destroy_default_instance_);
}
inline ::mesos::Offer_Operation_Destroy* Offer_Operation::release_destroy() {
  // @@protoc_insertion_point(field_release:mesos.Offer.Operation.destroy)
  clear_has_destroy();
  ::mesos::Offer_Operation_Destroy* temp = destroy_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  destroy_ = NULL;
  return temp;
}
inline ::mesos::Offer_Operation_Destroy* Offer_Operation::unsafe_arena_release_destroy() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Offer.Operation.destroy)
  clear_has_destroy();
  ::mesos::Offer_Operation_Destroy* temp = destroy_;
  destroy_ = NULL;
  return temp;
}
inline ::mesos::Offer_Operation_Destroy* Offer_Operation::mutable_destroy() {
  set_has_destroy();
  if (destroy_ == NULL) {
    _slow_mutable_destroy();
  }
  // @@protoc_insertion_point(field_mutable:mesos.Offer.Operation.destroy)
  return destroy_;
}
inline void Offer_Operation::set_allocated_destroy(::mesos::Offer_Operation_Destroy* destroy) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete destroy_;
  }
  if (destroy) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(destroy);
    if (message_arena != submessage_arena) {
      destroy = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, destroy, submessage_arena);
    }
    set_has_destroy();
  } else {
    clear_has_destroy();
  }
  destroy_ = destroy;
  // @@protoc_insertion_point(field_set_allocated:mesos.Offer.Operation.destroy)
}

// optional .mesos.Offer.Operation.GrowVolume grow_volume = 13;
inline bool Offer_Operation::has_grow_volume() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Offer_Operation::set_has_grow_volume() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Offer_Operation::clear_has_grow_volume() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Offer_Operation::clear_grow_volume() {
  if (grow_volume_ != NULL) grow_volume_->Clear();
  clear_has_grow_volume();
}
inline const ::mesos::Offer_Operation_GrowVolume& Offer_Operation::grow_volume() const {
  const ::mesos::Offer_Operation_GrowVolume* p = grow_volume_;
  // @@protoc_insertion_point(field_get:mesos.Offer.Operation.grow_volume)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::Offer_Operation_GrowVolume*>(
      &::mesos::_Offer_Operation_GrowVolume_default_instance_);
}
inline ::mesos::Offer_Operation_GrowVolume* Offer_Operation::release_grow_volume() {
  // @@protoc_insertion_point(field_release:mesos.Offer.Operation.grow_volume)
  clear_has_grow_volume();
  ::mesos::Offer_Operation_GrowVolume* temp = grow_volume_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  grow_volume_ = NULL;
  return temp;
}
inline ::mesos::Offer_Operation_GrowVolume* Offer_Operation::unsafe_arena_release_grow_volume() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Offer.Operation.grow_volume)
  clear_has_grow_volume();
  ::mesos::Offer_Operation_GrowVolume* temp = grow_volume_;
  grow_volume_ = NULL;
  return temp;
}
inline ::mesos::Offer_Operation_GrowVolume* Offer_Operation::mutable_grow_volume() {
  set_has_grow_volume();
  if (grow_volume_ == NULL) {
    _slow_mutable_grow_volume();
  }
  // @@protoc_insertion_point(field_mutable:mesos.Offer.Operation.grow_volume)
  return grow_volume_;
}
inline void Offer_Operation::set_allocated_grow_volume(::mesos::Offer_Operation_GrowVolume* grow_volume) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete grow_volume_;
  }
  if (grow_volume) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(grow_volume);
    if (message_arena != submessage_arena) {
      grow_volume = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, grow_volume, submessage_arena);
    }
    set_has_grow_volume();
  } else {
    clear_has_grow_volume();
  }
  grow_volume_ = grow_volume;
  // @@protoc_insertion_point(field_set_allocated:mesos.Offer.Operation.grow_volume)
}

// optional .mesos.Offer.Operation.ShrinkVolume shrink_volume = 14;
inline bool Offer_Operation::has_shrink_volume() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Offer_Operation::set_has_shrink_volume() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Offer_Operation::clear_has_shrink_volume() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Offer_Operation::clear_shrink_volume() {
  if (shrink_volume_ != NULL) shrink_volume_->Clear();
  clear_has_shrink_volume();
}
inline const ::mesos::Offer_Operation_ShrinkVolume& Offer_Operation::shrink_volume() const {
  const ::mesos::Offer_Operation_ShrinkVolume* p = shrink_volume_;
  // @@protoc_insertion_point(field_get:mesos.Offer.Operation.shrink_volume)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::Offer_Operation_ShrinkVolume*>(
      &::mesos::_Offer_Operation_ShrinkVolume_default_instance_);
}
inline ::mesos::Offer_Operation_ShrinkVolume* Offer_Operation::release_shrink_volume() {
  // @@protoc_insertion_point(field_release:mesos.Offer.Operation.shrink_volume)
  clear_has_shrink_volume();
  ::mesos::Offer_Operation_ShrinkVolume* temp = shrink_volume_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  shrink_volume_ = NULL;
  return temp;
}
inline ::mesos::Offer_Operation_ShrinkVolume* Offer_Operation::unsafe_arena_release_shrink_volume() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Offer.Operation.shrink_volume)
  clear_has_shrink_volume();
  ::mesos::Offer_Operation_ShrinkVolume* temp = shrink_volume_;
  shrink_volume_ = NULL;
  return temp;
}
inline ::mesos::Offer_Operation_ShrinkVolume* Offer_Operation::mutable_shrink_volume() {
  set_has_shrink_volume();
  if (shrink_volume_ == NULL) {
    _slow_mutable_shrink_volume();
  }
  // @@protoc_insertion_point(field_mutable:mesos.Offer.Operation.shrink_volume)
  return shrink_volume_;
}
inline void Offer_Operation::set_allocated_shrink_volume(::mesos::Offer_Operation_ShrinkVolume* shrink_volume) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete shrink_volume_;
  }
  if (shrink_volume) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(shrink_volume);
    if (message_arena != submessage_arena) {
      shrink_volume = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, shrink_volume, submessage_arena);
    }
    set_has_shrink_volume();
  } else {
    clear_has_shrink_volume();
  }
  shrink_volume_ = shrink_volume;
  // @@protoc_insertion_point(field_set_allocated:mesos.Offer.Operation.shrink_volume)
}

// optional .mesos.Offer.Operation.CreateVolume create_volume = 8;
inline bool Offer_Operation::has_create_volume() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Offer_Operation::set_has_create_volume() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Offer_Operation::clear_has_create_volume() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Offer_Operation::clear_create_volume() {
  if (create_volume_ != NULL) create_volume_->Clear();
  clear_has_create_volume();
}
inline const ::mesos::Offer_Operation_CreateVolume& Offer_Operation::create_volume() const {
  const ::mesos::Offer_Operation_CreateVolume* p = create_volume_;
  // @@protoc_insertion_point(field_get:mesos.Offer.Operation.create_volume)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::Offer_Operation_CreateVolume*>(
      &::mesos::_Offer_Operation_CreateVolume_default_instance_);
}
inline ::mesos::Offer_Operation_CreateVolume* Offer_Operation::release_create_volume() {
  // @@protoc_insertion_point(field_release:mesos.Offer.Operation.create_volume)
  clear_has_create_volume();
  ::mesos::Offer_Operation_CreateVolume* temp = create_volume_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  create_volume_ = NULL;
  return temp;
}
inline ::mesos::Offer_Operation_CreateVolume* Offer_Operation::unsafe_arena_release_create_volume() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Offer.Operation.create_volume)
  clear_has_create_volume();
  ::mesos::Offer_Operation_CreateVolume* temp = create_volume_;
  create_volume_ = NULL;
  return temp;
}
inline ::mesos::Offer_Operation_CreateVolume* Offer_Operation::mutable_create_volume() {
  set_has_create_volume();
  if (create_volume_ == NULL) {
    _slow_mutable_create_volume();
  }
  // @@protoc_insertion_point(field_mutable:mesos.Offer.Operation.create_volume)
  return create_volume_;
}
inline void Offer_Operation::set_allocated_create_volume(::mesos::Offer_Operation_CreateVolume* create_volume) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete create_volume_;
  }
  if (create_volume) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(create_volume);
    if (message_arena != submessage_arena) {
      create_volume = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, create_volume, submessage_arena);
    }
    set_has_create_volume();
  } else {
    clear_has_create_volume();
  }
  create_volume_ = create_volume;
  // @@protoc_insertion_point(field_set_allocated:mesos.Offer.Operation.create_volume)
}

// optional .mesos.Offer.Operation.DestroyVolume destroy_volume = 9;
inline bool Offer_Operation::has_destroy_volume() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Offer_Operation::set_has_destroy_volume() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Offer_Operation::clear_has_destroy_volume() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Offer_Operation::clear_destroy_volume() {
  if (destroy_volume_ != NULL) destroy_volume_->Clear();
  clear_has_destroy_volume();
}
inline const ::mesos::Offer_Operation_DestroyVolume& Offer_Operation::destroy_volume() const {
  const ::mesos::Offer_Operation_DestroyVolume* p = destroy_volume_;
  // @@protoc_insertion_point(field_get:mesos.Offer.Operation.destroy_volume)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::Offer_Operation_DestroyVolume*>(
      &::mesos::_Offer_Operation_DestroyVolume_default_instance_);
}
inline ::mesos::Offer_Operation_DestroyVolume* Offer_Operation::release_destroy_volume() {
  // @@protoc_insertion_point(field_release:mesos.Offer.Operation.destroy_volume)
  clear_has_destroy_volume();
  ::mesos::Offer_Operation_DestroyVolume* temp = destroy_volume_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  destroy_volume_ = NULL;
  return temp;
}
inline ::mesos::Offer_Operation_DestroyVolume* Offer_Operation::unsafe_arena_release_destroy_volume() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Offer.Operation.destroy_volume)
  clear_has_destroy_volume();
  ::mesos::Offer_Operation_DestroyVolume* temp = destroy_volume_;
  destroy_volume_ = NULL;
  return temp;
}
inline ::mesos::Offer_Operation_DestroyVolume* Offer_Operation::mutable_destroy_volume() {
  set_has_destroy_volume();
  if (destroy_volume_ == NULL) {
    _slow_mutable_destroy_volume();
  }
  // @@protoc_insertion_point(field_mutable:mesos.Offer.Operation.destroy_volume)
  return destroy_volume_;
}
inline void Offer_Operation::set_allocated_destroy_volume(::mesos::Offer_Operation_DestroyVolume* destroy_volume) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete destroy_volume_;
  }
  if (destroy_volume) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(destroy_volume);
    if (message_arena != submessage_arena) {
      destroy_volume = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, destroy_volume, submessage_arena);
    }
    set_has_destroy_volume();
  } else {
    clear_has_destroy_volume();
  }
  destroy_volume_ = destroy_volume;
  // @@protoc_insertion_point(field_set_allocated:mesos.Offer.Operation.destroy_volume)
}

// optional .mesos.Offer.Operation.CreateBlock create_block = 10;
inline bool Offer_Operation::has_create_block() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Offer_Operation::set_has_create_block() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Offer_Operation::clear_has_create_block() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Offer_Operation::clear_create_block() {
  if (create_block_ != NULL) create_block_->Clear();
  clear_has_create_block();
}
inline const ::mesos::Offer_Operation_CreateBlock& Offer_Operation::create_block() const {
  const ::mesos::Offer_Operation_CreateBlock* p = create_block_;
  // @@protoc_insertion_point(field_get:mesos.Offer.Operation.create_block)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::Offer_Operation_CreateBlock*>(
      &::mesos::_Offer_Operation_CreateBlock_default_instance_);
}
inline ::mesos::Offer_Operation_CreateBlock* Offer_Operation::release_create_block() {
  // @@protoc_insertion_point(field_release:mesos.Offer.Operation.create_block)
  clear_has_create_block();
  ::mesos::Offer_Operation_CreateBlock* temp = create_block_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  create_block_ = NULL;
  return temp;
}
inline ::mesos::Offer_Operation_CreateBlock* Offer_Operation::unsafe_arena_release_create_block() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Offer.Operation.create_block)
  clear_has_create_block();
  ::mesos::Offer_Operation_CreateBlock* temp = create_block_;
  create_block_ = NULL;
  return temp;
}
inline ::mesos::Offer_Operation_CreateBlock* Offer_Operation::mutable_create_block() {
  set_has_create_block();
  if (create_block_ == NULL) {
    _slow_mutable_create_block();
  }
  // @@protoc_insertion_point(field_mutable:mesos.Offer.Operation.create_block)
  return create_block_;
}
inline void Offer_Operation::set_allocated_create_block(::mesos::Offer_Operation_CreateBlock* create_block) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete create_block_;
  }
  if (create_block) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(create_block);
    if (message_arena != submessage_arena) {
      create_block = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, create_block, submessage_arena);
    }
    set_has_create_block();
  } else {
    clear_has_create_block();
  }
  create_block_ = create_block;
  // @@protoc_insertion_point(field_set_allocated:mesos.Offer.Operation.create_block)
}

// optional .mesos.Offer.Operation.DestroyBlock destroy_block = 11;
inline bool Offer_Operation::has_destroy_block() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Offer_Operation::set_has_destroy_block() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Offer_Operation::clear_has_destroy_block() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Offer_Operation::clear_destroy_block() {
  if (destroy_block_ != NULL) destroy_block_->Clear();
  clear_has_destroy_block();
}
inline const ::mesos::Offer_Operation_DestroyBlock& Offer_Operation::destroy_block() const {
  const ::mesos::Offer_Operation_DestroyBlock* p = destroy_block_;
  // @@protoc_insertion_point(field_get:mesos.Offer.Operation.destroy_block)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::Offer_Operation_DestroyBlock*>(
      &::mesos::_Offer_Operation_DestroyBlock_default_instance_);
}
inline ::mesos::Offer_Operation_DestroyBlock* Offer_Operation::release_destroy_block() {
  // @@protoc_insertion_point(field_release:mesos.Offer.Operation.destroy_block)
  clear_has_destroy_block();
  ::mesos::Offer_Operation_DestroyBlock* temp = destroy_block_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  destroy_block_ = NULL;
  return temp;
}
inline ::mesos::Offer_Operation_DestroyBlock* Offer_Operation::unsafe_arena_release_destroy_block() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Offer.Operation.destroy_block)
  clear_has_destroy_block();
  ::mesos::Offer_Operation_DestroyBlock* temp = destroy_block_;
  destroy_block_ = NULL;
  return temp;
}
inline ::mesos::Offer_Operation_DestroyBlock* Offer_Operation::mutable_destroy_block() {
  set_has_destroy_block();
  if (destroy_block_ == NULL) {
    _slow_mutable_destroy_block();
  }
  // @@protoc_insertion_point(field_mutable:mesos.Offer.Operation.destroy_block)
  return destroy_block_;
}
inline void Offer_Operation::set_allocated_destroy_block(::mesos::Offer_Operation_DestroyBlock* destroy_block) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete destroy_block_;
  }
  if (destroy_block) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(destroy_block);
    if (message_arena != submessage_arena) {
      destroy_block = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, destroy_block, submessage_arena);
    }
    set_has_destroy_block();
  } else {
    clear_has_destroy_block();
  }
  destroy_block_ = destroy_block;
  // @@protoc_insertion_point(field_set_allocated:mesos.Offer.Operation.destroy_block)
}

// -------------------------------------------------------------------

// Offer

// required .mesos.OfferID id = 1;
inline bool Offer::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Offer::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Offer::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Offer::clear_id() {
  if (id_ != NULL) id_->Clear();
  clear_has_id();
}
inline const ::mesos::OfferID& Offer::id() const {
  const ::mesos::OfferID* p = id_;
  // @@protoc_insertion_point(field_get:mesos.Offer.id)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::OfferID*>(
      &::mesos::_OfferID_default_instance_);
}
inline ::mesos::OfferID* Offer::release_id() {
  // @@protoc_insertion_point(field_release:mesos.Offer.id)
  clear_has_id();
  ::mesos::OfferID* temp = id_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  id_ = NULL;
  return temp;
}
inline ::mesos::OfferID* Offer::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Offer.id)
  clear_has_id();
  ::mesos::OfferID* temp = id_;
  id_ = NULL;
  return temp;
}
inline ::mesos::OfferID* Offer::mutable_id() {
  set_has_id();
  if (id_ == NULL) {
    _slow_mutable_id();
  }
  // @@protoc_insertion_point(field_mutable:mesos.Offer.id)
  return id_;
}
inline void Offer::set_allocated_id(::mesos::OfferID* id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete id_;
  }
  if (id) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(id);
    if (message_arena != submessage_arena) {
      id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    set_has_id();
  } else {
    clear_has_id();
  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:mesos.Offer.id)
}

// required .mesos.FrameworkID framework_id = 2;
inline bool Offer::has_framework_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Offer::set_has_framework_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Offer::clear_has_framework_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Offer::clear_framework_id() {
  if (framework_id_ != NULL) framework_id_->Clear();
  clear_has_framework_id();
}
inline const ::mesos::FrameworkID& Offer::framework_id() const {
  const ::mesos::FrameworkID* p = framework_id_;
  // @@protoc_insertion_point(field_get:mesos.Offer.framework_id)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::FrameworkID*>(
      &::mesos::_FrameworkID_default_instance_);
}
inline ::mesos::FrameworkID* Offer::release_framework_id() {
  // @@protoc_insertion_point(field_release:mesos.Offer.framework_id)
  clear_has_framework_id();
  ::mesos::FrameworkID* temp = framework_id_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  framework_id_ = NULL;
  return temp;
}
inline ::mesos::FrameworkID* Offer::unsafe_arena_release_framework_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Offer.framework_id)
  clear_has_framework_id();
  ::mesos::FrameworkID* temp = framework_id_;
  framework_id_ = NULL;
  return temp;
}
inline ::mesos::FrameworkID* Offer::mutable_framework_id() {
  set_has_framework_id();
  if (framework_id_ == NULL) {
    _slow_mutable_framework_id();
  }
  // @@protoc_insertion_point(field_mutable:mesos.Offer.framework_id)
  return framework_id_;
}
inline void Offer::set_allocated_framework_id(::mesos::FrameworkID* framework_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete framework_id_;
  }
  if (framework_id) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(framework_id);
    if (message_arena != submessage_arena) {
      framework_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, framework_id, submessage_arena);
    }
    set_has_framework_id();
  } else {
    clear_has_framework_id();
  }
  framework_id_ = framework_id;
  // @@protoc_insertion_point(field_set_allocated:mesos.Offer.framework_id)
}

// required .mesos.SlaveID slave_id = 3;
inline bool Offer::has_slave_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Offer::set_has_slave_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Offer::clear_has_slave_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Offer::clear_slave_id() {
  if (slave_id_ != NULL) slave_id_->Clear();
  clear_has_slave_id();
}
inline const ::mesos::SlaveID& Offer::slave_id() const {
  const ::mesos::SlaveID* p = slave_id_;
  // @@protoc_insertion_point(field_get:mesos.Offer.slave_id)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::SlaveID*>(
      &::mesos::_SlaveID_default_instance_);
}
inline ::mesos::SlaveID* Offer::release_slave_id() {
  // @@protoc_insertion_point(field_release:mesos.Offer.slave_id)
  clear_has_slave_id();
  ::mesos::SlaveID* temp = slave_id_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  slave_id_ = NULL;
  return temp;
}
inline ::mesos::SlaveID* Offer::unsafe_arena_release_slave_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Offer.slave_id)
  clear_has_slave_id();
  ::mesos::SlaveID* temp = slave_id_;
  slave_id_ = NULL;
  return temp;
}
inline ::mesos::SlaveID* Offer::mutable_slave_id() {
  set_has_slave_id();
  if (slave_id_ == NULL) {
    _slow_mutable_slave_id();
  }
  // @@protoc_insertion_point(field_mutable:mesos.Offer.slave_id)
  return slave_id_;
}
inline void Offer::set_allocated_slave_id(::mesos::SlaveID* slave_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete slave_id_;
  }
  if (slave_id) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(slave_id);
    if (message_arena != submessage_arena) {
      slave_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, slave_id, submessage_arena);
    }
    set_has_slave_id();
  } else {
    clear_has_slave_id();
  }
  slave_id_ = slave_id;
  // @@protoc_insertion_point(field_set_allocated:mesos.Offer.slave_id)
}

// required string hostname = 4;
inline bool Offer::has_hostname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Offer::set_has_hostname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Offer::clear_has_hostname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Offer::clear_hostname() {
  hostname_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_hostname();
}
inline const ::std::string& Offer::hostname() const {
  // @@protoc_insertion_point(field_get:mesos.Offer.hostname)
  return hostname_.Get();
}
inline void Offer::set_hostname(const ::std::string& value) {
  set_has_hostname();
  hostname_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.Offer.hostname)
}
#if LANG_CXX11
inline void Offer::set_hostname(::std::string&& value) {
  set_has_hostname();
  hostname_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.Offer.hostname)
}
#endif
inline void Offer::set_hostname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_hostname();
  hostname_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.Offer.hostname)
}
inline void Offer::set_hostname(const char* value,
    size_t size) {
  set_has_hostname();
  hostname_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.Offer.hostname)
}
inline ::std::string* Offer::mutable_hostname() {
  set_has_hostname();
  // @@protoc_insertion_point(field_mutable:mesos.Offer.hostname)
  return hostname_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* Offer::release_hostname() {
  // @@protoc_insertion_point(field_release:mesos.Offer.hostname)
  clear_has_hostname();
  return hostname_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void Offer::set_allocated_hostname(::std::string* hostname) {
  if (hostname != NULL) {
    set_has_hostname();
  } else {
    clear_has_hostname();
  }
  hostname_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hostname,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.Offer.hostname)
}
inline ::std::string* Offer::unsafe_arena_release_hostname() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Offer.hostname)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_hostname();
  return hostname_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void Offer::unsafe_arena_set_allocated_hostname(
    ::std::string* hostname) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (hostname != NULL) {
    set_has_hostname();
  } else {
    clear_has_hostname();
  }
  hostname_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      hostname, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.Offer.hostname)
}

// optional .mesos.URL url = 8;
inline bool Offer::has_url() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Offer::set_has_url() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Offer::clear_has_url() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Offer::clear_url() {
  if (url_ != NULL) url_->Clear();
  clear_has_url();
}
inline const ::mesos::URL& Offer::url() const {
  const ::mesos::URL* p = url_;
  // @@protoc_insertion_point(field_get:mesos.Offer.url)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::URL*>(
      &::mesos::_URL_default_instance_);
}
inline ::mesos::URL* Offer::release_url() {
  // @@protoc_insertion_point(field_release:mesos.Offer.url)
  clear_has_url();
  ::mesos::URL* temp = url_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  url_ = NULL;
  return temp;
}
inline ::mesos::URL* Offer::unsafe_arena_release_url() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Offer.url)
  clear_has_url();
  ::mesos::URL* temp = url_;
  url_ = NULL;
  return temp;
}
inline ::mesos::URL* Offer::mutable_url() {
  set_has_url();
  if (url_ == NULL) {
    _slow_mutable_url();
  }
  // @@protoc_insertion_point(field_mutable:mesos.Offer.url)
  return url_;
}
inline void Offer::set_allocated_url(::mesos::URL* url) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete url_;
  }
  if (url) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(url);
    if (message_arena != submessage_arena) {
      url = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, url, submessage_arena);
    }
    set_has_url();
  } else {
    clear_has_url();
  }
  url_ = url;
  // @@protoc_insertion_point(field_set_allocated:mesos.Offer.url)
}

// optional .mesos.DomainInfo domain = 11;
inline bool Offer::has_domain() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Offer::set_has_domain() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Offer::clear_has_domain() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Offer::clear_domain() {
  if (domain_ != NULL) domain_->Clear();
  clear_has_domain();
}
inline const ::mesos::DomainInfo& Offer::domain() const {
  const ::mesos::DomainInfo* p = domain_;
  // @@protoc_insertion_point(field_get:mesos.Offer.domain)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::DomainInfo*>(
      &::mesos::_DomainInfo_default_instance_);
}
inline ::mesos::DomainInfo* Offer::release_domain() {
  // @@protoc_insertion_point(field_release:mesos.Offer.domain)
  clear_has_domain();
  ::mesos::DomainInfo* temp = domain_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  domain_ = NULL;
  return temp;
}
inline ::mesos::DomainInfo* Offer::unsafe_arena_release_domain() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Offer.domain)
  clear_has_domain();
  ::mesos::DomainInfo* temp = domain_;
  domain_ = NULL;
  return temp;
}
inline ::mesos::DomainInfo* Offer::mutable_domain() {
  set_has_domain();
  if (domain_ == NULL) {
    _slow_mutable_domain();
  }
  // @@protoc_insertion_point(field_mutable:mesos.Offer.domain)
  return domain_;
}
inline void Offer::set_allocated_domain(::mesos::DomainInfo* domain) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete domain_;
  }
  if (domain) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(domain);
    if (message_arena != submessage_arena) {
      domain = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, domain, submessage_arena);
    }
    set_has_domain();
  } else {
    clear_has_domain();
  }
  domain_ = domain;
  // @@protoc_insertion_point(field_set_allocated:mesos.Offer.domain)
}

// repeated .mesos.Resource resources = 5;
inline int Offer::resources_size() const {
  return resources_.size();
}
inline void Offer::clear_resources() {
  resources_.Clear();
}
inline const ::mesos::Resource& Offer::resources(int index) const {
  // @@protoc_insertion_point(field_get:mesos.Offer.resources)
  return resources_.Get(index);
}
inline ::mesos::Resource* Offer::mutable_resources(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.Offer.resources)
  return resources_.Mutable(index);
}
inline ::mesos::Resource* Offer::add_resources() {
  // @@protoc_insertion_point(field_add:mesos.Offer.resources)
  return resources_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
Offer::mutable_resources() {
  // @@protoc_insertion_point(field_mutable_list:mesos.Offer.resources)
  return &resources_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
Offer::resources() const {
  // @@protoc_insertion_point(field_list:mesos.Offer.resources)
  return resources_;
}

// repeated .mesos.Attribute attributes = 7;
inline int Offer::attributes_size() const {
  return attributes_.size();
}
inline void Offer::clear_attributes() {
  attributes_.Clear();
}
inline const ::mesos::Attribute& Offer::attributes(int index) const {
  // @@protoc_insertion_point(field_get:mesos.Offer.attributes)
  return attributes_.Get(index);
}
inline ::mesos::Attribute* Offer::mutable_attributes(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.Offer.attributes)
  return attributes_.Mutable(index);
}
inline ::mesos::Attribute* Offer::add_attributes() {
  // @@protoc_insertion_point(field_add:mesos.Offer.attributes)
  return attributes_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Attribute >*
Offer::mutable_attributes() {
  // @@protoc_insertion_point(field_mutable_list:mesos.Offer.attributes)
  return &attributes_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Attribute >&
Offer::attributes() const {
  // @@protoc_insertion_point(field_list:mesos.Offer.attributes)
  return attributes_;
}

// repeated .mesos.ExecutorID executor_ids = 6;
inline int Offer::executor_ids_size() const {
  return executor_ids_.size();
}
inline void Offer::clear_executor_ids() {
  executor_ids_.Clear();
}
inline const ::mesos::ExecutorID& Offer::executor_ids(int index) const {
  // @@protoc_insertion_point(field_get:mesos.Offer.executor_ids)
  return executor_ids_.Get(index);
}
inline ::mesos::ExecutorID* Offer::mutable_executor_ids(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.Offer.executor_ids)
  return executor_ids_.Mutable(index);
}
inline ::mesos::ExecutorID* Offer::add_executor_ids() {
  // @@protoc_insertion_point(field_add:mesos.Offer.executor_ids)
  return executor_ids_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::ExecutorID >*
Offer::mutable_executor_ids() {
  // @@protoc_insertion_point(field_mutable_list:mesos.Offer.executor_ids)
  return &executor_ids_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::ExecutorID >&
Offer::executor_ids() const {
  // @@protoc_insertion_point(field_list:mesos.Offer.executor_ids)
  return executor_ids_;
}

// optional .mesos.Unavailability unavailability = 9;
inline bool Offer::has_unavailability() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Offer::set_has_unavailability() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Offer::clear_has_unavailability() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Offer::clear_unavailability() {
  if (unavailability_ != NULL) unavailability_->Clear();
  clear_has_unavailability();
}
inline const ::mesos::Unavailability& Offer::unavailability() const {
  const ::mesos::Unavailability* p = unavailability_;
  // @@protoc_insertion_point(field_get:mesos.Offer.unavailability)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::Unavailability*>(
      &::mesos::_Unavailability_default_instance_);
}
inline ::mesos::Unavailability* Offer::release_unavailability() {
  // @@protoc_insertion_point(field_release:mesos.Offer.unavailability)
  clear_has_unavailability();
  ::mesos::Unavailability* temp = unavailability_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  unavailability_ = NULL;
  return temp;
}
inline ::mesos::Unavailability* Offer::unsafe_arena_release_unavailability() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Offer.unavailability)
  clear_has_unavailability();
  ::mesos::Unavailability* temp = unavailability_;
  unavailability_ = NULL;
  return temp;
}
inline ::mesos::Unavailability* Offer::mutable_unavailability() {
  set_has_unavailability();
  if (unavailability_ == NULL) {
    _slow_mutable_unavailability();
  }
  // @@protoc_insertion_point(field_mutable:mesos.Offer.unavailability)
  return unavailability_;
}
inline void Offer::set_allocated_unavailability(::mesos::Unavailability* unavailability) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete unavailability_;
  }
  if (unavailability) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(unavailability);
    if (message_arena != submessage_arena) {
      unavailability = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, unavailability, submessage_arena);
    }
    set_has_unavailability();
  } else {
    clear_has_unavailability();
  }
  unavailability_ = unavailability;
  // @@protoc_insertion_point(field_set_allocated:mesos.Offer.unavailability)
}

// optional .mesos.Resource.AllocationInfo allocation_info = 10;
inline bool Offer::has_allocation_info() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Offer::set_has_allocation_info() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Offer::clear_has_allocation_info() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Offer::clear_allocation_info() {
  if (allocation_info_ != NULL) allocation_info_->Clear();
  clear_has_allocation_info();
}
inline const ::mesos::Resource_AllocationInfo& Offer::allocation_info() const {
  const ::mesos::Resource_AllocationInfo* p = allocation_info_;
  // @@protoc_insertion_point(field_get:mesos.Offer.allocation_info)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::Resource_AllocationInfo*>(
      &::mesos::_Resource_AllocationInfo_default_instance_);
}
inline ::mesos::Resource_AllocationInfo* Offer::release_allocation_info() {
  // @@protoc_insertion_point(field_release:mesos.Offer.allocation_info)
  clear_has_allocation_info();
  ::mesos::Resource_AllocationInfo* temp = allocation_info_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  allocation_info_ = NULL;
  return temp;
}
inline ::mesos::Resource_AllocationInfo* Offer::unsafe_arena_release_allocation_info() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Offer.allocation_info)
  clear_has_allocation_info();
  ::mesos::Resource_AllocationInfo* temp = allocation_info_;
  allocation_info_ = NULL;
  return temp;
}
inline ::mesos::Resource_AllocationInfo* Offer::mutable_allocation_info() {
  set_has_allocation_info();
  if (allocation_info_ == NULL) {
    _slow_mutable_allocation_info();
  }
  // @@protoc_insertion_point(field_mutable:mesos.Offer.allocation_info)
  return allocation_info_;
}
inline void Offer::set_allocated_allocation_info(::mesos::Resource_AllocationInfo* allocation_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete allocation_info_;
  }
  if (allocation_info) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(allocation_info);
    if (message_arena != submessage_arena) {
      allocation_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, allocation_info, submessage_arena);
    }
    set_has_allocation_info();
  } else {
    clear_has_allocation_info();
  }
  allocation_info_ = allocation_info;
  // @@protoc_insertion_point(field_set_allocated:mesos.Offer.allocation_info)
}

// -------------------------------------------------------------------

// InverseOffer

// required .mesos.OfferID id = 1;
inline bool InverseOffer::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InverseOffer::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InverseOffer::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InverseOffer::clear_id() {
  if (id_ != NULL) id_->Clear();
  clear_has_id();
}
inline const ::mesos::OfferID& InverseOffer::id() const {
  const ::mesos::OfferID* p = id_;
  // @@protoc_insertion_point(field_get:mesos.InverseOffer.id)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::OfferID*>(
      &::mesos::_OfferID_default_instance_);
}
inline ::mesos::OfferID* InverseOffer::release_id() {
  // @@protoc_insertion_point(field_release:mesos.InverseOffer.id)
  clear_has_id();
  ::mesos::OfferID* temp = id_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  id_ = NULL;
  return temp;
}
inline ::mesos::OfferID* InverseOffer::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.InverseOffer.id)
  clear_has_id();
  ::mesos::OfferID* temp = id_;
  id_ = NULL;
  return temp;
}
inline ::mesos::OfferID* InverseOffer::mutable_id() {
  set_has_id();
  if (id_ == NULL) {
    _slow_mutable_id();
  }
  // @@protoc_insertion_point(field_mutable:mesos.InverseOffer.id)
  return id_;
}
inline void InverseOffer::set_allocated_id(::mesos::OfferID* id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete id_;
  }
  if (id) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(id);
    if (message_arena != submessage_arena) {
      id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    set_has_id();
  } else {
    clear_has_id();
  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:mesos.InverseOffer.id)
}

// optional .mesos.URL url = 2;
inline bool InverseOffer::has_url() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InverseOffer::set_has_url() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InverseOffer::clear_has_url() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InverseOffer::clear_url() {
  if (url_ != NULL) url_->Clear();
  clear_has_url();
}
inline const ::mesos::URL& InverseOffer::url() const {
  const ::mesos::URL* p = url_;
  // @@protoc_insertion_point(field_get:mesos.InverseOffer.url)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::URL*>(
      &::mesos::_URL_default_instance_);
}
inline ::mesos::URL* InverseOffer::release_url() {
  // @@protoc_insertion_point(field_release:mesos.InverseOffer.url)
  clear_has_url();
  ::mesos::URL* temp = url_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  url_ = NULL;
  return temp;
}
inline ::mesos::URL* InverseOffer::unsafe_arena_release_url() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.InverseOffer.url)
  clear_has_url();
  ::mesos::URL* temp = url_;
  url_ = NULL;
  return temp;
}
inline ::mesos::URL* InverseOffer::mutable_url() {
  set_has_url();
  if (url_ == NULL) {
    _slow_mutable_url();
  }
  // @@protoc_insertion_point(field_mutable:mesos.InverseOffer.url)
  return url_;
}
inline void InverseOffer::set_allocated_url(::mesos::URL* url) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete url_;
  }
  if (url) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(url);
    if (message_arena != submessage_arena) {
      url = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, url, submessage_arena);
    }
    set_has_url();
  } else {
    clear_has_url();
  }
  url_ = url;
  // @@protoc_insertion_point(field_set_allocated:mesos.InverseOffer.url)
}

// required .mesos.FrameworkID framework_id = 3;
inline bool InverseOffer::has_framework_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InverseOffer::set_has_framework_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InverseOffer::clear_has_framework_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InverseOffer::clear_framework_id() {
  if (framework_id_ != NULL) framework_id_->Clear();
  clear_has_framework_id();
}
inline const ::mesos::FrameworkID& InverseOffer::framework_id() const {
  const ::mesos::FrameworkID* p = framework_id_;
  // @@protoc_insertion_point(field_get:mesos.InverseOffer.framework_id)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::FrameworkID*>(
      &::mesos::_FrameworkID_default_instance_);
}
inline ::mesos::FrameworkID* InverseOffer::release_framework_id() {
  // @@protoc_insertion_point(field_release:mesos.InverseOffer.framework_id)
  clear_has_framework_id();
  ::mesos::FrameworkID* temp = framework_id_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  framework_id_ = NULL;
  return temp;
}
inline ::mesos::FrameworkID* InverseOffer::unsafe_arena_release_framework_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.InverseOffer.framework_id)
  clear_has_framework_id();
  ::mesos::FrameworkID* temp = framework_id_;
  framework_id_ = NULL;
  return temp;
}
inline ::mesos::FrameworkID* InverseOffer::mutable_framework_id() {
  set_has_framework_id();
  if (framework_id_ == NULL) {
    _slow_mutable_framework_id();
  }
  // @@protoc_insertion_point(field_mutable:mesos.InverseOffer.framework_id)
  return framework_id_;
}
inline void InverseOffer::set_allocated_framework_id(::mesos::FrameworkID* framework_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete framework_id_;
  }
  if (framework_id) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(framework_id);
    if (message_arena != submessage_arena) {
      framework_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, framework_id, submessage_arena);
    }
    set_has_framework_id();
  } else {
    clear_has_framework_id();
  }
  framework_id_ = framework_id;
  // @@protoc_insertion_point(field_set_allocated:mesos.InverseOffer.framework_id)
}

// optional .mesos.SlaveID slave_id = 4;
inline bool InverseOffer::has_slave_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InverseOffer::set_has_slave_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InverseOffer::clear_has_slave_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InverseOffer::clear_slave_id() {
  if (slave_id_ != NULL) slave_id_->Clear();
  clear_has_slave_id();
}
inline const ::mesos::SlaveID& InverseOffer::slave_id() const {
  const ::mesos::SlaveID* p = slave_id_;
  // @@protoc_insertion_point(field_get:mesos.InverseOffer.slave_id)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::SlaveID*>(
      &::mesos::_SlaveID_default_instance_);
}
inline ::mesos::SlaveID* InverseOffer::release_slave_id() {
  // @@protoc_insertion_point(field_release:mesos.InverseOffer.slave_id)
  clear_has_slave_id();
  ::mesos::SlaveID* temp = slave_id_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  slave_id_ = NULL;
  return temp;
}
inline ::mesos::SlaveID* InverseOffer::unsafe_arena_release_slave_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.InverseOffer.slave_id)
  clear_has_slave_id();
  ::mesos::SlaveID* temp = slave_id_;
  slave_id_ = NULL;
  return temp;
}
inline ::mesos::SlaveID* InverseOffer::mutable_slave_id() {
  set_has_slave_id();
  if (slave_id_ == NULL) {
    _slow_mutable_slave_id();
  }
  // @@protoc_insertion_point(field_mutable:mesos.InverseOffer.slave_id)
  return slave_id_;
}
inline void InverseOffer::set_allocated_slave_id(::mesos::SlaveID* slave_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete slave_id_;
  }
  if (slave_id) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(slave_id);
    if (message_arena != submessage_arena) {
      slave_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, slave_id, submessage_arena);
    }
    set_has_slave_id();
  } else {
    clear_has_slave_id();
  }
  slave_id_ = slave_id;
  // @@protoc_insertion_point(field_set_allocated:mesos.InverseOffer.slave_id)
}

// required .mesos.Unavailability unavailability = 5;
inline bool InverseOffer::has_unavailability() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void InverseOffer::set_has_unavailability() {
  _has_bits_[0] |= 0x00000010u;
}
inline void InverseOffer::clear_has_unavailability() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void InverseOffer::clear_unavailability() {
  if (unavailability_ != NULL) unavailability_->Clear();
  clear_has_unavailability();
}
inline const ::mesos::Unavailability& InverseOffer::unavailability() const {
  const ::mesos::Unavailability* p = unavailability_;
  // @@protoc_insertion_point(field_get:mesos.InverseOffer.unavailability)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::Unavailability*>(
      &::mesos::_Unavailability_default_instance_);
}
inline ::mesos::Unavailability* InverseOffer::release_unavailability() {
  // @@protoc_insertion_point(field_release:mesos.InverseOffer.unavailability)
  clear_has_unavailability();
  ::mesos::Unavailability* temp = unavailability_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  unavailability_ = NULL;
  return temp;
}
inline ::mesos::Unavailability* InverseOffer::unsafe_arena_release_unavailability() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.InverseOffer.unavailability)
  clear_has_unavailability();
  ::mesos::Unavailability* temp = unavailability_;
  unavailability_ = NULL;
  return temp;
}
inline ::mesos::Unavailability* InverseOffer::mutable_unavailability() {
  set_has_unavailability();
  if (unavailability_ == NULL) {
    _slow_mutable_unavailability();
  }
  // @@protoc_insertion_point(field_mutable:mesos.InverseOffer.unavailability)
  return unavailability_;
}
inline void InverseOffer::set_allocated_unavailability(::mesos::Unavailability* unavailability) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete unavailability_;
  }
  if (unavailability) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(unavailability);
    if (message_arena != submessage_arena) {
      unavailability = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, unavailability, submessage_arena);
    }
    set_has_unavailability();
  } else {
    clear_has_unavailability();
  }
  unavailability_ = unavailability;
  // @@protoc_insertion_point(field_set_allocated:mesos.InverseOffer.unavailability)
}

// repeated .mesos.Resource resources = 6;
inline int InverseOffer::resources_size() const {
  return resources_.size();
}
inline void InverseOffer::clear_resources() {
  resources_.Clear();
}
inline const ::mesos::Resource& InverseOffer::resources(int index) const {
  // @@protoc_insertion_point(field_get:mesos.InverseOffer.resources)
  return resources_.Get(index);
}
inline ::mesos::Resource* InverseOffer::mutable_resources(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.InverseOffer.resources)
  return resources_.Mutable(index);
}
inline ::mesos::Resource* InverseOffer::add_resources() {
  // @@protoc_insertion_point(field_add:mesos.InverseOffer.resources)
  return resources_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
InverseOffer::mutable_resources() {
  // @@protoc_insertion_point(field_mutable_list:mesos.InverseOffer.resources)
  return &resources_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
InverseOffer::resources() const {
  // @@protoc_insertion_point(field_list:mesos.InverseOffer.resources)
  return resources_;
}

// -------------------------------------------------------------------

// TaskInfo

// required string name = 1;
inline bool TaskInfo::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TaskInfo::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TaskInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TaskInfo::clear_name() {
  name_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_name();
}
inline const ::std::string& TaskInfo::name() const {
  // @@protoc_insertion_point(field_get:mesos.TaskInfo.name)
  return name_.Get();
}
inline void TaskInfo::set_name(const ::std::string& value) {
  set_has_name();
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.TaskInfo.name)
}
#if LANG_CXX11
inline void TaskInfo::set_name(::std::string&& value) {
  set_has_name();
  name_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.TaskInfo.name)
}
#endif
inline void TaskInfo::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.TaskInfo.name)
}
inline void TaskInfo::set_name(const char* value,
    size_t size) {
  set_has_name();
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.TaskInfo.name)
}
inline ::std::string* TaskInfo::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:mesos.TaskInfo.name)
  return name_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* TaskInfo::release_name() {
  // @@protoc_insertion_point(field_release:mesos.TaskInfo.name)
  clear_has_name();
  return name_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void TaskInfo::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.TaskInfo.name)
}
inline ::std::string* TaskInfo::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.TaskInfo.name)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_name();
  return name_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void TaskInfo::unsafe_arena_set_allocated_name(
    ::std::string* name) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      name, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.TaskInfo.name)
}

// required .mesos.TaskID task_id = 2;
inline bool TaskInfo::has_task_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TaskInfo::set_has_task_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TaskInfo::clear_has_task_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TaskInfo::clear_task_id() {
  if (task_id_ != NULL) task_id_->Clear();
  clear_has_task_id();
}
inline const ::mesos::TaskID& TaskInfo::task_id() const {
  const ::mesos::TaskID* p = task_id_;
  // @@protoc_insertion_point(field_get:mesos.TaskInfo.task_id)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::TaskID*>(
      &::mesos::_TaskID_default_instance_);
}
inline ::mesos::TaskID* TaskInfo::release_task_id() {
  // @@protoc_insertion_point(field_release:mesos.TaskInfo.task_id)
  clear_has_task_id();
  ::mesos::TaskID* temp = task_id_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  task_id_ = NULL;
  return temp;
}
inline ::mesos::TaskID* TaskInfo::unsafe_arena_release_task_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.TaskInfo.task_id)
  clear_has_task_id();
  ::mesos::TaskID* temp = task_id_;
  task_id_ = NULL;
  return temp;
}
inline ::mesos::TaskID* TaskInfo::mutable_task_id() {
  set_has_task_id();
  if (task_id_ == NULL) {
    _slow_mutable_task_id();
  }
  // @@protoc_insertion_point(field_mutable:mesos.TaskInfo.task_id)
  return task_id_;
}
inline void TaskInfo::set_allocated_task_id(::mesos::TaskID* task_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete task_id_;
  }
  if (task_id) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(task_id);
    if (message_arena != submessage_arena) {
      task_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, task_id, submessage_arena);
    }
    set_has_task_id();
  } else {
    clear_has_task_id();
  }
  task_id_ = task_id;
  // @@protoc_insertion_point(field_set_allocated:mesos.TaskInfo.task_id)
}

// required .mesos.SlaveID slave_id = 3;
inline bool TaskInfo::has_slave_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TaskInfo::set_has_slave_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TaskInfo::clear_has_slave_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TaskInfo::clear_slave_id() {
  if (slave_id_ != NULL) slave_id_->Clear();
  clear_has_slave_id();
}
inline const ::mesos::SlaveID& TaskInfo::slave_id() const {
  const ::mesos::SlaveID* p = slave_id_;
  // @@protoc_insertion_point(field_get:mesos.TaskInfo.slave_id)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::SlaveID*>(
      &::mesos::_SlaveID_default_instance_);
}
inline ::mesos::SlaveID* TaskInfo::release_slave_id() {
  // @@protoc_insertion_point(field_release:mesos.TaskInfo.slave_id)
  clear_has_slave_id();
  ::mesos::SlaveID* temp = slave_id_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  slave_id_ = NULL;
  return temp;
}
inline ::mesos::SlaveID* TaskInfo::unsafe_arena_release_slave_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.TaskInfo.slave_id)
  clear_has_slave_id();
  ::mesos::SlaveID* temp = slave_id_;
  slave_id_ = NULL;
  return temp;
}
inline ::mesos::SlaveID* TaskInfo::mutable_slave_id() {
  set_has_slave_id();
  if (slave_id_ == NULL) {
    _slow_mutable_slave_id();
  }
  // @@protoc_insertion_point(field_mutable:mesos.TaskInfo.slave_id)
  return slave_id_;
}
inline void TaskInfo::set_allocated_slave_id(::mesos::SlaveID* slave_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete slave_id_;
  }
  if (slave_id) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(slave_id);
    if (message_arena != submessage_arena) {
      slave_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, slave_id, submessage_arena);
    }
    set_has_slave_id();
  } else {
    clear_has_slave_id();
  }
  slave_id_ = slave_id;
  // @@protoc_insertion_point(field_set_allocated:mesos.TaskInfo.slave_id)
}

// repeated .mesos.Resource resources = 4;
inline int TaskInfo::resources_size() const {
  return resources_.size();
}
inline void TaskInfo::clear_resources() {
  resources_.Clear();
}
inline const ::mesos::Resource& TaskInfo::resources(int index) const {
  // @@protoc_insertion_point(field_get:mesos.TaskInfo.resources)
  return resources_.Get(index);
}
inline ::mesos::Resource* TaskInfo::mutable_resources(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.TaskInfo.resources)
  return resources_.Mutable(index);
}
inline ::mesos::Resource* TaskInfo::add_resources() {
  // @@protoc_insertion_point(field_add:mesos.TaskInfo.resources)
  return resources_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
TaskInfo::mutable_resources() {
  // @@protoc_insertion_point(field_mutable_list:mesos.TaskInfo.resources)
  return &resources_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
TaskInfo::resources() const {
  // @@protoc_insertion_point(field_list:mesos.TaskInfo.resources)
  return resources_;
}

// optional .mesos.ExecutorInfo executor = 5;
inline bool TaskInfo::has_executor() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TaskInfo::set_has_executor() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TaskInfo::clear_has_executor() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TaskInfo::clear_executor() {
  if (executor_ != NULL) executor_->Clear();
  clear_has_executor();
}
inline const ::mesos::ExecutorInfo& TaskInfo::executor() const {
  const ::mesos::ExecutorInfo* p = executor_;
  // @@protoc_insertion_point(field_get:mesos.TaskInfo.executor)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ExecutorInfo*>(
      &::mesos::_ExecutorInfo_default_instance_);
}
inline ::mesos::ExecutorInfo* TaskInfo::release_executor() {
  // @@protoc_insertion_point(field_release:mesos.TaskInfo.executor)
  clear_has_executor();
  ::mesos::ExecutorInfo* temp = executor_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  executor_ = NULL;
  return temp;
}
inline ::mesos::ExecutorInfo* TaskInfo::unsafe_arena_release_executor() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.TaskInfo.executor)
  clear_has_executor();
  ::mesos::ExecutorInfo* temp = executor_;
  executor_ = NULL;
  return temp;
}
inline ::mesos::ExecutorInfo* TaskInfo::mutable_executor() {
  set_has_executor();
  if (executor_ == NULL) {
    _slow_mutable_executor();
  }
  // @@protoc_insertion_point(field_mutable:mesos.TaskInfo.executor)
  return executor_;
}
inline void TaskInfo::set_allocated_executor(::mesos::ExecutorInfo* executor) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete executor_;
  }
  if (executor) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(executor);
    if (message_arena != submessage_arena) {
      executor = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, executor, submessage_arena);
    }
    set_has_executor();
  } else {
    clear_has_executor();
  }
  executor_ = executor;
  // @@protoc_insertion_point(field_set_allocated:mesos.TaskInfo.executor)
}

// optional .mesos.CommandInfo command = 7;
inline bool TaskInfo::has_command() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TaskInfo::set_has_command() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TaskInfo::clear_has_command() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TaskInfo::clear_command() {
  if (command_ != NULL) command_->Clear();
  clear_has_command();
}
inline const ::mesos::CommandInfo& TaskInfo::command() const {
  const ::mesos::CommandInfo* p = command_;
  // @@protoc_insertion_point(field_get:mesos.TaskInfo.command)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::CommandInfo*>(
      &::mesos::_CommandInfo_default_instance_);
}
inline ::mesos::CommandInfo* TaskInfo::release_command() {
  // @@protoc_insertion_point(field_release:mesos.TaskInfo.command)
  clear_has_command();
  ::mesos::CommandInfo* temp = command_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  command_ = NULL;
  return temp;
}
inline ::mesos::CommandInfo* TaskInfo::unsafe_arena_release_command() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.TaskInfo.command)
  clear_has_command();
  ::mesos::CommandInfo* temp = command_;
  command_ = NULL;
  return temp;
}
inline ::mesos::CommandInfo* TaskInfo::mutable_command() {
  set_has_command();
  if (command_ == NULL) {
    _slow_mutable_command();
  }
  // @@protoc_insertion_point(field_mutable:mesos.TaskInfo.command)
  return command_;
}
inline void TaskInfo::set_allocated_command(::mesos::CommandInfo* command) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete command_;
  }
  if (command) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(command);
    if (message_arena != submessage_arena) {
      command = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, command, submessage_arena);
    }
    set_has_command();
  } else {
    clear_has_command();
  }
  command_ = command;
  // @@protoc_insertion_point(field_set_allocated:mesos.TaskInfo.command)
}

// optional .mesos.ContainerInfo container = 9;
inline bool TaskInfo::has_container() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TaskInfo::set_has_container() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TaskInfo::clear_has_container() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TaskInfo::clear_container() {
  if (container_ != NULL) container_->Clear();
  clear_has_container();
}
inline const ::mesos::ContainerInfo& TaskInfo::container() const {
  const ::mesos::ContainerInfo* p = container_;
  // @@protoc_insertion_point(field_get:mesos.TaskInfo.container)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ContainerInfo*>(
      &::mesos::_ContainerInfo_default_instance_);
}
inline ::mesos::ContainerInfo* TaskInfo::release_container() {
  // @@protoc_insertion_point(field_release:mesos.TaskInfo.container)
  clear_has_container();
  ::mesos::ContainerInfo* temp = container_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  container_ = NULL;
  return temp;
}
inline ::mesos::ContainerInfo* TaskInfo::unsafe_arena_release_container() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.TaskInfo.container)
  clear_has_container();
  ::mesos::ContainerInfo* temp = container_;
  container_ = NULL;
  return temp;
}
inline ::mesos::ContainerInfo* TaskInfo::mutable_container() {
  set_has_container();
  if (container_ == NULL) {
    _slow_mutable_container();
  }
  // @@protoc_insertion_point(field_mutable:mesos.TaskInfo.container)
  return container_;
}
inline void TaskInfo::set_allocated_container(::mesos::ContainerInfo* container) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete container_;
  }
  if (container) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(container);
    if (message_arena != submessage_arena) {
      container = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, container, submessage_arena);
    }
    set_has_container();
  } else {
    clear_has_container();
  }
  container_ = container;
  // @@protoc_insertion_point(field_set_allocated:mesos.TaskInfo.container)
}

// optional .mesos.HealthCheck health_check = 8;
inline bool TaskInfo::has_health_check() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TaskInfo::set_has_health_check() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TaskInfo::clear_has_health_check() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TaskInfo::clear_health_check() {
  if (health_check_ != NULL) health_check_->Clear();
  clear_has_health_check();
}
inline const ::mesos::HealthCheck& TaskInfo::health_check() const {
  const ::mesos::HealthCheck* p = health_check_;
  // @@protoc_insertion_point(field_get:mesos.TaskInfo.health_check)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::HealthCheck*>(
      &::mesos::_HealthCheck_default_instance_);
}
inline ::mesos::HealthCheck* TaskInfo::release_health_check() {
  // @@protoc_insertion_point(field_release:mesos.TaskInfo.health_check)
  clear_has_health_check();
  ::mesos::HealthCheck* temp = health_check_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  health_check_ = NULL;
  return temp;
}
inline ::mesos::HealthCheck* TaskInfo::unsafe_arena_release_health_check() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.TaskInfo.health_check)
  clear_has_health_check();
  ::mesos::HealthCheck* temp = health_check_;
  health_check_ = NULL;
  return temp;
}
inline ::mesos::HealthCheck* TaskInfo::mutable_health_check() {
  set_has_health_check();
  if (health_check_ == NULL) {
    _slow_mutable_health_check();
  }
  // @@protoc_insertion_point(field_mutable:mesos.TaskInfo.health_check)
  return health_check_;
}
inline void TaskInfo::set_allocated_health_check(::mesos::HealthCheck* health_check) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete health_check_;
  }
  if (health_check) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(health_check);
    if (message_arena != submessage_arena) {
      health_check = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, health_check, submessage_arena);
    }
    set_has_health_check();
  } else {
    clear_has_health_check();
  }
  health_check_ = health_check;
  // @@protoc_insertion_point(field_set_allocated:mesos.TaskInfo.health_check)
}

// optional .mesos.CheckInfo check = 13;
inline bool TaskInfo::has_check() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TaskInfo::set_has_check() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TaskInfo::clear_has_check() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TaskInfo::clear_check() {
  if (check_ != NULL) check_->Clear();
  clear_has_check();
}
inline const ::mesos::CheckInfo& TaskInfo::check() const {
  const ::mesos::CheckInfo* p = check_;
  // @@protoc_insertion_point(field_get:mesos.TaskInfo.check)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::CheckInfo*>(
      &::mesos::_CheckInfo_default_instance_);
}
inline ::mesos::CheckInfo* TaskInfo::release_check() {
  // @@protoc_insertion_point(field_release:mesos.TaskInfo.check)
  clear_has_check();
  ::mesos::CheckInfo* temp = check_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  check_ = NULL;
  return temp;
}
inline ::mesos::CheckInfo* TaskInfo::unsafe_arena_release_check() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.TaskInfo.check)
  clear_has_check();
  ::mesos::CheckInfo* temp = check_;
  check_ = NULL;
  return temp;
}
inline ::mesos::CheckInfo* TaskInfo::mutable_check() {
  set_has_check();
  if (check_ == NULL) {
    _slow_mutable_check();
  }
  // @@protoc_insertion_point(field_mutable:mesos.TaskInfo.check)
  return check_;
}
inline void TaskInfo::set_allocated_check(::mesos::CheckInfo* check) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete check_;
  }
  if (check) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(check);
    if (message_arena != submessage_arena) {
      check = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, check, submessage_arena);
    }
    set_has_check();
  } else {
    clear_has_check();
  }
  check_ = check;
  // @@protoc_insertion_point(field_set_allocated:mesos.TaskInfo.check)
}

// optional .mesos.KillPolicy kill_policy = 12;
inline bool TaskInfo::has_kill_policy() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TaskInfo::set_has_kill_policy() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TaskInfo::clear_has_kill_policy() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TaskInfo::clear_kill_policy() {
  if (kill_policy_ != NULL) kill_policy_->Clear();
  clear_has_kill_policy();
}
inline const ::mesos::KillPolicy& TaskInfo::kill_policy() const {
  const ::mesos::KillPolicy* p = kill_policy_;
  // @@protoc_insertion_point(field_get:mesos.TaskInfo.kill_policy)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::KillPolicy*>(
      &::mesos::_KillPolicy_default_instance_);
}
inline ::mesos::KillPolicy* TaskInfo::release_kill_policy() {
  // @@protoc_insertion_point(field_release:mesos.TaskInfo.kill_policy)
  clear_has_kill_policy();
  ::mesos::KillPolicy* temp = kill_policy_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  kill_policy_ = NULL;
  return temp;
}
inline ::mesos::KillPolicy* TaskInfo::unsafe_arena_release_kill_policy() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.TaskInfo.kill_policy)
  clear_has_kill_policy();
  ::mesos::KillPolicy* temp = kill_policy_;
  kill_policy_ = NULL;
  return temp;
}
inline ::mesos::KillPolicy* TaskInfo::mutable_kill_policy() {
  set_has_kill_policy();
  if (kill_policy_ == NULL) {
    _slow_mutable_kill_policy();
  }
  // @@protoc_insertion_point(field_mutable:mesos.TaskInfo.kill_policy)
  return kill_policy_;
}
inline void TaskInfo::set_allocated_kill_policy(::mesos::KillPolicy* kill_policy) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete kill_policy_;
  }
  if (kill_policy) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(kill_policy);
    if (message_arena != submessage_arena) {
      kill_policy = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, kill_policy, submessage_arena);
    }
    set_has_kill_policy();
  } else {
    clear_has_kill_policy();
  }
  kill_policy_ = kill_policy;
  // @@protoc_insertion_point(field_set_allocated:mesos.TaskInfo.kill_policy)
}

// optional bytes data = 6;
inline bool TaskInfo::has_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TaskInfo::set_has_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TaskInfo::clear_has_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TaskInfo::clear_data() {
  data_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_data();
}
inline const ::std::string& TaskInfo::data() const {
  // @@protoc_insertion_point(field_get:mesos.TaskInfo.data)
  return data_.Get();
}
inline void TaskInfo::set_data(const ::std::string& value) {
  set_has_data();
  data_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.TaskInfo.data)
}
#if LANG_CXX11
inline void TaskInfo::set_data(::std::string&& value) {
  set_has_data();
  data_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.TaskInfo.data)
}
#endif
inline void TaskInfo::set_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_data();
  data_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.TaskInfo.data)
}
inline void TaskInfo::set_data(const void* value,
    size_t size) {
  set_has_data();
  data_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.TaskInfo.data)
}
inline ::std::string* TaskInfo::mutable_data() {
  set_has_data();
  // @@protoc_insertion_point(field_mutable:mesos.TaskInfo.data)
  return data_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* TaskInfo::release_data() {
  // @@protoc_insertion_point(field_release:mesos.TaskInfo.data)
  clear_has_data();
  return data_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void TaskInfo::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    set_has_data();
  } else {
    clear_has_data();
  }
  data_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.TaskInfo.data)
}
inline ::std::string* TaskInfo::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.TaskInfo.data)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_data();
  return data_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void TaskInfo::unsafe_arena_set_allocated_data(
    ::std::string* data) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (data != NULL) {
    set_has_data();
  } else {
    clear_has_data();
  }
  data_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      data, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.TaskInfo.data)
}

// optional .mesos.Labels labels = 10;
inline bool TaskInfo::has_labels() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TaskInfo::set_has_labels() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TaskInfo::clear_has_labels() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TaskInfo::clear_labels() {
  if (labels_ != NULL) labels_->Clear();
  clear_has_labels();
}
inline const ::mesos::Labels& TaskInfo::labels() const {
  const ::mesos::Labels* p = labels_;
  // @@protoc_insertion_point(field_get:mesos.TaskInfo.labels)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::Labels*>(
      &::mesos::_Labels_default_instance_);
}
inline ::mesos::Labels* TaskInfo::release_labels() {
  // @@protoc_insertion_point(field_release:mesos.TaskInfo.labels)
  clear_has_labels();
  ::mesos::Labels* temp = labels_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  labels_ = NULL;
  return temp;
}
inline ::mesos::Labels* TaskInfo::unsafe_arena_release_labels() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.TaskInfo.labels)
  clear_has_labels();
  ::mesos::Labels* temp = labels_;
  labels_ = NULL;
  return temp;
}
inline ::mesos::Labels* TaskInfo::mutable_labels() {
  set_has_labels();
  if (labels_ == NULL) {
    _slow_mutable_labels();
  }
  // @@protoc_insertion_point(field_mutable:mesos.TaskInfo.labels)
  return labels_;
}
inline void TaskInfo::set_allocated_labels(::mesos::Labels* labels) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete labels_;
  }
  if (labels) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(labels);
    if (message_arena != submessage_arena) {
      labels = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, labels, submessage_arena);
    }
    set_has_labels();
  } else {
    clear_has_labels();
  }
  labels_ = labels;
  // @@protoc_insertion_point(field_set_allocated:mesos.TaskInfo.labels)
}

// optional .mesos.DiscoveryInfo discovery = 11;
inline bool TaskInfo::has_discovery() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TaskInfo::set_has_discovery() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TaskInfo::clear_has_discovery() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TaskInfo::clear_discovery() {
  if (discovery_ != NULL) discovery_->Clear();
  clear_has_discovery();
}
inline const ::mesos::DiscoveryInfo& TaskInfo::discovery() const {
  const ::mesos::DiscoveryInfo* p = discovery_;
  // @@protoc_insertion_point(field_get:mesos.TaskInfo.discovery)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::DiscoveryInfo*>(
      &::mesos::_DiscoveryInfo_default_instance_);
}
inline ::mesos::DiscoveryInfo* TaskInfo::release_discovery() {
  // @@protoc_insertion_point(field_release:mesos.TaskInfo.discovery)
  clear_has_discovery();
  ::mesos::DiscoveryInfo* temp = discovery_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  discovery_ = NULL;
  return temp;
}
inline ::mesos::DiscoveryInfo* TaskInfo::unsafe_arena_release_discovery() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.TaskInfo.discovery)
  clear_has_discovery();
  ::mesos::DiscoveryInfo* temp = discovery_;
  discovery_ = NULL;
  return temp;
}
inline ::mesos::DiscoveryInfo* TaskInfo::mutable_discovery() {
  set_has_discovery();
  if (discovery_ == NULL) {
    _slow_mutable_discovery();
  }
  // @@protoc_insertion_point(field_mutable:mesos.TaskInfo.discovery)
  return discovery_;
}
inline void TaskInfo::set_allocated_discovery(::mesos::DiscoveryInfo* discovery) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete discovery_;
  }
  if (discovery) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(discovery);
    if (message_arena != submessage_arena) {
      discovery = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, discovery, submessage_arena);
    }
    set_has_discovery();
  } else {
    clear_has_discovery();
  }
  discovery_ = discovery;
  // @@protoc_insertion_point(field_set_allocated:mesos.TaskInfo.discovery)
}

// optional .mesos.DurationInfo max_completion_time = 14;
inline bool TaskInfo::has_max_completion_time() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void TaskInfo::set_has_max_completion_time() {
  _has_bits_[0] |= 0x00001000u;
}
inline void TaskInfo::clear_has_max_completion_time() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void TaskInfo::clear_max_completion_time() {
  if (max_completion_time_ != NULL) max_completion_time_->Clear();
  clear_has_max_completion_time();
}
inline const ::mesos::DurationInfo& TaskInfo::max_completion_time() const {
  const ::mesos::DurationInfo* p = max_completion_time_;
  // @@protoc_insertion_point(field_get:mesos.TaskInfo.max_completion_time)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::DurationInfo*>(
      &::mesos::_DurationInfo_default_instance_);
}
inline ::mesos::DurationInfo* TaskInfo::release_max_completion_time() {
  // @@protoc_insertion_point(field_release:mesos.TaskInfo.max_completion_time)
  clear_has_max_completion_time();
  ::mesos::DurationInfo* temp = max_completion_time_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  max_completion_time_ = NULL;
  return temp;
}
inline ::mesos::DurationInfo* TaskInfo::unsafe_arena_release_max_completion_time() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.TaskInfo.max_completion_time)
  clear_has_max_completion_time();
  ::mesos::DurationInfo* temp = max_completion_time_;
  max_completion_time_ = NULL;
  return temp;
}
inline ::mesos::DurationInfo* TaskInfo::mutable_max_completion_time() {
  set_has_max_completion_time();
  if (max_completion_time_ == NULL) {
    _slow_mutable_max_completion_time();
  }
  // @@protoc_insertion_point(field_mutable:mesos.TaskInfo.max_completion_time)
  return max_completion_time_;
}
inline void TaskInfo::set_allocated_max_completion_time(::mesos::DurationInfo* max_completion_time) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete max_completion_time_;
  }
  if (max_completion_time) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(max_completion_time);
    if (message_arena != submessage_arena) {
      max_completion_time = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, max_completion_time, submessage_arena);
    }
    set_has_max_completion_time();
  } else {
    clear_has_max_completion_time();
  }
  max_completion_time_ = max_completion_time;
  // @@protoc_insertion_point(field_set_allocated:mesos.TaskInfo.max_completion_time)
}

// -------------------------------------------------------------------

// TaskGroupInfo

// repeated .mesos.TaskInfo tasks = 1;
inline int TaskGroupInfo::tasks_size() const {
  return tasks_.size();
}
inline void TaskGroupInfo::clear_tasks() {
  tasks_.Clear();
}
inline const ::mesos::TaskInfo& TaskGroupInfo::tasks(int index) const {
  // @@protoc_insertion_point(field_get:mesos.TaskGroupInfo.tasks)
  return tasks_.Get(index);
}
inline ::mesos::TaskInfo* TaskGroupInfo::mutable_tasks(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.TaskGroupInfo.tasks)
  return tasks_.Mutable(index);
}
inline ::mesos::TaskInfo* TaskGroupInfo::add_tasks() {
  // @@protoc_insertion_point(field_add:mesos.TaskGroupInfo.tasks)
  return tasks_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::TaskInfo >*
TaskGroupInfo::mutable_tasks() {
  // @@protoc_insertion_point(field_mutable_list:mesos.TaskGroupInfo.tasks)
  return &tasks_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::TaskInfo >&
TaskGroupInfo::tasks() const {
  // @@protoc_insertion_point(field_list:mesos.TaskGroupInfo.tasks)
  return tasks_;
}

// -------------------------------------------------------------------

// Task

// required string name = 1;
inline bool Task::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Task::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Task::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Task::clear_name() {
  name_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_name();
}
inline const ::std::string& Task::name() const {
  // @@protoc_insertion_point(field_get:mesos.Task.name)
  return name_.Get();
}
inline void Task::set_name(const ::std::string& value) {
  set_has_name();
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.Task.name)
}
#if LANG_CXX11
inline void Task::set_name(::std::string&& value) {
  set_has_name();
  name_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.Task.name)
}
#endif
inline void Task::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.Task.name)
}
inline void Task::set_name(const char* value,
    size_t size) {
  set_has_name();
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.Task.name)
}
inline ::std::string* Task::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:mesos.Task.name)
  return name_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* Task::release_name() {
  // @@protoc_insertion_point(field_release:mesos.Task.name)
  clear_has_name();
  return name_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void Task::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.Task.name)
}
inline ::std::string* Task::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Task.name)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_name();
  return name_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void Task::unsafe_arena_set_allocated_name(
    ::std::string* name) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      name, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.Task.name)
}

// required .mesos.TaskID task_id = 2;
inline bool Task::has_task_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Task::set_has_task_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Task::clear_has_task_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Task::clear_task_id() {
  if (task_id_ != NULL) task_id_->Clear();
  clear_has_task_id();
}
inline const ::mesos::TaskID& Task::task_id() const {
  const ::mesos::TaskID* p = task_id_;
  // @@protoc_insertion_point(field_get:mesos.Task.task_id)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::TaskID*>(
      &::mesos::_TaskID_default_instance_);
}
inline ::mesos::TaskID* Task::release_task_id() {
  // @@protoc_insertion_point(field_release:mesos.Task.task_id)
  clear_has_task_id();
  ::mesos::TaskID* temp = task_id_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  task_id_ = NULL;
  return temp;
}
inline ::mesos::TaskID* Task::unsafe_arena_release_task_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Task.task_id)
  clear_has_task_id();
  ::mesos::TaskID* temp = task_id_;
  task_id_ = NULL;
  return temp;
}
inline ::mesos::TaskID* Task::mutable_task_id() {
  set_has_task_id();
  if (task_id_ == NULL) {
    _slow_mutable_task_id();
  }
  // @@protoc_insertion_point(field_mutable:mesos.Task.task_id)
  return task_id_;
}
inline void Task::set_allocated_task_id(::mesos::TaskID* task_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete task_id_;
  }
  if (task_id) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(task_id);
    if (message_arena != submessage_arena) {
      task_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, task_id, submessage_arena);
    }
    set_has_task_id();
  } else {
    clear_has_task_id();
  }
  task_id_ = task_id;
  // @@protoc_insertion_point(field_set_allocated:mesos.Task.task_id)
}

// required .mesos.FrameworkID framework_id = 3;
inline bool Task::has_framework_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Task::set_has_framework_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Task::clear_has_framework_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Task::clear_framework_id() {
  if (framework_id_ != NULL) framework_id_->Clear();
  clear_has_framework_id();
}
inline const ::mesos::FrameworkID& Task::framework_id() const {
  const ::mesos::FrameworkID* p = framework_id_;
  // @@protoc_insertion_point(field_get:mesos.Task.framework_id)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::FrameworkID*>(
      &::mesos::_FrameworkID_default_instance_);
}
inline ::mesos::FrameworkID* Task::release_framework_id() {
  // @@protoc_insertion_point(field_release:mesos.Task.framework_id)
  clear_has_framework_id();
  ::mesos::FrameworkID* temp = framework_id_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  framework_id_ = NULL;
  return temp;
}
inline ::mesos::FrameworkID* Task::unsafe_arena_release_framework_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Task.framework_id)
  clear_has_framework_id();
  ::mesos::FrameworkID* temp = framework_id_;
  framework_id_ = NULL;
  return temp;
}
inline ::mesos::FrameworkID* Task::mutable_framework_id() {
  set_has_framework_id();
  if (framework_id_ == NULL) {
    _slow_mutable_framework_id();
  }
  // @@protoc_insertion_point(field_mutable:mesos.Task.framework_id)
  return framework_id_;
}
inline void Task::set_allocated_framework_id(::mesos::FrameworkID* framework_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete framework_id_;
  }
  if (framework_id) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(framework_id);
    if (message_arena != submessage_arena) {
      framework_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, framework_id, submessage_arena);
    }
    set_has_framework_id();
  } else {
    clear_has_framework_id();
  }
  framework_id_ = framework_id;
  // @@protoc_insertion_point(field_set_allocated:mesos.Task.framework_id)
}

// optional .mesos.ExecutorID executor_id = 4;
inline bool Task::has_executor_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Task::set_has_executor_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Task::clear_has_executor_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Task::clear_executor_id() {
  if (executor_id_ != NULL) executor_id_->Clear();
  clear_has_executor_id();
}
inline const ::mesos::ExecutorID& Task::executor_id() const {
  const ::mesos::ExecutorID* p = executor_id_;
  // @@protoc_insertion_point(field_get:mesos.Task.executor_id)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ExecutorID*>(
      &::mesos::_ExecutorID_default_instance_);
}
inline ::mesos::ExecutorID* Task::release_executor_id() {
  // @@protoc_insertion_point(field_release:mesos.Task.executor_id)
  clear_has_executor_id();
  ::mesos::ExecutorID* temp = executor_id_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  executor_id_ = NULL;
  return temp;
}
inline ::mesos::ExecutorID* Task::unsafe_arena_release_executor_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Task.executor_id)
  clear_has_executor_id();
  ::mesos::ExecutorID* temp = executor_id_;
  executor_id_ = NULL;
  return temp;
}
inline ::mesos::ExecutorID* Task::mutable_executor_id() {
  set_has_executor_id();
  if (executor_id_ == NULL) {
    _slow_mutable_executor_id();
  }
  // @@protoc_insertion_point(field_mutable:mesos.Task.executor_id)
  return executor_id_;
}
inline void Task::set_allocated_executor_id(::mesos::ExecutorID* executor_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete executor_id_;
  }
  if (executor_id) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(executor_id);
    if (message_arena != submessage_arena) {
      executor_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, executor_id, submessage_arena);
    }
    set_has_executor_id();
  } else {
    clear_has_executor_id();
  }
  executor_id_ = executor_id;
  // @@protoc_insertion_point(field_set_allocated:mesos.Task.executor_id)
}

// required .mesos.SlaveID slave_id = 5;
inline bool Task::has_slave_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Task::set_has_slave_id() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Task::clear_has_slave_id() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Task::clear_slave_id() {
  if (slave_id_ != NULL) slave_id_->Clear();
  clear_has_slave_id();
}
inline const ::mesos::SlaveID& Task::slave_id() const {
  const ::mesos::SlaveID* p = slave_id_;
  // @@protoc_insertion_point(field_get:mesos.Task.slave_id)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::SlaveID*>(
      &::mesos::_SlaveID_default_instance_);
}
inline ::mesos::SlaveID* Task::release_slave_id() {
  // @@protoc_insertion_point(field_release:mesos.Task.slave_id)
  clear_has_slave_id();
  ::mesos::SlaveID* temp = slave_id_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  slave_id_ = NULL;
  return temp;
}
inline ::mesos::SlaveID* Task::unsafe_arena_release_slave_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Task.slave_id)
  clear_has_slave_id();
  ::mesos::SlaveID* temp = slave_id_;
  slave_id_ = NULL;
  return temp;
}
inline ::mesos::SlaveID* Task::mutable_slave_id() {
  set_has_slave_id();
  if (slave_id_ == NULL) {
    _slow_mutable_slave_id();
  }
  // @@protoc_insertion_point(field_mutable:mesos.Task.slave_id)
  return slave_id_;
}
inline void Task::set_allocated_slave_id(::mesos::SlaveID* slave_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete slave_id_;
  }
  if (slave_id) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(slave_id);
    if (message_arena != submessage_arena) {
      slave_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, slave_id, submessage_arena);
    }
    set_has_slave_id();
  } else {
    clear_has_slave_id();
  }
  slave_id_ = slave_id;
  // @@protoc_insertion_point(field_set_allocated:mesos.Task.slave_id)
}

// required .mesos.TaskState state = 6;
inline bool Task::has_state() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Task::set_has_state() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Task::clear_has_state() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Task::clear_state() {
  state_ = 6;
  clear_has_state();
}
inline ::mesos::TaskState Task::state() const {
  // @@protoc_insertion_point(field_get:mesos.Task.state)
  return static_cast< ::mesos::TaskState >(state_);
}
inline void Task::set_state(::mesos::TaskState value) {
  assert(::mesos::TaskState_IsValid(value));
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:mesos.Task.state)
}

// repeated .mesos.Resource resources = 7;
inline int Task::resources_size() const {
  return resources_.size();
}
inline void Task::clear_resources() {
  resources_.Clear();
}
inline const ::mesos::Resource& Task::resources(int index) const {
  // @@protoc_insertion_point(field_get:mesos.Task.resources)
  return resources_.Get(index);
}
inline ::mesos::Resource* Task::mutable_resources(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.Task.resources)
  return resources_.Mutable(index);
}
inline ::mesos::Resource* Task::add_resources() {
  // @@protoc_insertion_point(field_add:mesos.Task.resources)
  return resources_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
Task::mutable_resources() {
  // @@protoc_insertion_point(field_mutable_list:mesos.Task.resources)
  return &resources_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
Task::resources() const {
  // @@protoc_insertion_point(field_list:mesos.Task.resources)
  return resources_;
}

// repeated .mesos.TaskStatus statuses = 8;
inline int Task::statuses_size() const {
  return statuses_.size();
}
inline void Task::clear_statuses() {
  statuses_.Clear();
}
inline const ::mesos::TaskStatus& Task::statuses(int index) const {
  // @@protoc_insertion_point(field_get:mesos.Task.statuses)
  return statuses_.Get(index);
}
inline ::mesos::TaskStatus* Task::mutable_statuses(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.Task.statuses)
  return statuses_.Mutable(index);
}
inline ::mesos::TaskStatus* Task::add_statuses() {
  // @@protoc_insertion_point(field_add:mesos.Task.statuses)
  return statuses_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::TaskStatus >*
Task::mutable_statuses() {
  // @@protoc_insertion_point(field_mutable_list:mesos.Task.statuses)
  return &statuses_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::TaskStatus >&
Task::statuses() const {
  // @@protoc_insertion_point(field_list:mesos.Task.statuses)
  return statuses_;
}

// optional .mesos.TaskState status_update_state = 9;
inline bool Task::has_status_update_state() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Task::set_has_status_update_state() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Task::clear_has_status_update_state() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Task::clear_status_update_state() {
  status_update_state_ = 6;
  clear_has_status_update_state();
}
inline ::mesos::TaskState Task::status_update_state() const {
  // @@protoc_insertion_point(field_get:mesos.Task.status_update_state)
  return static_cast< ::mesos::TaskState >(status_update_state_);
}
inline void Task::set_status_update_state(::mesos::TaskState value) {
  assert(::mesos::TaskState_IsValid(value));
  set_has_status_update_state();
  status_update_state_ = value;
  // @@protoc_insertion_point(field_set:mesos.Task.status_update_state)
}

// optional bytes status_update_uuid = 10;
inline bool Task::has_status_update_uuid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Task::set_has_status_update_uuid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Task::clear_has_status_update_uuid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Task::clear_status_update_uuid() {
  status_update_uuid_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_status_update_uuid();
}
inline const ::std::string& Task::status_update_uuid() const {
  // @@protoc_insertion_point(field_get:mesos.Task.status_update_uuid)
  return status_update_uuid_.Get();
}
inline void Task::set_status_update_uuid(const ::std::string& value) {
  set_has_status_update_uuid();
  status_update_uuid_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.Task.status_update_uuid)
}
#if LANG_CXX11
inline void Task::set_status_update_uuid(::std::string&& value) {
  set_has_status_update_uuid();
  status_update_uuid_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.Task.status_update_uuid)
}
#endif
inline void Task::set_status_update_uuid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_status_update_uuid();
  status_update_uuid_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.Task.status_update_uuid)
}
inline void Task::set_status_update_uuid(const void* value,
    size_t size) {
  set_has_status_update_uuid();
  status_update_uuid_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.Task.status_update_uuid)
}
inline ::std::string* Task::mutable_status_update_uuid() {
  set_has_status_update_uuid();
  // @@protoc_insertion_point(field_mutable:mesos.Task.status_update_uuid)
  return status_update_uuid_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* Task::release_status_update_uuid() {
  // @@protoc_insertion_point(field_release:mesos.Task.status_update_uuid)
  clear_has_status_update_uuid();
  return status_update_uuid_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void Task::set_allocated_status_update_uuid(::std::string* status_update_uuid) {
  if (status_update_uuid != NULL) {
    set_has_status_update_uuid();
  } else {
    clear_has_status_update_uuid();
  }
  status_update_uuid_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), status_update_uuid,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.Task.status_update_uuid)
}
inline ::std::string* Task::unsafe_arena_release_status_update_uuid() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Task.status_update_uuid)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_status_update_uuid();
  return status_update_uuid_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void Task::unsafe_arena_set_allocated_status_update_uuid(
    ::std::string* status_update_uuid) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (status_update_uuid != NULL) {
    set_has_status_update_uuid();
  } else {
    clear_has_status_update_uuid();
  }
  status_update_uuid_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      status_update_uuid, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.Task.status_update_uuid)
}

// optional .mesos.Labels labels = 11;
inline bool Task::has_labels() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Task::set_has_labels() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Task::clear_has_labels() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Task::clear_labels() {
  if (labels_ != NULL) labels_->Clear();
  clear_has_labels();
}
inline const ::mesos::Labels& Task::labels() const {
  const ::mesos::Labels* p = labels_;
  // @@protoc_insertion_point(field_get:mesos.Task.labels)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::Labels*>(
      &::mesos::_Labels_default_instance_);
}
inline ::mesos::Labels* Task::release_labels() {
  // @@protoc_insertion_point(field_release:mesos.Task.labels)
  clear_has_labels();
  ::mesos::Labels* temp = labels_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  labels_ = NULL;
  return temp;
}
inline ::mesos::Labels* Task::unsafe_arena_release_labels() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Task.labels)
  clear_has_labels();
  ::mesos::Labels* temp = labels_;
  labels_ = NULL;
  return temp;
}
inline ::mesos::Labels* Task::mutable_labels() {
  set_has_labels();
  if (labels_ == NULL) {
    _slow_mutable_labels();
  }
  // @@protoc_insertion_point(field_mutable:mesos.Task.labels)
  return labels_;
}
inline void Task::set_allocated_labels(::mesos::Labels* labels) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete labels_;
  }
  if (labels) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(labels);
    if (message_arena != submessage_arena) {
      labels = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, labels, submessage_arena);
    }
    set_has_labels();
  } else {
    clear_has_labels();
  }
  labels_ = labels;
  // @@protoc_insertion_point(field_set_allocated:mesos.Task.labels)
}

// optional .mesos.DiscoveryInfo discovery = 12;
inline bool Task::has_discovery() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Task::set_has_discovery() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Task::clear_has_discovery() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Task::clear_discovery() {
  if (discovery_ != NULL) discovery_->Clear();
  clear_has_discovery();
}
inline const ::mesos::DiscoveryInfo& Task::discovery() const {
  const ::mesos::DiscoveryInfo* p = discovery_;
  // @@protoc_insertion_point(field_get:mesos.Task.discovery)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::DiscoveryInfo*>(
      &::mesos::_DiscoveryInfo_default_instance_);
}
inline ::mesos::DiscoveryInfo* Task::release_discovery() {
  // @@protoc_insertion_point(field_release:mesos.Task.discovery)
  clear_has_discovery();
  ::mesos::DiscoveryInfo* temp = discovery_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  discovery_ = NULL;
  return temp;
}
inline ::mesos::DiscoveryInfo* Task::unsafe_arena_release_discovery() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Task.discovery)
  clear_has_discovery();
  ::mesos::DiscoveryInfo* temp = discovery_;
  discovery_ = NULL;
  return temp;
}
inline ::mesos::DiscoveryInfo* Task::mutable_discovery() {
  set_has_discovery();
  if (discovery_ == NULL) {
    _slow_mutable_discovery();
  }
  // @@protoc_insertion_point(field_mutable:mesos.Task.discovery)
  return discovery_;
}
inline void Task::set_allocated_discovery(::mesos::DiscoveryInfo* discovery) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete discovery_;
  }
  if (discovery) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(discovery);
    if (message_arena != submessage_arena) {
      discovery = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, discovery, submessage_arena);
    }
    set_has_discovery();
  } else {
    clear_has_discovery();
  }
  discovery_ = discovery;
  // @@protoc_insertion_point(field_set_allocated:mesos.Task.discovery)
}

// optional .mesos.ContainerInfo container = 13;
inline bool Task::has_container() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Task::set_has_container() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Task::clear_has_container() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Task::clear_container() {
  if (container_ != NULL) container_->Clear();
  clear_has_container();
}
inline const ::mesos::ContainerInfo& Task::container() const {
  const ::mesos::ContainerInfo* p = container_;
  // @@protoc_insertion_point(field_get:mesos.Task.container)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ContainerInfo*>(
      &::mesos::_ContainerInfo_default_instance_);
}
inline ::mesos::ContainerInfo* Task::release_container() {
  // @@protoc_insertion_point(field_release:mesos.Task.container)
  clear_has_container();
  ::mesos::ContainerInfo* temp = container_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  container_ = NULL;
  return temp;
}
inline ::mesos::ContainerInfo* Task::unsafe_arena_release_container() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Task.container)
  clear_has_container();
  ::mesos::ContainerInfo* temp = container_;
  container_ = NULL;
  return temp;
}
inline ::mesos::ContainerInfo* Task::mutable_container() {
  set_has_container();
  if (container_ == NULL) {
    _slow_mutable_container();
  }
  // @@protoc_insertion_point(field_mutable:mesos.Task.container)
  return container_;
}
inline void Task::set_allocated_container(::mesos::ContainerInfo* container) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete container_;
  }
  if (container) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(container);
    if (message_arena != submessage_arena) {
      container = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, container, submessage_arena);
    }
    set_has_container();
  } else {
    clear_has_container();
  }
  container_ = container;
  // @@protoc_insertion_point(field_set_allocated:mesos.Task.container)
}

// optional string user = 14;
inline bool Task::has_user() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Task::set_has_user() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Task::clear_has_user() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Task::clear_user() {
  user_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_user();
}
inline const ::std::string& Task::user() const {
  // @@protoc_insertion_point(field_get:mesos.Task.user)
  return user_.Get();
}
inline void Task::set_user(const ::std::string& value) {
  set_has_user();
  user_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.Task.user)
}
#if LANG_CXX11
inline void Task::set_user(::std::string&& value) {
  set_has_user();
  user_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.Task.user)
}
#endif
inline void Task::set_user(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_user();
  user_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.Task.user)
}
inline void Task::set_user(const char* value,
    size_t size) {
  set_has_user();
  user_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.Task.user)
}
inline ::std::string* Task::mutable_user() {
  set_has_user();
  // @@protoc_insertion_point(field_mutable:mesos.Task.user)
  return user_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* Task::release_user() {
  // @@protoc_insertion_point(field_release:mesos.Task.user)
  clear_has_user();
  return user_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void Task::set_allocated_user(::std::string* user) {
  if (user != NULL) {
    set_has_user();
  } else {
    clear_has_user();
  }
  user_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.Task.user)
}
inline ::std::string* Task::unsafe_arena_release_user() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Task.user)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_user();
  return user_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void Task::unsafe_arena_set_allocated_user(
    ::std::string* user) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (user != NULL) {
    set_has_user();
  } else {
    clear_has_user();
  }
  user_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      user, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.Task.user)
}

// -------------------------------------------------------------------

// TaskResourceLimitation

// repeated .mesos.Resource resources = 1;
inline int TaskResourceLimitation::resources_size() const {
  return resources_.size();
}
inline void TaskResourceLimitation::clear_resources() {
  resources_.Clear();
}
inline const ::mesos::Resource& TaskResourceLimitation::resources(int index) const {
  // @@protoc_insertion_point(field_get:mesos.TaskResourceLimitation.resources)
  return resources_.Get(index);
}
inline ::mesos::Resource* TaskResourceLimitation::mutable_resources(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.TaskResourceLimitation.resources)
  return resources_.Mutable(index);
}
inline ::mesos::Resource* TaskResourceLimitation::add_resources() {
  // @@protoc_insertion_point(field_add:mesos.TaskResourceLimitation.resources)
  return resources_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
TaskResourceLimitation::mutable_resources() {
  // @@protoc_insertion_point(field_mutable_list:mesos.TaskResourceLimitation.resources)
  return &resources_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
TaskResourceLimitation::resources() const {
  // @@protoc_insertion_point(field_list:mesos.TaskResourceLimitation.resources)
  return resources_;
}

// -------------------------------------------------------------------

// UUID

// required bytes value = 1;
inline bool UUID::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UUID::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UUID::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UUID::clear_value() {
  value_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_value();
}
inline const ::std::string& UUID::value() const {
  // @@protoc_insertion_point(field_get:mesos.UUID.value)
  return value_.Get();
}
inline void UUID::set_value(const ::std::string& value) {
  set_has_value();
  value_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.UUID.value)
}
#if LANG_CXX11
inline void UUID::set_value(::std::string&& value) {
  set_has_value();
  value_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.UUID.value)
}
#endif
inline void UUID::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_value();
  value_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.UUID.value)
}
inline void UUID::set_value(const void* value,
    size_t size) {
  set_has_value();
  value_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.UUID.value)
}
inline ::std::string* UUID::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:mesos.UUID.value)
  return value_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* UUID::release_value() {
  // @@protoc_insertion_point(field_release:mesos.UUID.value)
  clear_has_value();
  return value_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void UUID::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.UUID.value)
}
inline ::std::string* UUID::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.UUID.value)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_value();
  return value_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void UUID::unsafe_arena_set_allocated_value(
    ::std::string* value) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.UUID.value)
}

// -------------------------------------------------------------------

// Operation

// optional .mesos.FrameworkID framework_id = 1;
inline bool Operation::has_framework_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Operation::set_has_framework_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Operation::clear_has_framework_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Operation::clear_framework_id() {
  if (framework_id_ != NULL) framework_id_->Clear();
  clear_has_framework_id();
}
inline const ::mesos::FrameworkID& Operation::framework_id() const {
  const ::mesos::FrameworkID* p = framework_id_;
  // @@protoc_insertion_point(field_get:mesos.Operation.framework_id)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::FrameworkID*>(
      &::mesos::_FrameworkID_default_instance_);
}
inline ::mesos::FrameworkID* Operation::release_framework_id() {
  // @@protoc_insertion_point(field_release:mesos.Operation.framework_id)
  clear_has_framework_id();
  ::mesos::FrameworkID* temp = framework_id_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  framework_id_ = NULL;
  return temp;
}
inline ::mesos::FrameworkID* Operation::unsafe_arena_release_framework_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Operation.framework_id)
  clear_has_framework_id();
  ::mesos::FrameworkID* temp = framework_id_;
  framework_id_ = NULL;
  return temp;
}
inline ::mesos::FrameworkID* Operation::mutable_framework_id() {
  set_has_framework_id();
  if (framework_id_ == NULL) {
    _slow_mutable_framework_id();
  }
  // @@protoc_insertion_point(field_mutable:mesos.Operation.framework_id)
  return framework_id_;
}
inline void Operation::set_allocated_framework_id(::mesos::FrameworkID* framework_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete framework_id_;
  }
  if (framework_id) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(framework_id);
    if (message_arena != submessage_arena) {
      framework_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, framework_id, submessage_arena);
    }
    set_has_framework_id();
  } else {
    clear_has_framework_id();
  }
  framework_id_ = framework_id;
  // @@protoc_insertion_point(field_set_allocated:mesos.Operation.framework_id)
}

// optional .mesos.SlaveID slave_id = 2;
inline bool Operation::has_slave_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Operation::set_has_slave_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Operation::clear_has_slave_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Operation::clear_slave_id() {
  if (slave_id_ != NULL) slave_id_->Clear();
  clear_has_slave_id();
}
inline const ::mesos::SlaveID& Operation::slave_id() const {
  const ::mesos::SlaveID* p = slave_id_;
  // @@protoc_insertion_point(field_get:mesos.Operation.slave_id)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::SlaveID*>(
      &::mesos::_SlaveID_default_instance_);
}
inline ::mesos::SlaveID* Operation::release_slave_id() {
  // @@protoc_insertion_point(field_release:mesos.Operation.slave_id)
  clear_has_slave_id();
  ::mesos::SlaveID* temp = slave_id_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  slave_id_ = NULL;
  return temp;
}
inline ::mesos::SlaveID* Operation::unsafe_arena_release_slave_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Operation.slave_id)
  clear_has_slave_id();
  ::mesos::SlaveID* temp = slave_id_;
  slave_id_ = NULL;
  return temp;
}
inline ::mesos::SlaveID* Operation::mutable_slave_id() {
  set_has_slave_id();
  if (slave_id_ == NULL) {
    _slow_mutable_slave_id();
  }
  // @@protoc_insertion_point(field_mutable:mesos.Operation.slave_id)
  return slave_id_;
}
inline void Operation::set_allocated_slave_id(::mesos::SlaveID* slave_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete slave_id_;
  }
  if (slave_id) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(slave_id);
    if (message_arena != submessage_arena) {
      slave_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, slave_id, submessage_arena);
    }
    set_has_slave_id();
  } else {
    clear_has_slave_id();
  }
  slave_id_ = slave_id;
  // @@protoc_insertion_point(field_set_allocated:mesos.Operation.slave_id)
}

// required .mesos.Offer.Operation info = 3;
inline bool Operation::has_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Operation::set_has_info() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Operation::clear_has_info() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Operation::clear_info() {
  if (info_ != NULL) info_->Clear();
  clear_has_info();
}
inline const ::mesos::Offer_Operation& Operation::info() const {
  const ::mesos::Offer_Operation* p = info_;
  // @@protoc_insertion_point(field_get:mesos.Operation.info)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::Offer_Operation*>(
      &::mesos::_Offer_Operation_default_instance_);
}
inline ::mesos::Offer_Operation* Operation::release_info() {
  // @@protoc_insertion_point(field_release:mesos.Operation.info)
  clear_has_info();
  ::mesos::Offer_Operation* temp = info_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  info_ = NULL;
  return temp;
}
inline ::mesos::Offer_Operation* Operation::unsafe_arena_release_info() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Operation.info)
  clear_has_info();
  ::mesos::Offer_Operation* temp = info_;
  info_ = NULL;
  return temp;
}
inline ::mesos::Offer_Operation* Operation::mutable_info() {
  set_has_info();
  if (info_ == NULL) {
    _slow_mutable_info();
  }
  // @@protoc_insertion_point(field_mutable:mesos.Operation.info)
  return info_;
}
inline void Operation::set_allocated_info(::mesos::Offer_Operation* info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete info_;
  }
  if (info) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(info);
    if (message_arena != submessage_arena) {
      info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    set_has_info();
  } else {
    clear_has_info();
  }
  info_ = info;
  // @@protoc_insertion_point(field_set_allocated:mesos.Operation.info)
}

// required .mesos.OperationStatus latest_status = 4;
inline bool Operation::has_latest_status() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Operation::set_has_latest_status() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Operation::clear_has_latest_status() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Operation::clear_latest_status() {
  if (latest_status_ != NULL) latest_status_->Clear();
  clear_has_latest_status();
}
inline const ::mesos::OperationStatus& Operation::latest_status() const {
  const ::mesos::OperationStatus* p = latest_status_;
  // @@protoc_insertion_point(field_get:mesos.Operation.latest_status)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::OperationStatus*>(
      &::mesos::_OperationStatus_default_instance_);
}
inline ::mesos::OperationStatus* Operation::release_latest_status() {
  // @@protoc_insertion_point(field_release:mesos.Operation.latest_status)
  clear_has_latest_status();
  ::mesos::OperationStatus* temp = latest_status_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  latest_status_ = NULL;
  return temp;
}
inline ::mesos::OperationStatus* Operation::unsafe_arena_release_latest_status() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Operation.latest_status)
  clear_has_latest_status();
  ::mesos::OperationStatus* temp = latest_status_;
  latest_status_ = NULL;
  return temp;
}
inline ::mesos::OperationStatus* Operation::mutable_latest_status() {
  set_has_latest_status();
  if (latest_status_ == NULL) {
    _slow_mutable_latest_status();
  }
  // @@protoc_insertion_point(field_mutable:mesos.Operation.latest_status)
  return latest_status_;
}
inline void Operation::set_allocated_latest_status(::mesos::OperationStatus* latest_status) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete latest_status_;
  }
  if (latest_status) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(latest_status);
    if (message_arena != submessage_arena) {
      latest_status = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, latest_status, submessage_arena);
    }
    set_has_latest_status();
  } else {
    clear_has_latest_status();
  }
  latest_status_ = latest_status;
  // @@protoc_insertion_point(field_set_allocated:mesos.Operation.latest_status)
}

// repeated .mesos.OperationStatus statuses = 5;
inline int Operation::statuses_size() const {
  return statuses_.size();
}
inline void Operation::clear_statuses() {
  statuses_.Clear();
}
inline const ::mesos::OperationStatus& Operation::statuses(int index) const {
  // @@protoc_insertion_point(field_get:mesos.Operation.statuses)
  return statuses_.Get(index);
}
inline ::mesos::OperationStatus* Operation::mutable_statuses(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.Operation.statuses)
  return statuses_.Mutable(index);
}
inline ::mesos::OperationStatus* Operation::add_statuses() {
  // @@protoc_insertion_point(field_add:mesos.Operation.statuses)
  return statuses_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::OperationStatus >*
Operation::mutable_statuses() {
  // @@protoc_insertion_point(field_mutable_list:mesos.Operation.statuses)
  return &statuses_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::OperationStatus >&
Operation::statuses() const {
  // @@protoc_insertion_point(field_list:mesos.Operation.statuses)
  return statuses_;
}

// required .mesos.UUID uuid = 6;
inline bool Operation::has_uuid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Operation::set_has_uuid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Operation::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Operation::clear_uuid() {
  if (uuid_ != NULL) uuid_->Clear();
  clear_has_uuid();
}
inline const ::mesos::UUID& Operation::uuid() const {
  const ::mesos::UUID* p = uuid_;
  // @@protoc_insertion_point(field_get:mesos.Operation.uuid)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::UUID*>(
      &::mesos::_UUID_default_instance_);
}
inline ::mesos::UUID* Operation::release_uuid() {
  // @@protoc_insertion_point(field_release:mesos.Operation.uuid)
  clear_has_uuid();
  ::mesos::UUID* temp = uuid_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  uuid_ = NULL;
  return temp;
}
inline ::mesos::UUID* Operation::unsafe_arena_release_uuid() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Operation.uuid)
  clear_has_uuid();
  ::mesos::UUID* temp = uuid_;
  uuid_ = NULL;
  return temp;
}
inline ::mesos::UUID* Operation::mutable_uuid() {
  set_has_uuid();
  if (uuid_ == NULL) {
    _slow_mutable_uuid();
  }
  // @@protoc_insertion_point(field_mutable:mesos.Operation.uuid)
  return uuid_;
}
inline void Operation::set_allocated_uuid(::mesos::UUID* uuid) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete uuid_;
  }
  if (uuid) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(uuid);
    if (message_arena != submessage_arena) {
      uuid = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, uuid, submessage_arena);
    }
    set_has_uuid();
  } else {
    clear_has_uuid();
  }
  uuid_ = uuid;
  // @@protoc_insertion_point(field_set_allocated:mesos.Operation.uuid)
}

// -------------------------------------------------------------------

// OperationStatus

// optional .mesos.OperationID operation_id = 1;
inline bool OperationStatus::has_operation_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OperationStatus::set_has_operation_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OperationStatus::clear_has_operation_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OperationStatus::clear_operation_id() {
  if (operation_id_ != NULL) operation_id_->Clear();
  clear_has_operation_id();
}
inline const ::mesos::OperationID& OperationStatus::operation_id() const {
  const ::mesos::OperationID* p = operation_id_;
  // @@protoc_insertion_point(field_get:mesos.OperationStatus.operation_id)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::OperationID*>(
      &::mesos::_OperationID_default_instance_);
}
inline ::mesos::OperationID* OperationStatus::release_operation_id() {
  // @@protoc_insertion_point(field_release:mesos.OperationStatus.operation_id)
  clear_has_operation_id();
  ::mesos::OperationID* temp = operation_id_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  operation_id_ = NULL;
  return temp;
}
inline ::mesos::OperationID* OperationStatus::unsafe_arena_release_operation_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.OperationStatus.operation_id)
  clear_has_operation_id();
  ::mesos::OperationID* temp = operation_id_;
  operation_id_ = NULL;
  return temp;
}
inline ::mesos::OperationID* OperationStatus::mutable_operation_id() {
  set_has_operation_id();
  if (operation_id_ == NULL) {
    _slow_mutable_operation_id();
  }
  // @@protoc_insertion_point(field_mutable:mesos.OperationStatus.operation_id)
  return operation_id_;
}
inline void OperationStatus::set_allocated_operation_id(::mesos::OperationID* operation_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete operation_id_;
  }
  if (operation_id) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(operation_id);
    if (message_arena != submessage_arena) {
      operation_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, operation_id, submessage_arena);
    }
    set_has_operation_id();
  } else {
    clear_has_operation_id();
  }
  operation_id_ = operation_id;
  // @@protoc_insertion_point(field_set_allocated:mesos.OperationStatus.operation_id)
}

// required .mesos.OperationState state = 2;
inline bool OperationStatus::has_state() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OperationStatus::set_has_state() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OperationStatus::clear_has_state() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OperationStatus::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::mesos::OperationState OperationStatus::state() const {
  // @@protoc_insertion_point(field_get:mesos.OperationStatus.state)
  return static_cast< ::mesos::OperationState >(state_);
}
inline void OperationStatus::set_state(::mesos::OperationState value) {
  assert(::mesos::OperationState_IsValid(value));
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:mesos.OperationStatus.state)
}

// optional string message = 3;
inline bool OperationStatus::has_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OperationStatus::set_has_message() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OperationStatus::clear_has_message() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OperationStatus::clear_message() {
  message_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_message();
}
inline const ::std::string& OperationStatus::message() const {
  // @@protoc_insertion_point(field_get:mesos.OperationStatus.message)
  return message_.Get();
}
inline void OperationStatus::set_message(const ::std::string& value) {
  set_has_message();
  message_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.OperationStatus.message)
}
#if LANG_CXX11
inline void OperationStatus::set_message(::std::string&& value) {
  set_has_message();
  message_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.OperationStatus.message)
}
#endif
inline void OperationStatus::set_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_message();
  message_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.OperationStatus.message)
}
inline void OperationStatus::set_message(const char* value,
    size_t size) {
  set_has_message();
  message_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.OperationStatus.message)
}
inline ::std::string* OperationStatus::mutable_message() {
  set_has_message();
  // @@protoc_insertion_point(field_mutable:mesos.OperationStatus.message)
  return message_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* OperationStatus::release_message() {
  // @@protoc_insertion_point(field_release:mesos.OperationStatus.message)
  clear_has_message();
  return message_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void OperationStatus::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    set_has_message();
  } else {
    clear_has_message();
  }
  message_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.OperationStatus.message)
}
inline ::std::string* OperationStatus::unsafe_arena_release_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.OperationStatus.message)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_message();
  return message_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void OperationStatus::unsafe_arena_set_allocated_message(
    ::std::string* message) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (message != NULL) {
    set_has_message();
  } else {
    clear_has_message();
  }
  message_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      message, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.OperationStatus.message)
}

// repeated .mesos.Resource converted_resources = 4;
inline int OperationStatus::converted_resources_size() const {
  return converted_resources_.size();
}
inline void OperationStatus::clear_converted_resources() {
  converted_resources_.Clear();
}
inline const ::mesos::Resource& OperationStatus::converted_resources(int index) const {
  // @@protoc_insertion_point(field_get:mesos.OperationStatus.converted_resources)
  return converted_resources_.Get(index);
}
inline ::mesos::Resource* OperationStatus::mutable_converted_resources(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.OperationStatus.converted_resources)
  return converted_resources_.Mutable(index);
}
inline ::mesos::Resource* OperationStatus::add_converted_resources() {
  // @@protoc_insertion_point(field_add:mesos.OperationStatus.converted_resources)
  return converted_resources_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
OperationStatus::mutable_converted_resources() {
  // @@protoc_insertion_point(field_mutable_list:mesos.OperationStatus.converted_resources)
  return &converted_resources_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
OperationStatus::converted_resources() const {
  // @@protoc_insertion_point(field_list:mesos.OperationStatus.converted_resources)
  return converted_resources_;
}

// optional .mesos.UUID uuid = 5;
inline bool OperationStatus::has_uuid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OperationStatus::set_has_uuid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OperationStatus::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OperationStatus::clear_uuid() {
  if (uuid_ != NULL) uuid_->Clear();
  clear_has_uuid();
}
inline const ::mesos::UUID& OperationStatus::uuid() const {
  const ::mesos::UUID* p = uuid_;
  // @@protoc_insertion_point(field_get:mesos.OperationStatus.uuid)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::UUID*>(
      &::mesos::_UUID_default_instance_);
}
inline ::mesos::UUID* OperationStatus::release_uuid() {
  // @@protoc_insertion_point(field_release:mesos.OperationStatus.uuid)
  clear_has_uuid();
  ::mesos::UUID* temp = uuid_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  uuid_ = NULL;
  return temp;
}
inline ::mesos::UUID* OperationStatus::unsafe_arena_release_uuid() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.OperationStatus.uuid)
  clear_has_uuid();
  ::mesos::UUID* temp = uuid_;
  uuid_ = NULL;
  return temp;
}
inline ::mesos::UUID* OperationStatus::mutable_uuid() {
  set_has_uuid();
  if (uuid_ == NULL) {
    _slow_mutable_uuid();
  }
  // @@protoc_insertion_point(field_mutable:mesos.OperationStatus.uuid)
  return uuid_;
}
inline void OperationStatus::set_allocated_uuid(::mesos::UUID* uuid) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete uuid_;
  }
  if (uuid) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(uuid);
    if (message_arena != submessage_arena) {
      uuid = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, uuid, submessage_arena);
    }
    set_has_uuid();
  } else {
    clear_has_uuid();
  }
  uuid_ = uuid;
  // @@protoc_insertion_point(field_set_allocated:mesos.OperationStatus.uuid)
}

// -------------------------------------------------------------------

// CheckStatusInfo_Command

// optional int32 exit_code = 1;
inline bool CheckStatusInfo_Command::has_exit_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CheckStatusInfo_Command::set_has_exit_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CheckStatusInfo_Command::clear_has_exit_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CheckStatusInfo_Command::clear_exit_code() {
  exit_code_ = 0;
  clear_has_exit_code();
}
inline ::google::protobuf::int32 CheckStatusInfo_Command::exit_code() const {
  // @@protoc_insertion_point(field_get:mesos.CheckStatusInfo.Command.exit_code)
  return exit_code_;
}
inline void CheckStatusInfo_Command::set_exit_code(::google::protobuf::int32 value) {
  set_has_exit_code();
  exit_code_ = value;
  // @@protoc_insertion_point(field_set:mesos.CheckStatusInfo.Command.exit_code)
}

// -------------------------------------------------------------------

// CheckStatusInfo_Http

// optional uint32 status_code = 1;
inline bool CheckStatusInfo_Http::has_status_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CheckStatusInfo_Http::set_has_status_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CheckStatusInfo_Http::clear_has_status_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CheckStatusInfo_Http::clear_status_code() {
  status_code_ = 0u;
  clear_has_status_code();
}
inline ::google::protobuf::uint32 CheckStatusInfo_Http::status_code() const {
  // @@protoc_insertion_point(field_get:mesos.CheckStatusInfo.Http.status_code)
  return status_code_;
}
inline void CheckStatusInfo_Http::set_status_code(::google::protobuf::uint32 value) {
  set_has_status_code();
  status_code_ = value;
  // @@protoc_insertion_point(field_set:mesos.CheckStatusInfo.Http.status_code)
}

// -------------------------------------------------------------------

// CheckStatusInfo_Tcp

// optional bool succeeded = 1;
inline bool CheckStatusInfo_Tcp::has_succeeded() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CheckStatusInfo_Tcp::set_has_succeeded() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CheckStatusInfo_Tcp::clear_has_succeeded() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CheckStatusInfo_Tcp::clear_succeeded() {
  succeeded_ = false;
  clear_has_succeeded();
}
inline bool CheckStatusInfo_Tcp::succeeded() const {
  // @@protoc_insertion_point(field_get:mesos.CheckStatusInfo.Tcp.succeeded)
  return succeeded_;
}
inline void CheckStatusInfo_Tcp::set_succeeded(bool value) {
  set_has_succeeded();
  succeeded_ = value;
  // @@protoc_insertion_point(field_set:mesos.CheckStatusInfo.Tcp.succeeded)
}

// -------------------------------------------------------------------

// CheckStatusInfo

// optional .mesos.CheckInfo.Type type = 1;
inline bool CheckStatusInfo::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CheckStatusInfo::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CheckStatusInfo::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CheckStatusInfo::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::mesos::CheckInfo_Type CheckStatusInfo::type() const {
  // @@protoc_insertion_point(field_get:mesos.CheckStatusInfo.type)
  return static_cast< ::mesos::CheckInfo_Type >(type_);
}
inline void CheckStatusInfo::set_type(::mesos::CheckInfo_Type value) {
  assert(::mesos::CheckInfo_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:mesos.CheckStatusInfo.type)
}

// optional .mesos.CheckStatusInfo.Command command = 2;
inline bool CheckStatusInfo::has_command() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CheckStatusInfo::set_has_command() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CheckStatusInfo::clear_has_command() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CheckStatusInfo::clear_command() {
  if (command_ != NULL) command_->Clear();
  clear_has_command();
}
inline const ::mesos::CheckStatusInfo_Command& CheckStatusInfo::command() const {
  const ::mesos::CheckStatusInfo_Command* p = command_;
  // @@protoc_insertion_point(field_get:mesos.CheckStatusInfo.command)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::CheckStatusInfo_Command*>(
      &::mesos::_CheckStatusInfo_Command_default_instance_);
}
inline ::mesos::CheckStatusInfo_Command* CheckStatusInfo::release_command() {
  // @@protoc_insertion_point(field_release:mesos.CheckStatusInfo.command)
  clear_has_command();
  ::mesos::CheckStatusInfo_Command* temp = command_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  command_ = NULL;
  return temp;
}
inline ::mesos::CheckStatusInfo_Command* CheckStatusInfo::unsafe_arena_release_command() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.CheckStatusInfo.command)
  clear_has_command();
  ::mesos::CheckStatusInfo_Command* temp = command_;
  command_ = NULL;
  return temp;
}
inline ::mesos::CheckStatusInfo_Command* CheckStatusInfo::mutable_command() {
  set_has_command();
  if (command_ == NULL) {
    _slow_mutable_command();
  }
  // @@protoc_insertion_point(field_mutable:mesos.CheckStatusInfo.command)
  return command_;
}
inline void CheckStatusInfo::set_allocated_command(::mesos::CheckStatusInfo_Command* command) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete command_;
  }
  if (command) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(command);
    if (message_arena != submessage_arena) {
      command = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, command, submessage_arena);
    }
    set_has_command();
  } else {
    clear_has_command();
  }
  command_ = command;
  // @@protoc_insertion_point(field_set_allocated:mesos.CheckStatusInfo.command)
}

// optional .mesos.CheckStatusInfo.Http http = 3;
inline bool CheckStatusInfo::has_http() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CheckStatusInfo::set_has_http() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CheckStatusInfo::clear_has_http() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CheckStatusInfo::clear_http() {
  if (http_ != NULL) http_->Clear();
  clear_has_http();
}
inline const ::mesos::CheckStatusInfo_Http& CheckStatusInfo::http() const {
  const ::mesos::CheckStatusInfo_Http* p = http_;
  // @@protoc_insertion_point(field_get:mesos.CheckStatusInfo.http)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::CheckStatusInfo_Http*>(
      &::mesos::_CheckStatusInfo_Http_default_instance_);
}
inline ::mesos::CheckStatusInfo_Http* CheckStatusInfo::release_http() {
  // @@protoc_insertion_point(field_release:mesos.CheckStatusInfo.http)
  clear_has_http();
  ::mesos::CheckStatusInfo_Http* temp = http_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  http_ = NULL;
  return temp;
}
inline ::mesos::CheckStatusInfo_Http* CheckStatusInfo::unsafe_arena_release_http() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.CheckStatusInfo.http)
  clear_has_http();
  ::mesos::CheckStatusInfo_Http* temp = http_;
  http_ = NULL;
  return temp;
}
inline ::mesos::CheckStatusInfo_Http* CheckStatusInfo::mutable_http() {
  set_has_http();
  if (http_ == NULL) {
    _slow_mutable_http();
  }
  // @@protoc_insertion_point(field_mutable:mesos.CheckStatusInfo.http)
  return http_;
}
inline void CheckStatusInfo::set_allocated_http(::mesos::CheckStatusInfo_Http* http) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete http_;
  }
  if (http) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(http);
    if (message_arena != submessage_arena) {
      http = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, http, submessage_arena);
    }
    set_has_http();
  } else {
    clear_has_http();
  }
  http_ = http;
  // @@protoc_insertion_point(field_set_allocated:mesos.CheckStatusInfo.http)
}

// optional .mesos.CheckStatusInfo.Tcp tcp = 4;
inline bool CheckStatusInfo::has_tcp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CheckStatusInfo::set_has_tcp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CheckStatusInfo::clear_has_tcp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CheckStatusInfo::clear_tcp() {
  if (tcp_ != NULL) tcp_->Clear();
  clear_has_tcp();
}
inline const ::mesos::CheckStatusInfo_Tcp& CheckStatusInfo::tcp() const {
  const ::mesos::CheckStatusInfo_Tcp* p = tcp_;
  // @@protoc_insertion_point(field_get:mesos.CheckStatusInfo.tcp)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::CheckStatusInfo_Tcp*>(
      &::mesos::_CheckStatusInfo_Tcp_default_instance_);
}
inline ::mesos::CheckStatusInfo_Tcp* CheckStatusInfo::release_tcp() {
  // @@protoc_insertion_point(field_release:mesos.CheckStatusInfo.tcp)
  clear_has_tcp();
  ::mesos::CheckStatusInfo_Tcp* temp = tcp_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  tcp_ = NULL;
  return temp;
}
inline ::mesos::CheckStatusInfo_Tcp* CheckStatusInfo::unsafe_arena_release_tcp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.CheckStatusInfo.tcp)
  clear_has_tcp();
  ::mesos::CheckStatusInfo_Tcp* temp = tcp_;
  tcp_ = NULL;
  return temp;
}
inline ::mesos::CheckStatusInfo_Tcp* CheckStatusInfo::mutable_tcp() {
  set_has_tcp();
  if (tcp_ == NULL) {
    _slow_mutable_tcp();
  }
  // @@protoc_insertion_point(field_mutable:mesos.CheckStatusInfo.tcp)
  return tcp_;
}
inline void CheckStatusInfo::set_allocated_tcp(::mesos::CheckStatusInfo_Tcp* tcp) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete tcp_;
  }
  if (tcp) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(tcp);
    if (message_arena != submessage_arena) {
      tcp = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, tcp, submessage_arena);
    }
    set_has_tcp();
  } else {
    clear_has_tcp();
  }
  tcp_ = tcp;
  // @@protoc_insertion_point(field_set_allocated:mesos.CheckStatusInfo.tcp)
}

// -------------------------------------------------------------------

// TaskStatus

// required .mesos.TaskID task_id = 1;
inline bool TaskStatus::has_task_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TaskStatus::set_has_task_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TaskStatus::clear_has_task_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TaskStatus::clear_task_id() {
  if (task_id_ != NULL) task_id_->Clear();
  clear_has_task_id();
}
inline const ::mesos::TaskID& TaskStatus::task_id() const {
  const ::mesos::TaskID* p = task_id_;
  // @@protoc_insertion_point(field_get:mesos.TaskStatus.task_id)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::TaskID*>(
      &::mesos::_TaskID_default_instance_);
}
inline ::mesos::TaskID* TaskStatus::release_task_id() {
  // @@protoc_insertion_point(field_release:mesos.TaskStatus.task_id)
  clear_has_task_id();
  ::mesos::TaskID* temp = task_id_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  task_id_ = NULL;
  return temp;
}
inline ::mesos::TaskID* TaskStatus::unsafe_arena_release_task_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.TaskStatus.task_id)
  clear_has_task_id();
  ::mesos::TaskID* temp = task_id_;
  task_id_ = NULL;
  return temp;
}
inline ::mesos::TaskID* TaskStatus::mutable_task_id() {
  set_has_task_id();
  if (task_id_ == NULL) {
    _slow_mutable_task_id();
  }
  // @@protoc_insertion_point(field_mutable:mesos.TaskStatus.task_id)
  return task_id_;
}
inline void TaskStatus::set_allocated_task_id(::mesos::TaskID* task_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete task_id_;
  }
  if (task_id) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(task_id);
    if (message_arena != submessage_arena) {
      task_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, task_id, submessage_arena);
    }
    set_has_task_id();
  } else {
    clear_has_task_id();
  }
  task_id_ = task_id;
  // @@protoc_insertion_point(field_set_allocated:mesos.TaskStatus.task_id)
}

// required .mesos.TaskState state = 2;
inline bool TaskStatus::has_state() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void TaskStatus::set_has_state() {
  _has_bits_[0] |= 0x00008000u;
}
inline void TaskStatus::clear_has_state() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void TaskStatus::clear_state() {
  state_ = 6;
  clear_has_state();
}
inline ::mesos::TaskState TaskStatus::state() const {
  // @@protoc_insertion_point(field_get:mesos.TaskStatus.state)
  return static_cast< ::mesos::TaskState >(state_);
}
inline void TaskStatus::set_state(::mesos::TaskState value) {
  assert(::mesos::TaskState_IsValid(value));
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:mesos.TaskStatus.state)
}

// optional string message = 4;
inline bool TaskStatus::has_message() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TaskStatus::set_has_message() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TaskStatus::clear_has_message() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TaskStatus::clear_message() {
  message_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_message();
}
inline const ::std::string& TaskStatus::message() const {
  // @@protoc_insertion_point(field_get:mesos.TaskStatus.message)
  return message_.Get();
}
inline void TaskStatus::set_message(const ::std::string& value) {
  set_has_message();
  message_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.TaskStatus.message)
}
#if LANG_CXX11
inline void TaskStatus::set_message(::std::string&& value) {
  set_has_message();
  message_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.TaskStatus.message)
}
#endif
inline void TaskStatus::set_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_message();
  message_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.TaskStatus.message)
}
inline void TaskStatus::set_message(const char* value,
    size_t size) {
  set_has_message();
  message_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.TaskStatus.message)
}
inline ::std::string* TaskStatus::mutable_message() {
  set_has_message();
  // @@protoc_insertion_point(field_mutable:mesos.TaskStatus.message)
  return message_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* TaskStatus::release_message() {
  // @@protoc_insertion_point(field_release:mesos.TaskStatus.message)
  clear_has_message();
  return message_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void TaskStatus::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    set_has_message();
  } else {
    clear_has_message();
  }
  message_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.TaskStatus.message)
}
inline ::std::string* TaskStatus::unsafe_arena_release_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.TaskStatus.message)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_message();
  return message_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void TaskStatus::unsafe_arena_set_allocated_message(
    ::std::string* message) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (message != NULL) {
    set_has_message();
  } else {
    clear_has_message();
  }
  message_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      message, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.TaskStatus.message)
}

// optional .mesos.TaskStatus.Source source = 9;
inline bool TaskStatus::has_source() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void TaskStatus::set_has_source() {
  _has_bits_[0] |= 0x00002000u;
}
inline void TaskStatus::clear_has_source() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void TaskStatus::clear_source() {
  source_ = 0;
  clear_has_source();
}
inline ::mesos::TaskStatus_Source TaskStatus::source() const {
  // @@protoc_insertion_point(field_get:mesos.TaskStatus.source)
  return static_cast< ::mesos::TaskStatus_Source >(source_);
}
inline void TaskStatus::set_source(::mesos::TaskStatus_Source value) {
  assert(::mesos::TaskStatus_Source_IsValid(value));
  set_has_source();
  source_ = value;
  // @@protoc_insertion_point(field_set:mesos.TaskStatus.source)
}

// optional .mesos.TaskStatus.Reason reason = 10;
inline bool TaskStatus::has_reason() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void TaskStatus::set_has_reason() {
  _has_bits_[0] |= 0x00004000u;
}
inline void TaskStatus::clear_has_reason() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void TaskStatus::clear_reason() {
  reason_ = 0;
  clear_has_reason();
}
inline ::mesos::TaskStatus_Reason TaskStatus::reason() const {
  // @@protoc_insertion_point(field_get:mesos.TaskStatus.reason)
  return static_cast< ::mesos::TaskStatus_Reason >(reason_);
}
inline void TaskStatus::set_reason(::mesos::TaskStatus_Reason value) {
  assert(::mesos::TaskStatus_Reason_IsValid(value));
  set_has_reason();
  reason_ = value;
  // @@protoc_insertion_point(field_set:mesos.TaskStatus.reason)
}

// optional bytes data = 3;
inline bool TaskStatus::has_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TaskStatus::set_has_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TaskStatus::clear_has_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TaskStatus::clear_data() {
  data_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_data();
}
inline const ::std::string& TaskStatus::data() const {
  // @@protoc_insertion_point(field_get:mesos.TaskStatus.data)
  return data_.Get();
}
inline void TaskStatus::set_data(const ::std::string& value) {
  set_has_data();
  data_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.TaskStatus.data)
}
#if LANG_CXX11
inline void TaskStatus::set_data(::std::string&& value) {
  set_has_data();
  data_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.TaskStatus.data)
}
#endif
inline void TaskStatus::set_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_data();
  data_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.TaskStatus.data)
}
inline void TaskStatus::set_data(const void* value,
    size_t size) {
  set_has_data();
  data_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.TaskStatus.data)
}
inline ::std::string* TaskStatus::mutable_data() {
  set_has_data();
  // @@protoc_insertion_point(field_mutable:mesos.TaskStatus.data)
  return data_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* TaskStatus::release_data() {
  // @@protoc_insertion_point(field_release:mesos.TaskStatus.data)
  clear_has_data();
  return data_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void TaskStatus::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    set_has_data();
  } else {
    clear_has_data();
  }
  data_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.TaskStatus.data)
}
inline ::std::string* TaskStatus::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.TaskStatus.data)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_data();
  return data_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void TaskStatus::unsafe_arena_set_allocated_data(
    ::std::string* data) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (data != NULL) {
    set_has_data();
  } else {
    clear_has_data();
  }
  data_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      data, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.TaskStatus.data)
}

// optional .mesos.SlaveID slave_id = 5;
inline bool TaskStatus::has_slave_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TaskStatus::set_has_slave_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TaskStatus::clear_has_slave_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TaskStatus::clear_slave_id() {
  if (slave_id_ != NULL) slave_id_->Clear();
  clear_has_slave_id();
}
inline const ::mesos::SlaveID& TaskStatus::slave_id() const {
  const ::mesos::SlaveID* p = slave_id_;
  // @@protoc_insertion_point(field_get:mesos.TaskStatus.slave_id)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::SlaveID*>(
      &::mesos::_SlaveID_default_instance_);
}
inline ::mesos::SlaveID* TaskStatus::release_slave_id() {
  // @@protoc_insertion_point(field_release:mesos.TaskStatus.slave_id)
  clear_has_slave_id();
  ::mesos::SlaveID* temp = slave_id_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  slave_id_ = NULL;
  return temp;
}
inline ::mesos::SlaveID* TaskStatus::unsafe_arena_release_slave_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.TaskStatus.slave_id)
  clear_has_slave_id();
  ::mesos::SlaveID* temp = slave_id_;
  slave_id_ = NULL;
  return temp;
}
inline ::mesos::SlaveID* TaskStatus::mutable_slave_id() {
  set_has_slave_id();
  if (slave_id_ == NULL) {
    _slow_mutable_slave_id();
  }
  // @@protoc_insertion_point(field_mutable:mesos.TaskStatus.slave_id)
  return slave_id_;
}
inline void TaskStatus::set_allocated_slave_id(::mesos::SlaveID* slave_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete slave_id_;
  }
  if (slave_id) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(slave_id);
    if (message_arena != submessage_arena) {
      slave_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, slave_id, submessage_arena);
    }
    set_has_slave_id();
  } else {
    clear_has_slave_id();
  }
  slave_id_ = slave_id;
  // @@protoc_insertion_point(field_set_allocated:mesos.TaskStatus.slave_id)
}

// optional .mesos.ExecutorID executor_id = 7;
inline bool TaskStatus::has_executor_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TaskStatus::set_has_executor_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TaskStatus::clear_has_executor_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TaskStatus::clear_executor_id() {
  if (executor_id_ != NULL) executor_id_->Clear();
  clear_has_executor_id();
}
inline const ::mesos::ExecutorID& TaskStatus::executor_id() const {
  const ::mesos::ExecutorID* p = executor_id_;
  // @@protoc_insertion_point(field_get:mesos.TaskStatus.executor_id)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ExecutorID*>(
      &::mesos::_ExecutorID_default_instance_);
}
inline ::mesos::ExecutorID* TaskStatus::release_executor_id() {
  // @@protoc_insertion_point(field_release:mesos.TaskStatus.executor_id)
  clear_has_executor_id();
  ::mesos::ExecutorID* temp = executor_id_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  executor_id_ = NULL;
  return temp;
}
inline ::mesos::ExecutorID* TaskStatus::unsafe_arena_release_executor_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.TaskStatus.executor_id)
  clear_has_executor_id();
  ::mesos::ExecutorID* temp = executor_id_;
  executor_id_ = NULL;
  return temp;
}
inline ::mesos::ExecutorID* TaskStatus::mutable_executor_id() {
  set_has_executor_id();
  if (executor_id_ == NULL) {
    _slow_mutable_executor_id();
  }
  // @@protoc_insertion_point(field_mutable:mesos.TaskStatus.executor_id)
  return executor_id_;
}
inline void TaskStatus::set_allocated_executor_id(::mesos::ExecutorID* executor_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete executor_id_;
  }
  if (executor_id) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(executor_id);
    if (message_arena != submessage_arena) {
      executor_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, executor_id, submessage_arena);
    }
    set_has_executor_id();
  } else {
    clear_has_executor_id();
  }
  executor_id_ = executor_id;
  // @@protoc_insertion_point(field_set_allocated:mesos.TaskStatus.executor_id)
}

// optional double timestamp = 6;
inline bool TaskStatus::has_timestamp() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TaskStatus::set_has_timestamp() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TaskStatus::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TaskStatus::clear_timestamp() {
  timestamp_ = 0;
  clear_has_timestamp();
}
inline double TaskStatus::timestamp() const {
  // @@protoc_insertion_point(field_get:mesos.TaskStatus.timestamp)
  return timestamp_;
}
inline void TaskStatus::set_timestamp(double value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:mesos.TaskStatus.timestamp)
}

// optional bytes uuid = 11;
inline bool TaskStatus::has_uuid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TaskStatus::set_has_uuid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TaskStatus::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TaskStatus::clear_uuid() {
  uuid_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_uuid();
}
inline const ::std::string& TaskStatus::uuid() const {
  // @@protoc_insertion_point(field_get:mesos.TaskStatus.uuid)
  return uuid_.Get();
}
inline void TaskStatus::set_uuid(const ::std::string& value) {
  set_has_uuid();
  uuid_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.TaskStatus.uuid)
}
#if LANG_CXX11
inline void TaskStatus::set_uuid(::std::string&& value) {
  set_has_uuid();
  uuid_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.TaskStatus.uuid)
}
#endif
inline void TaskStatus::set_uuid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_uuid();
  uuid_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.TaskStatus.uuid)
}
inline void TaskStatus::set_uuid(const void* value,
    size_t size) {
  set_has_uuid();
  uuid_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.TaskStatus.uuid)
}
inline ::std::string* TaskStatus::mutable_uuid() {
  set_has_uuid();
  // @@protoc_insertion_point(field_mutable:mesos.TaskStatus.uuid)
  return uuid_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* TaskStatus::release_uuid() {
  // @@protoc_insertion_point(field_release:mesos.TaskStatus.uuid)
  clear_has_uuid();
  return uuid_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void TaskStatus::set_allocated_uuid(::std::string* uuid) {
  if (uuid != NULL) {
    set_has_uuid();
  } else {
    clear_has_uuid();
  }
  uuid_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), uuid,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.TaskStatus.uuid)
}
inline ::std::string* TaskStatus::unsafe_arena_release_uuid() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.TaskStatus.uuid)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_uuid();
  return uuid_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void TaskStatus::unsafe_arena_set_allocated_uuid(
    ::std::string* uuid) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (uuid != NULL) {
    set_has_uuid();
  } else {
    clear_has_uuid();
  }
  uuid_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      uuid, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.TaskStatus.uuid)
}

// optional bool healthy = 8;
inline bool TaskStatus::has_healthy() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void TaskStatus::set_has_healthy() {
  _has_bits_[0] |= 0x00001000u;
}
inline void TaskStatus::clear_has_healthy() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void TaskStatus::clear_healthy() {
  healthy_ = false;
  clear_has_healthy();
}
inline bool TaskStatus::healthy() const {
  // @@protoc_insertion_point(field_get:mesos.TaskStatus.healthy)
  return healthy_;
}
inline void TaskStatus::set_healthy(bool value) {
  set_has_healthy();
  healthy_ = value;
  // @@protoc_insertion_point(field_set:mesos.TaskStatus.healthy)
}

// optional .mesos.CheckStatusInfo check_status = 15;
inline bool TaskStatus::has_check_status() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TaskStatus::set_has_check_status() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TaskStatus::clear_has_check_status() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TaskStatus::clear_check_status() {
  if (check_status_ != NULL) check_status_->Clear();
  clear_has_check_status();
}
inline const ::mesos::CheckStatusInfo& TaskStatus::check_status() const {
  const ::mesos::CheckStatusInfo* p = check_status_;
  // @@protoc_insertion_point(field_get:mesos.TaskStatus.check_status)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::CheckStatusInfo*>(
      &::mesos::_CheckStatusInfo_default_instance_);
}
inline ::mesos::CheckStatusInfo* TaskStatus::release_check_status() {
  // @@protoc_insertion_point(field_release:mesos.TaskStatus.check_status)
  clear_has_check_status();
  ::mesos::CheckStatusInfo* temp = check_status_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  check_status_ = NULL;
  return temp;
}
inline ::mesos::CheckStatusInfo* TaskStatus::unsafe_arena_release_check_status() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.TaskStatus.check_status)
  clear_has_check_status();
  ::mesos::CheckStatusInfo* temp = check_status_;
  check_status_ = NULL;
  return temp;
}
inline ::mesos::CheckStatusInfo* TaskStatus::mutable_check_status() {
  set_has_check_status();
  if (check_status_ == NULL) {
    _slow_mutable_check_status();
  }
  // @@protoc_insertion_point(field_mutable:mesos.TaskStatus.check_status)
  return check_status_;
}
inline void TaskStatus::set_allocated_check_status(::mesos::CheckStatusInfo* check_status) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete check_status_;
  }
  if (check_status) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(check_status);
    if (message_arena != submessage_arena) {
      check_status = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, check_status, submessage_arena);
    }
    set_has_check_status();
  } else {
    clear_has_check_status();
  }
  check_status_ = check_status;
  // @@protoc_insertion_point(field_set_allocated:mesos.TaskStatus.check_status)
}

// optional .mesos.Labels labels = 12;
inline bool TaskStatus::has_labels() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TaskStatus::set_has_labels() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TaskStatus::clear_has_labels() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TaskStatus::clear_labels() {
  if (labels_ != NULL) labels_->Clear();
  clear_has_labels();
}
inline const ::mesos::Labels& TaskStatus::labels() const {
  const ::mesos::Labels* p = labels_;
  // @@protoc_insertion_point(field_get:mesos.TaskStatus.labels)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::Labels*>(
      &::mesos::_Labels_default_instance_);
}
inline ::mesos::Labels* TaskStatus::release_labels() {
  // @@protoc_insertion_point(field_release:mesos.TaskStatus.labels)
  clear_has_labels();
  ::mesos::Labels* temp = labels_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  labels_ = NULL;
  return temp;
}
inline ::mesos::Labels* TaskStatus::unsafe_arena_release_labels() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.TaskStatus.labels)
  clear_has_labels();
  ::mesos::Labels* temp = labels_;
  labels_ = NULL;
  return temp;
}
inline ::mesos::Labels* TaskStatus::mutable_labels() {
  set_has_labels();
  if (labels_ == NULL) {
    _slow_mutable_labels();
  }
  // @@protoc_insertion_point(field_mutable:mesos.TaskStatus.labels)
  return labels_;
}
inline void TaskStatus::set_allocated_labels(::mesos::Labels* labels) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete labels_;
  }
  if (labels) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(labels);
    if (message_arena != submessage_arena) {
      labels = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, labels, submessage_arena);
    }
    set_has_labels();
  } else {
    clear_has_labels();
  }
  labels_ = labels;
  // @@protoc_insertion_point(field_set_allocated:mesos.TaskStatus.labels)
}

// optional .mesos.ContainerStatus container_status = 13;
inline bool TaskStatus::has_container_status() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TaskStatus::set_has_container_status() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TaskStatus::clear_has_container_status() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TaskStatus::clear_container_status() {
  if (container_status_ != NULL) container_status_->Clear();
  clear_has_container_status();
}
inline const ::mesos::ContainerStatus& TaskStatus::container_status() const {
  const ::mesos::ContainerStatus* p = container_status_;
  // @@protoc_insertion_point(field_get:mesos.TaskStatus.container_status)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ContainerStatus*>(
      &::mesos::_ContainerStatus_default_instance_);
}
inline ::mesos::ContainerStatus* TaskStatus::release_container_status() {
  // @@protoc_insertion_point(field_release:mesos.TaskStatus.container_status)
  clear_has_container_status();
  ::mesos::ContainerStatus* temp = container_status_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  container_status_ = NULL;
  return temp;
}
inline ::mesos::ContainerStatus* TaskStatus::unsafe_arena_release_container_status() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.TaskStatus.container_status)
  clear_has_container_status();
  ::mesos::ContainerStatus* temp = container_status_;
  container_status_ = NULL;
  return temp;
}
inline ::mesos::ContainerStatus* TaskStatus::mutable_container_status() {
  set_has_container_status();
  if (container_status_ == NULL) {
    _slow_mutable_container_status();
  }
  // @@protoc_insertion_point(field_mutable:mesos.TaskStatus.container_status)
  return container_status_;
}
inline void TaskStatus::set_allocated_container_status(::mesos::ContainerStatus* container_status) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete container_status_;
  }
  if (container_status) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(container_status);
    if (message_arena != submessage_arena) {
      container_status = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, container_status, submessage_arena);
    }
    set_has_container_status();
  } else {
    clear_has_container_status();
  }
  container_status_ = container_status;
  // @@protoc_insertion_point(field_set_allocated:mesos.TaskStatus.container_status)
}

// optional .mesos.TimeInfo unreachable_time = 14;
inline bool TaskStatus::has_unreachable_time() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TaskStatus::set_has_unreachable_time() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TaskStatus::clear_has_unreachable_time() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TaskStatus::clear_unreachable_time() {
  if (unreachable_time_ != NULL) unreachable_time_->Clear();
  clear_has_unreachable_time();
}
inline const ::mesos::TimeInfo& TaskStatus::unreachable_time() const {
  const ::mesos::TimeInfo* p = unreachable_time_;
  // @@protoc_insertion_point(field_get:mesos.TaskStatus.unreachable_time)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::TimeInfo*>(
      &::mesos::_TimeInfo_default_instance_);
}
inline ::mesos::TimeInfo* TaskStatus::release_unreachable_time() {
  // @@protoc_insertion_point(field_release:mesos.TaskStatus.unreachable_time)
  clear_has_unreachable_time();
  ::mesos::TimeInfo* temp = unreachable_time_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  unreachable_time_ = NULL;
  return temp;
}
inline ::mesos::TimeInfo* TaskStatus::unsafe_arena_release_unreachable_time() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.TaskStatus.unreachable_time)
  clear_has_unreachable_time();
  ::mesos::TimeInfo* temp = unreachable_time_;
  unreachable_time_ = NULL;
  return temp;
}
inline ::mesos::TimeInfo* TaskStatus::mutable_unreachable_time() {
  set_has_unreachable_time();
  if (unreachable_time_ == NULL) {
    _slow_mutable_unreachable_time();
  }
  // @@protoc_insertion_point(field_mutable:mesos.TaskStatus.unreachable_time)
  return unreachable_time_;
}
inline void TaskStatus::set_allocated_unreachable_time(::mesos::TimeInfo* unreachable_time) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete unreachable_time_;
  }
  if (unreachable_time) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(unreachable_time);
    if (message_arena != submessage_arena) {
      unreachable_time = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, unreachable_time, submessage_arena);
    }
    set_has_unreachable_time();
  } else {
    clear_has_unreachable_time();
  }
  unreachable_time_ = unreachable_time;
  // @@protoc_insertion_point(field_set_allocated:mesos.TaskStatus.unreachable_time)
}

// optional .mesos.TaskResourceLimitation limitation = 16;
inline bool TaskStatus::has_limitation() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TaskStatus::set_has_limitation() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TaskStatus::clear_has_limitation() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TaskStatus::clear_limitation() {
  if (limitation_ != NULL) limitation_->Clear();
  clear_has_limitation();
}
inline const ::mesos::TaskResourceLimitation& TaskStatus::limitation() const {
  const ::mesos::TaskResourceLimitation* p = limitation_;
  // @@protoc_insertion_point(field_get:mesos.TaskStatus.limitation)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::TaskResourceLimitation*>(
      &::mesos::_TaskResourceLimitation_default_instance_);
}
inline ::mesos::TaskResourceLimitation* TaskStatus::release_limitation() {
  // @@protoc_insertion_point(field_release:mesos.TaskStatus.limitation)
  clear_has_limitation();
  ::mesos::TaskResourceLimitation* temp = limitation_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  limitation_ = NULL;
  return temp;
}
inline ::mesos::TaskResourceLimitation* TaskStatus::unsafe_arena_release_limitation() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.TaskStatus.limitation)
  clear_has_limitation();
  ::mesos::TaskResourceLimitation* temp = limitation_;
  limitation_ = NULL;
  return temp;
}
inline ::mesos::TaskResourceLimitation* TaskStatus::mutable_limitation() {
  set_has_limitation();
  if (limitation_ == NULL) {
    _slow_mutable_limitation();
  }
  // @@protoc_insertion_point(field_mutable:mesos.TaskStatus.limitation)
  return limitation_;
}
inline void TaskStatus::set_allocated_limitation(::mesos::TaskResourceLimitation* limitation) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete limitation_;
  }
  if (limitation) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(limitation);
    if (message_arena != submessage_arena) {
      limitation = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, limitation, submessage_arena);
    }
    set_has_limitation();
  } else {
    clear_has_limitation();
  }
  limitation_ = limitation;
  // @@protoc_insertion_point(field_set_allocated:mesos.TaskStatus.limitation)
}

// -------------------------------------------------------------------

// Filters

// optional double refuse_seconds = 1 [default = 5];
inline bool Filters::has_refuse_seconds() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Filters::set_has_refuse_seconds() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Filters::clear_has_refuse_seconds() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Filters::clear_refuse_seconds() {
  refuse_seconds_ = 5;
  clear_has_refuse_seconds();
}
inline double Filters::refuse_seconds() const {
  // @@protoc_insertion_point(field_get:mesos.Filters.refuse_seconds)
  return refuse_seconds_;
}
inline void Filters::set_refuse_seconds(double value) {
  set_has_refuse_seconds();
  refuse_seconds_ = value;
  // @@protoc_insertion_point(field_set:mesos.Filters.refuse_seconds)
}

// -------------------------------------------------------------------

// Environment_Variable

// required string name = 1;
inline bool Environment_Variable::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Environment_Variable::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Environment_Variable::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Environment_Variable::clear_name() {
  name_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_name();
}
inline const ::std::string& Environment_Variable::name() const {
  // @@protoc_insertion_point(field_get:mesos.Environment.Variable.name)
  return name_.Get();
}
inline void Environment_Variable::set_name(const ::std::string& value) {
  set_has_name();
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.Environment.Variable.name)
}
#if LANG_CXX11
inline void Environment_Variable::set_name(::std::string&& value) {
  set_has_name();
  name_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.Environment.Variable.name)
}
#endif
inline void Environment_Variable::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.Environment.Variable.name)
}
inline void Environment_Variable::set_name(const char* value,
    size_t size) {
  set_has_name();
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.Environment.Variable.name)
}
inline ::std::string* Environment_Variable::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:mesos.Environment.Variable.name)
  return name_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* Environment_Variable::release_name() {
  // @@protoc_insertion_point(field_release:mesos.Environment.Variable.name)
  clear_has_name();
  return name_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void Environment_Variable::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.Environment.Variable.name)
}
inline ::std::string* Environment_Variable::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Environment.Variable.name)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_name();
  return name_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void Environment_Variable::unsafe_arena_set_allocated_name(
    ::std::string* name) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      name, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.Environment.Variable.name)
}

// optional .mesos.Environment.Variable.Type type = 3 [default = VALUE];
inline bool Environment_Variable::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Environment_Variable::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Environment_Variable::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Environment_Variable::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::mesos::Environment_Variable_Type Environment_Variable::type() const {
  // @@protoc_insertion_point(field_get:mesos.Environment.Variable.type)
  return static_cast< ::mesos::Environment_Variable_Type >(type_);
}
inline void Environment_Variable::set_type(::mesos::Environment_Variable_Type value) {
  assert(::mesos::Environment_Variable_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:mesos.Environment.Variable.type)
}

// optional string value = 2;
inline bool Environment_Variable::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Environment_Variable::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Environment_Variable::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Environment_Variable::clear_value() {
  value_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_value();
}
inline const ::std::string& Environment_Variable::value() const {
  // @@protoc_insertion_point(field_get:mesos.Environment.Variable.value)
  return value_.Get();
}
inline void Environment_Variable::set_value(const ::std::string& value) {
  set_has_value();
  value_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.Environment.Variable.value)
}
#if LANG_CXX11
inline void Environment_Variable::set_value(::std::string&& value) {
  set_has_value();
  value_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.Environment.Variable.value)
}
#endif
inline void Environment_Variable::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_value();
  value_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.Environment.Variable.value)
}
inline void Environment_Variable::set_value(const char* value,
    size_t size) {
  set_has_value();
  value_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.Environment.Variable.value)
}
inline ::std::string* Environment_Variable::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:mesos.Environment.Variable.value)
  return value_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* Environment_Variable::release_value() {
  // @@protoc_insertion_point(field_release:mesos.Environment.Variable.value)
  clear_has_value();
  return value_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void Environment_Variable::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.Environment.Variable.value)
}
inline ::std::string* Environment_Variable::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Environment.Variable.value)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_value();
  return value_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void Environment_Variable::unsafe_arena_set_allocated_value(
    ::std::string* value) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.Environment.Variable.value)
}

// optional .mesos.Secret secret = 4;
inline bool Environment_Variable::has_secret() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Environment_Variable::set_has_secret() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Environment_Variable::clear_has_secret() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Environment_Variable::clear_secret() {
  if (secret_ != NULL) secret_->Clear();
  clear_has_secret();
}
inline const ::mesos::Secret& Environment_Variable::secret() const {
  const ::mesos::Secret* p = secret_;
  // @@protoc_insertion_point(field_get:mesos.Environment.Variable.secret)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::Secret*>(
      &::mesos::_Secret_default_instance_);
}
inline ::mesos::Secret* Environment_Variable::release_secret() {
  // @@protoc_insertion_point(field_release:mesos.Environment.Variable.secret)
  clear_has_secret();
  ::mesos::Secret* temp = secret_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  secret_ = NULL;
  return temp;
}
inline ::mesos::Secret* Environment_Variable::unsafe_arena_release_secret() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Environment.Variable.secret)
  clear_has_secret();
  ::mesos::Secret* temp = secret_;
  secret_ = NULL;
  return temp;
}
inline ::mesos::Secret* Environment_Variable::mutable_secret() {
  set_has_secret();
  if (secret_ == NULL) {
    _slow_mutable_secret();
  }
  // @@protoc_insertion_point(field_mutable:mesos.Environment.Variable.secret)
  return secret_;
}
inline void Environment_Variable::set_allocated_secret(::mesos::Secret* secret) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete secret_;
  }
  if (secret) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(secret);
    if (message_arena != submessage_arena) {
      secret = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, secret, submessage_arena);
    }
    set_has_secret();
  } else {
    clear_has_secret();
  }
  secret_ = secret;
  // @@protoc_insertion_point(field_set_allocated:mesos.Environment.Variable.secret)
}

// -------------------------------------------------------------------

// Environment

// repeated .mesos.Environment.Variable variables = 1;
inline int Environment::variables_size() const {
  return variables_.size();
}
inline void Environment::clear_variables() {
  variables_.Clear();
}
inline const ::mesos::Environment_Variable& Environment::variables(int index) const {
  // @@protoc_insertion_point(field_get:mesos.Environment.variables)
  return variables_.Get(index);
}
inline ::mesos::Environment_Variable* Environment::mutable_variables(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.Environment.variables)
  return variables_.Mutable(index);
}
inline ::mesos::Environment_Variable* Environment::add_variables() {
  // @@protoc_insertion_point(field_add:mesos.Environment.variables)
  return variables_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Environment_Variable >*
Environment::mutable_variables() {
  // @@protoc_insertion_point(field_mutable_list:mesos.Environment.variables)
  return &variables_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Environment_Variable >&
Environment::variables() const {
  // @@protoc_insertion_point(field_list:mesos.Environment.variables)
  return variables_;
}

// -------------------------------------------------------------------

// Parameter

// required string key = 1;
inline bool Parameter::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Parameter::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Parameter::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Parameter::clear_key() {
  key_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_key();
}
inline const ::std::string& Parameter::key() const {
  // @@protoc_insertion_point(field_get:mesos.Parameter.key)
  return key_.Get();
}
inline void Parameter::set_key(const ::std::string& value) {
  set_has_key();
  key_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.Parameter.key)
}
#if LANG_CXX11
inline void Parameter::set_key(::std::string&& value) {
  set_has_key();
  key_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.Parameter.key)
}
#endif
inline void Parameter::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_key();
  key_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.Parameter.key)
}
inline void Parameter::set_key(const char* value,
    size_t size) {
  set_has_key();
  key_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.Parameter.key)
}
inline ::std::string* Parameter::mutable_key() {
  set_has_key();
  // @@protoc_insertion_point(field_mutable:mesos.Parameter.key)
  return key_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* Parameter::release_key() {
  // @@protoc_insertion_point(field_release:mesos.Parameter.key)
  clear_has_key();
  return key_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void Parameter::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.Parameter.key)
}
inline ::std::string* Parameter::unsafe_arena_release_key() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Parameter.key)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_key();
  return key_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void Parameter::unsafe_arena_set_allocated_key(
    ::std::string* key) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      key, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.Parameter.key)
}

// required string value = 2;
inline bool Parameter::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Parameter::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Parameter::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Parameter::clear_value() {
  value_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_value();
}
inline const ::std::string& Parameter::value() const {
  // @@protoc_insertion_point(field_get:mesos.Parameter.value)
  return value_.Get();
}
inline void Parameter::set_value(const ::std::string& value) {
  set_has_value();
  value_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.Parameter.value)
}
#if LANG_CXX11
inline void Parameter::set_value(::std::string&& value) {
  set_has_value();
  value_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.Parameter.value)
}
#endif
inline void Parameter::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_value();
  value_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.Parameter.value)
}
inline void Parameter::set_value(const char* value,
    size_t size) {
  set_has_value();
  value_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.Parameter.value)
}
inline ::std::string* Parameter::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:mesos.Parameter.value)
  return value_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* Parameter::release_value() {
  // @@protoc_insertion_point(field_release:mesos.Parameter.value)
  clear_has_value();
  return value_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void Parameter::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.Parameter.value)
}
inline ::std::string* Parameter::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Parameter.value)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_value();
  return value_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void Parameter::unsafe_arena_set_allocated_value(
    ::std::string* value) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.Parameter.value)
}

// -------------------------------------------------------------------

// Parameters

// repeated .mesos.Parameter parameter = 1;
inline int Parameters::parameter_size() const {
  return parameter_.size();
}
inline void Parameters::clear_parameter() {
  parameter_.Clear();
}
inline const ::mesos::Parameter& Parameters::parameter(int index) const {
  // @@protoc_insertion_point(field_get:mesos.Parameters.parameter)
  return parameter_.Get(index);
}
inline ::mesos::Parameter* Parameters::mutable_parameter(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.Parameters.parameter)
  return parameter_.Mutable(index);
}
inline ::mesos::Parameter* Parameters::add_parameter() {
  // @@protoc_insertion_point(field_add:mesos.Parameters.parameter)
  return parameter_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Parameter >*
Parameters::mutable_parameter() {
  // @@protoc_insertion_point(field_mutable_list:mesos.Parameters.parameter)
  return &parameter_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Parameter >&
Parameters::parameter() const {
  // @@protoc_insertion_point(field_list:mesos.Parameters.parameter)
  return parameter_;
}

// -------------------------------------------------------------------

// Credential

// required string principal = 1;
inline bool Credential::has_principal() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Credential::set_has_principal() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Credential::clear_has_principal() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Credential::clear_principal() {
  principal_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_principal();
}
inline const ::std::string& Credential::principal() const {
  // @@protoc_insertion_point(field_get:mesos.Credential.principal)
  return principal_.Get();
}
inline void Credential::set_principal(const ::std::string& value) {
  set_has_principal();
  principal_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.Credential.principal)
}
#if LANG_CXX11
inline void Credential::set_principal(::std::string&& value) {
  set_has_principal();
  principal_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.Credential.principal)
}
#endif
inline void Credential::set_principal(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_principal();
  principal_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.Credential.principal)
}
inline void Credential::set_principal(const char* value,
    size_t size) {
  set_has_principal();
  principal_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.Credential.principal)
}
inline ::std::string* Credential::mutable_principal() {
  set_has_principal();
  // @@protoc_insertion_point(field_mutable:mesos.Credential.principal)
  return principal_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* Credential::release_principal() {
  // @@protoc_insertion_point(field_release:mesos.Credential.principal)
  clear_has_principal();
  return principal_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void Credential::set_allocated_principal(::std::string* principal) {
  if (principal != NULL) {
    set_has_principal();
  } else {
    clear_has_principal();
  }
  principal_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), principal,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.Credential.principal)
}
inline ::std::string* Credential::unsafe_arena_release_principal() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Credential.principal)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_principal();
  return principal_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void Credential::unsafe_arena_set_allocated_principal(
    ::std::string* principal) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (principal != NULL) {
    set_has_principal();
  } else {
    clear_has_principal();
  }
  principal_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      principal, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.Credential.principal)
}

// optional string secret = 2;
inline bool Credential::has_secret() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Credential::set_has_secret() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Credential::clear_has_secret() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Credential::clear_secret() {
  secret_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_secret();
}
inline const ::std::string& Credential::secret() const {
  // @@protoc_insertion_point(field_get:mesos.Credential.secret)
  return secret_.Get();
}
inline void Credential::set_secret(const ::std::string& value) {
  set_has_secret();
  secret_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.Credential.secret)
}
#if LANG_CXX11
inline void Credential::set_secret(::std::string&& value) {
  set_has_secret();
  secret_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.Credential.secret)
}
#endif
inline void Credential::set_secret(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_secret();
  secret_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.Credential.secret)
}
inline void Credential::set_secret(const char* value,
    size_t size) {
  set_has_secret();
  secret_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.Credential.secret)
}
inline ::std::string* Credential::mutable_secret() {
  set_has_secret();
  // @@protoc_insertion_point(field_mutable:mesos.Credential.secret)
  return secret_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* Credential::release_secret() {
  // @@protoc_insertion_point(field_release:mesos.Credential.secret)
  clear_has_secret();
  return secret_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void Credential::set_allocated_secret(::std::string* secret) {
  if (secret != NULL) {
    set_has_secret();
  } else {
    clear_has_secret();
  }
  secret_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), secret,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.Credential.secret)
}
inline ::std::string* Credential::unsafe_arena_release_secret() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Credential.secret)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_secret();
  return secret_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void Credential::unsafe_arena_set_allocated_secret(
    ::std::string* secret) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (secret != NULL) {
    set_has_secret();
  } else {
    clear_has_secret();
  }
  secret_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      secret, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.Credential.secret)
}

// -------------------------------------------------------------------

// Credentials

// repeated .mesos.Credential credentials = 1;
inline int Credentials::credentials_size() const {
  return credentials_.size();
}
inline void Credentials::clear_credentials() {
  credentials_.Clear();
}
inline const ::mesos::Credential& Credentials::credentials(int index) const {
  // @@protoc_insertion_point(field_get:mesos.Credentials.credentials)
  return credentials_.Get(index);
}
inline ::mesos::Credential* Credentials::mutable_credentials(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.Credentials.credentials)
  return credentials_.Mutable(index);
}
inline ::mesos::Credential* Credentials::add_credentials() {
  // @@protoc_insertion_point(field_add:mesos.Credentials.credentials)
  return credentials_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Credential >*
Credentials::mutable_credentials() {
  // @@protoc_insertion_point(field_mutable_list:mesos.Credentials.credentials)
  return &credentials_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Credential >&
Credentials::credentials() const {
  // @@protoc_insertion_point(field_list:mesos.Credentials.credentials)
  return credentials_;
}

// -------------------------------------------------------------------

// Secret_Reference

// required string name = 1;
inline bool Secret_Reference::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Secret_Reference::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Secret_Reference::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Secret_Reference::clear_name() {
  name_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_name();
}
inline const ::std::string& Secret_Reference::name() const {
  // @@protoc_insertion_point(field_get:mesos.Secret.Reference.name)
  return name_.Get();
}
inline void Secret_Reference::set_name(const ::std::string& value) {
  set_has_name();
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.Secret.Reference.name)
}
#if LANG_CXX11
inline void Secret_Reference::set_name(::std::string&& value) {
  set_has_name();
  name_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.Secret.Reference.name)
}
#endif
inline void Secret_Reference::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.Secret.Reference.name)
}
inline void Secret_Reference::set_name(const char* value,
    size_t size) {
  set_has_name();
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.Secret.Reference.name)
}
inline ::std::string* Secret_Reference::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:mesos.Secret.Reference.name)
  return name_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* Secret_Reference::release_name() {
  // @@protoc_insertion_point(field_release:mesos.Secret.Reference.name)
  clear_has_name();
  return name_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void Secret_Reference::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.Secret.Reference.name)
}
inline ::std::string* Secret_Reference::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Secret.Reference.name)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_name();
  return name_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void Secret_Reference::unsafe_arena_set_allocated_name(
    ::std::string* name) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      name, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.Secret.Reference.name)
}

// optional string key = 2;
inline bool Secret_Reference::has_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Secret_Reference::set_has_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Secret_Reference::clear_has_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Secret_Reference::clear_key() {
  key_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_key();
}
inline const ::std::string& Secret_Reference::key() const {
  // @@protoc_insertion_point(field_get:mesos.Secret.Reference.key)
  return key_.Get();
}
inline void Secret_Reference::set_key(const ::std::string& value) {
  set_has_key();
  key_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.Secret.Reference.key)
}
#if LANG_CXX11
inline void Secret_Reference::set_key(::std::string&& value) {
  set_has_key();
  key_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.Secret.Reference.key)
}
#endif
inline void Secret_Reference::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_key();
  key_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.Secret.Reference.key)
}
inline void Secret_Reference::set_key(const char* value,
    size_t size) {
  set_has_key();
  key_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.Secret.Reference.key)
}
inline ::std::string* Secret_Reference::mutable_key() {
  set_has_key();
  // @@protoc_insertion_point(field_mutable:mesos.Secret.Reference.key)
  return key_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* Secret_Reference::release_key() {
  // @@protoc_insertion_point(field_release:mesos.Secret.Reference.key)
  clear_has_key();
  return key_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void Secret_Reference::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.Secret.Reference.key)
}
inline ::std::string* Secret_Reference::unsafe_arena_release_key() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Secret.Reference.key)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_key();
  return key_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void Secret_Reference::unsafe_arena_set_allocated_key(
    ::std::string* key) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      key, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.Secret.Reference.key)
}

// -------------------------------------------------------------------

// Secret_Value

// required bytes data = 1;
inline bool Secret_Value::has_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Secret_Value::set_has_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Secret_Value::clear_has_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Secret_Value::clear_data() {
  data_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_data();
}
inline const ::std::string& Secret_Value::data() const {
  // @@protoc_insertion_point(field_get:mesos.Secret.Value.data)
  return data_.Get();
}
inline void Secret_Value::set_data(const ::std::string& value) {
  set_has_data();
  data_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.Secret.Value.data)
}
#if LANG_CXX11
inline void Secret_Value::set_data(::std::string&& value) {
  set_has_data();
  data_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.Secret.Value.data)
}
#endif
inline void Secret_Value::set_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_data();
  data_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.Secret.Value.data)
}
inline void Secret_Value::set_data(const void* value,
    size_t size) {
  set_has_data();
  data_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.Secret.Value.data)
}
inline ::std::string* Secret_Value::mutable_data() {
  set_has_data();
  // @@protoc_insertion_point(field_mutable:mesos.Secret.Value.data)
  return data_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* Secret_Value::release_data() {
  // @@protoc_insertion_point(field_release:mesos.Secret.Value.data)
  clear_has_data();
  return data_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void Secret_Value::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    set_has_data();
  } else {
    clear_has_data();
  }
  data_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.Secret.Value.data)
}
inline ::std::string* Secret_Value::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Secret.Value.data)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_data();
  return data_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void Secret_Value::unsafe_arena_set_allocated_data(
    ::std::string* data) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (data != NULL) {
    set_has_data();
  } else {
    clear_has_data();
  }
  data_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      data, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.Secret.Value.data)
}

// -------------------------------------------------------------------

// Secret

// optional .mesos.Secret.Type type = 1;
inline bool Secret::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Secret::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Secret::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Secret::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::mesos::Secret_Type Secret::type() const {
  // @@protoc_insertion_point(field_get:mesos.Secret.type)
  return static_cast< ::mesos::Secret_Type >(type_);
}
inline void Secret::set_type(::mesos::Secret_Type value) {
  assert(::mesos::Secret_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:mesos.Secret.type)
}

// optional .mesos.Secret.Reference reference = 2;
inline bool Secret::has_reference() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Secret::set_has_reference() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Secret::clear_has_reference() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Secret::clear_reference() {
  if (reference_ != NULL) reference_->Clear();
  clear_has_reference();
}
inline const ::mesos::Secret_Reference& Secret::reference() const {
  const ::mesos::Secret_Reference* p = reference_;
  // @@protoc_insertion_point(field_get:mesos.Secret.reference)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::Secret_Reference*>(
      &::mesos::_Secret_Reference_default_instance_);
}
inline ::mesos::Secret_Reference* Secret::release_reference() {
  // @@protoc_insertion_point(field_release:mesos.Secret.reference)
  clear_has_reference();
  ::mesos::Secret_Reference* temp = reference_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  reference_ = NULL;
  return temp;
}
inline ::mesos::Secret_Reference* Secret::unsafe_arena_release_reference() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Secret.reference)
  clear_has_reference();
  ::mesos::Secret_Reference* temp = reference_;
  reference_ = NULL;
  return temp;
}
inline ::mesos::Secret_Reference* Secret::mutable_reference() {
  set_has_reference();
  if (reference_ == NULL) {
    _slow_mutable_reference();
  }
  // @@protoc_insertion_point(field_mutable:mesos.Secret.reference)
  return reference_;
}
inline void Secret::set_allocated_reference(::mesos::Secret_Reference* reference) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reference_;
  }
  if (reference) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(reference);
    if (message_arena != submessage_arena) {
      reference = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, reference, submessage_arena);
    }
    set_has_reference();
  } else {
    clear_has_reference();
  }
  reference_ = reference;
  // @@protoc_insertion_point(field_set_allocated:mesos.Secret.reference)
}

// optional .mesos.Secret.Value value = 3;
inline bool Secret::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Secret::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Secret::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Secret::clear_value() {
  if (value_ != NULL) value_->Clear();
  clear_has_value();
}
inline const ::mesos::Secret_Value& Secret::value() const {
  const ::mesos::Secret_Value* p = value_;
  // @@protoc_insertion_point(field_get:mesos.Secret.value)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::Secret_Value*>(
      &::mesos::_Secret_Value_default_instance_);
}
inline ::mesos::Secret_Value* Secret::release_value() {
  // @@protoc_insertion_point(field_release:mesos.Secret.value)
  clear_has_value();
  ::mesos::Secret_Value* temp = value_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  value_ = NULL;
  return temp;
}
inline ::mesos::Secret_Value* Secret::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Secret.value)
  clear_has_value();
  ::mesos::Secret_Value* temp = value_;
  value_ = NULL;
  return temp;
}
inline ::mesos::Secret_Value* Secret::mutable_value() {
  set_has_value();
  if (value_ == NULL) {
    _slow_mutable_value();
  }
  // @@protoc_insertion_point(field_mutable:mesos.Secret.value)
  return value_;
}
inline void Secret::set_allocated_value(::mesos::Secret_Value* value) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete value_;
  }
  if (value) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(value);
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    set_has_value();
  } else {
    clear_has_value();
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:mesos.Secret.value)
}

// -------------------------------------------------------------------

// RateLimit

// optional double qps = 1;
inline bool RateLimit::has_qps() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RateLimit::set_has_qps() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RateLimit::clear_has_qps() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RateLimit::clear_qps() {
  qps_ = 0;
  clear_has_qps();
}
inline double RateLimit::qps() const {
  // @@protoc_insertion_point(field_get:mesos.RateLimit.qps)
  return qps_;
}
inline void RateLimit::set_qps(double value) {
  set_has_qps();
  qps_ = value;
  // @@protoc_insertion_point(field_set:mesos.RateLimit.qps)
}

// required string principal = 2;
inline bool RateLimit::has_principal() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RateLimit::set_has_principal() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RateLimit::clear_has_principal() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RateLimit::clear_principal() {
  principal_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_principal();
}
inline const ::std::string& RateLimit::principal() const {
  // @@protoc_insertion_point(field_get:mesos.RateLimit.principal)
  return principal_.Get();
}
inline void RateLimit::set_principal(const ::std::string& value) {
  set_has_principal();
  principal_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.RateLimit.principal)
}
#if LANG_CXX11
inline void RateLimit::set_principal(::std::string&& value) {
  set_has_principal();
  principal_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.RateLimit.principal)
}
#endif
inline void RateLimit::set_principal(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_principal();
  principal_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.RateLimit.principal)
}
inline void RateLimit::set_principal(const char* value,
    size_t size) {
  set_has_principal();
  principal_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.RateLimit.principal)
}
inline ::std::string* RateLimit::mutable_principal() {
  set_has_principal();
  // @@protoc_insertion_point(field_mutable:mesos.RateLimit.principal)
  return principal_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* RateLimit::release_principal() {
  // @@protoc_insertion_point(field_release:mesos.RateLimit.principal)
  clear_has_principal();
  return principal_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void RateLimit::set_allocated_principal(::std::string* principal) {
  if (principal != NULL) {
    set_has_principal();
  } else {
    clear_has_principal();
  }
  principal_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), principal,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.RateLimit.principal)
}
inline ::std::string* RateLimit::unsafe_arena_release_principal() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.RateLimit.principal)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_principal();
  return principal_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void RateLimit::unsafe_arena_set_allocated_principal(
    ::std::string* principal) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (principal != NULL) {
    set_has_principal();
  } else {
    clear_has_principal();
  }
  principal_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      principal, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.RateLimit.principal)
}

// optional uint64 capacity = 3;
inline bool RateLimit::has_capacity() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RateLimit::set_has_capacity() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RateLimit::clear_has_capacity() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RateLimit::clear_capacity() {
  capacity_ = GOOGLE_ULONGLONG(0);
  clear_has_capacity();
}
inline ::google::protobuf::uint64 RateLimit::capacity() const {
  // @@protoc_insertion_point(field_get:mesos.RateLimit.capacity)
  return capacity_;
}
inline void RateLimit::set_capacity(::google::protobuf::uint64 value) {
  set_has_capacity();
  capacity_ = value;
  // @@protoc_insertion_point(field_set:mesos.RateLimit.capacity)
}

// -------------------------------------------------------------------

// RateLimits

// repeated .mesos.RateLimit limits = 1;
inline int RateLimits::limits_size() const {
  return limits_.size();
}
inline void RateLimits::clear_limits() {
  limits_.Clear();
}
inline const ::mesos::RateLimit& RateLimits::limits(int index) const {
  // @@protoc_insertion_point(field_get:mesos.RateLimits.limits)
  return limits_.Get(index);
}
inline ::mesos::RateLimit* RateLimits::mutable_limits(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.RateLimits.limits)
  return limits_.Mutable(index);
}
inline ::mesos::RateLimit* RateLimits::add_limits() {
  // @@protoc_insertion_point(field_add:mesos.RateLimits.limits)
  return limits_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::RateLimit >*
RateLimits::mutable_limits() {
  // @@protoc_insertion_point(field_mutable_list:mesos.RateLimits.limits)
  return &limits_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::RateLimit >&
RateLimits::limits() const {
  // @@protoc_insertion_point(field_list:mesos.RateLimits.limits)
  return limits_;
}

// optional double aggregate_default_qps = 2;
inline bool RateLimits::has_aggregate_default_qps() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RateLimits::set_has_aggregate_default_qps() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RateLimits::clear_has_aggregate_default_qps() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RateLimits::clear_aggregate_default_qps() {
  aggregate_default_qps_ = 0;
  clear_has_aggregate_default_qps();
}
inline double RateLimits::aggregate_default_qps() const {
  // @@protoc_insertion_point(field_get:mesos.RateLimits.aggregate_default_qps)
  return aggregate_default_qps_;
}
inline void RateLimits::set_aggregate_default_qps(double value) {
  set_has_aggregate_default_qps();
  aggregate_default_qps_ = value;
  // @@protoc_insertion_point(field_set:mesos.RateLimits.aggregate_default_qps)
}

// optional uint64 aggregate_default_capacity = 3;
inline bool RateLimits::has_aggregate_default_capacity() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RateLimits::set_has_aggregate_default_capacity() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RateLimits::clear_has_aggregate_default_capacity() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RateLimits::clear_aggregate_default_capacity() {
  aggregate_default_capacity_ = GOOGLE_ULONGLONG(0);
  clear_has_aggregate_default_capacity();
}
inline ::google::protobuf::uint64 RateLimits::aggregate_default_capacity() const {
  // @@protoc_insertion_point(field_get:mesos.RateLimits.aggregate_default_capacity)
  return aggregate_default_capacity_;
}
inline void RateLimits::set_aggregate_default_capacity(::google::protobuf::uint64 value) {
  set_has_aggregate_default_capacity();
  aggregate_default_capacity_ = value;
  // @@protoc_insertion_point(field_set:mesos.RateLimits.aggregate_default_capacity)
}

// -------------------------------------------------------------------

// Image_Appc

// required string name = 1;
inline bool Image_Appc::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Image_Appc::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Image_Appc::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Image_Appc::clear_name() {
  name_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_name();
}
inline const ::std::string& Image_Appc::name() const {
  // @@protoc_insertion_point(field_get:mesos.Image.Appc.name)
  return name_.Get();
}
inline void Image_Appc::set_name(const ::std::string& value) {
  set_has_name();
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.Image.Appc.name)
}
#if LANG_CXX11
inline void Image_Appc::set_name(::std::string&& value) {
  set_has_name();
  name_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.Image.Appc.name)
}
#endif
inline void Image_Appc::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.Image.Appc.name)
}
inline void Image_Appc::set_name(const char* value,
    size_t size) {
  set_has_name();
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.Image.Appc.name)
}
inline ::std::string* Image_Appc::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:mesos.Image.Appc.name)
  return name_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* Image_Appc::release_name() {
  // @@protoc_insertion_point(field_release:mesos.Image.Appc.name)
  clear_has_name();
  return name_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void Image_Appc::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.Image.Appc.name)
}
inline ::std::string* Image_Appc::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Image.Appc.name)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_name();
  return name_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void Image_Appc::unsafe_arena_set_allocated_name(
    ::std::string* name) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      name, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.Image.Appc.name)
}

// optional string id = 2;
inline bool Image_Appc::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Image_Appc::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Image_Appc::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Image_Appc::clear_id() {
  id_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_id();
}
inline const ::std::string& Image_Appc::id() const {
  // @@protoc_insertion_point(field_get:mesos.Image.Appc.id)
  return id_.Get();
}
inline void Image_Appc::set_id(const ::std::string& value) {
  set_has_id();
  id_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.Image.Appc.id)
}
#if LANG_CXX11
inline void Image_Appc::set_id(::std::string&& value) {
  set_has_id();
  id_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.Image.Appc.id)
}
#endif
inline void Image_Appc::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_id();
  id_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.Image.Appc.id)
}
inline void Image_Appc::set_id(const char* value,
    size_t size) {
  set_has_id();
  id_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.Image.Appc.id)
}
inline ::std::string* Image_Appc::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:mesos.Image.Appc.id)
  return id_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* Image_Appc::release_id() {
  // @@protoc_insertion_point(field_release:mesos.Image.Appc.id)
  clear_has_id();
  return id_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void Image_Appc::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.Image.Appc.id)
}
inline ::std::string* Image_Appc::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Image.Appc.id)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_id();
  return id_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void Image_Appc::unsafe_arena_set_allocated_id(
    ::std::string* id) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      id, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.Image.Appc.id)
}

// optional .mesos.Labels labels = 3;
inline bool Image_Appc::has_labels() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Image_Appc::set_has_labels() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Image_Appc::clear_has_labels() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Image_Appc::clear_labels() {
  if (labels_ != NULL) labels_->Clear();
  clear_has_labels();
}
inline const ::mesos::Labels& Image_Appc::labels() const {
  const ::mesos::Labels* p = labels_;
  // @@protoc_insertion_point(field_get:mesos.Image.Appc.labels)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::Labels*>(
      &::mesos::_Labels_default_instance_);
}
inline ::mesos::Labels* Image_Appc::release_labels() {
  // @@protoc_insertion_point(field_release:mesos.Image.Appc.labels)
  clear_has_labels();
  ::mesos::Labels* temp = labels_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  labels_ = NULL;
  return temp;
}
inline ::mesos::Labels* Image_Appc::unsafe_arena_release_labels() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Image.Appc.labels)
  clear_has_labels();
  ::mesos::Labels* temp = labels_;
  labels_ = NULL;
  return temp;
}
inline ::mesos::Labels* Image_Appc::mutable_labels() {
  set_has_labels();
  if (labels_ == NULL) {
    _slow_mutable_labels();
  }
  // @@protoc_insertion_point(field_mutable:mesos.Image.Appc.labels)
  return labels_;
}
inline void Image_Appc::set_allocated_labels(::mesos::Labels* labels) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete labels_;
  }
  if (labels) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(labels);
    if (message_arena != submessage_arena) {
      labels = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, labels, submessage_arena);
    }
    set_has_labels();
  } else {
    clear_has_labels();
  }
  labels_ = labels;
  // @@protoc_insertion_point(field_set_allocated:mesos.Image.Appc.labels)
}

// -------------------------------------------------------------------

// Image_Docker

// required string name = 1;
inline bool Image_Docker::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Image_Docker::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Image_Docker::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Image_Docker::clear_name() {
  name_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_name();
}
inline const ::std::string& Image_Docker::name() const {
  // @@protoc_insertion_point(field_get:mesos.Image.Docker.name)
  return name_.Get();
}
inline void Image_Docker::set_name(const ::std::string& value) {
  set_has_name();
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.Image.Docker.name)
}
#if LANG_CXX11
inline void Image_Docker::set_name(::std::string&& value) {
  set_has_name();
  name_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.Image.Docker.name)
}
#endif
inline void Image_Docker::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.Image.Docker.name)
}
inline void Image_Docker::set_name(const char* value,
    size_t size) {
  set_has_name();
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.Image.Docker.name)
}
inline ::std::string* Image_Docker::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:mesos.Image.Docker.name)
  return name_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* Image_Docker::release_name() {
  // @@protoc_insertion_point(field_release:mesos.Image.Docker.name)
  clear_has_name();
  return name_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void Image_Docker::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.Image.Docker.name)
}
inline ::std::string* Image_Docker::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Image.Docker.name)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_name();
  return name_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void Image_Docker::unsafe_arena_set_allocated_name(
    ::std::string* name) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      name, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.Image.Docker.name)
}

// optional .mesos.Credential credential = 2 [deprecated = true];
inline bool Image_Docker::has_credential() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Image_Docker::set_has_credential() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Image_Docker::clear_has_credential() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Image_Docker::clear_credential() {
  if (credential_ != NULL) credential_->Clear();
  clear_has_credential();
}
inline const ::mesos::Credential& Image_Docker::credential() const {
  const ::mesos::Credential* p = credential_;
  // @@protoc_insertion_point(field_get:mesos.Image.Docker.credential)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::Credential*>(
      &::mesos::_Credential_default_instance_);
}
inline ::mesos::Credential* Image_Docker::release_credential() {
  // @@protoc_insertion_point(field_release:mesos.Image.Docker.credential)
  clear_has_credential();
  ::mesos::Credential* temp = credential_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  credential_ = NULL;
  return temp;
}
inline ::mesos::Credential* Image_Docker::unsafe_arena_release_credential() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Image.Docker.credential)
  clear_has_credential();
  ::mesos::Credential* temp = credential_;
  credential_ = NULL;
  return temp;
}
inline ::mesos::Credential* Image_Docker::mutable_credential() {
  set_has_credential();
  if (credential_ == NULL) {
    _slow_mutable_credential();
  }
  // @@protoc_insertion_point(field_mutable:mesos.Image.Docker.credential)
  return credential_;
}
inline void Image_Docker::set_allocated_credential(::mesos::Credential* credential) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete credential_;
  }
  if (credential) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(credential);
    if (message_arena != submessage_arena) {
      credential = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, credential, submessage_arena);
    }
    set_has_credential();
  } else {
    clear_has_credential();
  }
  credential_ = credential;
  // @@protoc_insertion_point(field_set_allocated:mesos.Image.Docker.credential)
}

// optional .mesos.Secret config = 3;
inline bool Image_Docker::has_config() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Image_Docker::set_has_config() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Image_Docker::clear_has_config() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Image_Docker::clear_config() {
  if (config_ != NULL) config_->Clear();
  clear_has_config();
}
inline const ::mesos::Secret& Image_Docker::config() const {
  const ::mesos::Secret* p = config_;
  // @@protoc_insertion_point(field_get:mesos.Image.Docker.config)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::Secret*>(
      &::mesos::_Secret_default_instance_);
}
inline ::mesos::Secret* Image_Docker::release_config() {
  // @@protoc_insertion_point(field_release:mesos.Image.Docker.config)
  clear_has_config();
  ::mesos::Secret* temp = config_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  config_ = NULL;
  return temp;
}
inline ::mesos::Secret* Image_Docker::unsafe_arena_release_config() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Image.Docker.config)
  clear_has_config();
  ::mesos::Secret* temp = config_;
  config_ = NULL;
  return temp;
}
inline ::mesos::Secret* Image_Docker::mutable_config() {
  set_has_config();
  if (config_ == NULL) {
    _slow_mutable_config();
  }
  // @@protoc_insertion_point(field_mutable:mesos.Image.Docker.config)
  return config_;
}
inline void Image_Docker::set_allocated_config(::mesos::Secret* config) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete config_;
  }
  if (config) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(config);
    if (message_arena != submessage_arena) {
      config = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, config, submessage_arena);
    }
    set_has_config();
  } else {
    clear_has_config();
  }
  config_ = config;
  // @@protoc_insertion_point(field_set_allocated:mesos.Image.Docker.config)
}

// -------------------------------------------------------------------

// Image

// required .mesos.Image.Type type = 1;
inline bool Image::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Image::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Image::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Image::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::mesos::Image_Type Image::type() const {
  // @@protoc_insertion_point(field_get:mesos.Image.type)
  return static_cast< ::mesos::Image_Type >(type_);
}
inline void Image::set_type(::mesos::Image_Type value) {
  assert(::mesos::Image_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:mesos.Image.type)
}

// optional .mesos.Image.Appc appc = 2;
inline bool Image::has_appc() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Image::set_has_appc() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Image::clear_has_appc() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Image::clear_appc() {
  if (appc_ != NULL) appc_->Clear();
  clear_has_appc();
}
inline const ::mesos::Image_Appc& Image::appc() const {
  const ::mesos::Image_Appc* p = appc_;
  // @@protoc_insertion_point(field_get:mesos.Image.appc)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::Image_Appc*>(
      &::mesos::_Image_Appc_default_instance_);
}
inline ::mesos::Image_Appc* Image::release_appc() {
  // @@protoc_insertion_point(field_release:mesos.Image.appc)
  clear_has_appc();
  ::mesos::Image_Appc* temp = appc_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  appc_ = NULL;
  return temp;
}
inline ::mesos::Image_Appc* Image::unsafe_arena_release_appc() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Image.appc)
  clear_has_appc();
  ::mesos::Image_Appc* temp = appc_;
  appc_ = NULL;
  return temp;
}
inline ::mesos::Image_Appc* Image::mutable_appc() {
  set_has_appc();
  if (appc_ == NULL) {
    _slow_mutable_appc();
  }
  // @@protoc_insertion_point(field_mutable:mesos.Image.appc)
  return appc_;
}
inline void Image::set_allocated_appc(::mesos::Image_Appc* appc) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete appc_;
  }
  if (appc) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(appc);
    if (message_arena != submessage_arena) {
      appc = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, appc, submessage_arena);
    }
    set_has_appc();
  } else {
    clear_has_appc();
  }
  appc_ = appc;
  // @@protoc_insertion_point(field_set_allocated:mesos.Image.appc)
}

// optional .mesos.Image.Docker docker = 3;
inline bool Image::has_docker() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Image::set_has_docker() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Image::clear_has_docker() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Image::clear_docker() {
  if (docker_ != NULL) docker_->Clear();
  clear_has_docker();
}
inline const ::mesos::Image_Docker& Image::docker() const {
  const ::mesos::Image_Docker* p = docker_;
  // @@protoc_insertion_point(field_get:mesos.Image.docker)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::Image_Docker*>(
      &::mesos::_Image_Docker_default_instance_);
}
inline ::mesos::Image_Docker* Image::release_docker() {
  // @@protoc_insertion_point(field_release:mesos.Image.docker)
  clear_has_docker();
  ::mesos::Image_Docker* temp = docker_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  docker_ = NULL;
  return temp;
}
inline ::mesos::Image_Docker* Image::unsafe_arena_release_docker() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Image.docker)
  clear_has_docker();
  ::mesos::Image_Docker* temp = docker_;
  docker_ = NULL;
  return temp;
}
inline ::mesos::Image_Docker* Image::mutable_docker() {
  set_has_docker();
  if (docker_ == NULL) {
    _slow_mutable_docker();
  }
  // @@protoc_insertion_point(field_mutable:mesos.Image.docker)
  return docker_;
}
inline void Image::set_allocated_docker(::mesos::Image_Docker* docker) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete docker_;
  }
  if (docker) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(docker);
    if (message_arena != submessage_arena) {
      docker = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, docker, submessage_arena);
    }
    set_has_docker();
  } else {
    clear_has_docker();
  }
  docker_ = docker;
  // @@protoc_insertion_point(field_set_allocated:mesos.Image.docker)
}

// optional bool cached = 4 [default = true];
inline bool Image::has_cached() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Image::set_has_cached() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Image::clear_has_cached() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Image::clear_cached() {
  cached_ = true;
  clear_has_cached();
}
inline bool Image::cached() const {
  // @@protoc_insertion_point(field_get:mesos.Image.cached)
  return cached_;
}
inline void Image::set_cached(bool value) {
  set_has_cached();
  cached_ = value;
  // @@protoc_insertion_point(field_set:mesos.Image.cached)
}

// -------------------------------------------------------------------

// MountPropagation

// optional .mesos.MountPropagation.Mode mode = 1;
inline bool MountPropagation::has_mode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MountPropagation::set_has_mode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MountPropagation::clear_has_mode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MountPropagation::clear_mode() {
  mode_ = 0;
  clear_has_mode();
}
inline ::mesos::MountPropagation_Mode MountPropagation::mode() const {
  // @@protoc_insertion_point(field_get:mesos.MountPropagation.mode)
  return static_cast< ::mesos::MountPropagation_Mode >(mode_);
}
inline void MountPropagation::set_mode(::mesos::MountPropagation_Mode value) {
  assert(::mesos::MountPropagation_Mode_IsValid(value));
  set_has_mode();
  mode_ = value;
  // @@protoc_insertion_point(field_set:mesos.MountPropagation.mode)
}

// -------------------------------------------------------------------

// Volume_Source_DockerVolume

// optional string driver = 1;
inline bool Volume_Source_DockerVolume::has_driver() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Volume_Source_DockerVolume::set_has_driver() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Volume_Source_DockerVolume::clear_has_driver() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Volume_Source_DockerVolume::clear_driver() {
  driver_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_driver();
}
inline const ::std::string& Volume_Source_DockerVolume::driver() const {
  // @@protoc_insertion_point(field_get:mesos.Volume.Source.DockerVolume.driver)
  return driver_.Get();
}
inline void Volume_Source_DockerVolume::set_driver(const ::std::string& value) {
  set_has_driver();
  driver_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.Volume.Source.DockerVolume.driver)
}
#if LANG_CXX11
inline void Volume_Source_DockerVolume::set_driver(::std::string&& value) {
  set_has_driver();
  driver_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.Volume.Source.DockerVolume.driver)
}
#endif
inline void Volume_Source_DockerVolume::set_driver(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_driver();
  driver_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.Volume.Source.DockerVolume.driver)
}
inline void Volume_Source_DockerVolume::set_driver(const char* value,
    size_t size) {
  set_has_driver();
  driver_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.Volume.Source.DockerVolume.driver)
}
inline ::std::string* Volume_Source_DockerVolume::mutable_driver() {
  set_has_driver();
  // @@protoc_insertion_point(field_mutable:mesos.Volume.Source.DockerVolume.driver)
  return driver_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* Volume_Source_DockerVolume::release_driver() {
  // @@protoc_insertion_point(field_release:mesos.Volume.Source.DockerVolume.driver)
  clear_has_driver();
  return driver_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void Volume_Source_DockerVolume::set_allocated_driver(::std::string* driver) {
  if (driver != NULL) {
    set_has_driver();
  } else {
    clear_has_driver();
  }
  driver_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), driver,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.Volume.Source.DockerVolume.driver)
}
inline ::std::string* Volume_Source_DockerVolume::unsafe_arena_release_driver() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Volume.Source.DockerVolume.driver)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_driver();
  return driver_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void Volume_Source_DockerVolume::unsafe_arena_set_allocated_driver(
    ::std::string* driver) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (driver != NULL) {
    set_has_driver();
  } else {
    clear_has_driver();
  }
  driver_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      driver, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.Volume.Source.DockerVolume.driver)
}

// required string name = 2;
inline bool Volume_Source_DockerVolume::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Volume_Source_DockerVolume::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Volume_Source_DockerVolume::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Volume_Source_DockerVolume::clear_name() {
  name_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_name();
}
inline const ::std::string& Volume_Source_DockerVolume::name() const {
  // @@protoc_insertion_point(field_get:mesos.Volume.Source.DockerVolume.name)
  return name_.Get();
}
inline void Volume_Source_DockerVolume::set_name(const ::std::string& value) {
  set_has_name();
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.Volume.Source.DockerVolume.name)
}
#if LANG_CXX11
inline void Volume_Source_DockerVolume::set_name(::std::string&& value) {
  set_has_name();
  name_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.Volume.Source.DockerVolume.name)
}
#endif
inline void Volume_Source_DockerVolume::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.Volume.Source.DockerVolume.name)
}
inline void Volume_Source_DockerVolume::set_name(const char* value,
    size_t size) {
  set_has_name();
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.Volume.Source.DockerVolume.name)
}
inline ::std::string* Volume_Source_DockerVolume::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:mesos.Volume.Source.DockerVolume.name)
  return name_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* Volume_Source_DockerVolume::release_name() {
  // @@protoc_insertion_point(field_release:mesos.Volume.Source.DockerVolume.name)
  clear_has_name();
  return name_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void Volume_Source_DockerVolume::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.Volume.Source.DockerVolume.name)
}
inline ::std::string* Volume_Source_DockerVolume::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Volume.Source.DockerVolume.name)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_name();
  return name_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void Volume_Source_DockerVolume::unsafe_arena_set_allocated_name(
    ::std::string* name) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      name, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.Volume.Source.DockerVolume.name)
}

// optional .mesos.Parameters driver_options = 3;
inline bool Volume_Source_DockerVolume::has_driver_options() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Volume_Source_DockerVolume::set_has_driver_options() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Volume_Source_DockerVolume::clear_has_driver_options() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Volume_Source_DockerVolume::clear_driver_options() {
  if (driver_options_ != NULL) driver_options_->Clear();
  clear_has_driver_options();
}
inline const ::mesos::Parameters& Volume_Source_DockerVolume::driver_options() const {
  const ::mesos::Parameters* p = driver_options_;
  // @@protoc_insertion_point(field_get:mesos.Volume.Source.DockerVolume.driver_options)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::Parameters*>(
      &::mesos::_Parameters_default_instance_);
}
inline ::mesos::Parameters* Volume_Source_DockerVolume::release_driver_options() {
  // @@protoc_insertion_point(field_release:mesos.Volume.Source.DockerVolume.driver_options)
  clear_has_driver_options();
  ::mesos::Parameters* temp = driver_options_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  driver_options_ = NULL;
  return temp;
}
inline ::mesos::Parameters* Volume_Source_DockerVolume::unsafe_arena_release_driver_options() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Volume.Source.DockerVolume.driver_options)
  clear_has_driver_options();
  ::mesos::Parameters* temp = driver_options_;
  driver_options_ = NULL;
  return temp;
}
inline ::mesos::Parameters* Volume_Source_DockerVolume::mutable_driver_options() {
  set_has_driver_options();
  if (driver_options_ == NULL) {
    _slow_mutable_driver_options();
  }
  // @@protoc_insertion_point(field_mutable:mesos.Volume.Source.DockerVolume.driver_options)
  return driver_options_;
}
inline void Volume_Source_DockerVolume::set_allocated_driver_options(::mesos::Parameters* driver_options) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete driver_options_;
  }
  if (driver_options) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(driver_options);
    if (message_arena != submessage_arena) {
      driver_options = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, driver_options, submessage_arena);
    }
    set_has_driver_options();
  } else {
    clear_has_driver_options();
  }
  driver_options_ = driver_options;
  // @@protoc_insertion_point(field_set_allocated:mesos.Volume.Source.DockerVolume.driver_options)
}

// -------------------------------------------------------------------

// Volume_Source_HostPath

// required string path = 1;
inline bool Volume_Source_HostPath::has_path() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Volume_Source_HostPath::set_has_path() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Volume_Source_HostPath::clear_has_path() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Volume_Source_HostPath::clear_path() {
  path_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_path();
}
inline const ::std::string& Volume_Source_HostPath::path() const {
  // @@protoc_insertion_point(field_get:mesos.Volume.Source.HostPath.path)
  return path_.Get();
}
inline void Volume_Source_HostPath::set_path(const ::std::string& value) {
  set_has_path();
  path_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.Volume.Source.HostPath.path)
}
#if LANG_CXX11
inline void Volume_Source_HostPath::set_path(::std::string&& value) {
  set_has_path();
  path_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.Volume.Source.HostPath.path)
}
#endif
inline void Volume_Source_HostPath::set_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_path();
  path_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.Volume.Source.HostPath.path)
}
inline void Volume_Source_HostPath::set_path(const char* value,
    size_t size) {
  set_has_path();
  path_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.Volume.Source.HostPath.path)
}
inline ::std::string* Volume_Source_HostPath::mutable_path() {
  set_has_path();
  // @@protoc_insertion_point(field_mutable:mesos.Volume.Source.HostPath.path)
  return path_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* Volume_Source_HostPath::release_path() {
  // @@protoc_insertion_point(field_release:mesos.Volume.Source.HostPath.path)
  clear_has_path();
  return path_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void Volume_Source_HostPath::set_allocated_path(::std::string* path) {
  if (path != NULL) {
    set_has_path();
  } else {
    clear_has_path();
  }
  path_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), path,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.Volume.Source.HostPath.path)
}
inline ::std::string* Volume_Source_HostPath::unsafe_arena_release_path() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Volume.Source.HostPath.path)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_path();
  return path_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void Volume_Source_HostPath::unsafe_arena_set_allocated_path(
    ::std::string* path) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (path != NULL) {
    set_has_path();
  } else {
    clear_has_path();
  }
  path_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      path, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.Volume.Source.HostPath.path)
}

// optional .mesos.MountPropagation mount_propagation = 2;
inline bool Volume_Source_HostPath::has_mount_propagation() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Volume_Source_HostPath::set_has_mount_propagation() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Volume_Source_HostPath::clear_has_mount_propagation() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Volume_Source_HostPath::clear_mount_propagation() {
  if (mount_propagation_ != NULL) mount_propagation_->Clear();
  clear_has_mount_propagation();
}
inline const ::mesos::MountPropagation& Volume_Source_HostPath::mount_propagation() const {
  const ::mesos::MountPropagation* p = mount_propagation_;
  // @@protoc_insertion_point(field_get:mesos.Volume.Source.HostPath.mount_propagation)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::MountPropagation*>(
      &::mesos::_MountPropagation_default_instance_);
}
inline ::mesos::MountPropagation* Volume_Source_HostPath::release_mount_propagation() {
  // @@protoc_insertion_point(field_release:mesos.Volume.Source.HostPath.mount_propagation)
  clear_has_mount_propagation();
  ::mesos::MountPropagation* temp = mount_propagation_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  mount_propagation_ = NULL;
  return temp;
}
inline ::mesos::MountPropagation* Volume_Source_HostPath::unsafe_arena_release_mount_propagation() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Volume.Source.HostPath.mount_propagation)
  clear_has_mount_propagation();
  ::mesos::MountPropagation* temp = mount_propagation_;
  mount_propagation_ = NULL;
  return temp;
}
inline ::mesos::MountPropagation* Volume_Source_HostPath::mutable_mount_propagation() {
  set_has_mount_propagation();
  if (mount_propagation_ == NULL) {
    _slow_mutable_mount_propagation();
  }
  // @@protoc_insertion_point(field_mutable:mesos.Volume.Source.HostPath.mount_propagation)
  return mount_propagation_;
}
inline void Volume_Source_HostPath::set_allocated_mount_propagation(::mesos::MountPropagation* mount_propagation) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete mount_propagation_;
  }
  if (mount_propagation) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(mount_propagation);
    if (message_arena != submessage_arena) {
      mount_propagation = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, mount_propagation, submessage_arena);
    }
    set_has_mount_propagation();
  } else {
    clear_has_mount_propagation();
  }
  mount_propagation_ = mount_propagation;
  // @@protoc_insertion_point(field_set_allocated:mesos.Volume.Source.HostPath.mount_propagation)
}

// -------------------------------------------------------------------

// Volume_Source_SandboxPath

// optional .mesos.Volume.Source.SandboxPath.Type type = 1;
inline bool Volume_Source_SandboxPath::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Volume_Source_SandboxPath::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Volume_Source_SandboxPath::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Volume_Source_SandboxPath::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::mesos::Volume_Source_SandboxPath_Type Volume_Source_SandboxPath::type() const {
  // @@protoc_insertion_point(field_get:mesos.Volume.Source.SandboxPath.type)
  return static_cast< ::mesos::Volume_Source_SandboxPath_Type >(type_);
}
inline void Volume_Source_SandboxPath::set_type(::mesos::Volume_Source_SandboxPath_Type value) {
  assert(::mesos::Volume_Source_SandboxPath_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:mesos.Volume.Source.SandboxPath.type)
}

// required string path = 2;
inline bool Volume_Source_SandboxPath::has_path() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Volume_Source_SandboxPath::set_has_path() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Volume_Source_SandboxPath::clear_has_path() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Volume_Source_SandboxPath::clear_path() {
  path_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_path();
}
inline const ::std::string& Volume_Source_SandboxPath::path() const {
  // @@protoc_insertion_point(field_get:mesos.Volume.Source.SandboxPath.path)
  return path_.Get();
}
inline void Volume_Source_SandboxPath::set_path(const ::std::string& value) {
  set_has_path();
  path_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.Volume.Source.SandboxPath.path)
}
#if LANG_CXX11
inline void Volume_Source_SandboxPath::set_path(::std::string&& value) {
  set_has_path();
  path_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.Volume.Source.SandboxPath.path)
}
#endif
inline void Volume_Source_SandboxPath::set_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_path();
  path_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.Volume.Source.SandboxPath.path)
}
inline void Volume_Source_SandboxPath::set_path(const char* value,
    size_t size) {
  set_has_path();
  path_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.Volume.Source.SandboxPath.path)
}
inline ::std::string* Volume_Source_SandboxPath::mutable_path() {
  set_has_path();
  // @@protoc_insertion_point(field_mutable:mesos.Volume.Source.SandboxPath.path)
  return path_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* Volume_Source_SandboxPath::release_path() {
  // @@protoc_insertion_point(field_release:mesos.Volume.Source.SandboxPath.path)
  clear_has_path();
  return path_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void Volume_Source_SandboxPath::set_allocated_path(::std::string* path) {
  if (path != NULL) {
    set_has_path();
  } else {
    clear_has_path();
  }
  path_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), path,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.Volume.Source.SandboxPath.path)
}
inline ::std::string* Volume_Source_SandboxPath::unsafe_arena_release_path() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Volume.Source.SandboxPath.path)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_path();
  return path_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void Volume_Source_SandboxPath::unsafe_arena_set_allocated_path(
    ::std::string* path) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (path != NULL) {
    set_has_path();
  } else {
    clear_has_path();
  }
  path_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      path, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.Volume.Source.SandboxPath.path)
}

// -------------------------------------------------------------------

// Volume_Source

// optional .mesos.Volume.Source.Type type = 1;
inline bool Volume_Source::has_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Volume_Source::set_has_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Volume_Source::clear_has_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Volume_Source::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::mesos::Volume_Source_Type Volume_Source::type() const {
  // @@protoc_insertion_point(field_get:mesos.Volume.Source.type)
  return static_cast< ::mesos::Volume_Source_Type >(type_);
}
inline void Volume_Source::set_type(::mesos::Volume_Source_Type value) {
  assert(::mesos::Volume_Source_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:mesos.Volume.Source.type)
}

// optional .mesos.Volume.Source.DockerVolume docker_volume = 2;
inline bool Volume_Source::has_docker_volume() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Volume_Source::set_has_docker_volume() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Volume_Source::clear_has_docker_volume() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Volume_Source::clear_docker_volume() {
  if (docker_volume_ != NULL) docker_volume_->Clear();
  clear_has_docker_volume();
}
inline const ::mesos::Volume_Source_DockerVolume& Volume_Source::docker_volume() const {
  const ::mesos::Volume_Source_DockerVolume* p = docker_volume_;
  // @@protoc_insertion_point(field_get:mesos.Volume.Source.docker_volume)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::Volume_Source_DockerVolume*>(
      &::mesos::_Volume_Source_DockerVolume_default_instance_);
}
inline ::mesos::Volume_Source_DockerVolume* Volume_Source::release_docker_volume() {
  // @@protoc_insertion_point(field_release:mesos.Volume.Source.docker_volume)
  clear_has_docker_volume();
  ::mesos::Volume_Source_DockerVolume* temp = docker_volume_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  docker_volume_ = NULL;
  return temp;
}
inline ::mesos::Volume_Source_DockerVolume* Volume_Source::unsafe_arena_release_docker_volume() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Volume.Source.docker_volume)
  clear_has_docker_volume();
  ::mesos::Volume_Source_DockerVolume* temp = docker_volume_;
  docker_volume_ = NULL;
  return temp;
}
inline ::mesos::Volume_Source_DockerVolume* Volume_Source::mutable_docker_volume() {
  set_has_docker_volume();
  if (docker_volume_ == NULL) {
    _slow_mutable_docker_volume();
  }
  // @@protoc_insertion_point(field_mutable:mesos.Volume.Source.docker_volume)
  return docker_volume_;
}
inline void Volume_Source::set_allocated_docker_volume(::mesos::Volume_Source_DockerVolume* docker_volume) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete docker_volume_;
  }
  if (docker_volume) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(docker_volume);
    if (message_arena != submessage_arena) {
      docker_volume = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, docker_volume, submessage_arena);
    }
    set_has_docker_volume();
  } else {
    clear_has_docker_volume();
  }
  docker_volume_ = docker_volume;
  // @@protoc_insertion_point(field_set_allocated:mesos.Volume.Source.docker_volume)
}

// optional .mesos.Volume.Source.HostPath host_path = 5;
inline bool Volume_Source::has_host_path() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Volume_Source::set_has_host_path() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Volume_Source::clear_has_host_path() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Volume_Source::clear_host_path() {
  if (host_path_ != NULL) host_path_->Clear();
  clear_has_host_path();
}
inline const ::mesos::Volume_Source_HostPath& Volume_Source::host_path() const {
  const ::mesos::Volume_Source_HostPath* p = host_path_;
  // @@protoc_insertion_point(field_get:mesos.Volume.Source.host_path)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::Volume_Source_HostPath*>(
      &::mesos::_Volume_Source_HostPath_default_instance_);
}
inline ::mesos::Volume_Source_HostPath* Volume_Source::release_host_path() {
  // @@protoc_insertion_point(field_release:mesos.Volume.Source.host_path)
  clear_has_host_path();
  ::mesos::Volume_Source_HostPath* temp = host_path_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  host_path_ = NULL;
  return temp;
}
inline ::mesos::Volume_Source_HostPath* Volume_Source::unsafe_arena_release_host_path() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Volume.Source.host_path)
  clear_has_host_path();
  ::mesos::Volume_Source_HostPath* temp = host_path_;
  host_path_ = NULL;
  return temp;
}
inline ::mesos::Volume_Source_HostPath* Volume_Source::mutable_host_path() {
  set_has_host_path();
  if (host_path_ == NULL) {
    _slow_mutable_host_path();
  }
  // @@protoc_insertion_point(field_mutable:mesos.Volume.Source.host_path)
  return host_path_;
}
inline void Volume_Source::set_allocated_host_path(::mesos::Volume_Source_HostPath* host_path) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete host_path_;
  }
  if (host_path) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(host_path);
    if (message_arena != submessage_arena) {
      host_path = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, host_path, submessage_arena);
    }
    set_has_host_path();
  } else {
    clear_has_host_path();
  }
  host_path_ = host_path;
  // @@protoc_insertion_point(field_set_allocated:mesos.Volume.Source.host_path)
}

// optional .mesos.Volume.Source.SandboxPath sandbox_path = 3;
inline bool Volume_Source::has_sandbox_path() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Volume_Source::set_has_sandbox_path() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Volume_Source::clear_has_sandbox_path() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Volume_Source::clear_sandbox_path() {
  if (sandbox_path_ != NULL) sandbox_path_->Clear();
  clear_has_sandbox_path();
}
inline const ::mesos::Volume_Source_SandboxPath& Volume_Source::sandbox_path() const {
  const ::mesos::Volume_Source_SandboxPath* p = sandbox_path_;
  // @@protoc_insertion_point(field_get:mesos.Volume.Source.sandbox_path)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::Volume_Source_SandboxPath*>(
      &::mesos::_Volume_Source_SandboxPath_default_instance_);
}
inline ::mesos::Volume_Source_SandboxPath* Volume_Source::release_sandbox_path() {
  // @@protoc_insertion_point(field_release:mesos.Volume.Source.sandbox_path)
  clear_has_sandbox_path();
  ::mesos::Volume_Source_SandboxPath* temp = sandbox_path_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  sandbox_path_ = NULL;
  return temp;
}
inline ::mesos::Volume_Source_SandboxPath* Volume_Source::unsafe_arena_release_sandbox_path() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Volume.Source.sandbox_path)
  clear_has_sandbox_path();
  ::mesos::Volume_Source_SandboxPath* temp = sandbox_path_;
  sandbox_path_ = NULL;
  return temp;
}
inline ::mesos::Volume_Source_SandboxPath* Volume_Source::mutable_sandbox_path() {
  set_has_sandbox_path();
  if (sandbox_path_ == NULL) {
    _slow_mutable_sandbox_path();
  }
  // @@protoc_insertion_point(field_mutable:mesos.Volume.Source.sandbox_path)
  return sandbox_path_;
}
inline void Volume_Source::set_allocated_sandbox_path(::mesos::Volume_Source_SandboxPath* sandbox_path) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete sandbox_path_;
  }
  if (sandbox_path) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(sandbox_path);
    if (message_arena != submessage_arena) {
      sandbox_path = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, sandbox_path, submessage_arena);
    }
    set_has_sandbox_path();
  } else {
    clear_has_sandbox_path();
  }
  sandbox_path_ = sandbox_path;
  // @@protoc_insertion_point(field_set_allocated:mesos.Volume.Source.sandbox_path)
}

// optional .mesos.Secret secret = 4;
inline bool Volume_Source::has_secret() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Volume_Source::set_has_secret() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Volume_Source::clear_has_secret() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Volume_Source::clear_secret() {
  if (secret_ != NULL) secret_->Clear();
  clear_has_secret();
}
inline const ::mesos::Secret& Volume_Source::secret() const {
  const ::mesos::Secret* p = secret_;
  // @@protoc_insertion_point(field_get:mesos.Volume.Source.secret)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::Secret*>(
      &::mesos::_Secret_default_instance_);
}
inline ::mesos::Secret* Volume_Source::release_secret() {
  // @@protoc_insertion_point(field_release:mesos.Volume.Source.secret)
  clear_has_secret();
  ::mesos::Secret* temp = secret_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  secret_ = NULL;
  return temp;
}
inline ::mesos::Secret* Volume_Source::unsafe_arena_release_secret() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Volume.Source.secret)
  clear_has_secret();
  ::mesos::Secret* temp = secret_;
  secret_ = NULL;
  return temp;
}
inline ::mesos::Secret* Volume_Source::mutable_secret() {
  set_has_secret();
  if (secret_ == NULL) {
    _slow_mutable_secret();
  }
  // @@protoc_insertion_point(field_mutable:mesos.Volume.Source.secret)
  return secret_;
}
inline void Volume_Source::set_allocated_secret(::mesos::Secret* secret) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete secret_;
  }
  if (secret) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(secret);
    if (message_arena != submessage_arena) {
      secret = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, secret, submessage_arena);
    }
    set_has_secret();
  } else {
    clear_has_secret();
  }
  secret_ = secret;
  // @@protoc_insertion_point(field_set_allocated:mesos.Volume.Source.secret)
}

// -------------------------------------------------------------------

// Volume

// required .mesos.Volume.Mode mode = 3;
inline bool Volume::has_mode() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Volume::set_has_mode() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Volume::clear_has_mode() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Volume::clear_mode() {
  mode_ = 1;
  clear_has_mode();
}
inline ::mesos::Volume_Mode Volume::mode() const {
  // @@protoc_insertion_point(field_get:mesos.Volume.mode)
  return static_cast< ::mesos::Volume_Mode >(mode_);
}
inline void Volume::set_mode(::mesos::Volume_Mode value) {
  assert(::mesos::Volume_Mode_IsValid(value));
  set_has_mode();
  mode_ = value;
  // @@protoc_insertion_point(field_set:mesos.Volume.mode)
}

// required string container_path = 1;
inline bool Volume::has_container_path() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Volume::set_has_container_path() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Volume::clear_has_container_path() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Volume::clear_container_path() {
  container_path_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_container_path();
}
inline const ::std::string& Volume::container_path() const {
  // @@protoc_insertion_point(field_get:mesos.Volume.container_path)
  return container_path_.Get();
}
inline void Volume::set_container_path(const ::std::string& value) {
  set_has_container_path();
  container_path_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.Volume.container_path)
}
#if LANG_CXX11
inline void Volume::set_container_path(::std::string&& value) {
  set_has_container_path();
  container_path_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.Volume.container_path)
}
#endif
inline void Volume::set_container_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_container_path();
  container_path_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.Volume.container_path)
}
inline void Volume::set_container_path(const char* value,
    size_t size) {
  set_has_container_path();
  container_path_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.Volume.container_path)
}
inline ::std::string* Volume::mutable_container_path() {
  set_has_container_path();
  // @@protoc_insertion_point(field_mutable:mesos.Volume.container_path)
  return container_path_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* Volume::release_container_path() {
  // @@protoc_insertion_point(field_release:mesos.Volume.container_path)
  clear_has_container_path();
  return container_path_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void Volume::set_allocated_container_path(::std::string* container_path) {
  if (container_path != NULL) {
    set_has_container_path();
  } else {
    clear_has_container_path();
  }
  container_path_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), container_path,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.Volume.container_path)
}
inline ::std::string* Volume::unsafe_arena_release_container_path() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Volume.container_path)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_container_path();
  return container_path_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void Volume::unsafe_arena_set_allocated_container_path(
    ::std::string* container_path) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (container_path != NULL) {
    set_has_container_path();
  } else {
    clear_has_container_path();
  }
  container_path_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      container_path, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.Volume.container_path)
}

// optional string host_path = 2;
inline bool Volume::has_host_path() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Volume::set_has_host_path() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Volume::clear_has_host_path() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Volume::clear_host_path() {
  host_path_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_host_path();
}
inline const ::std::string& Volume::host_path() const {
  // @@protoc_insertion_point(field_get:mesos.Volume.host_path)
  return host_path_.Get();
}
inline void Volume::set_host_path(const ::std::string& value) {
  set_has_host_path();
  host_path_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.Volume.host_path)
}
#if LANG_CXX11
inline void Volume::set_host_path(::std::string&& value) {
  set_has_host_path();
  host_path_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.Volume.host_path)
}
#endif
inline void Volume::set_host_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_host_path();
  host_path_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.Volume.host_path)
}
inline void Volume::set_host_path(const char* value,
    size_t size) {
  set_has_host_path();
  host_path_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.Volume.host_path)
}
inline ::std::string* Volume::mutable_host_path() {
  set_has_host_path();
  // @@protoc_insertion_point(field_mutable:mesos.Volume.host_path)
  return host_path_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* Volume::release_host_path() {
  // @@protoc_insertion_point(field_release:mesos.Volume.host_path)
  clear_has_host_path();
  return host_path_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void Volume::set_allocated_host_path(::std::string* host_path) {
  if (host_path != NULL) {
    set_has_host_path();
  } else {
    clear_has_host_path();
  }
  host_path_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), host_path,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.Volume.host_path)
}
inline ::std::string* Volume::unsafe_arena_release_host_path() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Volume.host_path)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_host_path();
  return host_path_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void Volume::unsafe_arena_set_allocated_host_path(
    ::std::string* host_path) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (host_path != NULL) {
    set_has_host_path();
  } else {
    clear_has_host_path();
  }
  host_path_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      host_path, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.Volume.host_path)
}

// optional .mesos.Image image = 4;
inline bool Volume::has_image() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Volume::set_has_image() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Volume::clear_has_image() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Volume::clear_image() {
  if (image_ != NULL) image_->Clear();
  clear_has_image();
}
inline const ::mesos::Image& Volume::image() const {
  const ::mesos::Image* p = image_;
  // @@protoc_insertion_point(field_get:mesos.Volume.image)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::Image*>(
      &::mesos::_Image_default_instance_);
}
inline ::mesos::Image* Volume::release_image() {
  // @@protoc_insertion_point(field_release:mesos.Volume.image)
  clear_has_image();
  ::mesos::Image* temp = image_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  image_ = NULL;
  return temp;
}
inline ::mesos::Image* Volume::unsafe_arena_release_image() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Volume.image)
  clear_has_image();
  ::mesos::Image* temp = image_;
  image_ = NULL;
  return temp;
}
inline ::mesos::Image* Volume::mutable_image() {
  set_has_image();
  if (image_ == NULL) {
    _slow_mutable_image();
  }
  // @@protoc_insertion_point(field_mutable:mesos.Volume.image)
  return image_;
}
inline void Volume::set_allocated_image(::mesos::Image* image) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete image_;
  }
  if (image) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(image);
    if (message_arena != submessage_arena) {
      image = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, image, submessage_arena);
    }
    set_has_image();
  } else {
    clear_has_image();
  }
  image_ = image;
  // @@protoc_insertion_point(field_set_allocated:mesos.Volume.image)
}

// optional .mesos.Volume.Source source = 5;
inline bool Volume::has_source() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Volume::set_has_source() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Volume::clear_has_source() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Volume::clear_source() {
  if (source_ != NULL) source_->Clear();
  clear_has_source();
}
inline const ::mesos::Volume_Source& Volume::source() const {
  const ::mesos::Volume_Source* p = source_;
  // @@protoc_insertion_point(field_get:mesos.Volume.source)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::Volume_Source*>(
      &::mesos::_Volume_Source_default_instance_);
}
inline ::mesos::Volume_Source* Volume::release_source() {
  // @@protoc_insertion_point(field_release:mesos.Volume.source)
  clear_has_source();
  ::mesos::Volume_Source* temp = source_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  source_ = NULL;
  return temp;
}
inline ::mesos::Volume_Source* Volume::unsafe_arena_release_source() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Volume.source)
  clear_has_source();
  ::mesos::Volume_Source* temp = source_;
  source_ = NULL;
  return temp;
}
inline ::mesos::Volume_Source* Volume::mutable_source() {
  set_has_source();
  if (source_ == NULL) {
    _slow_mutable_source();
  }
  // @@protoc_insertion_point(field_mutable:mesos.Volume.source)
  return source_;
}
inline void Volume::set_allocated_source(::mesos::Volume_Source* source) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete source_;
  }
  if (source) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(source);
    if (message_arena != submessage_arena) {
      source = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, source, submessage_arena);
    }
    set_has_source();
  } else {
    clear_has_source();
  }
  source_ = source;
  // @@protoc_insertion_point(field_set_allocated:mesos.Volume.source)
}

// -------------------------------------------------------------------

// NetworkInfo_IPAddress

// optional .mesos.NetworkInfo.Protocol protocol = 1 [default = IPv4];
inline bool NetworkInfo_IPAddress::has_protocol() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NetworkInfo_IPAddress::set_has_protocol() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NetworkInfo_IPAddress::clear_has_protocol() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NetworkInfo_IPAddress::clear_protocol() {
  protocol_ = 1;
  clear_has_protocol();
}
inline ::mesos::NetworkInfo_Protocol NetworkInfo_IPAddress::protocol() const {
  // @@protoc_insertion_point(field_get:mesos.NetworkInfo.IPAddress.protocol)
  return static_cast< ::mesos::NetworkInfo_Protocol >(protocol_);
}
inline void NetworkInfo_IPAddress::set_protocol(::mesos::NetworkInfo_Protocol value) {
  assert(::mesos::NetworkInfo_Protocol_IsValid(value));
  set_has_protocol();
  protocol_ = value;
  // @@protoc_insertion_point(field_set:mesos.NetworkInfo.IPAddress.protocol)
}

// optional string ip_address = 2;
inline bool NetworkInfo_IPAddress::has_ip_address() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NetworkInfo_IPAddress::set_has_ip_address() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NetworkInfo_IPAddress::clear_has_ip_address() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NetworkInfo_IPAddress::clear_ip_address() {
  ip_address_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_ip_address();
}
inline const ::std::string& NetworkInfo_IPAddress::ip_address() const {
  // @@protoc_insertion_point(field_get:mesos.NetworkInfo.IPAddress.ip_address)
  return ip_address_.Get();
}
inline void NetworkInfo_IPAddress::set_ip_address(const ::std::string& value) {
  set_has_ip_address();
  ip_address_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.NetworkInfo.IPAddress.ip_address)
}
#if LANG_CXX11
inline void NetworkInfo_IPAddress::set_ip_address(::std::string&& value) {
  set_has_ip_address();
  ip_address_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.NetworkInfo.IPAddress.ip_address)
}
#endif
inline void NetworkInfo_IPAddress::set_ip_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_ip_address();
  ip_address_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.NetworkInfo.IPAddress.ip_address)
}
inline void NetworkInfo_IPAddress::set_ip_address(const char* value,
    size_t size) {
  set_has_ip_address();
  ip_address_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.NetworkInfo.IPAddress.ip_address)
}
inline ::std::string* NetworkInfo_IPAddress::mutable_ip_address() {
  set_has_ip_address();
  // @@protoc_insertion_point(field_mutable:mesos.NetworkInfo.IPAddress.ip_address)
  return ip_address_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* NetworkInfo_IPAddress::release_ip_address() {
  // @@protoc_insertion_point(field_release:mesos.NetworkInfo.IPAddress.ip_address)
  clear_has_ip_address();
  return ip_address_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void NetworkInfo_IPAddress::set_allocated_ip_address(::std::string* ip_address) {
  if (ip_address != NULL) {
    set_has_ip_address();
  } else {
    clear_has_ip_address();
  }
  ip_address_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ip_address,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.NetworkInfo.IPAddress.ip_address)
}
inline ::std::string* NetworkInfo_IPAddress::unsafe_arena_release_ip_address() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.NetworkInfo.IPAddress.ip_address)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_ip_address();
  return ip_address_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void NetworkInfo_IPAddress::unsafe_arena_set_allocated_ip_address(
    ::std::string* ip_address) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (ip_address != NULL) {
    set_has_ip_address();
  } else {
    clear_has_ip_address();
  }
  ip_address_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ip_address, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.NetworkInfo.IPAddress.ip_address)
}

// -------------------------------------------------------------------

// NetworkInfo_PortMapping

// required uint32 host_port = 1;
inline bool NetworkInfo_PortMapping::has_host_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NetworkInfo_PortMapping::set_has_host_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NetworkInfo_PortMapping::clear_has_host_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NetworkInfo_PortMapping::clear_host_port() {
  host_port_ = 0u;
  clear_has_host_port();
}
inline ::google::protobuf::uint32 NetworkInfo_PortMapping::host_port() const {
  // @@protoc_insertion_point(field_get:mesos.NetworkInfo.PortMapping.host_port)
  return host_port_;
}
inline void NetworkInfo_PortMapping::set_host_port(::google::protobuf::uint32 value) {
  set_has_host_port();
  host_port_ = value;
  // @@protoc_insertion_point(field_set:mesos.NetworkInfo.PortMapping.host_port)
}

// required uint32 container_port = 2;
inline bool NetworkInfo_PortMapping::has_container_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NetworkInfo_PortMapping::set_has_container_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NetworkInfo_PortMapping::clear_has_container_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NetworkInfo_PortMapping::clear_container_port() {
  container_port_ = 0u;
  clear_has_container_port();
}
inline ::google::protobuf::uint32 NetworkInfo_PortMapping::container_port() const {
  // @@protoc_insertion_point(field_get:mesos.NetworkInfo.PortMapping.container_port)
  return container_port_;
}
inline void NetworkInfo_PortMapping::set_container_port(::google::protobuf::uint32 value) {
  set_has_container_port();
  container_port_ = value;
  // @@protoc_insertion_point(field_set:mesos.NetworkInfo.PortMapping.container_port)
}

// optional string protocol = 3;
inline bool NetworkInfo_PortMapping::has_protocol() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NetworkInfo_PortMapping::set_has_protocol() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NetworkInfo_PortMapping::clear_has_protocol() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NetworkInfo_PortMapping::clear_protocol() {
  protocol_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_protocol();
}
inline const ::std::string& NetworkInfo_PortMapping::protocol() const {
  // @@protoc_insertion_point(field_get:mesos.NetworkInfo.PortMapping.protocol)
  return protocol_.Get();
}
inline void NetworkInfo_PortMapping::set_protocol(const ::std::string& value) {
  set_has_protocol();
  protocol_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.NetworkInfo.PortMapping.protocol)
}
#if LANG_CXX11
inline void NetworkInfo_PortMapping::set_protocol(::std::string&& value) {
  set_has_protocol();
  protocol_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.NetworkInfo.PortMapping.protocol)
}
#endif
inline void NetworkInfo_PortMapping::set_protocol(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_protocol();
  protocol_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.NetworkInfo.PortMapping.protocol)
}
inline void NetworkInfo_PortMapping::set_protocol(const char* value,
    size_t size) {
  set_has_protocol();
  protocol_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.NetworkInfo.PortMapping.protocol)
}
inline ::std::string* NetworkInfo_PortMapping::mutable_protocol() {
  set_has_protocol();
  // @@protoc_insertion_point(field_mutable:mesos.NetworkInfo.PortMapping.protocol)
  return protocol_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* NetworkInfo_PortMapping::release_protocol() {
  // @@protoc_insertion_point(field_release:mesos.NetworkInfo.PortMapping.protocol)
  clear_has_protocol();
  return protocol_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void NetworkInfo_PortMapping::set_allocated_protocol(::std::string* protocol) {
  if (protocol != NULL) {
    set_has_protocol();
  } else {
    clear_has_protocol();
  }
  protocol_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), protocol,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.NetworkInfo.PortMapping.protocol)
}
inline ::std::string* NetworkInfo_PortMapping::unsafe_arena_release_protocol() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.NetworkInfo.PortMapping.protocol)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_protocol();
  return protocol_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void NetworkInfo_PortMapping::unsafe_arena_set_allocated_protocol(
    ::std::string* protocol) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (protocol != NULL) {
    set_has_protocol();
  } else {
    clear_has_protocol();
  }
  protocol_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      protocol, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.NetworkInfo.PortMapping.protocol)
}

// -------------------------------------------------------------------

// NetworkInfo

// repeated .mesos.NetworkInfo.IPAddress ip_addresses = 5;
inline int NetworkInfo::ip_addresses_size() const {
  return ip_addresses_.size();
}
inline void NetworkInfo::clear_ip_addresses() {
  ip_addresses_.Clear();
}
inline const ::mesos::NetworkInfo_IPAddress& NetworkInfo::ip_addresses(int index) const {
  // @@protoc_insertion_point(field_get:mesos.NetworkInfo.ip_addresses)
  return ip_addresses_.Get(index);
}
inline ::mesos::NetworkInfo_IPAddress* NetworkInfo::mutable_ip_addresses(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.NetworkInfo.ip_addresses)
  return ip_addresses_.Mutable(index);
}
inline ::mesos::NetworkInfo_IPAddress* NetworkInfo::add_ip_addresses() {
  // @@protoc_insertion_point(field_add:mesos.NetworkInfo.ip_addresses)
  return ip_addresses_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::NetworkInfo_IPAddress >*
NetworkInfo::mutable_ip_addresses() {
  // @@protoc_insertion_point(field_mutable_list:mesos.NetworkInfo.ip_addresses)
  return &ip_addresses_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::NetworkInfo_IPAddress >&
NetworkInfo::ip_addresses() const {
  // @@protoc_insertion_point(field_list:mesos.NetworkInfo.ip_addresses)
  return ip_addresses_;
}

// optional string name = 6;
inline bool NetworkInfo::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NetworkInfo::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NetworkInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NetworkInfo::clear_name() {
  name_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_name();
}
inline const ::std::string& NetworkInfo::name() const {
  // @@protoc_insertion_point(field_get:mesos.NetworkInfo.name)
  return name_.Get();
}
inline void NetworkInfo::set_name(const ::std::string& value) {
  set_has_name();
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.NetworkInfo.name)
}
#if LANG_CXX11
inline void NetworkInfo::set_name(::std::string&& value) {
  set_has_name();
  name_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.NetworkInfo.name)
}
#endif
inline void NetworkInfo::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.NetworkInfo.name)
}
inline void NetworkInfo::set_name(const char* value,
    size_t size) {
  set_has_name();
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.NetworkInfo.name)
}
inline ::std::string* NetworkInfo::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:mesos.NetworkInfo.name)
  return name_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* NetworkInfo::release_name() {
  // @@protoc_insertion_point(field_release:mesos.NetworkInfo.name)
  clear_has_name();
  return name_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void NetworkInfo::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.NetworkInfo.name)
}
inline ::std::string* NetworkInfo::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.NetworkInfo.name)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_name();
  return name_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void NetworkInfo::unsafe_arena_set_allocated_name(
    ::std::string* name) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      name, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.NetworkInfo.name)
}

// repeated string groups = 3;
inline int NetworkInfo::groups_size() const {
  return groups_.size();
}
inline void NetworkInfo::clear_groups() {
  groups_.Clear();
}
inline const ::std::string& NetworkInfo::groups(int index) const {
  // @@protoc_insertion_point(field_get:mesos.NetworkInfo.groups)
  return groups_.Get(index);
}
inline ::std::string* NetworkInfo::mutable_groups(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.NetworkInfo.groups)
  return groups_.Mutable(index);
}
inline void NetworkInfo::set_groups(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:mesos.NetworkInfo.groups)
  groups_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void NetworkInfo::set_groups(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:mesos.NetworkInfo.groups)
  groups_.Mutable(index)->assign(std::move(value));
}
#endif
inline void NetworkInfo::set_groups(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  groups_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.NetworkInfo.groups)
}
inline void NetworkInfo::set_groups(int index, const char* value, size_t size) {
  groups_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.NetworkInfo.groups)
}
inline ::std::string* NetworkInfo::add_groups() {
  // @@protoc_insertion_point(field_add_mutable:mesos.NetworkInfo.groups)
  return groups_.Add();
}
inline void NetworkInfo::add_groups(const ::std::string& value) {
  groups_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:mesos.NetworkInfo.groups)
}
#if LANG_CXX11
inline void NetworkInfo::add_groups(::std::string&& value) {
  groups_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:mesos.NetworkInfo.groups)
}
#endif
inline void NetworkInfo::add_groups(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  groups_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:mesos.NetworkInfo.groups)
}
inline void NetworkInfo::add_groups(const char* value, size_t size) {
  groups_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:mesos.NetworkInfo.groups)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
NetworkInfo::groups() const {
  // @@protoc_insertion_point(field_list:mesos.NetworkInfo.groups)
  return groups_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
NetworkInfo::mutable_groups() {
  // @@protoc_insertion_point(field_mutable_list:mesos.NetworkInfo.groups)
  return &groups_;
}

// optional .mesos.Labels labels = 4;
inline bool NetworkInfo::has_labels() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NetworkInfo::set_has_labels() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NetworkInfo::clear_has_labels() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NetworkInfo::clear_labels() {
  if (labels_ != NULL) labels_->Clear();
  clear_has_labels();
}
inline const ::mesos::Labels& NetworkInfo::labels() const {
  const ::mesos::Labels* p = labels_;
  // @@protoc_insertion_point(field_get:mesos.NetworkInfo.labels)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::Labels*>(
      &::mesos::_Labels_default_instance_);
}
inline ::mesos::Labels* NetworkInfo::release_labels() {
  // @@protoc_insertion_point(field_release:mesos.NetworkInfo.labels)
  clear_has_labels();
  ::mesos::Labels* temp = labels_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  labels_ = NULL;
  return temp;
}
inline ::mesos::Labels* NetworkInfo::unsafe_arena_release_labels() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.NetworkInfo.labels)
  clear_has_labels();
  ::mesos::Labels* temp = labels_;
  labels_ = NULL;
  return temp;
}
inline ::mesos::Labels* NetworkInfo::mutable_labels() {
  set_has_labels();
  if (labels_ == NULL) {
    _slow_mutable_labels();
  }
  // @@protoc_insertion_point(field_mutable:mesos.NetworkInfo.labels)
  return labels_;
}
inline void NetworkInfo::set_allocated_labels(::mesos::Labels* labels) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete labels_;
  }
  if (labels) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(labels);
    if (message_arena != submessage_arena) {
      labels = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, labels, submessage_arena);
    }
    set_has_labels();
  } else {
    clear_has_labels();
  }
  labels_ = labels;
  // @@protoc_insertion_point(field_set_allocated:mesos.NetworkInfo.labels)
}

// repeated .mesos.NetworkInfo.PortMapping port_mappings = 7;
inline int NetworkInfo::port_mappings_size() const {
  return port_mappings_.size();
}
inline void NetworkInfo::clear_port_mappings() {
  port_mappings_.Clear();
}
inline const ::mesos::NetworkInfo_PortMapping& NetworkInfo::port_mappings(int index) const {
  // @@protoc_insertion_point(field_get:mesos.NetworkInfo.port_mappings)
  return port_mappings_.Get(index);
}
inline ::mesos::NetworkInfo_PortMapping* NetworkInfo::mutable_port_mappings(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.NetworkInfo.port_mappings)
  return port_mappings_.Mutable(index);
}
inline ::mesos::NetworkInfo_PortMapping* NetworkInfo::add_port_mappings() {
  // @@protoc_insertion_point(field_add:mesos.NetworkInfo.port_mappings)
  return port_mappings_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::NetworkInfo_PortMapping >*
NetworkInfo::mutable_port_mappings() {
  // @@protoc_insertion_point(field_mutable_list:mesos.NetworkInfo.port_mappings)
  return &port_mappings_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::NetworkInfo_PortMapping >&
NetworkInfo::port_mappings() const {
  // @@protoc_insertion_point(field_list:mesos.NetworkInfo.port_mappings)
  return port_mappings_;
}

// -------------------------------------------------------------------

// CapabilityInfo

// repeated .mesos.CapabilityInfo.Capability capabilities = 1;
inline int CapabilityInfo::capabilities_size() const {
  return capabilities_.size();
}
inline void CapabilityInfo::clear_capabilities() {
  capabilities_.Clear();
}
inline ::mesos::CapabilityInfo_Capability CapabilityInfo::capabilities(int index) const {
  // @@protoc_insertion_point(field_get:mesos.CapabilityInfo.capabilities)
  return static_cast< ::mesos::CapabilityInfo_Capability >(capabilities_.Get(index));
}
inline void CapabilityInfo::set_capabilities(int index, ::mesos::CapabilityInfo_Capability value) {
  assert(::mesos::CapabilityInfo_Capability_IsValid(value));
  capabilities_.Set(index, value);
  // @@protoc_insertion_point(field_set:mesos.CapabilityInfo.capabilities)
}
inline void CapabilityInfo::add_capabilities(::mesos::CapabilityInfo_Capability value) {
  assert(::mesos::CapabilityInfo_Capability_IsValid(value));
  capabilities_.Add(value);
  // @@protoc_insertion_point(field_add:mesos.CapabilityInfo.capabilities)
}
inline const ::google::protobuf::RepeatedField<int>&
CapabilityInfo::capabilities() const {
  // @@protoc_insertion_point(field_list:mesos.CapabilityInfo.capabilities)
  return capabilities_;
}
inline ::google::protobuf::RepeatedField<int>*
CapabilityInfo::mutable_capabilities() {
  // @@protoc_insertion_point(field_mutable_list:mesos.CapabilityInfo.capabilities)
  return &capabilities_;
}

// -------------------------------------------------------------------

// LinuxInfo

// optional .mesos.CapabilityInfo capability_info = 1 [deprecated = true];
inline bool LinuxInfo::has_capability_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LinuxInfo::set_has_capability_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LinuxInfo::clear_has_capability_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LinuxInfo::clear_capability_info() {
  if (capability_info_ != NULL) capability_info_->Clear();
  clear_has_capability_info();
}
inline const ::mesos::CapabilityInfo& LinuxInfo::capability_info() const {
  const ::mesos::CapabilityInfo* p = capability_info_;
  // @@protoc_insertion_point(field_get:mesos.LinuxInfo.capability_info)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::CapabilityInfo*>(
      &::mesos::_CapabilityInfo_default_instance_);
}
inline ::mesos::CapabilityInfo* LinuxInfo::release_capability_info() {
  // @@protoc_insertion_point(field_release:mesos.LinuxInfo.capability_info)
  clear_has_capability_info();
  ::mesos::CapabilityInfo* temp = capability_info_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  capability_info_ = NULL;
  return temp;
}
inline ::mesos::CapabilityInfo* LinuxInfo::unsafe_arena_release_capability_info() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.LinuxInfo.capability_info)
  clear_has_capability_info();
  ::mesos::CapabilityInfo* temp = capability_info_;
  capability_info_ = NULL;
  return temp;
}
inline ::mesos::CapabilityInfo* LinuxInfo::mutable_capability_info() {
  set_has_capability_info();
  if (capability_info_ == NULL) {
    _slow_mutable_capability_info();
  }
  // @@protoc_insertion_point(field_mutable:mesos.LinuxInfo.capability_info)
  return capability_info_;
}
inline void LinuxInfo::set_allocated_capability_info(::mesos::CapabilityInfo* capability_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete capability_info_;
  }
  if (capability_info) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(capability_info);
    if (message_arena != submessage_arena) {
      capability_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, capability_info, submessage_arena);
    }
    set_has_capability_info();
  } else {
    clear_has_capability_info();
  }
  capability_info_ = capability_info;
  // @@protoc_insertion_point(field_set_allocated:mesos.LinuxInfo.capability_info)
}

// optional .mesos.CapabilityInfo bounding_capabilities = 2;
inline bool LinuxInfo::has_bounding_capabilities() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LinuxInfo::set_has_bounding_capabilities() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LinuxInfo::clear_has_bounding_capabilities() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LinuxInfo::clear_bounding_capabilities() {
  if (bounding_capabilities_ != NULL) bounding_capabilities_->Clear();
  clear_has_bounding_capabilities();
}
inline const ::mesos::CapabilityInfo& LinuxInfo::bounding_capabilities() const {
  const ::mesos::CapabilityInfo* p = bounding_capabilities_;
  // @@protoc_insertion_point(field_get:mesos.LinuxInfo.bounding_capabilities)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::CapabilityInfo*>(
      &::mesos::_CapabilityInfo_default_instance_);
}
inline ::mesos::CapabilityInfo* LinuxInfo::release_bounding_capabilities() {
  // @@protoc_insertion_point(field_release:mesos.LinuxInfo.bounding_capabilities)
  clear_has_bounding_capabilities();
  ::mesos::CapabilityInfo* temp = bounding_capabilities_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  bounding_capabilities_ = NULL;
  return temp;
}
inline ::mesos::CapabilityInfo* LinuxInfo::unsafe_arena_release_bounding_capabilities() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.LinuxInfo.bounding_capabilities)
  clear_has_bounding_capabilities();
  ::mesos::CapabilityInfo* temp = bounding_capabilities_;
  bounding_capabilities_ = NULL;
  return temp;
}
inline ::mesos::CapabilityInfo* LinuxInfo::mutable_bounding_capabilities() {
  set_has_bounding_capabilities();
  if (bounding_capabilities_ == NULL) {
    _slow_mutable_bounding_capabilities();
  }
  // @@protoc_insertion_point(field_mutable:mesos.LinuxInfo.bounding_capabilities)
  return bounding_capabilities_;
}
inline void LinuxInfo::set_allocated_bounding_capabilities(::mesos::CapabilityInfo* bounding_capabilities) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete bounding_capabilities_;
  }
  if (bounding_capabilities) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(bounding_capabilities);
    if (message_arena != submessage_arena) {
      bounding_capabilities = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, bounding_capabilities, submessage_arena);
    }
    set_has_bounding_capabilities();
  } else {
    clear_has_bounding_capabilities();
  }
  bounding_capabilities_ = bounding_capabilities;
  // @@protoc_insertion_point(field_set_allocated:mesos.LinuxInfo.bounding_capabilities)
}

// optional .mesos.CapabilityInfo effective_capabilities = 3;
inline bool LinuxInfo::has_effective_capabilities() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LinuxInfo::set_has_effective_capabilities() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LinuxInfo::clear_has_effective_capabilities() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LinuxInfo::clear_effective_capabilities() {
  if (effective_capabilities_ != NULL) effective_capabilities_->Clear();
  clear_has_effective_capabilities();
}
inline const ::mesos::CapabilityInfo& LinuxInfo::effective_capabilities() const {
  const ::mesos::CapabilityInfo* p = effective_capabilities_;
  // @@protoc_insertion_point(field_get:mesos.LinuxInfo.effective_capabilities)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::CapabilityInfo*>(
      &::mesos::_CapabilityInfo_default_instance_);
}
inline ::mesos::CapabilityInfo* LinuxInfo::release_effective_capabilities() {
  // @@protoc_insertion_point(field_release:mesos.LinuxInfo.effective_capabilities)
  clear_has_effective_capabilities();
  ::mesos::CapabilityInfo* temp = effective_capabilities_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  effective_capabilities_ = NULL;
  return temp;
}
inline ::mesos::CapabilityInfo* LinuxInfo::unsafe_arena_release_effective_capabilities() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.LinuxInfo.effective_capabilities)
  clear_has_effective_capabilities();
  ::mesos::CapabilityInfo* temp = effective_capabilities_;
  effective_capabilities_ = NULL;
  return temp;
}
inline ::mesos::CapabilityInfo* LinuxInfo::mutable_effective_capabilities() {
  set_has_effective_capabilities();
  if (effective_capabilities_ == NULL) {
    _slow_mutable_effective_capabilities();
  }
  // @@protoc_insertion_point(field_mutable:mesos.LinuxInfo.effective_capabilities)
  return effective_capabilities_;
}
inline void LinuxInfo::set_allocated_effective_capabilities(::mesos::CapabilityInfo* effective_capabilities) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete effective_capabilities_;
  }
  if (effective_capabilities) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(effective_capabilities);
    if (message_arena != submessage_arena) {
      effective_capabilities = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, effective_capabilities, submessage_arena);
    }
    set_has_effective_capabilities();
  } else {
    clear_has_effective_capabilities();
  }
  effective_capabilities_ = effective_capabilities;
  // @@protoc_insertion_point(field_set_allocated:mesos.LinuxInfo.effective_capabilities)
}

// optional bool share_pid_namespace = 4;
inline bool LinuxInfo::has_share_pid_namespace() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LinuxInfo::set_has_share_pid_namespace() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LinuxInfo::clear_has_share_pid_namespace() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LinuxInfo::clear_share_pid_namespace() {
  share_pid_namespace_ = false;
  clear_has_share_pid_namespace();
}
inline bool LinuxInfo::share_pid_namespace() const {
  // @@protoc_insertion_point(field_get:mesos.LinuxInfo.share_pid_namespace)
  return share_pid_namespace_;
}
inline void LinuxInfo::set_share_pid_namespace(bool value) {
  set_has_share_pid_namespace();
  share_pid_namespace_ = value;
  // @@protoc_insertion_point(field_set:mesos.LinuxInfo.share_pid_namespace)
}

// -------------------------------------------------------------------

// RLimitInfo_RLimit

// optional .mesos.RLimitInfo.RLimit.Type type = 1;
inline bool RLimitInfo_RLimit::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RLimitInfo_RLimit::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RLimitInfo_RLimit::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RLimitInfo_RLimit::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::mesos::RLimitInfo_RLimit_Type RLimitInfo_RLimit::type() const {
  // @@protoc_insertion_point(field_get:mesos.RLimitInfo.RLimit.type)
  return static_cast< ::mesos::RLimitInfo_RLimit_Type >(type_);
}
inline void RLimitInfo_RLimit::set_type(::mesos::RLimitInfo_RLimit_Type value) {
  assert(::mesos::RLimitInfo_RLimit_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:mesos.RLimitInfo.RLimit.type)
}

// optional uint64 hard = 2;
inline bool RLimitInfo_RLimit::has_hard() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RLimitInfo_RLimit::set_has_hard() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RLimitInfo_RLimit::clear_has_hard() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RLimitInfo_RLimit::clear_hard() {
  hard_ = GOOGLE_ULONGLONG(0);
  clear_has_hard();
}
inline ::google::protobuf::uint64 RLimitInfo_RLimit::hard() const {
  // @@protoc_insertion_point(field_get:mesos.RLimitInfo.RLimit.hard)
  return hard_;
}
inline void RLimitInfo_RLimit::set_hard(::google::protobuf::uint64 value) {
  set_has_hard();
  hard_ = value;
  // @@protoc_insertion_point(field_set:mesos.RLimitInfo.RLimit.hard)
}

// optional uint64 soft = 3;
inline bool RLimitInfo_RLimit::has_soft() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RLimitInfo_RLimit::set_has_soft() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RLimitInfo_RLimit::clear_has_soft() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RLimitInfo_RLimit::clear_soft() {
  soft_ = GOOGLE_ULONGLONG(0);
  clear_has_soft();
}
inline ::google::protobuf::uint64 RLimitInfo_RLimit::soft() const {
  // @@protoc_insertion_point(field_get:mesos.RLimitInfo.RLimit.soft)
  return soft_;
}
inline void RLimitInfo_RLimit::set_soft(::google::protobuf::uint64 value) {
  set_has_soft();
  soft_ = value;
  // @@protoc_insertion_point(field_set:mesos.RLimitInfo.RLimit.soft)
}

// -------------------------------------------------------------------

// RLimitInfo

// repeated .mesos.RLimitInfo.RLimit rlimits = 1;
inline int RLimitInfo::rlimits_size() const {
  return rlimits_.size();
}
inline void RLimitInfo::clear_rlimits() {
  rlimits_.Clear();
}
inline const ::mesos::RLimitInfo_RLimit& RLimitInfo::rlimits(int index) const {
  // @@protoc_insertion_point(field_get:mesos.RLimitInfo.rlimits)
  return rlimits_.Get(index);
}
inline ::mesos::RLimitInfo_RLimit* RLimitInfo::mutable_rlimits(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.RLimitInfo.rlimits)
  return rlimits_.Mutable(index);
}
inline ::mesos::RLimitInfo_RLimit* RLimitInfo::add_rlimits() {
  // @@protoc_insertion_point(field_add:mesos.RLimitInfo.rlimits)
  return rlimits_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::RLimitInfo_RLimit >*
RLimitInfo::mutable_rlimits() {
  // @@protoc_insertion_point(field_mutable_list:mesos.RLimitInfo.rlimits)
  return &rlimits_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::RLimitInfo_RLimit >&
RLimitInfo::rlimits() const {
  // @@protoc_insertion_point(field_list:mesos.RLimitInfo.rlimits)
  return rlimits_;
}

// -------------------------------------------------------------------

// TTYInfo_WindowSize

// required uint32 rows = 1;
inline bool TTYInfo_WindowSize::has_rows() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TTYInfo_WindowSize::set_has_rows() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TTYInfo_WindowSize::clear_has_rows() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TTYInfo_WindowSize::clear_rows() {
  rows_ = 0u;
  clear_has_rows();
}
inline ::google::protobuf::uint32 TTYInfo_WindowSize::rows() const {
  // @@protoc_insertion_point(field_get:mesos.TTYInfo.WindowSize.rows)
  return rows_;
}
inline void TTYInfo_WindowSize::set_rows(::google::protobuf::uint32 value) {
  set_has_rows();
  rows_ = value;
  // @@protoc_insertion_point(field_set:mesos.TTYInfo.WindowSize.rows)
}

// required uint32 columns = 2;
inline bool TTYInfo_WindowSize::has_columns() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TTYInfo_WindowSize::set_has_columns() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TTYInfo_WindowSize::clear_has_columns() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TTYInfo_WindowSize::clear_columns() {
  columns_ = 0u;
  clear_has_columns();
}
inline ::google::protobuf::uint32 TTYInfo_WindowSize::columns() const {
  // @@protoc_insertion_point(field_get:mesos.TTYInfo.WindowSize.columns)
  return columns_;
}
inline void TTYInfo_WindowSize::set_columns(::google::protobuf::uint32 value) {
  set_has_columns();
  columns_ = value;
  // @@protoc_insertion_point(field_set:mesos.TTYInfo.WindowSize.columns)
}

// -------------------------------------------------------------------

// TTYInfo

// optional .mesos.TTYInfo.WindowSize window_size = 1;
inline bool TTYInfo::has_window_size() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TTYInfo::set_has_window_size() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TTYInfo::clear_has_window_size() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TTYInfo::clear_window_size() {
  if (window_size_ != NULL) window_size_->Clear();
  clear_has_window_size();
}
inline const ::mesos::TTYInfo_WindowSize& TTYInfo::window_size() const {
  const ::mesos::TTYInfo_WindowSize* p = window_size_;
  // @@protoc_insertion_point(field_get:mesos.TTYInfo.window_size)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::TTYInfo_WindowSize*>(
      &::mesos::_TTYInfo_WindowSize_default_instance_);
}
inline ::mesos::TTYInfo_WindowSize* TTYInfo::release_window_size() {
  // @@protoc_insertion_point(field_release:mesos.TTYInfo.window_size)
  clear_has_window_size();
  ::mesos::TTYInfo_WindowSize* temp = window_size_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  window_size_ = NULL;
  return temp;
}
inline ::mesos::TTYInfo_WindowSize* TTYInfo::unsafe_arena_release_window_size() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.TTYInfo.window_size)
  clear_has_window_size();
  ::mesos::TTYInfo_WindowSize* temp = window_size_;
  window_size_ = NULL;
  return temp;
}
inline ::mesos::TTYInfo_WindowSize* TTYInfo::mutable_window_size() {
  set_has_window_size();
  if (window_size_ == NULL) {
    _slow_mutable_window_size();
  }
  // @@protoc_insertion_point(field_mutable:mesos.TTYInfo.window_size)
  return window_size_;
}
inline void TTYInfo::set_allocated_window_size(::mesos::TTYInfo_WindowSize* window_size) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete window_size_;
  }
  if (window_size) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(window_size);
    if (message_arena != submessage_arena) {
      window_size = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, window_size, submessage_arena);
    }
    set_has_window_size();
  } else {
    clear_has_window_size();
  }
  window_size_ = window_size;
  // @@protoc_insertion_point(field_set_allocated:mesos.TTYInfo.window_size)
}

// -------------------------------------------------------------------

// ContainerInfo_DockerInfo_PortMapping

// required uint32 host_port = 1;
inline bool ContainerInfo_DockerInfo_PortMapping::has_host_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ContainerInfo_DockerInfo_PortMapping::set_has_host_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ContainerInfo_DockerInfo_PortMapping::clear_has_host_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ContainerInfo_DockerInfo_PortMapping::clear_host_port() {
  host_port_ = 0u;
  clear_has_host_port();
}
inline ::google::protobuf::uint32 ContainerInfo_DockerInfo_PortMapping::host_port() const {
  // @@protoc_insertion_point(field_get:mesos.ContainerInfo.DockerInfo.PortMapping.host_port)
  return host_port_;
}
inline void ContainerInfo_DockerInfo_PortMapping::set_host_port(::google::protobuf::uint32 value) {
  set_has_host_port();
  host_port_ = value;
  // @@protoc_insertion_point(field_set:mesos.ContainerInfo.DockerInfo.PortMapping.host_port)
}

// required uint32 container_port = 2;
inline bool ContainerInfo_DockerInfo_PortMapping::has_container_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ContainerInfo_DockerInfo_PortMapping::set_has_container_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ContainerInfo_DockerInfo_PortMapping::clear_has_container_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ContainerInfo_DockerInfo_PortMapping::clear_container_port() {
  container_port_ = 0u;
  clear_has_container_port();
}
inline ::google::protobuf::uint32 ContainerInfo_DockerInfo_PortMapping::container_port() const {
  // @@protoc_insertion_point(field_get:mesos.ContainerInfo.DockerInfo.PortMapping.container_port)
  return container_port_;
}
inline void ContainerInfo_DockerInfo_PortMapping::set_container_port(::google::protobuf::uint32 value) {
  set_has_container_port();
  container_port_ = value;
  // @@protoc_insertion_point(field_set:mesos.ContainerInfo.DockerInfo.PortMapping.container_port)
}

// optional string protocol = 3;
inline bool ContainerInfo_DockerInfo_PortMapping::has_protocol() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ContainerInfo_DockerInfo_PortMapping::set_has_protocol() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ContainerInfo_DockerInfo_PortMapping::clear_has_protocol() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ContainerInfo_DockerInfo_PortMapping::clear_protocol() {
  protocol_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_protocol();
}
inline const ::std::string& ContainerInfo_DockerInfo_PortMapping::protocol() const {
  // @@protoc_insertion_point(field_get:mesos.ContainerInfo.DockerInfo.PortMapping.protocol)
  return protocol_.Get();
}
inline void ContainerInfo_DockerInfo_PortMapping::set_protocol(const ::std::string& value) {
  set_has_protocol();
  protocol_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.ContainerInfo.DockerInfo.PortMapping.protocol)
}
#if LANG_CXX11
inline void ContainerInfo_DockerInfo_PortMapping::set_protocol(::std::string&& value) {
  set_has_protocol();
  protocol_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.ContainerInfo.DockerInfo.PortMapping.protocol)
}
#endif
inline void ContainerInfo_DockerInfo_PortMapping::set_protocol(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_protocol();
  protocol_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.ContainerInfo.DockerInfo.PortMapping.protocol)
}
inline void ContainerInfo_DockerInfo_PortMapping::set_protocol(const char* value,
    size_t size) {
  set_has_protocol();
  protocol_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.ContainerInfo.DockerInfo.PortMapping.protocol)
}
inline ::std::string* ContainerInfo_DockerInfo_PortMapping::mutable_protocol() {
  set_has_protocol();
  // @@protoc_insertion_point(field_mutable:mesos.ContainerInfo.DockerInfo.PortMapping.protocol)
  return protocol_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* ContainerInfo_DockerInfo_PortMapping::release_protocol() {
  // @@protoc_insertion_point(field_release:mesos.ContainerInfo.DockerInfo.PortMapping.protocol)
  clear_has_protocol();
  return protocol_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void ContainerInfo_DockerInfo_PortMapping::set_allocated_protocol(::std::string* protocol) {
  if (protocol != NULL) {
    set_has_protocol();
  } else {
    clear_has_protocol();
  }
  protocol_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), protocol,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.ContainerInfo.DockerInfo.PortMapping.protocol)
}
inline ::std::string* ContainerInfo_DockerInfo_PortMapping::unsafe_arena_release_protocol() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.ContainerInfo.DockerInfo.PortMapping.protocol)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_protocol();
  return protocol_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void ContainerInfo_DockerInfo_PortMapping::unsafe_arena_set_allocated_protocol(
    ::std::string* protocol) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (protocol != NULL) {
    set_has_protocol();
  } else {
    clear_has_protocol();
  }
  protocol_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      protocol, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.ContainerInfo.DockerInfo.PortMapping.protocol)
}

// -------------------------------------------------------------------

// ContainerInfo_DockerInfo

// required string image = 1;
inline bool ContainerInfo_DockerInfo::has_image() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ContainerInfo_DockerInfo::set_has_image() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ContainerInfo_DockerInfo::clear_has_image() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ContainerInfo_DockerInfo::clear_image() {
  image_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_image();
}
inline const ::std::string& ContainerInfo_DockerInfo::image() const {
  // @@protoc_insertion_point(field_get:mesos.ContainerInfo.DockerInfo.image)
  return image_.Get();
}
inline void ContainerInfo_DockerInfo::set_image(const ::std::string& value) {
  set_has_image();
  image_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.ContainerInfo.DockerInfo.image)
}
#if LANG_CXX11
inline void ContainerInfo_DockerInfo::set_image(::std::string&& value) {
  set_has_image();
  image_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.ContainerInfo.DockerInfo.image)
}
#endif
inline void ContainerInfo_DockerInfo::set_image(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_image();
  image_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.ContainerInfo.DockerInfo.image)
}
inline void ContainerInfo_DockerInfo::set_image(const char* value,
    size_t size) {
  set_has_image();
  image_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.ContainerInfo.DockerInfo.image)
}
inline ::std::string* ContainerInfo_DockerInfo::mutable_image() {
  set_has_image();
  // @@protoc_insertion_point(field_mutable:mesos.ContainerInfo.DockerInfo.image)
  return image_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* ContainerInfo_DockerInfo::release_image() {
  // @@protoc_insertion_point(field_release:mesos.ContainerInfo.DockerInfo.image)
  clear_has_image();
  return image_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void ContainerInfo_DockerInfo::set_allocated_image(::std::string* image) {
  if (image != NULL) {
    set_has_image();
  } else {
    clear_has_image();
  }
  image_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), image,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.ContainerInfo.DockerInfo.image)
}
inline ::std::string* ContainerInfo_DockerInfo::unsafe_arena_release_image() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.ContainerInfo.DockerInfo.image)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_image();
  return image_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void ContainerInfo_DockerInfo::unsafe_arena_set_allocated_image(
    ::std::string* image) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (image != NULL) {
    set_has_image();
  } else {
    clear_has_image();
  }
  image_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      image, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.ContainerInfo.DockerInfo.image)
}

// optional .mesos.ContainerInfo.DockerInfo.Network network = 2 [default = HOST];
inline bool ContainerInfo_DockerInfo::has_network() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ContainerInfo_DockerInfo::set_has_network() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ContainerInfo_DockerInfo::clear_has_network() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ContainerInfo_DockerInfo::clear_network() {
  network_ = 1;
  clear_has_network();
}
inline ::mesos::ContainerInfo_DockerInfo_Network ContainerInfo_DockerInfo::network() const {
  // @@protoc_insertion_point(field_get:mesos.ContainerInfo.DockerInfo.network)
  return static_cast< ::mesos::ContainerInfo_DockerInfo_Network >(network_);
}
inline void ContainerInfo_DockerInfo::set_network(::mesos::ContainerInfo_DockerInfo_Network value) {
  assert(::mesos::ContainerInfo_DockerInfo_Network_IsValid(value));
  set_has_network();
  network_ = value;
  // @@protoc_insertion_point(field_set:mesos.ContainerInfo.DockerInfo.network)
}

// repeated .mesos.ContainerInfo.DockerInfo.PortMapping port_mappings = 3;
inline int ContainerInfo_DockerInfo::port_mappings_size() const {
  return port_mappings_.size();
}
inline void ContainerInfo_DockerInfo::clear_port_mappings() {
  port_mappings_.Clear();
}
inline const ::mesos::ContainerInfo_DockerInfo_PortMapping& ContainerInfo_DockerInfo::port_mappings(int index) const {
  // @@protoc_insertion_point(field_get:mesos.ContainerInfo.DockerInfo.port_mappings)
  return port_mappings_.Get(index);
}
inline ::mesos::ContainerInfo_DockerInfo_PortMapping* ContainerInfo_DockerInfo::mutable_port_mappings(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.ContainerInfo.DockerInfo.port_mappings)
  return port_mappings_.Mutable(index);
}
inline ::mesos::ContainerInfo_DockerInfo_PortMapping* ContainerInfo_DockerInfo::add_port_mappings() {
  // @@protoc_insertion_point(field_add:mesos.ContainerInfo.DockerInfo.port_mappings)
  return port_mappings_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::ContainerInfo_DockerInfo_PortMapping >*
ContainerInfo_DockerInfo::mutable_port_mappings() {
  // @@protoc_insertion_point(field_mutable_list:mesos.ContainerInfo.DockerInfo.port_mappings)
  return &port_mappings_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::ContainerInfo_DockerInfo_PortMapping >&
ContainerInfo_DockerInfo::port_mappings() const {
  // @@protoc_insertion_point(field_list:mesos.ContainerInfo.DockerInfo.port_mappings)
  return port_mappings_;
}

// optional bool privileged = 4 [default = false];
inline bool ContainerInfo_DockerInfo::has_privileged() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ContainerInfo_DockerInfo::set_has_privileged() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ContainerInfo_DockerInfo::clear_has_privileged() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ContainerInfo_DockerInfo::clear_privileged() {
  privileged_ = false;
  clear_has_privileged();
}
inline bool ContainerInfo_DockerInfo::privileged() const {
  // @@protoc_insertion_point(field_get:mesos.ContainerInfo.DockerInfo.privileged)
  return privileged_;
}
inline void ContainerInfo_DockerInfo::set_privileged(bool value) {
  set_has_privileged();
  privileged_ = value;
  // @@protoc_insertion_point(field_set:mesos.ContainerInfo.DockerInfo.privileged)
}

// repeated .mesos.Parameter parameters = 5;
inline int ContainerInfo_DockerInfo::parameters_size() const {
  return parameters_.size();
}
inline void ContainerInfo_DockerInfo::clear_parameters() {
  parameters_.Clear();
}
inline const ::mesos::Parameter& ContainerInfo_DockerInfo::parameters(int index) const {
  // @@protoc_insertion_point(field_get:mesos.ContainerInfo.DockerInfo.parameters)
  return parameters_.Get(index);
}
inline ::mesos::Parameter* ContainerInfo_DockerInfo::mutable_parameters(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.ContainerInfo.DockerInfo.parameters)
  return parameters_.Mutable(index);
}
inline ::mesos::Parameter* ContainerInfo_DockerInfo::add_parameters() {
  // @@protoc_insertion_point(field_add:mesos.ContainerInfo.DockerInfo.parameters)
  return parameters_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Parameter >*
ContainerInfo_DockerInfo::mutable_parameters() {
  // @@protoc_insertion_point(field_mutable_list:mesos.ContainerInfo.DockerInfo.parameters)
  return &parameters_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Parameter >&
ContainerInfo_DockerInfo::parameters() const {
  // @@protoc_insertion_point(field_list:mesos.ContainerInfo.DockerInfo.parameters)
  return parameters_;
}

// optional bool force_pull_image = 6;
inline bool ContainerInfo_DockerInfo::has_force_pull_image() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ContainerInfo_DockerInfo::set_has_force_pull_image() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ContainerInfo_DockerInfo::clear_has_force_pull_image() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ContainerInfo_DockerInfo::clear_force_pull_image() {
  force_pull_image_ = false;
  clear_has_force_pull_image();
}
inline bool ContainerInfo_DockerInfo::force_pull_image() const {
  // @@protoc_insertion_point(field_get:mesos.ContainerInfo.DockerInfo.force_pull_image)
  return force_pull_image_;
}
inline void ContainerInfo_DockerInfo::set_force_pull_image(bool value) {
  set_has_force_pull_image();
  force_pull_image_ = value;
  // @@protoc_insertion_point(field_set:mesos.ContainerInfo.DockerInfo.force_pull_image)
}

// optional string volume_driver = 7 [deprecated = true];
inline bool ContainerInfo_DockerInfo::has_volume_driver() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ContainerInfo_DockerInfo::set_has_volume_driver() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ContainerInfo_DockerInfo::clear_has_volume_driver() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ContainerInfo_DockerInfo::clear_volume_driver() {
  volume_driver_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_volume_driver();
}
inline const ::std::string& ContainerInfo_DockerInfo::volume_driver() const {
  // @@protoc_insertion_point(field_get:mesos.ContainerInfo.DockerInfo.volume_driver)
  return volume_driver_.Get();
}
inline void ContainerInfo_DockerInfo::set_volume_driver(const ::std::string& value) {
  set_has_volume_driver();
  volume_driver_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.ContainerInfo.DockerInfo.volume_driver)
}
#if LANG_CXX11
inline void ContainerInfo_DockerInfo::set_volume_driver(::std::string&& value) {
  set_has_volume_driver();
  volume_driver_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.ContainerInfo.DockerInfo.volume_driver)
}
#endif
inline void ContainerInfo_DockerInfo::set_volume_driver(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_volume_driver();
  volume_driver_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.ContainerInfo.DockerInfo.volume_driver)
}
inline void ContainerInfo_DockerInfo::set_volume_driver(const char* value,
    size_t size) {
  set_has_volume_driver();
  volume_driver_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.ContainerInfo.DockerInfo.volume_driver)
}
inline ::std::string* ContainerInfo_DockerInfo::mutable_volume_driver() {
  set_has_volume_driver();
  // @@protoc_insertion_point(field_mutable:mesos.ContainerInfo.DockerInfo.volume_driver)
  return volume_driver_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* ContainerInfo_DockerInfo::release_volume_driver() {
  // @@protoc_insertion_point(field_release:mesos.ContainerInfo.DockerInfo.volume_driver)
  clear_has_volume_driver();
  return volume_driver_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void ContainerInfo_DockerInfo::set_allocated_volume_driver(::std::string* volume_driver) {
  if (volume_driver != NULL) {
    set_has_volume_driver();
  } else {
    clear_has_volume_driver();
  }
  volume_driver_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), volume_driver,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.ContainerInfo.DockerInfo.volume_driver)
}
inline ::std::string* ContainerInfo_DockerInfo::unsafe_arena_release_volume_driver() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.ContainerInfo.DockerInfo.volume_driver)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_volume_driver();
  return volume_driver_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void ContainerInfo_DockerInfo::unsafe_arena_set_allocated_volume_driver(
    ::std::string* volume_driver) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (volume_driver != NULL) {
    set_has_volume_driver();
  } else {
    clear_has_volume_driver();
  }
  volume_driver_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      volume_driver, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.ContainerInfo.DockerInfo.volume_driver)
}

// -------------------------------------------------------------------

// ContainerInfo_MesosInfo

// optional .mesos.Image image = 1;
inline bool ContainerInfo_MesosInfo::has_image() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ContainerInfo_MesosInfo::set_has_image() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ContainerInfo_MesosInfo::clear_has_image() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ContainerInfo_MesosInfo::clear_image() {
  if (image_ != NULL) image_->Clear();
  clear_has_image();
}
inline const ::mesos::Image& ContainerInfo_MesosInfo::image() const {
  const ::mesos::Image* p = image_;
  // @@protoc_insertion_point(field_get:mesos.ContainerInfo.MesosInfo.image)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::Image*>(
      &::mesos::_Image_default_instance_);
}
inline ::mesos::Image* ContainerInfo_MesosInfo::release_image() {
  // @@protoc_insertion_point(field_release:mesos.ContainerInfo.MesosInfo.image)
  clear_has_image();
  ::mesos::Image* temp = image_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  image_ = NULL;
  return temp;
}
inline ::mesos::Image* ContainerInfo_MesosInfo::unsafe_arena_release_image() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.ContainerInfo.MesosInfo.image)
  clear_has_image();
  ::mesos::Image* temp = image_;
  image_ = NULL;
  return temp;
}
inline ::mesos::Image* ContainerInfo_MesosInfo::mutable_image() {
  set_has_image();
  if (image_ == NULL) {
    _slow_mutable_image();
  }
  // @@protoc_insertion_point(field_mutable:mesos.ContainerInfo.MesosInfo.image)
  return image_;
}
inline void ContainerInfo_MesosInfo::set_allocated_image(::mesos::Image* image) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete image_;
  }
  if (image) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(image);
    if (message_arena != submessage_arena) {
      image = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, image, submessage_arena);
    }
    set_has_image();
  } else {
    clear_has_image();
  }
  image_ = image;
  // @@protoc_insertion_point(field_set_allocated:mesos.ContainerInfo.MesosInfo.image)
}

// -------------------------------------------------------------------

// ContainerInfo

// required .mesos.ContainerInfo.Type type = 1;
inline bool ContainerInfo::has_type() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ContainerInfo::set_has_type() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ContainerInfo::clear_has_type() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ContainerInfo::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::mesos::ContainerInfo_Type ContainerInfo::type() const {
  // @@protoc_insertion_point(field_get:mesos.ContainerInfo.type)
  return static_cast< ::mesos::ContainerInfo_Type >(type_);
}
inline void ContainerInfo::set_type(::mesos::ContainerInfo_Type value) {
  assert(::mesos::ContainerInfo_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:mesos.ContainerInfo.type)
}

// repeated .mesos.Volume volumes = 2;
inline int ContainerInfo::volumes_size() const {
  return volumes_.size();
}
inline void ContainerInfo::clear_volumes() {
  volumes_.Clear();
}
inline const ::mesos::Volume& ContainerInfo::volumes(int index) const {
  // @@protoc_insertion_point(field_get:mesos.ContainerInfo.volumes)
  return volumes_.Get(index);
}
inline ::mesos::Volume* ContainerInfo::mutable_volumes(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.ContainerInfo.volumes)
  return volumes_.Mutable(index);
}
inline ::mesos::Volume* ContainerInfo::add_volumes() {
  // @@protoc_insertion_point(field_add:mesos.ContainerInfo.volumes)
  return volumes_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Volume >*
ContainerInfo::mutable_volumes() {
  // @@protoc_insertion_point(field_mutable_list:mesos.ContainerInfo.volumes)
  return &volumes_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Volume >&
ContainerInfo::volumes() const {
  // @@protoc_insertion_point(field_list:mesos.ContainerInfo.volumes)
  return volumes_;
}

// optional string hostname = 4;
inline bool ContainerInfo::has_hostname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ContainerInfo::set_has_hostname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ContainerInfo::clear_has_hostname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ContainerInfo::clear_hostname() {
  hostname_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_hostname();
}
inline const ::std::string& ContainerInfo::hostname() const {
  // @@protoc_insertion_point(field_get:mesos.ContainerInfo.hostname)
  return hostname_.Get();
}
inline void ContainerInfo::set_hostname(const ::std::string& value) {
  set_has_hostname();
  hostname_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.ContainerInfo.hostname)
}
#if LANG_CXX11
inline void ContainerInfo::set_hostname(::std::string&& value) {
  set_has_hostname();
  hostname_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.ContainerInfo.hostname)
}
#endif
inline void ContainerInfo::set_hostname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_hostname();
  hostname_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.ContainerInfo.hostname)
}
inline void ContainerInfo::set_hostname(const char* value,
    size_t size) {
  set_has_hostname();
  hostname_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.ContainerInfo.hostname)
}
inline ::std::string* ContainerInfo::mutable_hostname() {
  set_has_hostname();
  // @@protoc_insertion_point(field_mutable:mesos.ContainerInfo.hostname)
  return hostname_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* ContainerInfo::release_hostname() {
  // @@protoc_insertion_point(field_release:mesos.ContainerInfo.hostname)
  clear_has_hostname();
  return hostname_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void ContainerInfo::set_allocated_hostname(::std::string* hostname) {
  if (hostname != NULL) {
    set_has_hostname();
  } else {
    clear_has_hostname();
  }
  hostname_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hostname,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.ContainerInfo.hostname)
}
inline ::std::string* ContainerInfo::unsafe_arena_release_hostname() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.ContainerInfo.hostname)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_hostname();
  return hostname_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void ContainerInfo::unsafe_arena_set_allocated_hostname(
    ::std::string* hostname) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (hostname != NULL) {
    set_has_hostname();
  } else {
    clear_has_hostname();
  }
  hostname_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      hostname, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.ContainerInfo.hostname)
}

// optional .mesos.ContainerInfo.DockerInfo docker = 3;
inline bool ContainerInfo::has_docker() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ContainerInfo::set_has_docker() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ContainerInfo::clear_has_docker() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ContainerInfo::clear_docker() {
  if (docker_ != NULL) docker_->Clear();
  clear_has_docker();
}
inline const ::mesos::ContainerInfo_DockerInfo& ContainerInfo::docker() const {
  const ::mesos::ContainerInfo_DockerInfo* p = docker_;
  // @@protoc_insertion_point(field_get:mesos.ContainerInfo.docker)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ContainerInfo_DockerInfo*>(
      &::mesos::_ContainerInfo_DockerInfo_default_instance_);
}
inline ::mesos::ContainerInfo_DockerInfo* ContainerInfo::release_docker() {
  // @@protoc_insertion_point(field_release:mesos.ContainerInfo.docker)
  clear_has_docker();
  ::mesos::ContainerInfo_DockerInfo* temp = docker_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  docker_ = NULL;
  return temp;
}
inline ::mesos::ContainerInfo_DockerInfo* ContainerInfo::unsafe_arena_release_docker() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.ContainerInfo.docker)
  clear_has_docker();
  ::mesos::ContainerInfo_DockerInfo* temp = docker_;
  docker_ = NULL;
  return temp;
}
inline ::mesos::ContainerInfo_DockerInfo* ContainerInfo::mutable_docker() {
  set_has_docker();
  if (docker_ == NULL) {
    _slow_mutable_docker();
  }
  // @@protoc_insertion_point(field_mutable:mesos.ContainerInfo.docker)
  return docker_;
}
inline void ContainerInfo::set_allocated_docker(::mesos::ContainerInfo_DockerInfo* docker) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete docker_;
  }
  if (docker) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(docker);
    if (message_arena != submessage_arena) {
      docker = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, docker, submessage_arena);
    }
    set_has_docker();
  } else {
    clear_has_docker();
  }
  docker_ = docker;
  // @@protoc_insertion_point(field_set_allocated:mesos.ContainerInfo.docker)
}

// optional .mesos.ContainerInfo.MesosInfo mesos = 5;
inline bool ContainerInfo::has_mesos() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ContainerInfo::set_has_mesos() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ContainerInfo::clear_has_mesos() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ContainerInfo::clear_mesos() {
  if (mesos_ != NULL) mesos_->Clear();
  clear_has_mesos();
}
inline const ::mesos::ContainerInfo_MesosInfo& ContainerInfo::mesos() const {
  const ::mesos::ContainerInfo_MesosInfo* p = mesos_;
  // @@protoc_insertion_point(field_get:mesos.ContainerInfo.mesos)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ContainerInfo_MesosInfo*>(
      &::mesos::_ContainerInfo_MesosInfo_default_instance_);
}
inline ::mesos::ContainerInfo_MesosInfo* ContainerInfo::release_mesos() {
  // @@protoc_insertion_point(field_release:mesos.ContainerInfo.mesos)
  clear_has_mesos();
  ::mesos::ContainerInfo_MesosInfo* temp = mesos_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  mesos_ = NULL;
  return temp;
}
inline ::mesos::ContainerInfo_MesosInfo* ContainerInfo::unsafe_arena_release_mesos() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.ContainerInfo.mesos)
  clear_has_mesos();
  ::mesos::ContainerInfo_MesosInfo* temp = mesos_;
  mesos_ = NULL;
  return temp;
}
inline ::mesos::ContainerInfo_MesosInfo* ContainerInfo::mutable_mesos() {
  set_has_mesos();
  if (mesos_ == NULL) {
    _slow_mutable_mesos();
  }
  // @@protoc_insertion_point(field_mutable:mesos.ContainerInfo.mesos)
  return mesos_;
}
inline void ContainerInfo::set_allocated_mesos(::mesos::ContainerInfo_MesosInfo* mesos) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete mesos_;
  }
  if (mesos) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(mesos);
    if (message_arena != submessage_arena) {
      mesos = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, mesos, submessage_arena);
    }
    set_has_mesos();
  } else {
    clear_has_mesos();
  }
  mesos_ = mesos;
  // @@protoc_insertion_point(field_set_allocated:mesos.ContainerInfo.mesos)
}

// repeated .mesos.NetworkInfo network_infos = 7;
inline int ContainerInfo::network_infos_size() const {
  return network_infos_.size();
}
inline void ContainerInfo::clear_network_infos() {
  network_infos_.Clear();
}
inline const ::mesos::NetworkInfo& ContainerInfo::network_infos(int index) const {
  // @@protoc_insertion_point(field_get:mesos.ContainerInfo.network_infos)
  return network_infos_.Get(index);
}
inline ::mesos::NetworkInfo* ContainerInfo::mutable_network_infos(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.ContainerInfo.network_infos)
  return network_infos_.Mutable(index);
}
inline ::mesos::NetworkInfo* ContainerInfo::add_network_infos() {
  // @@protoc_insertion_point(field_add:mesos.ContainerInfo.network_infos)
  return network_infos_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::NetworkInfo >*
ContainerInfo::mutable_network_infos() {
  // @@protoc_insertion_point(field_mutable_list:mesos.ContainerInfo.network_infos)
  return &network_infos_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::NetworkInfo >&
ContainerInfo::network_infos() const {
  // @@protoc_insertion_point(field_list:mesos.ContainerInfo.network_infos)
  return network_infos_;
}

// optional .mesos.LinuxInfo linux_info = 8;
inline bool ContainerInfo::has_linux_info() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ContainerInfo::set_has_linux_info() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ContainerInfo::clear_has_linux_info() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ContainerInfo::clear_linux_info() {
  if (linux_info_ != NULL) linux_info_->Clear();
  clear_has_linux_info();
}
inline const ::mesos::LinuxInfo& ContainerInfo::linux_info() const {
  const ::mesos::LinuxInfo* p = linux_info_;
  // @@protoc_insertion_point(field_get:mesos.ContainerInfo.linux_info)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::LinuxInfo*>(
      &::mesos::_LinuxInfo_default_instance_);
}
inline ::mesos::LinuxInfo* ContainerInfo::release_linux_info() {
  // @@protoc_insertion_point(field_release:mesos.ContainerInfo.linux_info)
  clear_has_linux_info();
  ::mesos::LinuxInfo* temp = linux_info_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  linux_info_ = NULL;
  return temp;
}
inline ::mesos::LinuxInfo* ContainerInfo::unsafe_arena_release_linux_info() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.ContainerInfo.linux_info)
  clear_has_linux_info();
  ::mesos::LinuxInfo* temp = linux_info_;
  linux_info_ = NULL;
  return temp;
}
inline ::mesos::LinuxInfo* ContainerInfo::mutable_linux_info() {
  set_has_linux_info();
  if (linux_info_ == NULL) {
    _slow_mutable_linux_info();
  }
  // @@protoc_insertion_point(field_mutable:mesos.ContainerInfo.linux_info)
  return linux_info_;
}
inline void ContainerInfo::set_allocated_linux_info(::mesos::LinuxInfo* linux_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete linux_info_;
  }
  if (linux_info) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(linux_info);
    if (message_arena != submessage_arena) {
      linux_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, linux_info, submessage_arena);
    }
    set_has_linux_info();
  } else {
    clear_has_linux_info();
  }
  linux_info_ = linux_info;
  // @@protoc_insertion_point(field_set_allocated:mesos.ContainerInfo.linux_info)
}

// optional .mesos.RLimitInfo rlimit_info = 9;
inline bool ContainerInfo::has_rlimit_info() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ContainerInfo::set_has_rlimit_info() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ContainerInfo::clear_has_rlimit_info() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ContainerInfo::clear_rlimit_info() {
  if (rlimit_info_ != NULL) rlimit_info_->Clear();
  clear_has_rlimit_info();
}
inline const ::mesos::RLimitInfo& ContainerInfo::rlimit_info() const {
  const ::mesos::RLimitInfo* p = rlimit_info_;
  // @@protoc_insertion_point(field_get:mesos.ContainerInfo.rlimit_info)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::RLimitInfo*>(
      &::mesos::_RLimitInfo_default_instance_);
}
inline ::mesos::RLimitInfo* ContainerInfo::release_rlimit_info() {
  // @@protoc_insertion_point(field_release:mesos.ContainerInfo.rlimit_info)
  clear_has_rlimit_info();
  ::mesos::RLimitInfo* temp = rlimit_info_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  rlimit_info_ = NULL;
  return temp;
}
inline ::mesos::RLimitInfo* ContainerInfo::unsafe_arena_release_rlimit_info() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.ContainerInfo.rlimit_info)
  clear_has_rlimit_info();
  ::mesos::RLimitInfo* temp = rlimit_info_;
  rlimit_info_ = NULL;
  return temp;
}
inline ::mesos::RLimitInfo* ContainerInfo::mutable_rlimit_info() {
  set_has_rlimit_info();
  if (rlimit_info_ == NULL) {
    _slow_mutable_rlimit_info();
  }
  // @@protoc_insertion_point(field_mutable:mesos.ContainerInfo.rlimit_info)
  return rlimit_info_;
}
inline void ContainerInfo::set_allocated_rlimit_info(::mesos::RLimitInfo* rlimit_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete rlimit_info_;
  }
  if (rlimit_info) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(rlimit_info);
    if (message_arena != submessage_arena) {
      rlimit_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, rlimit_info, submessage_arena);
    }
    set_has_rlimit_info();
  } else {
    clear_has_rlimit_info();
  }
  rlimit_info_ = rlimit_info;
  // @@protoc_insertion_point(field_set_allocated:mesos.ContainerInfo.rlimit_info)
}

// optional .mesos.TTYInfo tty_info = 10;
inline bool ContainerInfo::has_tty_info() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ContainerInfo::set_has_tty_info() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ContainerInfo::clear_has_tty_info() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ContainerInfo::clear_tty_info() {
  if (tty_info_ != NULL) tty_info_->Clear();
  clear_has_tty_info();
}
inline const ::mesos::TTYInfo& ContainerInfo::tty_info() const {
  const ::mesos::TTYInfo* p = tty_info_;
  // @@protoc_insertion_point(field_get:mesos.ContainerInfo.tty_info)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::TTYInfo*>(
      &::mesos::_TTYInfo_default_instance_);
}
inline ::mesos::TTYInfo* ContainerInfo::release_tty_info() {
  // @@protoc_insertion_point(field_release:mesos.ContainerInfo.tty_info)
  clear_has_tty_info();
  ::mesos::TTYInfo* temp = tty_info_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  tty_info_ = NULL;
  return temp;
}
inline ::mesos::TTYInfo* ContainerInfo::unsafe_arena_release_tty_info() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.ContainerInfo.tty_info)
  clear_has_tty_info();
  ::mesos::TTYInfo* temp = tty_info_;
  tty_info_ = NULL;
  return temp;
}
inline ::mesos::TTYInfo* ContainerInfo::mutable_tty_info() {
  set_has_tty_info();
  if (tty_info_ == NULL) {
    _slow_mutable_tty_info();
  }
  // @@protoc_insertion_point(field_mutable:mesos.ContainerInfo.tty_info)
  return tty_info_;
}
inline void ContainerInfo::set_allocated_tty_info(::mesos::TTYInfo* tty_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete tty_info_;
  }
  if (tty_info) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(tty_info);
    if (message_arena != submessage_arena) {
      tty_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, tty_info, submessage_arena);
    }
    set_has_tty_info();
  } else {
    clear_has_tty_info();
  }
  tty_info_ = tty_info;
  // @@protoc_insertion_point(field_set_allocated:mesos.ContainerInfo.tty_info)
}

// -------------------------------------------------------------------

// ContainerStatus

// optional .mesos.ContainerID container_id = 4;
inline bool ContainerStatus::has_container_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ContainerStatus::set_has_container_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ContainerStatus::clear_has_container_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ContainerStatus::clear_container_id() {
  if (container_id_ != NULL) container_id_->Clear();
  clear_has_container_id();
}
inline const ::mesos::ContainerID& ContainerStatus::container_id() const {
  const ::mesos::ContainerID* p = container_id_;
  // @@protoc_insertion_point(field_get:mesos.ContainerStatus.container_id)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ContainerID*>(
      &::mesos::_ContainerID_default_instance_);
}
inline ::mesos::ContainerID* ContainerStatus::release_container_id() {
  // @@protoc_insertion_point(field_release:mesos.ContainerStatus.container_id)
  clear_has_container_id();
  ::mesos::ContainerID* temp = container_id_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  container_id_ = NULL;
  return temp;
}
inline ::mesos::ContainerID* ContainerStatus::unsafe_arena_release_container_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.ContainerStatus.container_id)
  clear_has_container_id();
  ::mesos::ContainerID* temp = container_id_;
  container_id_ = NULL;
  return temp;
}
inline ::mesos::ContainerID* ContainerStatus::mutable_container_id() {
  set_has_container_id();
  if (container_id_ == NULL) {
    _slow_mutable_container_id();
  }
  // @@protoc_insertion_point(field_mutable:mesos.ContainerStatus.container_id)
  return container_id_;
}
inline void ContainerStatus::set_allocated_container_id(::mesos::ContainerID* container_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete container_id_;
  }
  if (container_id) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(container_id);
    if (message_arena != submessage_arena) {
      container_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, container_id, submessage_arena);
    }
    set_has_container_id();
  } else {
    clear_has_container_id();
  }
  container_id_ = container_id;
  // @@protoc_insertion_point(field_set_allocated:mesos.ContainerStatus.container_id)
}

// repeated .mesos.NetworkInfo network_infos = 1;
inline int ContainerStatus::network_infos_size() const {
  return network_infos_.size();
}
inline void ContainerStatus::clear_network_infos() {
  network_infos_.Clear();
}
inline const ::mesos::NetworkInfo& ContainerStatus::network_infos(int index) const {
  // @@protoc_insertion_point(field_get:mesos.ContainerStatus.network_infos)
  return network_infos_.Get(index);
}
inline ::mesos::NetworkInfo* ContainerStatus::mutable_network_infos(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.ContainerStatus.network_infos)
  return network_infos_.Mutable(index);
}
inline ::mesos::NetworkInfo* ContainerStatus::add_network_infos() {
  // @@protoc_insertion_point(field_add:mesos.ContainerStatus.network_infos)
  return network_infos_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::NetworkInfo >*
ContainerStatus::mutable_network_infos() {
  // @@protoc_insertion_point(field_mutable_list:mesos.ContainerStatus.network_infos)
  return &network_infos_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::NetworkInfo >&
ContainerStatus::network_infos() const {
  // @@protoc_insertion_point(field_list:mesos.ContainerStatus.network_infos)
  return network_infos_;
}

// optional .mesos.CgroupInfo cgroup_info = 2;
inline bool ContainerStatus::has_cgroup_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ContainerStatus::set_has_cgroup_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ContainerStatus::clear_has_cgroup_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ContainerStatus::clear_cgroup_info() {
  if (cgroup_info_ != NULL) cgroup_info_->Clear();
  clear_has_cgroup_info();
}
inline const ::mesos::CgroupInfo& ContainerStatus::cgroup_info() const {
  const ::mesos::CgroupInfo* p = cgroup_info_;
  // @@protoc_insertion_point(field_get:mesos.ContainerStatus.cgroup_info)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::CgroupInfo*>(
      &::mesos::_CgroupInfo_default_instance_);
}
inline ::mesos::CgroupInfo* ContainerStatus::release_cgroup_info() {
  // @@protoc_insertion_point(field_release:mesos.ContainerStatus.cgroup_info)
  clear_has_cgroup_info();
  ::mesos::CgroupInfo* temp = cgroup_info_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  cgroup_info_ = NULL;
  return temp;
}
inline ::mesos::CgroupInfo* ContainerStatus::unsafe_arena_release_cgroup_info() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.ContainerStatus.cgroup_info)
  clear_has_cgroup_info();
  ::mesos::CgroupInfo* temp = cgroup_info_;
  cgroup_info_ = NULL;
  return temp;
}
inline ::mesos::CgroupInfo* ContainerStatus::mutable_cgroup_info() {
  set_has_cgroup_info();
  if (cgroup_info_ == NULL) {
    _slow_mutable_cgroup_info();
  }
  // @@protoc_insertion_point(field_mutable:mesos.ContainerStatus.cgroup_info)
  return cgroup_info_;
}
inline void ContainerStatus::set_allocated_cgroup_info(::mesos::CgroupInfo* cgroup_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete cgroup_info_;
  }
  if (cgroup_info) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(cgroup_info);
    if (message_arena != submessage_arena) {
      cgroup_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, cgroup_info, submessage_arena);
    }
    set_has_cgroup_info();
  } else {
    clear_has_cgroup_info();
  }
  cgroup_info_ = cgroup_info;
  // @@protoc_insertion_point(field_set_allocated:mesos.ContainerStatus.cgroup_info)
}

// optional uint32 executor_pid = 3;
inline bool ContainerStatus::has_executor_pid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ContainerStatus::set_has_executor_pid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ContainerStatus::clear_has_executor_pid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ContainerStatus::clear_executor_pid() {
  executor_pid_ = 0u;
  clear_has_executor_pid();
}
inline ::google::protobuf::uint32 ContainerStatus::executor_pid() const {
  // @@protoc_insertion_point(field_get:mesos.ContainerStatus.executor_pid)
  return executor_pid_;
}
inline void ContainerStatus::set_executor_pid(::google::protobuf::uint32 value) {
  set_has_executor_pid();
  executor_pid_ = value;
  // @@protoc_insertion_point(field_set:mesos.ContainerStatus.executor_pid)
}

// -------------------------------------------------------------------

// CgroupInfo_Blkio_Value

// optional .mesos.CgroupInfo.Blkio.Operation op = 1;
inline bool CgroupInfo_Blkio_Value::has_op() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CgroupInfo_Blkio_Value::set_has_op() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CgroupInfo_Blkio_Value::clear_has_op() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CgroupInfo_Blkio_Value::clear_op() {
  op_ = 0;
  clear_has_op();
}
inline ::mesos::CgroupInfo_Blkio_Operation CgroupInfo_Blkio_Value::op() const {
  // @@protoc_insertion_point(field_get:mesos.CgroupInfo.Blkio.Value.op)
  return static_cast< ::mesos::CgroupInfo_Blkio_Operation >(op_);
}
inline void CgroupInfo_Blkio_Value::set_op(::mesos::CgroupInfo_Blkio_Operation value) {
  assert(::mesos::CgroupInfo_Blkio_Operation_IsValid(value));
  set_has_op();
  op_ = value;
  // @@protoc_insertion_point(field_set:mesos.CgroupInfo.Blkio.Value.op)
}

// optional uint64 value = 2;
inline bool CgroupInfo_Blkio_Value::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CgroupInfo_Blkio_Value::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CgroupInfo_Blkio_Value::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CgroupInfo_Blkio_Value::clear_value() {
  value_ = GOOGLE_ULONGLONG(0);
  clear_has_value();
}
inline ::google::protobuf::uint64 CgroupInfo_Blkio_Value::value() const {
  // @@protoc_insertion_point(field_get:mesos.CgroupInfo.Blkio.Value.value)
  return value_;
}
inline void CgroupInfo_Blkio_Value::set_value(::google::protobuf::uint64 value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:mesos.CgroupInfo.Blkio.Value.value)
}

// -------------------------------------------------------------------

// CgroupInfo_Blkio_CFQ_Statistics

// optional .mesos.Device.Number device = 1;
inline bool CgroupInfo_Blkio_CFQ_Statistics::has_device() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CgroupInfo_Blkio_CFQ_Statistics::set_has_device() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CgroupInfo_Blkio_CFQ_Statistics::clear_has_device() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CgroupInfo_Blkio_CFQ_Statistics::clear_device() {
  if (device_ != NULL) device_->Clear();
  clear_has_device();
}
inline const ::mesos::Device_Number& CgroupInfo_Blkio_CFQ_Statistics::device() const {
  const ::mesos::Device_Number* p = device_;
  // @@protoc_insertion_point(field_get:mesos.CgroupInfo.Blkio.CFQ.Statistics.device)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::Device_Number*>(
      &::mesos::_Device_Number_default_instance_);
}
inline ::mesos::Device_Number* CgroupInfo_Blkio_CFQ_Statistics::release_device() {
  // @@protoc_insertion_point(field_release:mesos.CgroupInfo.Blkio.CFQ.Statistics.device)
  clear_has_device();
  ::mesos::Device_Number* temp = device_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  device_ = NULL;
  return temp;
}
inline ::mesos::Device_Number* CgroupInfo_Blkio_CFQ_Statistics::unsafe_arena_release_device() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.CgroupInfo.Blkio.CFQ.Statistics.device)
  clear_has_device();
  ::mesos::Device_Number* temp = device_;
  device_ = NULL;
  return temp;
}
inline ::mesos::Device_Number* CgroupInfo_Blkio_CFQ_Statistics::mutable_device() {
  set_has_device();
  if (device_ == NULL) {
    _slow_mutable_device();
  }
  // @@protoc_insertion_point(field_mutable:mesos.CgroupInfo.Blkio.CFQ.Statistics.device)
  return device_;
}
inline void CgroupInfo_Blkio_CFQ_Statistics::set_allocated_device(::mesos::Device_Number* device) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete device_;
  }
  if (device) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(device);
    if (message_arena != submessage_arena) {
      device = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, device, submessage_arena);
    }
    set_has_device();
  } else {
    clear_has_device();
  }
  device_ = device;
  // @@protoc_insertion_point(field_set_allocated:mesos.CgroupInfo.Blkio.CFQ.Statistics.device)
}

// optional uint64 sectors = 2;
inline bool CgroupInfo_Blkio_CFQ_Statistics::has_sectors() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CgroupInfo_Blkio_CFQ_Statistics::set_has_sectors() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CgroupInfo_Blkio_CFQ_Statistics::clear_has_sectors() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CgroupInfo_Blkio_CFQ_Statistics::clear_sectors() {
  sectors_ = GOOGLE_ULONGLONG(0);
  clear_has_sectors();
}
inline ::google::protobuf::uint64 CgroupInfo_Blkio_CFQ_Statistics::sectors() const {
  // @@protoc_insertion_point(field_get:mesos.CgroupInfo.Blkio.CFQ.Statistics.sectors)
  return sectors_;
}
inline void CgroupInfo_Blkio_CFQ_Statistics::set_sectors(::google::protobuf::uint64 value) {
  set_has_sectors();
  sectors_ = value;
  // @@protoc_insertion_point(field_set:mesos.CgroupInfo.Blkio.CFQ.Statistics.sectors)
}

// optional uint64 time = 3;
inline bool CgroupInfo_Blkio_CFQ_Statistics::has_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CgroupInfo_Blkio_CFQ_Statistics::set_has_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CgroupInfo_Blkio_CFQ_Statistics::clear_has_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CgroupInfo_Blkio_CFQ_Statistics::clear_time() {
  time_ = GOOGLE_ULONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::uint64 CgroupInfo_Blkio_CFQ_Statistics::time() const {
  // @@protoc_insertion_point(field_get:mesos.CgroupInfo.Blkio.CFQ.Statistics.time)
  return time_;
}
inline void CgroupInfo_Blkio_CFQ_Statistics::set_time(::google::protobuf::uint64 value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:mesos.CgroupInfo.Blkio.CFQ.Statistics.time)
}

// repeated .mesos.CgroupInfo.Blkio.Value io_serviced = 4;
inline int CgroupInfo_Blkio_CFQ_Statistics::io_serviced_size() const {
  return io_serviced_.size();
}
inline void CgroupInfo_Blkio_CFQ_Statistics::clear_io_serviced() {
  io_serviced_.Clear();
}
inline const ::mesos::CgroupInfo_Blkio_Value& CgroupInfo_Blkio_CFQ_Statistics::io_serviced(int index) const {
  // @@protoc_insertion_point(field_get:mesos.CgroupInfo.Blkio.CFQ.Statistics.io_serviced)
  return io_serviced_.Get(index);
}
inline ::mesos::CgroupInfo_Blkio_Value* CgroupInfo_Blkio_CFQ_Statistics::mutable_io_serviced(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.CgroupInfo.Blkio.CFQ.Statistics.io_serviced)
  return io_serviced_.Mutable(index);
}
inline ::mesos::CgroupInfo_Blkio_Value* CgroupInfo_Blkio_CFQ_Statistics::add_io_serviced() {
  // @@protoc_insertion_point(field_add:mesos.CgroupInfo.Blkio.CFQ.Statistics.io_serviced)
  return io_serviced_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::CgroupInfo_Blkio_Value >*
CgroupInfo_Blkio_CFQ_Statistics::mutable_io_serviced() {
  // @@protoc_insertion_point(field_mutable_list:mesos.CgroupInfo.Blkio.CFQ.Statistics.io_serviced)
  return &io_serviced_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::CgroupInfo_Blkio_Value >&
CgroupInfo_Blkio_CFQ_Statistics::io_serviced() const {
  // @@protoc_insertion_point(field_list:mesos.CgroupInfo.Blkio.CFQ.Statistics.io_serviced)
  return io_serviced_;
}

// repeated .mesos.CgroupInfo.Blkio.Value io_service_bytes = 5;
inline int CgroupInfo_Blkio_CFQ_Statistics::io_service_bytes_size() const {
  return io_service_bytes_.size();
}
inline void CgroupInfo_Blkio_CFQ_Statistics::clear_io_service_bytes() {
  io_service_bytes_.Clear();
}
inline const ::mesos::CgroupInfo_Blkio_Value& CgroupInfo_Blkio_CFQ_Statistics::io_service_bytes(int index) const {
  // @@protoc_insertion_point(field_get:mesos.CgroupInfo.Blkio.CFQ.Statistics.io_service_bytes)
  return io_service_bytes_.Get(index);
}
inline ::mesos::CgroupInfo_Blkio_Value* CgroupInfo_Blkio_CFQ_Statistics::mutable_io_service_bytes(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.CgroupInfo.Blkio.CFQ.Statistics.io_service_bytes)
  return io_service_bytes_.Mutable(index);
}
inline ::mesos::CgroupInfo_Blkio_Value* CgroupInfo_Blkio_CFQ_Statistics::add_io_service_bytes() {
  // @@protoc_insertion_point(field_add:mesos.CgroupInfo.Blkio.CFQ.Statistics.io_service_bytes)
  return io_service_bytes_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::CgroupInfo_Blkio_Value >*
CgroupInfo_Blkio_CFQ_Statistics::mutable_io_service_bytes() {
  // @@protoc_insertion_point(field_mutable_list:mesos.CgroupInfo.Blkio.CFQ.Statistics.io_service_bytes)
  return &io_service_bytes_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::CgroupInfo_Blkio_Value >&
CgroupInfo_Blkio_CFQ_Statistics::io_service_bytes() const {
  // @@protoc_insertion_point(field_list:mesos.CgroupInfo.Blkio.CFQ.Statistics.io_service_bytes)
  return io_service_bytes_;
}

// repeated .mesos.CgroupInfo.Blkio.Value io_service_time = 6;
inline int CgroupInfo_Blkio_CFQ_Statistics::io_service_time_size() const {
  return io_service_time_.size();
}
inline void CgroupInfo_Blkio_CFQ_Statistics::clear_io_service_time() {
  io_service_time_.Clear();
}
inline const ::mesos::CgroupInfo_Blkio_Value& CgroupInfo_Blkio_CFQ_Statistics::io_service_time(int index) const {
  // @@protoc_insertion_point(field_get:mesos.CgroupInfo.Blkio.CFQ.Statistics.io_service_time)
  return io_service_time_.Get(index);
}
inline ::mesos::CgroupInfo_Blkio_Value* CgroupInfo_Blkio_CFQ_Statistics::mutable_io_service_time(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.CgroupInfo.Blkio.CFQ.Statistics.io_service_time)
  return io_service_time_.Mutable(index);
}
inline ::mesos::CgroupInfo_Blkio_Value* CgroupInfo_Blkio_CFQ_Statistics::add_io_service_time() {
  // @@protoc_insertion_point(field_add:mesos.CgroupInfo.Blkio.CFQ.Statistics.io_service_time)
  return io_service_time_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::CgroupInfo_Blkio_Value >*
CgroupInfo_Blkio_CFQ_Statistics::mutable_io_service_time() {
  // @@protoc_insertion_point(field_mutable_list:mesos.CgroupInfo.Blkio.CFQ.Statistics.io_service_time)
  return &io_service_time_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::CgroupInfo_Blkio_Value >&
CgroupInfo_Blkio_CFQ_Statistics::io_service_time() const {
  // @@protoc_insertion_point(field_list:mesos.CgroupInfo.Blkio.CFQ.Statistics.io_service_time)
  return io_service_time_;
}

// repeated .mesos.CgroupInfo.Blkio.Value io_wait_time = 7;
inline int CgroupInfo_Blkio_CFQ_Statistics::io_wait_time_size() const {
  return io_wait_time_.size();
}
inline void CgroupInfo_Blkio_CFQ_Statistics::clear_io_wait_time() {
  io_wait_time_.Clear();
}
inline const ::mesos::CgroupInfo_Blkio_Value& CgroupInfo_Blkio_CFQ_Statistics::io_wait_time(int index) const {
  // @@protoc_insertion_point(field_get:mesos.CgroupInfo.Blkio.CFQ.Statistics.io_wait_time)
  return io_wait_time_.Get(index);
}
inline ::mesos::CgroupInfo_Blkio_Value* CgroupInfo_Blkio_CFQ_Statistics::mutable_io_wait_time(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.CgroupInfo.Blkio.CFQ.Statistics.io_wait_time)
  return io_wait_time_.Mutable(index);
}
inline ::mesos::CgroupInfo_Blkio_Value* CgroupInfo_Blkio_CFQ_Statistics::add_io_wait_time() {
  // @@protoc_insertion_point(field_add:mesos.CgroupInfo.Blkio.CFQ.Statistics.io_wait_time)
  return io_wait_time_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::CgroupInfo_Blkio_Value >*
CgroupInfo_Blkio_CFQ_Statistics::mutable_io_wait_time() {
  // @@protoc_insertion_point(field_mutable_list:mesos.CgroupInfo.Blkio.CFQ.Statistics.io_wait_time)
  return &io_wait_time_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::CgroupInfo_Blkio_Value >&
CgroupInfo_Blkio_CFQ_Statistics::io_wait_time() const {
  // @@protoc_insertion_point(field_list:mesos.CgroupInfo.Blkio.CFQ.Statistics.io_wait_time)
  return io_wait_time_;
}

// repeated .mesos.CgroupInfo.Blkio.Value io_merged = 8;
inline int CgroupInfo_Blkio_CFQ_Statistics::io_merged_size() const {
  return io_merged_.size();
}
inline void CgroupInfo_Blkio_CFQ_Statistics::clear_io_merged() {
  io_merged_.Clear();
}
inline const ::mesos::CgroupInfo_Blkio_Value& CgroupInfo_Blkio_CFQ_Statistics::io_merged(int index) const {
  // @@protoc_insertion_point(field_get:mesos.CgroupInfo.Blkio.CFQ.Statistics.io_merged)
  return io_merged_.Get(index);
}
inline ::mesos::CgroupInfo_Blkio_Value* CgroupInfo_Blkio_CFQ_Statistics::mutable_io_merged(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.CgroupInfo.Blkio.CFQ.Statistics.io_merged)
  return io_merged_.Mutable(index);
}
inline ::mesos::CgroupInfo_Blkio_Value* CgroupInfo_Blkio_CFQ_Statistics::add_io_merged() {
  // @@protoc_insertion_point(field_add:mesos.CgroupInfo.Blkio.CFQ.Statistics.io_merged)
  return io_merged_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::CgroupInfo_Blkio_Value >*
CgroupInfo_Blkio_CFQ_Statistics::mutable_io_merged() {
  // @@protoc_insertion_point(field_mutable_list:mesos.CgroupInfo.Blkio.CFQ.Statistics.io_merged)
  return &io_merged_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::CgroupInfo_Blkio_Value >&
CgroupInfo_Blkio_CFQ_Statistics::io_merged() const {
  // @@protoc_insertion_point(field_list:mesos.CgroupInfo.Blkio.CFQ.Statistics.io_merged)
  return io_merged_;
}

// repeated .mesos.CgroupInfo.Blkio.Value io_queued = 9;
inline int CgroupInfo_Blkio_CFQ_Statistics::io_queued_size() const {
  return io_queued_.size();
}
inline void CgroupInfo_Blkio_CFQ_Statistics::clear_io_queued() {
  io_queued_.Clear();
}
inline const ::mesos::CgroupInfo_Blkio_Value& CgroupInfo_Blkio_CFQ_Statistics::io_queued(int index) const {
  // @@protoc_insertion_point(field_get:mesos.CgroupInfo.Blkio.CFQ.Statistics.io_queued)
  return io_queued_.Get(index);
}
inline ::mesos::CgroupInfo_Blkio_Value* CgroupInfo_Blkio_CFQ_Statistics::mutable_io_queued(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.CgroupInfo.Blkio.CFQ.Statistics.io_queued)
  return io_queued_.Mutable(index);
}
inline ::mesos::CgroupInfo_Blkio_Value* CgroupInfo_Blkio_CFQ_Statistics::add_io_queued() {
  // @@protoc_insertion_point(field_add:mesos.CgroupInfo.Blkio.CFQ.Statistics.io_queued)
  return io_queued_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::CgroupInfo_Blkio_Value >*
CgroupInfo_Blkio_CFQ_Statistics::mutable_io_queued() {
  // @@protoc_insertion_point(field_mutable_list:mesos.CgroupInfo.Blkio.CFQ.Statistics.io_queued)
  return &io_queued_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::CgroupInfo_Blkio_Value >&
CgroupInfo_Blkio_CFQ_Statistics::io_queued() const {
  // @@protoc_insertion_point(field_list:mesos.CgroupInfo.Blkio.CFQ.Statistics.io_queued)
  return io_queued_;
}

// -------------------------------------------------------------------

// CgroupInfo_Blkio_CFQ

// -------------------------------------------------------------------

// CgroupInfo_Blkio_Throttling_Statistics

// optional .mesos.Device.Number device = 1;
inline bool CgroupInfo_Blkio_Throttling_Statistics::has_device() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CgroupInfo_Blkio_Throttling_Statistics::set_has_device() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CgroupInfo_Blkio_Throttling_Statistics::clear_has_device() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CgroupInfo_Blkio_Throttling_Statistics::clear_device() {
  if (device_ != NULL) device_->Clear();
  clear_has_device();
}
inline const ::mesos::Device_Number& CgroupInfo_Blkio_Throttling_Statistics::device() const {
  const ::mesos::Device_Number* p = device_;
  // @@protoc_insertion_point(field_get:mesos.CgroupInfo.Blkio.Throttling.Statistics.device)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::Device_Number*>(
      &::mesos::_Device_Number_default_instance_);
}
inline ::mesos::Device_Number* CgroupInfo_Blkio_Throttling_Statistics::release_device() {
  // @@protoc_insertion_point(field_release:mesos.CgroupInfo.Blkio.Throttling.Statistics.device)
  clear_has_device();
  ::mesos::Device_Number* temp = device_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  device_ = NULL;
  return temp;
}
inline ::mesos::Device_Number* CgroupInfo_Blkio_Throttling_Statistics::unsafe_arena_release_device() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.CgroupInfo.Blkio.Throttling.Statistics.device)
  clear_has_device();
  ::mesos::Device_Number* temp = device_;
  device_ = NULL;
  return temp;
}
inline ::mesos::Device_Number* CgroupInfo_Blkio_Throttling_Statistics::mutable_device() {
  set_has_device();
  if (device_ == NULL) {
    _slow_mutable_device();
  }
  // @@protoc_insertion_point(field_mutable:mesos.CgroupInfo.Blkio.Throttling.Statistics.device)
  return device_;
}
inline void CgroupInfo_Blkio_Throttling_Statistics::set_allocated_device(::mesos::Device_Number* device) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete device_;
  }
  if (device) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(device);
    if (message_arena != submessage_arena) {
      device = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, device, submessage_arena);
    }
    set_has_device();
  } else {
    clear_has_device();
  }
  device_ = device;
  // @@protoc_insertion_point(field_set_allocated:mesos.CgroupInfo.Blkio.Throttling.Statistics.device)
}

// repeated .mesos.CgroupInfo.Blkio.Value io_serviced = 2;
inline int CgroupInfo_Blkio_Throttling_Statistics::io_serviced_size() const {
  return io_serviced_.size();
}
inline void CgroupInfo_Blkio_Throttling_Statistics::clear_io_serviced() {
  io_serviced_.Clear();
}
inline const ::mesos::CgroupInfo_Blkio_Value& CgroupInfo_Blkio_Throttling_Statistics::io_serviced(int index) const {
  // @@protoc_insertion_point(field_get:mesos.CgroupInfo.Blkio.Throttling.Statistics.io_serviced)
  return io_serviced_.Get(index);
}
inline ::mesos::CgroupInfo_Blkio_Value* CgroupInfo_Blkio_Throttling_Statistics::mutable_io_serviced(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.CgroupInfo.Blkio.Throttling.Statistics.io_serviced)
  return io_serviced_.Mutable(index);
}
inline ::mesos::CgroupInfo_Blkio_Value* CgroupInfo_Blkio_Throttling_Statistics::add_io_serviced() {
  // @@protoc_insertion_point(field_add:mesos.CgroupInfo.Blkio.Throttling.Statistics.io_serviced)
  return io_serviced_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::CgroupInfo_Blkio_Value >*
CgroupInfo_Blkio_Throttling_Statistics::mutable_io_serviced() {
  // @@protoc_insertion_point(field_mutable_list:mesos.CgroupInfo.Blkio.Throttling.Statistics.io_serviced)
  return &io_serviced_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::CgroupInfo_Blkio_Value >&
CgroupInfo_Blkio_Throttling_Statistics::io_serviced() const {
  // @@protoc_insertion_point(field_list:mesos.CgroupInfo.Blkio.Throttling.Statistics.io_serviced)
  return io_serviced_;
}

// repeated .mesos.CgroupInfo.Blkio.Value io_service_bytes = 3;
inline int CgroupInfo_Blkio_Throttling_Statistics::io_service_bytes_size() const {
  return io_service_bytes_.size();
}
inline void CgroupInfo_Blkio_Throttling_Statistics::clear_io_service_bytes() {
  io_service_bytes_.Clear();
}
inline const ::mesos::CgroupInfo_Blkio_Value& CgroupInfo_Blkio_Throttling_Statistics::io_service_bytes(int index) const {
  // @@protoc_insertion_point(field_get:mesos.CgroupInfo.Blkio.Throttling.Statistics.io_service_bytes)
  return io_service_bytes_.Get(index);
}
inline ::mesos::CgroupInfo_Blkio_Value* CgroupInfo_Blkio_Throttling_Statistics::mutable_io_service_bytes(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.CgroupInfo.Blkio.Throttling.Statistics.io_service_bytes)
  return io_service_bytes_.Mutable(index);
}
inline ::mesos::CgroupInfo_Blkio_Value* CgroupInfo_Blkio_Throttling_Statistics::add_io_service_bytes() {
  // @@protoc_insertion_point(field_add:mesos.CgroupInfo.Blkio.Throttling.Statistics.io_service_bytes)
  return io_service_bytes_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::CgroupInfo_Blkio_Value >*
CgroupInfo_Blkio_Throttling_Statistics::mutable_io_service_bytes() {
  // @@protoc_insertion_point(field_mutable_list:mesos.CgroupInfo.Blkio.Throttling.Statistics.io_service_bytes)
  return &io_service_bytes_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::CgroupInfo_Blkio_Value >&
CgroupInfo_Blkio_Throttling_Statistics::io_service_bytes() const {
  // @@protoc_insertion_point(field_list:mesos.CgroupInfo.Blkio.Throttling.Statistics.io_service_bytes)
  return io_service_bytes_;
}

// -------------------------------------------------------------------

// CgroupInfo_Blkio_Throttling

// -------------------------------------------------------------------

// CgroupInfo_Blkio_Statistics

// repeated .mesos.CgroupInfo.Blkio.CFQ.Statistics cfq = 1;
inline int CgroupInfo_Blkio_Statistics::cfq_size() const {
  return cfq_.size();
}
inline void CgroupInfo_Blkio_Statistics::clear_cfq() {
  cfq_.Clear();
}
inline const ::mesos::CgroupInfo_Blkio_CFQ_Statistics& CgroupInfo_Blkio_Statistics::cfq(int index) const {
  // @@protoc_insertion_point(field_get:mesos.CgroupInfo.Blkio.Statistics.cfq)
  return cfq_.Get(index);
}
inline ::mesos::CgroupInfo_Blkio_CFQ_Statistics* CgroupInfo_Blkio_Statistics::mutable_cfq(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.CgroupInfo.Blkio.Statistics.cfq)
  return cfq_.Mutable(index);
}
inline ::mesos::CgroupInfo_Blkio_CFQ_Statistics* CgroupInfo_Blkio_Statistics::add_cfq() {
  // @@protoc_insertion_point(field_add:mesos.CgroupInfo.Blkio.Statistics.cfq)
  return cfq_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::CgroupInfo_Blkio_CFQ_Statistics >*
CgroupInfo_Blkio_Statistics::mutable_cfq() {
  // @@protoc_insertion_point(field_mutable_list:mesos.CgroupInfo.Blkio.Statistics.cfq)
  return &cfq_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::CgroupInfo_Blkio_CFQ_Statistics >&
CgroupInfo_Blkio_Statistics::cfq() const {
  // @@protoc_insertion_point(field_list:mesos.CgroupInfo.Blkio.Statistics.cfq)
  return cfq_;
}

// repeated .mesos.CgroupInfo.Blkio.CFQ.Statistics cfq_recursive = 2;
inline int CgroupInfo_Blkio_Statistics::cfq_recursive_size() const {
  return cfq_recursive_.size();
}
inline void CgroupInfo_Blkio_Statistics::clear_cfq_recursive() {
  cfq_recursive_.Clear();
}
inline const ::mesos::CgroupInfo_Blkio_CFQ_Statistics& CgroupInfo_Blkio_Statistics::cfq_recursive(int index) const {
  // @@protoc_insertion_point(field_get:mesos.CgroupInfo.Blkio.Statistics.cfq_recursive)
  return cfq_recursive_.Get(index);
}
inline ::mesos::CgroupInfo_Blkio_CFQ_Statistics* CgroupInfo_Blkio_Statistics::mutable_cfq_recursive(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.CgroupInfo.Blkio.Statistics.cfq_recursive)
  return cfq_recursive_.Mutable(index);
}
inline ::mesos::CgroupInfo_Blkio_CFQ_Statistics* CgroupInfo_Blkio_Statistics::add_cfq_recursive() {
  // @@protoc_insertion_point(field_add:mesos.CgroupInfo.Blkio.Statistics.cfq_recursive)
  return cfq_recursive_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::CgroupInfo_Blkio_CFQ_Statistics >*
CgroupInfo_Blkio_Statistics::mutable_cfq_recursive() {
  // @@protoc_insertion_point(field_mutable_list:mesos.CgroupInfo.Blkio.Statistics.cfq_recursive)
  return &cfq_recursive_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::CgroupInfo_Blkio_CFQ_Statistics >&
CgroupInfo_Blkio_Statistics::cfq_recursive() const {
  // @@protoc_insertion_point(field_list:mesos.CgroupInfo.Blkio.Statistics.cfq_recursive)
  return cfq_recursive_;
}

// repeated .mesos.CgroupInfo.Blkio.Throttling.Statistics throttling = 3;
inline int CgroupInfo_Blkio_Statistics::throttling_size() const {
  return throttling_.size();
}
inline void CgroupInfo_Blkio_Statistics::clear_throttling() {
  throttling_.Clear();
}
inline const ::mesos::CgroupInfo_Blkio_Throttling_Statistics& CgroupInfo_Blkio_Statistics::throttling(int index) const {
  // @@protoc_insertion_point(field_get:mesos.CgroupInfo.Blkio.Statistics.throttling)
  return throttling_.Get(index);
}
inline ::mesos::CgroupInfo_Blkio_Throttling_Statistics* CgroupInfo_Blkio_Statistics::mutable_throttling(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.CgroupInfo.Blkio.Statistics.throttling)
  return throttling_.Mutable(index);
}
inline ::mesos::CgroupInfo_Blkio_Throttling_Statistics* CgroupInfo_Blkio_Statistics::add_throttling() {
  // @@protoc_insertion_point(field_add:mesos.CgroupInfo.Blkio.Statistics.throttling)
  return throttling_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::CgroupInfo_Blkio_Throttling_Statistics >*
CgroupInfo_Blkio_Statistics::mutable_throttling() {
  // @@protoc_insertion_point(field_mutable_list:mesos.CgroupInfo.Blkio.Statistics.throttling)
  return &throttling_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::CgroupInfo_Blkio_Throttling_Statistics >&
CgroupInfo_Blkio_Statistics::throttling() const {
  // @@protoc_insertion_point(field_list:mesos.CgroupInfo.Blkio.Statistics.throttling)
  return throttling_;
}

// -------------------------------------------------------------------

// CgroupInfo_Blkio

// -------------------------------------------------------------------

// CgroupInfo_NetCls

// optional uint32 classid = 1;
inline bool CgroupInfo_NetCls::has_classid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CgroupInfo_NetCls::set_has_classid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CgroupInfo_NetCls::clear_has_classid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CgroupInfo_NetCls::clear_classid() {
  classid_ = 0u;
  clear_has_classid();
}
inline ::google::protobuf::uint32 CgroupInfo_NetCls::classid() const {
  // @@protoc_insertion_point(field_get:mesos.CgroupInfo.NetCls.classid)
  return classid_;
}
inline void CgroupInfo_NetCls::set_classid(::google::protobuf::uint32 value) {
  set_has_classid();
  classid_ = value;
  // @@protoc_insertion_point(field_set:mesos.CgroupInfo.NetCls.classid)
}

// -------------------------------------------------------------------

// CgroupInfo

// optional .mesos.CgroupInfo.NetCls net_cls = 1;
inline bool CgroupInfo::has_net_cls() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CgroupInfo::set_has_net_cls() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CgroupInfo::clear_has_net_cls() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CgroupInfo::clear_net_cls() {
  if (net_cls_ != NULL) net_cls_->Clear();
  clear_has_net_cls();
}
inline const ::mesos::CgroupInfo_NetCls& CgroupInfo::net_cls() const {
  const ::mesos::CgroupInfo_NetCls* p = net_cls_;
  // @@protoc_insertion_point(field_get:mesos.CgroupInfo.net_cls)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::CgroupInfo_NetCls*>(
      &::mesos::_CgroupInfo_NetCls_default_instance_);
}
inline ::mesos::CgroupInfo_NetCls* CgroupInfo::release_net_cls() {
  // @@protoc_insertion_point(field_release:mesos.CgroupInfo.net_cls)
  clear_has_net_cls();
  ::mesos::CgroupInfo_NetCls* temp = net_cls_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  net_cls_ = NULL;
  return temp;
}
inline ::mesos::CgroupInfo_NetCls* CgroupInfo::unsafe_arena_release_net_cls() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.CgroupInfo.net_cls)
  clear_has_net_cls();
  ::mesos::CgroupInfo_NetCls* temp = net_cls_;
  net_cls_ = NULL;
  return temp;
}
inline ::mesos::CgroupInfo_NetCls* CgroupInfo::mutable_net_cls() {
  set_has_net_cls();
  if (net_cls_ == NULL) {
    _slow_mutable_net_cls();
  }
  // @@protoc_insertion_point(field_mutable:mesos.CgroupInfo.net_cls)
  return net_cls_;
}
inline void CgroupInfo::set_allocated_net_cls(::mesos::CgroupInfo_NetCls* net_cls) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete net_cls_;
  }
  if (net_cls) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(net_cls);
    if (message_arena != submessage_arena) {
      net_cls = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, net_cls, submessage_arena);
    }
    set_has_net_cls();
  } else {
    clear_has_net_cls();
  }
  net_cls_ = net_cls;
  // @@protoc_insertion_point(field_set_allocated:mesos.CgroupInfo.net_cls)
}

// -------------------------------------------------------------------

// Labels

// repeated .mesos.Label labels = 1;
inline int Labels::labels_size() const {
  return labels_.size();
}
inline void Labels::clear_labels() {
  labels_.Clear();
}
inline const ::mesos::Label& Labels::labels(int index) const {
  // @@protoc_insertion_point(field_get:mesos.Labels.labels)
  return labels_.Get(index);
}
inline ::mesos::Label* Labels::mutable_labels(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.Labels.labels)
  return labels_.Mutable(index);
}
inline ::mesos::Label* Labels::add_labels() {
  // @@protoc_insertion_point(field_add:mesos.Labels.labels)
  return labels_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Label >*
Labels::mutable_labels() {
  // @@protoc_insertion_point(field_mutable_list:mesos.Labels.labels)
  return &labels_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Label >&
Labels::labels() const {
  // @@protoc_insertion_point(field_list:mesos.Labels.labels)
  return labels_;
}

// -------------------------------------------------------------------

// Label

// required string key = 1;
inline bool Label::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Label::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Label::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Label::clear_key() {
  key_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_key();
}
inline const ::std::string& Label::key() const {
  // @@protoc_insertion_point(field_get:mesos.Label.key)
  return key_.Get();
}
inline void Label::set_key(const ::std::string& value) {
  set_has_key();
  key_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.Label.key)
}
#if LANG_CXX11
inline void Label::set_key(::std::string&& value) {
  set_has_key();
  key_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.Label.key)
}
#endif
inline void Label::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_key();
  key_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.Label.key)
}
inline void Label::set_key(const char* value,
    size_t size) {
  set_has_key();
  key_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.Label.key)
}
inline ::std::string* Label::mutable_key() {
  set_has_key();
  // @@protoc_insertion_point(field_mutable:mesos.Label.key)
  return key_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* Label::release_key() {
  // @@protoc_insertion_point(field_release:mesos.Label.key)
  clear_has_key();
  return key_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void Label::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.Label.key)
}
inline ::std::string* Label::unsafe_arena_release_key() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Label.key)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_key();
  return key_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void Label::unsafe_arena_set_allocated_key(
    ::std::string* key) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      key, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.Label.key)
}

// optional string value = 2;
inline bool Label::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Label::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Label::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Label::clear_value() {
  value_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_value();
}
inline const ::std::string& Label::value() const {
  // @@protoc_insertion_point(field_get:mesos.Label.value)
  return value_.Get();
}
inline void Label::set_value(const ::std::string& value) {
  set_has_value();
  value_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.Label.value)
}
#if LANG_CXX11
inline void Label::set_value(::std::string&& value) {
  set_has_value();
  value_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.Label.value)
}
#endif
inline void Label::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_value();
  value_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.Label.value)
}
inline void Label::set_value(const char* value,
    size_t size) {
  set_has_value();
  value_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.Label.value)
}
inline ::std::string* Label::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:mesos.Label.value)
  return value_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* Label::release_value() {
  // @@protoc_insertion_point(field_release:mesos.Label.value)
  clear_has_value();
  return value_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void Label::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.Label.value)
}
inline ::std::string* Label::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Label.value)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_value();
  return value_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void Label::unsafe_arena_set_allocated_value(
    ::std::string* value) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.Label.value)
}

// -------------------------------------------------------------------

// Port

// required uint32 number = 1;
inline bool Port::has_number() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Port::set_has_number() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Port::clear_has_number() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Port::clear_number() {
  number_ = 0u;
  clear_has_number();
}
inline ::google::protobuf::uint32 Port::number() const {
  // @@protoc_insertion_point(field_get:mesos.Port.number)
  return number_;
}
inline void Port::set_number(::google::protobuf::uint32 value) {
  set_has_number();
  number_ = value;
  // @@protoc_insertion_point(field_set:mesos.Port.number)
}

// optional string name = 2;
inline bool Port::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Port::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Port::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Port::clear_name() {
  name_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_name();
}
inline const ::std::string& Port::name() const {
  // @@protoc_insertion_point(field_get:mesos.Port.name)
  return name_.Get();
}
inline void Port::set_name(const ::std::string& value) {
  set_has_name();
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.Port.name)
}
#if LANG_CXX11
inline void Port::set_name(::std::string&& value) {
  set_has_name();
  name_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.Port.name)
}
#endif
inline void Port::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.Port.name)
}
inline void Port::set_name(const char* value,
    size_t size) {
  set_has_name();
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.Port.name)
}
inline ::std::string* Port::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:mesos.Port.name)
  return name_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* Port::release_name() {
  // @@protoc_insertion_point(field_release:mesos.Port.name)
  clear_has_name();
  return name_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void Port::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.Port.name)
}
inline ::std::string* Port::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Port.name)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_name();
  return name_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void Port::unsafe_arena_set_allocated_name(
    ::std::string* name) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      name, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.Port.name)
}

// optional string protocol = 3;
inline bool Port::has_protocol() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Port::set_has_protocol() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Port::clear_has_protocol() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Port::clear_protocol() {
  protocol_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_protocol();
}
inline const ::std::string& Port::protocol() const {
  // @@protoc_insertion_point(field_get:mesos.Port.protocol)
  return protocol_.Get();
}
inline void Port::set_protocol(const ::std::string& value) {
  set_has_protocol();
  protocol_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.Port.protocol)
}
#if LANG_CXX11
inline void Port::set_protocol(::std::string&& value) {
  set_has_protocol();
  protocol_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.Port.protocol)
}
#endif
inline void Port::set_protocol(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_protocol();
  protocol_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.Port.protocol)
}
inline void Port::set_protocol(const char* value,
    size_t size) {
  set_has_protocol();
  protocol_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.Port.protocol)
}
inline ::std::string* Port::mutable_protocol() {
  set_has_protocol();
  // @@protoc_insertion_point(field_mutable:mesos.Port.protocol)
  return protocol_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* Port::release_protocol() {
  // @@protoc_insertion_point(field_release:mesos.Port.protocol)
  clear_has_protocol();
  return protocol_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void Port::set_allocated_protocol(::std::string* protocol) {
  if (protocol != NULL) {
    set_has_protocol();
  } else {
    clear_has_protocol();
  }
  protocol_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), protocol,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.Port.protocol)
}
inline ::std::string* Port::unsafe_arena_release_protocol() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Port.protocol)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_protocol();
  return protocol_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void Port::unsafe_arena_set_allocated_protocol(
    ::std::string* protocol) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (protocol != NULL) {
    set_has_protocol();
  } else {
    clear_has_protocol();
  }
  protocol_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      protocol, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.Port.protocol)
}

// optional .mesos.DiscoveryInfo.Visibility visibility = 4;
inline bool Port::has_visibility() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Port::set_has_visibility() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Port::clear_has_visibility() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Port::clear_visibility() {
  visibility_ = 0;
  clear_has_visibility();
}
inline ::mesos::DiscoveryInfo_Visibility Port::visibility() const {
  // @@protoc_insertion_point(field_get:mesos.Port.visibility)
  return static_cast< ::mesos::DiscoveryInfo_Visibility >(visibility_);
}
inline void Port::set_visibility(::mesos::DiscoveryInfo_Visibility value) {
  assert(::mesos::DiscoveryInfo_Visibility_IsValid(value));
  set_has_visibility();
  visibility_ = value;
  // @@protoc_insertion_point(field_set:mesos.Port.visibility)
}

// optional .mesos.Labels labels = 5;
inline bool Port::has_labels() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Port::set_has_labels() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Port::clear_has_labels() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Port::clear_labels() {
  if (labels_ != NULL) labels_->Clear();
  clear_has_labels();
}
inline const ::mesos::Labels& Port::labels() const {
  const ::mesos::Labels* p = labels_;
  // @@protoc_insertion_point(field_get:mesos.Port.labels)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::Labels*>(
      &::mesos::_Labels_default_instance_);
}
inline ::mesos::Labels* Port::release_labels() {
  // @@protoc_insertion_point(field_release:mesos.Port.labels)
  clear_has_labels();
  ::mesos::Labels* temp = labels_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  labels_ = NULL;
  return temp;
}
inline ::mesos::Labels* Port::unsafe_arena_release_labels() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Port.labels)
  clear_has_labels();
  ::mesos::Labels* temp = labels_;
  labels_ = NULL;
  return temp;
}
inline ::mesos::Labels* Port::mutable_labels() {
  set_has_labels();
  if (labels_ == NULL) {
    _slow_mutable_labels();
  }
  // @@protoc_insertion_point(field_mutable:mesos.Port.labels)
  return labels_;
}
inline void Port::set_allocated_labels(::mesos::Labels* labels) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete labels_;
  }
  if (labels) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(labels);
    if (message_arena != submessage_arena) {
      labels = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, labels, submessage_arena);
    }
    set_has_labels();
  } else {
    clear_has_labels();
  }
  labels_ = labels;
  // @@protoc_insertion_point(field_set_allocated:mesos.Port.labels)
}

// -------------------------------------------------------------------

// Ports

// repeated .mesos.Port ports = 1;
inline int Ports::ports_size() const {
  return ports_.size();
}
inline void Ports::clear_ports() {
  ports_.Clear();
}
inline const ::mesos::Port& Ports::ports(int index) const {
  // @@protoc_insertion_point(field_get:mesos.Ports.ports)
  return ports_.Get(index);
}
inline ::mesos::Port* Ports::mutable_ports(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.Ports.ports)
  return ports_.Mutable(index);
}
inline ::mesos::Port* Ports::add_ports() {
  // @@protoc_insertion_point(field_add:mesos.Ports.ports)
  return ports_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Port >*
Ports::mutable_ports() {
  // @@protoc_insertion_point(field_mutable_list:mesos.Ports.ports)
  return &ports_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Port >&
Ports::ports() const {
  // @@protoc_insertion_point(field_list:mesos.Ports.ports)
  return ports_;
}

// -------------------------------------------------------------------

// DiscoveryInfo

// required .mesos.DiscoveryInfo.Visibility visibility = 1;
inline bool DiscoveryInfo::has_visibility() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DiscoveryInfo::set_has_visibility() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DiscoveryInfo::clear_has_visibility() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DiscoveryInfo::clear_visibility() {
  visibility_ = 0;
  clear_has_visibility();
}
inline ::mesos::DiscoveryInfo_Visibility DiscoveryInfo::visibility() const {
  // @@protoc_insertion_point(field_get:mesos.DiscoveryInfo.visibility)
  return static_cast< ::mesos::DiscoveryInfo_Visibility >(visibility_);
}
inline void DiscoveryInfo::set_visibility(::mesos::DiscoveryInfo_Visibility value) {
  assert(::mesos::DiscoveryInfo_Visibility_IsValid(value));
  set_has_visibility();
  visibility_ = value;
  // @@protoc_insertion_point(field_set:mesos.DiscoveryInfo.visibility)
}

// optional string name = 2;
inline bool DiscoveryInfo::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DiscoveryInfo::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DiscoveryInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DiscoveryInfo::clear_name() {
  name_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_name();
}
inline const ::std::string& DiscoveryInfo::name() const {
  // @@protoc_insertion_point(field_get:mesos.DiscoveryInfo.name)
  return name_.Get();
}
inline void DiscoveryInfo::set_name(const ::std::string& value) {
  set_has_name();
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.DiscoveryInfo.name)
}
#if LANG_CXX11
inline void DiscoveryInfo::set_name(::std::string&& value) {
  set_has_name();
  name_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.DiscoveryInfo.name)
}
#endif
inline void DiscoveryInfo::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.DiscoveryInfo.name)
}
inline void DiscoveryInfo::set_name(const char* value,
    size_t size) {
  set_has_name();
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.DiscoveryInfo.name)
}
inline ::std::string* DiscoveryInfo::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:mesos.DiscoveryInfo.name)
  return name_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* DiscoveryInfo::release_name() {
  // @@protoc_insertion_point(field_release:mesos.DiscoveryInfo.name)
  clear_has_name();
  return name_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void DiscoveryInfo::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.DiscoveryInfo.name)
}
inline ::std::string* DiscoveryInfo::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.DiscoveryInfo.name)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_name();
  return name_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void DiscoveryInfo::unsafe_arena_set_allocated_name(
    ::std::string* name) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      name, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.DiscoveryInfo.name)
}

// optional string environment = 3;
inline bool DiscoveryInfo::has_environment() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DiscoveryInfo::set_has_environment() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DiscoveryInfo::clear_has_environment() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DiscoveryInfo::clear_environment() {
  environment_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_environment();
}
inline const ::std::string& DiscoveryInfo::environment() const {
  // @@protoc_insertion_point(field_get:mesos.DiscoveryInfo.environment)
  return environment_.Get();
}
inline void DiscoveryInfo::set_environment(const ::std::string& value) {
  set_has_environment();
  environment_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.DiscoveryInfo.environment)
}
#if LANG_CXX11
inline void DiscoveryInfo::set_environment(::std::string&& value) {
  set_has_environment();
  environment_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.DiscoveryInfo.environment)
}
#endif
inline void DiscoveryInfo::set_environment(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_environment();
  environment_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.DiscoveryInfo.environment)
}
inline void DiscoveryInfo::set_environment(const char* value,
    size_t size) {
  set_has_environment();
  environment_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.DiscoveryInfo.environment)
}
inline ::std::string* DiscoveryInfo::mutable_environment() {
  set_has_environment();
  // @@protoc_insertion_point(field_mutable:mesos.DiscoveryInfo.environment)
  return environment_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* DiscoveryInfo::release_environment() {
  // @@protoc_insertion_point(field_release:mesos.DiscoveryInfo.environment)
  clear_has_environment();
  return environment_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void DiscoveryInfo::set_allocated_environment(::std::string* environment) {
  if (environment != NULL) {
    set_has_environment();
  } else {
    clear_has_environment();
  }
  environment_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), environment,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.DiscoveryInfo.environment)
}
inline ::std::string* DiscoveryInfo::unsafe_arena_release_environment() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.DiscoveryInfo.environment)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_environment();
  return environment_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void DiscoveryInfo::unsafe_arena_set_allocated_environment(
    ::std::string* environment) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (environment != NULL) {
    set_has_environment();
  } else {
    clear_has_environment();
  }
  environment_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      environment, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.DiscoveryInfo.environment)
}

// optional string location = 4;
inline bool DiscoveryInfo::has_location() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DiscoveryInfo::set_has_location() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DiscoveryInfo::clear_has_location() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DiscoveryInfo::clear_location() {
  location_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_location();
}
inline const ::std::string& DiscoveryInfo::location() const {
  // @@protoc_insertion_point(field_get:mesos.DiscoveryInfo.location)
  return location_.Get();
}
inline void DiscoveryInfo::set_location(const ::std::string& value) {
  set_has_location();
  location_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.DiscoveryInfo.location)
}
#if LANG_CXX11
inline void DiscoveryInfo::set_location(::std::string&& value) {
  set_has_location();
  location_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.DiscoveryInfo.location)
}
#endif
inline void DiscoveryInfo::set_location(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_location();
  location_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.DiscoveryInfo.location)
}
inline void DiscoveryInfo::set_location(const char* value,
    size_t size) {
  set_has_location();
  location_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.DiscoveryInfo.location)
}
inline ::std::string* DiscoveryInfo::mutable_location() {
  set_has_location();
  // @@protoc_insertion_point(field_mutable:mesos.DiscoveryInfo.location)
  return location_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* DiscoveryInfo::release_location() {
  // @@protoc_insertion_point(field_release:mesos.DiscoveryInfo.location)
  clear_has_location();
  return location_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void DiscoveryInfo::set_allocated_location(::std::string* location) {
  if (location != NULL) {
    set_has_location();
  } else {
    clear_has_location();
  }
  location_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), location,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.DiscoveryInfo.location)
}
inline ::std::string* DiscoveryInfo::unsafe_arena_release_location() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.DiscoveryInfo.location)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_location();
  return location_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void DiscoveryInfo::unsafe_arena_set_allocated_location(
    ::std::string* location) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (location != NULL) {
    set_has_location();
  } else {
    clear_has_location();
  }
  location_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      location, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.DiscoveryInfo.location)
}

// optional string version = 5;
inline bool DiscoveryInfo::has_version() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DiscoveryInfo::set_has_version() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DiscoveryInfo::clear_has_version() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DiscoveryInfo::clear_version() {
  version_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_version();
}
inline const ::std::string& DiscoveryInfo::version() const {
  // @@protoc_insertion_point(field_get:mesos.DiscoveryInfo.version)
  return version_.Get();
}
inline void DiscoveryInfo::set_version(const ::std::string& value) {
  set_has_version();
  version_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.DiscoveryInfo.version)
}
#if LANG_CXX11
inline void DiscoveryInfo::set_version(::std::string&& value) {
  set_has_version();
  version_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.DiscoveryInfo.version)
}
#endif
inline void DiscoveryInfo::set_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_version();
  version_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.DiscoveryInfo.version)
}
inline void DiscoveryInfo::set_version(const char* value,
    size_t size) {
  set_has_version();
  version_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.DiscoveryInfo.version)
}
inline ::std::string* DiscoveryInfo::mutable_version() {
  set_has_version();
  // @@protoc_insertion_point(field_mutable:mesos.DiscoveryInfo.version)
  return version_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* DiscoveryInfo::release_version() {
  // @@protoc_insertion_point(field_release:mesos.DiscoveryInfo.version)
  clear_has_version();
  return version_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void DiscoveryInfo::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    set_has_version();
  } else {
    clear_has_version();
  }
  version_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.DiscoveryInfo.version)
}
inline ::std::string* DiscoveryInfo::unsafe_arena_release_version() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.DiscoveryInfo.version)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_version();
  return version_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void DiscoveryInfo::unsafe_arena_set_allocated_version(
    ::std::string* version) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (version != NULL) {
    set_has_version();
  } else {
    clear_has_version();
  }
  version_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      version, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.DiscoveryInfo.version)
}

// optional .mesos.Ports ports = 6;
inline bool DiscoveryInfo::has_ports() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DiscoveryInfo::set_has_ports() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DiscoveryInfo::clear_has_ports() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DiscoveryInfo::clear_ports() {
  if (ports_ != NULL) ports_->Clear();
  clear_has_ports();
}
inline const ::mesos::Ports& DiscoveryInfo::ports() const {
  const ::mesos::Ports* p = ports_;
  // @@protoc_insertion_point(field_get:mesos.DiscoveryInfo.ports)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::Ports*>(
      &::mesos::_Ports_default_instance_);
}
inline ::mesos::Ports* DiscoveryInfo::release_ports() {
  // @@protoc_insertion_point(field_release:mesos.DiscoveryInfo.ports)
  clear_has_ports();
  ::mesos::Ports* temp = ports_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  ports_ = NULL;
  return temp;
}
inline ::mesos::Ports* DiscoveryInfo::unsafe_arena_release_ports() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.DiscoveryInfo.ports)
  clear_has_ports();
  ::mesos::Ports* temp = ports_;
  ports_ = NULL;
  return temp;
}
inline ::mesos::Ports* DiscoveryInfo::mutable_ports() {
  set_has_ports();
  if (ports_ == NULL) {
    _slow_mutable_ports();
  }
  // @@protoc_insertion_point(field_mutable:mesos.DiscoveryInfo.ports)
  return ports_;
}
inline void DiscoveryInfo::set_allocated_ports(::mesos::Ports* ports) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete ports_;
  }
  if (ports) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(ports);
    if (message_arena != submessage_arena) {
      ports = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ports, submessage_arena);
    }
    set_has_ports();
  } else {
    clear_has_ports();
  }
  ports_ = ports;
  // @@protoc_insertion_point(field_set_allocated:mesos.DiscoveryInfo.ports)
}

// optional .mesos.Labels labels = 7;
inline bool DiscoveryInfo::has_labels() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DiscoveryInfo::set_has_labels() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DiscoveryInfo::clear_has_labels() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DiscoveryInfo::clear_labels() {
  if (labels_ != NULL) labels_->Clear();
  clear_has_labels();
}
inline const ::mesos::Labels& DiscoveryInfo::labels() const {
  const ::mesos::Labels* p = labels_;
  // @@protoc_insertion_point(field_get:mesos.DiscoveryInfo.labels)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::Labels*>(
      &::mesos::_Labels_default_instance_);
}
inline ::mesos::Labels* DiscoveryInfo::release_labels() {
  // @@protoc_insertion_point(field_release:mesos.DiscoveryInfo.labels)
  clear_has_labels();
  ::mesos::Labels* temp = labels_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  labels_ = NULL;
  return temp;
}
inline ::mesos::Labels* DiscoveryInfo::unsafe_arena_release_labels() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.DiscoveryInfo.labels)
  clear_has_labels();
  ::mesos::Labels* temp = labels_;
  labels_ = NULL;
  return temp;
}
inline ::mesos::Labels* DiscoveryInfo::mutable_labels() {
  set_has_labels();
  if (labels_ == NULL) {
    _slow_mutable_labels();
  }
  // @@protoc_insertion_point(field_mutable:mesos.DiscoveryInfo.labels)
  return labels_;
}
inline void DiscoveryInfo::set_allocated_labels(::mesos::Labels* labels) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete labels_;
  }
  if (labels) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(labels);
    if (message_arena != submessage_arena) {
      labels = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, labels, submessage_arena);
    }
    set_has_labels();
  } else {
    clear_has_labels();
  }
  labels_ = labels;
  // @@protoc_insertion_point(field_set_allocated:mesos.DiscoveryInfo.labels)
}

// -------------------------------------------------------------------

// WeightInfo

// required double weight = 1;
inline bool WeightInfo::has_weight() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WeightInfo::set_has_weight() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WeightInfo::clear_has_weight() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WeightInfo::clear_weight() {
  weight_ = 0;
  clear_has_weight();
}
inline double WeightInfo::weight() const {
  // @@protoc_insertion_point(field_get:mesos.WeightInfo.weight)
  return weight_;
}
inline void WeightInfo::set_weight(double value) {
  set_has_weight();
  weight_ = value;
  // @@protoc_insertion_point(field_set:mesos.WeightInfo.weight)
}

// optional string role = 2;
inline bool WeightInfo::has_role() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WeightInfo::set_has_role() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WeightInfo::clear_has_role() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WeightInfo::clear_role() {
  role_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_role();
}
inline const ::std::string& WeightInfo::role() const {
  // @@protoc_insertion_point(field_get:mesos.WeightInfo.role)
  return role_.Get();
}
inline void WeightInfo::set_role(const ::std::string& value) {
  set_has_role();
  role_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.WeightInfo.role)
}
#if LANG_CXX11
inline void WeightInfo::set_role(::std::string&& value) {
  set_has_role();
  role_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.WeightInfo.role)
}
#endif
inline void WeightInfo::set_role(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_role();
  role_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.WeightInfo.role)
}
inline void WeightInfo::set_role(const char* value,
    size_t size) {
  set_has_role();
  role_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.WeightInfo.role)
}
inline ::std::string* WeightInfo::mutable_role() {
  set_has_role();
  // @@protoc_insertion_point(field_mutable:mesos.WeightInfo.role)
  return role_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* WeightInfo::release_role() {
  // @@protoc_insertion_point(field_release:mesos.WeightInfo.role)
  clear_has_role();
  return role_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void WeightInfo::set_allocated_role(::std::string* role) {
  if (role != NULL) {
    set_has_role();
  } else {
    clear_has_role();
  }
  role_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), role,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.WeightInfo.role)
}
inline ::std::string* WeightInfo::unsafe_arena_release_role() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.WeightInfo.role)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_role();
  return role_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void WeightInfo::unsafe_arena_set_allocated_role(
    ::std::string* role) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (role != NULL) {
    set_has_role();
  } else {
    clear_has_role();
  }
  role_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      role, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.WeightInfo.role)
}

// -------------------------------------------------------------------

// VersionInfo

// required string version = 1;
inline bool VersionInfo::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VersionInfo::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VersionInfo::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VersionInfo::clear_version() {
  version_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_version();
}
inline const ::std::string& VersionInfo::version() const {
  // @@protoc_insertion_point(field_get:mesos.VersionInfo.version)
  return version_.Get();
}
inline void VersionInfo::set_version(const ::std::string& value) {
  set_has_version();
  version_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.VersionInfo.version)
}
#if LANG_CXX11
inline void VersionInfo::set_version(::std::string&& value) {
  set_has_version();
  version_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.VersionInfo.version)
}
#endif
inline void VersionInfo::set_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_version();
  version_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.VersionInfo.version)
}
inline void VersionInfo::set_version(const char* value,
    size_t size) {
  set_has_version();
  version_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.VersionInfo.version)
}
inline ::std::string* VersionInfo::mutable_version() {
  set_has_version();
  // @@protoc_insertion_point(field_mutable:mesos.VersionInfo.version)
  return version_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* VersionInfo::release_version() {
  // @@protoc_insertion_point(field_release:mesos.VersionInfo.version)
  clear_has_version();
  return version_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void VersionInfo::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    set_has_version();
  } else {
    clear_has_version();
  }
  version_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.VersionInfo.version)
}
inline ::std::string* VersionInfo::unsafe_arena_release_version() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.VersionInfo.version)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_version();
  return version_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void VersionInfo::unsafe_arena_set_allocated_version(
    ::std::string* version) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (version != NULL) {
    set_has_version();
  } else {
    clear_has_version();
  }
  version_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      version, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.VersionInfo.version)
}

// optional string build_date = 2;
inline bool VersionInfo::has_build_date() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VersionInfo::set_has_build_date() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VersionInfo::clear_has_build_date() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VersionInfo::clear_build_date() {
  build_date_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_build_date();
}
inline const ::std::string& VersionInfo::build_date() const {
  // @@protoc_insertion_point(field_get:mesos.VersionInfo.build_date)
  return build_date_.Get();
}
inline void VersionInfo::set_build_date(const ::std::string& value) {
  set_has_build_date();
  build_date_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.VersionInfo.build_date)
}
#if LANG_CXX11
inline void VersionInfo::set_build_date(::std::string&& value) {
  set_has_build_date();
  build_date_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.VersionInfo.build_date)
}
#endif
inline void VersionInfo::set_build_date(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_build_date();
  build_date_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.VersionInfo.build_date)
}
inline void VersionInfo::set_build_date(const char* value,
    size_t size) {
  set_has_build_date();
  build_date_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.VersionInfo.build_date)
}
inline ::std::string* VersionInfo::mutable_build_date() {
  set_has_build_date();
  // @@protoc_insertion_point(field_mutable:mesos.VersionInfo.build_date)
  return build_date_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* VersionInfo::release_build_date() {
  // @@protoc_insertion_point(field_release:mesos.VersionInfo.build_date)
  clear_has_build_date();
  return build_date_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void VersionInfo::set_allocated_build_date(::std::string* build_date) {
  if (build_date != NULL) {
    set_has_build_date();
  } else {
    clear_has_build_date();
  }
  build_date_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), build_date,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.VersionInfo.build_date)
}
inline ::std::string* VersionInfo::unsafe_arena_release_build_date() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.VersionInfo.build_date)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_build_date();
  return build_date_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void VersionInfo::unsafe_arena_set_allocated_build_date(
    ::std::string* build_date) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (build_date != NULL) {
    set_has_build_date();
  } else {
    clear_has_build_date();
  }
  build_date_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      build_date, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.VersionInfo.build_date)
}

// optional double build_time = 3;
inline bool VersionInfo::has_build_time() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void VersionInfo::set_has_build_time() {
  _has_bits_[0] |= 0x00000040u;
}
inline void VersionInfo::clear_has_build_time() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void VersionInfo::clear_build_time() {
  build_time_ = 0;
  clear_has_build_time();
}
inline double VersionInfo::build_time() const {
  // @@protoc_insertion_point(field_get:mesos.VersionInfo.build_time)
  return build_time_;
}
inline void VersionInfo::set_build_time(double value) {
  set_has_build_time();
  build_time_ = value;
  // @@protoc_insertion_point(field_set:mesos.VersionInfo.build_time)
}

// optional string build_user = 4;
inline bool VersionInfo::has_build_user() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VersionInfo::set_has_build_user() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VersionInfo::clear_has_build_user() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VersionInfo::clear_build_user() {
  build_user_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_build_user();
}
inline const ::std::string& VersionInfo::build_user() const {
  // @@protoc_insertion_point(field_get:mesos.VersionInfo.build_user)
  return build_user_.Get();
}
inline void VersionInfo::set_build_user(const ::std::string& value) {
  set_has_build_user();
  build_user_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.VersionInfo.build_user)
}
#if LANG_CXX11
inline void VersionInfo::set_build_user(::std::string&& value) {
  set_has_build_user();
  build_user_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.VersionInfo.build_user)
}
#endif
inline void VersionInfo::set_build_user(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_build_user();
  build_user_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.VersionInfo.build_user)
}
inline void VersionInfo::set_build_user(const char* value,
    size_t size) {
  set_has_build_user();
  build_user_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.VersionInfo.build_user)
}
inline ::std::string* VersionInfo::mutable_build_user() {
  set_has_build_user();
  // @@protoc_insertion_point(field_mutable:mesos.VersionInfo.build_user)
  return build_user_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* VersionInfo::release_build_user() {
  // @@protoc_insertion_point(field_release:mesos.VersionInfo.build_user)
  clear_has_build_user();
  return build_user_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void VersionInfo::set_allocated_build_user(::std::string* build_user) {
  if (build_user != NULL) {
    set_has_build_user();
  } else {
    clear_has_build_user();
  }
  build_user_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), build_user,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.VersionInfo.build_user)
}
inline ::std::string* VersionInfo::unsafe_arena_release_build_user() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.VersionInfo.build_user)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_build_user();
  return build_user_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void VersionInfo::unsafe_arena_set_allocated_build_user(
    ::std::string* build_user) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (build_user != NULL) {
    set_has_build_user();
  } else {
    clear_has_build_user();
  }
  build_user_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      build_user, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.VersionInfo.build_user)
}

// optional string git_sha = 5;
inline bool VersionInfo::has_git_sha() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void VersionInfo::set_has_git_sha() {
  _has_bits_[0] |= 0x00000008u;
}
inline void VersionInfo::clear_has_git_sha() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void VersionInfo::clear_git_sha() {
  git_sha_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_git_sha();
}
inline const ::std::string& VersionInfo::git_sha() const {
  // @@protoc_insertion_point(field_get:mesos.VersionInfo.git_sha)
  return git_sha_.Get();
}
inline void VersionInfo::set_git_sha(const ::std::string& value) {
  set_has_git_sha();
  git_sha_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.VersionInfo.git_sha)
}
#if LANG_CXX11
inline void VersionInfo::set_git_sha(::std::string&& value) {
  set_has_git_sha();
  git_sha_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.VersionInfo.git_sha)
}
#endif
inline void VersionInfo::set_git_sha(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_git_sha();
  git_sha_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.VersionInfo.git_sha)
}
inline void VersionInfo::set_git_sha(const char* value,
    size_t size) {
  set_has_git_sha();
  git_sha_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.VersionInfo.git_sha)
}
inline ::std::string* VersionInfo::mutable_git_sha() {
  set_has_git_sha();
  // @@protoc_insertion_point(field_mutable:mesos.VersionInfo.git_sha)
  return git_sha_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* VersionInfo::release_git_sha() {
  // @@protoc_insertion_point(field_release:mesos.VersionInfo.git_sha)
  clear_has_git_sha();
  return git_sha_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void VersionInfo::set_allocated_git_sha(::std::string* git_sha) {
  if (git_sha != NULL) {
    set_has_git_sha();
  } else {
    clear_has_git_sha();
  }
  git_sha_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), git_sha,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.VersionInfo.git_sha)
}
inline ::std::string* VersionInfo::unsafe_arena_release_git_sha() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.VersionInfo.git_sha)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_git_sha();
  return git_sha_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void VersionInfo::unsafe_arena_set_allocated_git_sha(
    ::std::string* git_sha) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (git_sha != NULL) {
    set_has_git_sha();
  } else {
    clear_has_git_sha();
  }
  git_sha_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      git_sha, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.VersionInfo.git_sha)
}

// optional string git_branch = 6;
inline bool VersionInfo::has_git_branch() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void VersionInfo::set_has_git_branch() {
  _has_bits_[0] |= 0x00000010u;
}
inline void VersionInfo::clear_has_git_branch() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void VersionInfo::clear_git_branch() {
  git_branch_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_git_branch();
}
inline const ::std::string& VersionInfo::git_branch() const {
  // @@protoc_insertion_point(field_get:mesos.VersionInfo.git_branch)
  return git_branch_.Get();
}
inline void VersionInfo::set_git_branch(const ::std::string& value) {
  set_has_git_branch();
  git_branch_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.VersionInfo.git_branch)
}
#if LANG_CXX11
inline void VersionInfo::set_git_branch(::std::string&& value) {
  set_has_git_branch();
  git_branch_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.VersionInfo.git_branch)
}
#endif
inline void VersionInfo::set_git_branch(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_git_branch();
  git_branch_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.VersionInfo.git_branch)
}
inline void VersionInfo::set_git_branch(const char* value,
    size_t size) {
  set_has_git_branch();
  git_branch_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.VersionInfo.git_branch)
}
inline ::std::string* VersionInfo::mutable_git_branch() {
  set_has_git_branch();
  // @@protoc_insertion_point(field_mutable:mesos.VersionInfo.git_branch)
  return git_branch_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* VersionInfo::release_git_branch() {
  // @@protoc_insertion_point(field_release:mesos.VersionInfo.git_branch)
  clear_has_git_branch();
  return git_branch_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void VersionInfo::set_allocated_git_branch(::std::string* git_branch) {
  if (git_branch != NULL) {
    set_has_git_branch();
  } else {
    clear_has_git_branch();
  }
  git_branch_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), git_branch,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.VersionInfo.git_branch)
}
inline ::std::string* VersionInfo::unsafe_arena_release_git_branch() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.VersionInfo.git_branch)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_git_branch();
  return git_branch_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void VersionInfo::unsafe_arena_set_allocated_git_branch(
    ::std::string* git_branch) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (git_branch != NULL) {
    set_has_git_branch();
  } else {
    clear_has_git_branch();
  }
  git_branch_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      git_branch, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.VersionInfo.git_branch)
}

// optional string git_tag = 7;
inline bool VersionInfo::has_git_tag() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void VersionInfo::set_has_git_tag() {
  _has_bits_[0] |= 0x00000020u;
}
inline void VersionInfo::clear_has_git_tag() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void VersionInfo::clear_git_tag() {
  git_tag_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_git_tag();
}
inline const ::std::string& VersionInfo::git_tag() const {
  // @@protoc_insertion_point(field_get:mesos.VersionInfo.git_tag)
  return git_tag_.Get();
}
inline void VersionInfo::set_git_tag(const ::std::string& value) {
  set_has_git_tag();
  git_tag_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.VersionInfo.git_tag)
}
#if LANG_CXX11
inline void VersionInfo::set_git_tag(::std::string&& value) {
  set_has_git_tag();
  git_tag_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.VersionInfo.git_tag)
}
#endif
inline void VersionInfo::set_git_tag(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_git_tag();
  git_tag_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.VersionInfo.git_tag)
}
inline void VersionInfo::set_git_tag(const char* value,
    size_t size) {
  set_has_git_tag();
  git_tag_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.VersionInfo.git_tag)
}
inline ::std::string* VersionInfo::mutable_git_tag() {
  set_has_git_tag();
  // @@protoc_insertion_point(field_mutable:mesos.VersionInfo.git_tag)
  return git_tag_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* VersionInfo::release_git_tag() {
  // @@protoc_insertion_point(field_release:mesos.VersionInfo.git_tag)
  clear_has_git_tag();
  return git_tag_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void VersionInfo::set_allocated_git_tag(::std::string* git_tag) {
  if (git_tag != NULL) {
    set_has_git_tag();
  } else {
    clear_has_git_tag();
  }
  git_tag_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), git_tag,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.VersionInfo.git_tag)
}
inline ::std::string* VersionInfo::unsafe_arena_release_git_tag() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.VersionInfo.git_tag)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_git_tag();
  return git_tag_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void VersionInfo::unsafe_arena_set_allocated_git_tag(
    ::std::string* git_tag) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (git_tag != NULL) {
    set_has_git_tag();
  } else {
    clear_has_git_tag();
  }
  git_tag_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      git_tag, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.VersionInfo.git_tag)
}

// -------------------------------------------------------------------

// Flag

// required string name = 1;
inline bool Flag::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Flag::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Flag::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Flag::clear_name() {
  name_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_name();
}
inline const ::std::string& Flag::name() const {
  // @@protoc_insertion_point(field_get:mesos.Flag.name)
  return name_.Get();
}
inline void Flag::set_name(const ::std::string& value) {
  set_has_name();
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.Flag.name)
}
#if LANG_CXX11
inline void Flag::set_name(::std::string&& value) {
  set_has_name();
  name_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.Flag.name)
}
#endif
inline void Flag::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.Flag.name)
}
inline void Flag::set_name(const char* value,
    size_t size) {
  set_has_name();
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.Flag.name)
}
inline ::std::string* Flag::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:mesos.Flag.name)
  return name_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* Flag::release_name() {
  // @@protoc_insertion_point(field_release:mesos.Flag.name)
  clear_has_name();
  return name_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void Flag::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.Flag.name)
}
inline ::std::string* Flag::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Flag.name)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_name();
  return name_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void Flag::unsafe_arena_set_allocated_name(
    ::std::string* name) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      name, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.Flag.name)
}

// optional string value = 2;
inline bool Flag::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Flag::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Flag::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Flag::clear_value() {
  value_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_value();
}
inline const ::std::string& Flag::value() const {
  // @@protoc_insertion_point(field_get:mesos.Flag.value)
  return value_.Get();
}
inline void Flag::set_value(const ::std::string& value) {
  set_has_value();
  value_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.Flag.value)
}
#if LANG_CXX11
inline void Flag::set_value(::std::string&& value) {
  set_has_value();
  value_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.Flag.value)
}
#endif
inline void Flag::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_value();
  value_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.Flag.value)
}
inline void Flag::set_value(const char* value,
    size_t size) {
  set_has_value();
  value_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.Flag.value)
}
inline ::std::string* Flag::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:mesos.Flag.value)
  return value_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* Flag::release_value() {
  // @@protoc_insertion_point(field_release:mesos.Flag.value)
  clear_has_value();
  return value_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void Flag::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.Flag.value)
}
inline ::std::string* Flag::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Flag.value)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_value();
  return value_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void Flag::unsafe_arena_set_allocated_value(
    ::std::string* value) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.Flag.value)
}

// -------------------------------------------------------------------

// Role

// required string name = 1;
inline bool Role::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Role::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Role::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Role::clear_name() {
  name_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_name();
}
inline const ::std::string& Role::name() const {
  // @@protoc_insertion_point(field_get:mesos.Role.name)
  return name_.Get();
}
inline void Role::set_name(const ::std::string& value) {
  set_has_name();
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.Role.name)
}
#if LANG_CXX11
inline void Role::set_name(::std::string&& value) {
  set_has_name();
  name_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.Role.name)
}
#endif
inline void Role::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.Role.name)
}
inline void Role::set_name(const char* value,
    size_t size) {
  set_has_name();
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.Role.name)
}
inline ::std::string* Role::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:mesos.Role.name)
  return name_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* Role::release_name() {
  // @@protoc_insertion_point(field_release:mesos.Role.name)
  clear_has_name();
  return name_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void Role::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.Role.name)
}
inline ::std::string* Role::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Role.name)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_name();
  return name_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void Role::unsafe_arena_set_allocated_name(
    ::std::string* name) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      name, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.Role.name)
}

// required double weight = 2;
inline bool Role::has_weight() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Role::set_has_weight() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Role::clear_has_weight() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Role::clear_weight() {
  weight_ = 0;
  clear_has_weight();
}
inline double Role::weight() const {
  // @@protoc_insertion_point(field_get:mesos.Role.weight)
  return weight_;
}
inline void Role::set_weight(double value) {
  set_has_weight();
  weight_ = value;
  // @@protoc_insertion_point(field_set:mesos.Role.weight)
}

// repeated .mesos.FrameworkID frameworks = 3;
inline int Role::frameworks_size() const {
  return frameworks_.size();
}
inline void Role::clear_frameworks() {
  frameworks_.Clear();
}
inline const ::mesos::FrameworkID& Role::frameworks(int index) const {
  // @@protoc_insertion_point(field_get:mesos.Role.frameworks)
  return frameworks_.Get(index);
}
inline ::mesos::FrameworkID* Role::mutable_frameworks(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.Role.frameworks)
  return frameworks_.Mutable(index);
}
inline ::mesos::FrameworkID* Role::add_frameworks() {
  // @@protoc_insertion_point(field_add:mesos.Role.frameworks)
  return frameworks_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::FrameworkID >*
Role::mutable_frameworks() {
  // @@protoc_insertion_point(field_mutable_list:mesos.Role.frameworks)
  return &frameworks_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::FrameworkID >&
Role::frameworks() const {
  // @@protoc_insertion_point(field_list:mesos.Role.frameworks)
  return frameworks_;
}

// repeated .mesos.Resource resources = 4;
inline int Role::resources_size() const {
  return resources_.size();
}
inline void Role::clear_resources() {
  resources_.Clear();
}
inline const ::mesos::Resource& Role::resources(int index) const {
  // @@protoc_insertion_point(field_get:mesos.Role.resources)
  return resources_.Get(index);
}
inline ::mesos::Resource* Role::mutable_resources(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.Role.resources)
  return resources_.Mutable(index);
}
inline ::mesos::Resource* Role::add_resources() {
  // @@protoc_insertion_point(field_add:mesos.Role.resources)
  return resources_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
Role::mutable_resources() {
  // @@protoc_insertion_point(field_mutable_list:mesos.Role.resources)
  return &resources_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
Role::resources() const {
  // @@protoc_insertion_point(field_list:mesos.Role.resources)
  return resources_;
}

// -------------------------------------------------------------------

// Metric

// required string name = 1;
inline bool Metric::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Metric::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Metric::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Metric::clear_name() {
  name_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_name();
}
inline const ::std::string& Metric::name() const {
  // @@protoc_insertion_point(field_get:mesos.Metric.name)
  return name_.Get();
}
inline void Metric::set_name(const ::std::string& value) {
  set_has_name();
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.Metric.name)
}
#if LANG_CXX11
inline void Metric::set_name(::std::string&& value) {
  set_has_name();
  name_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.Metric.name)
}
#endif
inline void Metric::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.Metric.name)
}
inline void Metric::set_name(const char* value,
    size_t size) {
  set_has_name();
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.Metric.name)
}
inline ::std::string* Metric::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:mesos.Metric.name)
  return name_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* Metric::release_name() {
  // @@protoc_insertion_point(field_release:mesos.Metric.name)
  clear_has_name();
  return name_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void Metric::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.Metric.name)
}
inline ::std::string* Metric::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Metric.name)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_name();
  return name_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void Metric::unsafe_arena_set_allocated_name(
    ::std::string* name) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      name, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.Metric.name)
}

// optional double value = 2;
inline bool Metric::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Metric::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Metric::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Metric::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline double Metric::value() const {
  // @@protoc_insertion_point(field_get:mesos.Metric.value)
  return value_;
}
inline void Metric::set_value(double value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:mesos.Metric.value)
}

// -------------------------------------------------------------------

// FileInfo

// required string path = 1;
inline bool FileInfo::has_path() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FileInfo::set_has_path() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FileInfo::clear_has_path() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FileInfo::clear_path() {
  path_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_path();
}
inline const ::std::string& FileInfo::path() const {
  // @@protoc_insertion_point(field_get:mesos.FileInfo.path)
  return path_.Get();
}
inline void FileInfo::set_path(const ::std::string& value) {
  set_has_path();
  path_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.FileInfo.path)
}
#if LANG_CXX11
inline void FileInfo::set_path(::std::string&& value) {
  set_has_path();
  path_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.FileInfo.path)
}
#endif
inline void FileInfo::set_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_path();
  path_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.FileInfo.path)
}
inline void FileInfo::set_path(const char* value,
    size_t size) {
  set_has_path();
  path_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.FileInfo.path)
}
inline ::std::string* FileInfo::mutable_path() {
  set_has_path();
  // @@protoc_insertion_point(field_mutable:mesos.FileInfo.path)
  return path_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* FileInfo::release_path() {
  // @@protoc_insertion_point(field_release:mesos.FileInfo.path)
  clear_has_path();
  return path_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void FileInfo::set_allocated_path(::std::string* path) {
  if (path != NULL) {
    set_has_path();
  } else {
    clear_has_path();
  }
  path_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), path,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.FileInfo.path)
}
inline ::std::string* FileInfo::unsafe_arena_release_path() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.FileInfo.path)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_path();
  return path_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void FileInfo::unsafe_arena_set_allocated_path(
    ::std::string* path) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (path != NULL) {
    set_has_path();
  } else {
    clear_has_path();
  }
  path_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      path, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.FileInfo.path)
}

// optional int32 nlink = 2;
inline bool FileInfo::has_nlink() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void FileInfo::set_has_nlink() {
  _has_bits_[0] |= 0x00000020u;
}
inline void FileInfo::clear_has_nlink() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void FileInfo::clear_nlink() {
  nlink_ = 0;
  clear_has_nlink();
}
inline ::google::protobuf::int32 FileInfo::nlink() const {
  // @@protoc_insertion_point(field_get:mesos.FileInfo.nlink)
  return nlink_;
}
inline void FileInfo::set_nlink(::google::protobuf::int32 value) {
  set_has_nlink();
  nlink_ = value;
  // @@protoc_insertion_point(field_set:mesos.FileInfo.nlink)
}

// optional uint64 size = 3;
inline bool FileInfo::has_size() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FileInfo::set_has_size() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FileInfo::clear_has_size() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FileInfo::clear_size() {
  size_ = GOOGLE_ULONGLONG(0);
  clear_has_size();
}
inline ::google::protobuf::uint64 FileInfo::size() const {
  // @@protoc_insertion_point(field_get:mesos.FileInfo.size)
  return size_;
}
inline void FileInfo::set_size(::google::protobuf::uint64 value) {
  set_has_size();
  size_ = value;
  // @@protoc_insertion_point(field_set:mesos.FileInfo.size)
}

// optional .mesos.TimeInfo mtime = 4;
inline bool FileInfo::has_mtime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FileInfo::set_has_mtime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FileInfo::clear_has_mtime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FileInfo::clear_mtime() {
  if (mtime_ != NULL) mtime_->Clear();
  clear_has_mtime();
}
inline const ::mesos::TimeInfo& FileInfo::mtime() const {
  const ::mesos::TimeInfo* p = mtime_;
  // @@protoc_insertion_point(field_get:mesos.FileInfo.mtime)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::TimeInfo*>(
      &::mesos::_TimeInfo_default_instance_);
}
inline ::mesos::TimeInfo* FileInfo::release_mtime() {
  // @@protoc_insertion_point(field_release:mesos.FileInfo.mtime)
  clear_has_mtime();
  ::mesos::TimeInfo* temp = mtime_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  mtime_ = NULL;
  return temp;
}
inline ::mesos::TimeInfo* FileInfo::unsafe_arena_release_mtime() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.FileInfo.mtime)
  clear_has_mtime();
  ::mesos::TimeInfo* temp = mtime_;
  mtime_ = NULL;
  return temp;
}
inline ::mesos::TimeInfo* FileInfo::mutable_mtime() {
  set_has_mtime();
  if (mtime_ == NULL) {
    _slow_mutable_mtime();
  }
  // @@protoc_insertion_point(field_mutable:mesos.FileInfo.mtime)
  return mtime_;
}
inline void FileInfo::set_allocated_mtime(::mesos::TimeInfo* mtime) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete mtime_;
  }
  if (mtime) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(mtime);
    if (message_arena != submessage_arena) {
      mtime = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, mtime, submessage_arena);
    }
    set_has_mtime();
  } else {
    clear_has_mtime();
  }
  mtime_ = mtime;
  // @@protoc_insertion_point(field_set_allocated:mesos.FileInfo.mtime)
}

// optional uint32 mode = 5;
inline bool FileInfo::has_mode() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void FileInfo::set_has_mode() {
  _has_bits_[0] |= 0x00000040u;
}
inline void FileInfo::clear_has_mode() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void FileInfo::clear_mode() {
  mode_ = 0u;
  clear_has_mode();
}
inline ::google::protobuf::uint32 FileInfo::mode() const {
  // @@protoc_insertion_point(field_get:mesos.FileInfo.mode)
  return mode_;
}
inline void FileInfo::set_mode(::google::protobuf::uint32 value) {
  set_has_mode();
  mode_ = value;
  // @@protoc_insertion_point(field_set:mesos.FileInfo.mode)
}

// optional string uid = 6;
inline bool FileInfo::has_uid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FileInfo::set_has_uid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FileInfo::clear_has_uid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FileInfo::clear_uid() {
  uid_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_uid();
}
inline const ::std::string& FileInfo::uid() const {
  // @@protoc_insertion_point(field_get:mesos.FileInfo.uid)
  return uid_.Get();
}
inline void FileInfo::set_uid(const ::std::string& value) {
  set_has_uid();
  uid_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.FileInfo.uid)
}
#if LANG_CXX11
inline void FileInfo::set_uid(::std::string&& value) {
  set_has_uid();
  uid_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.FileInfo.uid)
}
#endif
inline void FileInfo::set_uid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_uid();
  uid_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.FileInfo.uid)
}
inline void FileInfo::set_uid(const char* value,
    size_t size) {
  set_has_uid();
  uid_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.FileInfo.uid)
}
inline ::std::string* FileInfo::mutable_uid() {
  set_has_uid();
  // @@protoc_insertion_point(field_mutable:mesos.FileInfo.uid)
  return uid_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* FileInfo::release_uid() {
  // @@protoc_insertion_point(field_release:mesos.FileInfo.uid)
  clear_has_uid();
  return uid_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void FileInfo::set_allocated_uid(::std::string* uid) {
  if (uid != NULL) {
    set_has_uid();
  } else {
    clear_has_uid();
  }
  uid_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), uid,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.FileInfo.uid)
}
inline ::std::string* FileInfo::unsafe_arena_release_uid() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.FileInfo.uid)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_uid();
  return uid_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void FileInfo::unsafe_arena_set_allocated_uid(
    ::std::string* uid) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (uid != NULL) {
    set_has_uid();
  } else {
    clear_has_uid();
  }
  uid_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      uid, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.FileInfo.uid)
}

// optional string gid = 7;
inline bool FileInfo::has_gid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FileInfo::set_has_gid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FileInfo::clear_has_gid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FileInfo::clear_gid() {
  gid_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_gid();
}
inline const ::std::string& FileInfo::gid() const {
  // @@protoc_insertion_point(field_get:mesos.FileInfo.gid)
  return gid_.Get();
}
inline void FileInfo::set_gid(const ::std::string& value) {
  set_has_gid();
  gid_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.FileInfo.gid)
}
#if LANG_CXX11
inline void FileInfo::set_gid(::std::string&& value) {
  set_has_gid();
  gid_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.FileInfo.gid)
}
#endif
inline void FileInfo::set_gid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_gid();
  gid_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.FileInfo.gid)
}
inline void FileInfo::set_gid(const char* value,
    size_t size) {
  set_has_gid();
  gid_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.FileInfo.gid)
}
inline ::std::string* FileInfo::mutable_gid() {
  set_has_gid();
  // @@protoc_insertion_point(field_mutable:mesos.FileInfo.gid)
  return gid_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* FileInfo::release_gid() {
  // @@protoc_insertion_point(field_release:mesos.FileInfo.gid)
  clear_has_gid();
  return gid_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void FileInfo::set_allocated_gid(::std::string* gid) {
  if (gid != NULL) {
    set_has_gid();
  } else {
    clear_has_gid();
  }
  gid_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), gid,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.FileInfo.gid)
}
inline ::std::string* FileInfo::unsafe_arena_release_gid() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.FileInfo.gid)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_gid();
  return gid_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void FileInfo::unsafe_arena_set_allocated_gid(
    ::std::string* gid) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (gid != NULL) {
    set_has_gid();
  } else {
    clear_has_gid();
  }
  gid_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      gid, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.FileInfo.gid)
}

// -------------------------------------------------------------------

// Device_Number

// required uint64 major_number = 1;
inline bool Device_Number::has_major_number() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Device_Number::set_has_major_number() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Device_Number::clear_has_major_number() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Device_Number::clear_major_number() {
  major_number_ = GOOGLE_ULONGLONG(0);
  clear_has_major_number();
}
inline ::google::protobuf::uint64 Device_Number::major_number() const {
  // @@protoc_insertion_point(field_get:mesos.Device.Number.major_number)
  return major_number_;
}
inline void Device_Number::set_major_number(::google::protobuf::uint64 value) {
  set_has_major_number();
  major_number_ = value;
  // @@protoc_insertion_point(field_set:mesos.Device.Number.major_number)
}

// required uint64 minor_number = 2;
inline bool Device_Number::has_minor_number() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Device_Number::set_has_minor_number() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Device_Number::clear_has_minor_number() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Device_Number::clear_minor_number() {
  minor_number_ = GOOGLE_ULONGLONG(0);
  clear_has_minor_number();
}
inline ::google::protobuf::uint64 Device_Number::minor_number() const {
  // @@protoc_insertion_point(field_get:mesos.Device.Number.minor_number)
  return minor_number_;
}
inline void Device_Number::set_minor_number(::google::protobuf::uint64 value) {
  set_has_minor_number();
  minor_number_ = value;
  // @@protoc_insertion_point(field_set:mesos.Device.Number.minor_number)
}

// -------------------------------------------------------------------

// Device

// optional string path = 1;
inline bool Device::has_path() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Device::set_has_path() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Device::clear_has_path() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Device::clear_path() {
  path_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_path();
}
inline const ::std::string& Device::path() const {
  // @@protoc_insertion_point(field_get:mesos.Device.path)
  return path_.Get();
}
inline void Device::set_path(const ::std::string& value) {
  set_has_path();
  path_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.Device.path)
}
#if LANG_CXX11
inline void Device::set_path(::std::string&& value) {
  set_has_path();
  path_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.Device.path)
}
#endif
inline void Device::set_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_path();
  path_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.Device.path)
}
inline void Device::set_path(const char* value,
    size_t size) {
  set_has_path();
  path_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.Device.path)
}
inline ::std::string* Device::mutable_path() {
  set_has_path();
  // @@protoc_insertion_point(field_mutable:mesos.Device.path)
  return path_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* Device::release_path() {
  // @@protoc_insertion_point(field_release:mesos.Device.path)
  clear_has_path();
  return path_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void Device::set_allocated_path(::std::string* path) {
  if (path != NULL) {
    set_has_path();
  } else {
    clear_has_path();
  }
  path_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), path,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.Device.path)
}
inline ::std::string* Device::unsafe_arena_release_path() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Device.path)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_path();
  return path_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void Device::unsafe_arena_set_allocated_path(
    ::std::string* path) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (path != NULL) {
    set_has_path();
  } else {
    clear_has_path();
  }
  path_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      path, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.Device.path)
}

// optional .mesos.Device.Number number = 2;
inline bool Device::has_number() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Device::set_has_number() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Device::clear_has_number() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Device::clear_number() {
  if (number_ != NULL) number_->Clear();
  clear_has_number();
}
inline const ::mesos::Device_Number& Device::number() const {
  const ::mesos::Device_Number* p = number_;
  // @@protoc_insertion_point(field_get:mesos.Device.number)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::Device_Number*>(
      &::mesos::_Device_Number_default_instance_);
}
inline ::mesos::Device_Number* Device::release_number() {
  // @@protoc_insertion_point(field_release:mesos.Device.number)
  clear_has_number();
  ::mesos::Device_Number* temp = number_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  number_ = NULL;
  return temp;
}
inline ::mesos::Device_Number* Device::unsafe_arena_release_number() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.Device.number)
  clear_has_number();
  ::mesos::Device_Number* temp = number_;
  number_ = NULL;
  return temp;
}
inline ::mesos::Device_Number* Device::mutable_number() {
  set_has_number();
  if (number_ == NULL) {
    _slow_mutable_number();
  }
  // @@protoc_insertion_point(field_mutable:mesos.Device.number)
  return number_;
}
inline void Device::set_allocated_number(::mesos::Device_Number* number) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete number_;
  }
  if (number) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(number);
    if (message_arena != submessage_arena) {
      number = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, number, submessage_arena);
    }
    set_has_number();
  } else {
    clear_has_number();
  }
  number_ = number;
  // @@protoc_insertion_point(field_set_allocated:mesos.Device.number)
}

// -------------------------------------------------------------------

// DeviceAccess_Access

// optional bool read = 1;
inline bool DeviceAccess_Access::has_read() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeviceAccess_Access::set_has_read() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeviceAccess_Access::clear_has_read() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeviceAccess_Access::clear_read() {
  read_ = false;
  clear_has_read();
}
inline bool DeviceAccess_Access::read() const {
  // @@protoc_insertion_point(field_get:mesos.DeviceAccess.Access.read)
  return read_;
}
inline void DeviceAccess_Access::set_read(bool value) {
  set_has_read();
  read_ = value;
  // @@protoc_insertion_point(field_set:mesos.DeviceAccess.Access.read)
}

// optional bool write = 2;
inline bool DeviceAccess_Access::has_write() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DeviceAccess_Access::set_has_write() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DeviceAccess_Access::clear_has_write() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DeviceAccess_Access::clear_write() {
  write_ = false;
  clear_has_write();
}
inline bool DeviceAccess_Access::write() const {
  // @@protoc_insertion_point(field_get:mesos.DeviceAccess.Access.write)
  return write_;
}
inline void DeviceAccess_Access::set_write(bool value) {
  set_has_write();
  write_ = value;
  // @@protoc_insertion_point(field_set:mesos.DeviceAccess.Access.write)
}

// optional bool mknod = 3;
inline bool DeviceAccess_Access::has_mknod() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DeviceAccess_Access::set_has_mknod() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DeviceAccess_Access::clear_has_mknod() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DeviceAccess_Access::clear_mknod() {
  mknod_ = false;
  clear_has_mknod();
}
inline bool DeviceAccess_Access::mknod() const {
  // @@protoc_insertion_point(field_get:mesos.DeviceAccess.Access.mknod)
  return mknod_;
}
inline void DeviceAccess_Access::set_mknod(bool value) {
  set_has_mknod();
  mknod_ = value;
  // @@protoc_insertion_point(field_set:mesos.DeviceAccess.Access.mknod)
}

// -------------------------------------------------------------------

// DeviceAccess

// required .mesos.Device device = 1;
inline bool DeviceAccess::has_device() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeviceAccess::set_has_device() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeviceAccess::clear_has_device() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeviceAccess::clear_device() {
  if (device_ != NULL) device_->Clear();
  clear_has_device();
}
inline const ::mesos::Device& DeviceAccess::device() const {
  const ::mesos::Device* p = device_;
  // @@protoc_insertion_point(field_get:mesos.DeviceAccess.device)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::Device*>(
      &::mesos::_Device_default_instance_);
}
inline ::mesos::Device* DeviceAccess::release_device() {
  // @@protoc_insertion_point(field_release:mesos.DeviceAccess.device)
  clear_has_device();
  ::mesos::Device* temp = device_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  device_ = NULL;
  return temp;
}
inline ::mesos::Device* DeviceAccess::unsafe_arena_release_device() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.DeviceAccess.device)
  clear_has_device();
  ::mesos::Device* temp = device_;
  device_ = NULL;
  return temp;
}
inline ::mesos::Device* DeviceAccess::mutable_device() {
  set_has_device();
  if (device_ == NULL) {
    _slow_mutable_device();
  }
  // @@protoc_insertion_point(field_mutable:mesos.DeviceAccess.device)
  return device_;
}
inline void DeviceAccess::set_allocated_device(::mesos::Device* device) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete device_;
  }
  if (device) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(device);
    if (message_arena != submessage_arena) {
      device = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, device, submessage_arena);
    }
    set_has_device();
  } else {
    clear_has_device();
  }
  device_ = device;
  // @@protoc_insertion_point(field_set_allocated:mesos.DeviceAccess.device)
}

// required .mesos.DeviceAccess.Access access = 2;
inline bool DeviceAccess::has_access() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DeviceAccess::set_has_access() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DeviceAccess::clear_has_access() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DeviceAccess::clear_access() {
  if (access_ != NULL) access_->Clear();
  clear_has_access();
}
inline const ::mesos::DeviceAccess_Access& DeviceAccess::access() const {
  const ::mesos::DeviceAccess_Access* p = access_;
  // @@protoc_insertion_point(field_get:mesos.DeviceAccess.access)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::DeviceAccess_Access*>(
      &::mesos::_DeviceAccess_Access_default_instance_);
}
inline ::mesos::DeviceAccess_Access* DeviceAccess::release_access() {
  // @@protoc_insertion_point(field_release:mesos.DeviceAccess.access)
  clear_has_access();
  ::mesos::DeviceAccess_Access* temp = access_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  access_ = NULL;
  return temp;
}
inline ::mesos::DeviceAccess_Access* DeviceAccess::unsafe_arena_release_access() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.DeviceAccess.access)
  clear_has_access();
  ::mesos::DeviceAccess_Access* temp = access_;
  access_ = NULL;
  return temp;
}
inline ::mesos::DeviceAccess_Access* DeviceAccess::mutable_access() {
  set_has_access();
  if (access_ == NULL) {
    _slow_mutable_access();
  }
  // @@protoc_insertion_point(field_mutable:mesos.DeviceAccess.access)
  return access_;
}
inline void DeviceAccess::set_allocated_access(::mesos::DeviceAccess_Access* access) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete access_;
  }
  if (access) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(access);
    if (message_arena != submessage_arena) {
      access = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, access, submessage_arena);
    }
    set_has_access();
  } else {
    clear_has_access();
  }
  access_ = access;
  // @@protoc_insertion_point(field_set_allocated:mesos.DeviceAccess.access)
}

// -------------------------------------------------------------------

// DeviceWhitelist

// repeated .mesos.DeviceAccess allowed_devices = 1;
inline int DeviceWhitelist::allowed_devices_size() const {
  return allowed_devices_.size();
}
inline void DeviceWhitelist::clear_allowed_devices() {
  allowed_devices_.Clear();
}
inline const ::mesos::DeviceAccess& DeviceWhitelist::allowed_devices(int index) const {
  // @@protoc_insertion_point(field_get:mesos.DeviceWhitelist.allowed_devices)
  return allowed_devices_.Get(index);
}
inline ::mesos::DeviceAccess* DeviceWhitelist::mutable_allowed_devices(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.DeviceWhitelist.allowed_devices)
  return allowed_devices_.Mutable(index);
}
inline ::mesos::DeviceAccess* DeviceWhitelist::add_allowed_devices() {
  // @@protoc_insertion_point(field_add:mesos.DeviceWhitelist.allowed_devices)
  return allowed_devices_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::DeviceAccess >*
DeviceWhitelist::mutable_allowed_devices() {
  // @@protoc_insertion_point(field_mutable_list:mesos.DeviceWhitelist.allowed_devices)
  return &allowed_devices_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::DeviceAccess >&
DeviceWhitelist::allowed_devices() const {
  // @@protoc_insertion_point(field_list:mesos.DeviceWhitelist.allowed_devices)
  return allowed_devices_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace mesos

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::mesos::MachineInfo_Mode> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mesos::MachineInfo_Mode>() {
  return ::mesos::MachineInfo_Mode_descriptor();
}
template <> struct is_proto_enum< ::mesos::FrameworkInfo_Capability_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mesos::FrameworkInfo_Capability_Type>() {
  return ::mesos::FrameworkInfo_Capability_Type_descriptor();
}
template <> struct is_proto_enum< ::mesos::CheckInfo_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mesos::CheckInfo_Type>() {
  return ::mesos::CheckInfo_Type_descriptor();
}
template <> struct is_proto_enum< ::mesos::HealthCheck_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mesos::HealthCheck_Type>() {
  return ::mesos::HealthCheck_Type_descriptor();
}
template <> struct is_proto_enum< ::mesos::ExecutorInfo_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mesos::ExecutorInfo_Type>() {
  return ::mesos::ExecutorInfo_Type_descriptor();
}
template <> struct is_proto_enum< ::mesos::MasterInfo_Capability_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mesos::MasterInfo_Capability_Type>() {
  return ::mesos::MasterInfo_Capability_Type_descriptor();
}
template <> struct is_proto_enum< ::mesos::SlaveInfo_Capability_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mesos::SlaveInfo_Capability_Type>() {
  return ::mesos::SlaveInfo_Capability_Type_descriptor();
}
template <> struct is_proto_enum< ::mesos::CSIPluginContainerInfo_Service> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mesos::CSIPluginContainerInfo_Service>() {
  return ::mesos::CSIPluginContainerInfo_Service_descriptor();
}
template <> struct is_proto_enum< ::mesos::Value_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mesos::Value_Type>() {
  return ::mesos::Value_Type_descriptor();
}
template <> struct is_proto_enum< ::mesos::Resource_ReservationInfo_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mesos::Resource_ReservationInfo_Type>() {
  return ::mesos::Resource_ReservationInfo_Type_descriptor();
}
template <> struct is_proto_enum< ::mesos::Resource_DiskInfo_Source_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mesos::Resource_DiskInfo_Source_Type>() {
  return ::mesos::Resource_DiskInfo_Source_Type_descriptor();
}
template <> struct is_proto_enum< ::mesos::Offer_Operation_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mesos::Offer_Operation_Type>() {
  return ::mesos::Offer_Operation_Type_descriptor();
}
template <> struct is_proto_enum< ::mesos::TaskStatus_Source> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mesos::TaskStatus_Source>() {
  return ::mesos::TaskStatus_Source_descriptor();
}
template <> struct is_proto_enum< ::mesos::TaskStatus_Reason> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mesos::TaskStatus_Reason>() {
  return ::mesos::TaskStatus_Reason_descriptor();
}
template <> struct is_proto_enum< ::mesos::Environment_Variable_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mesos::Environment_Variable_Type>() {
  return ::mesos::Environment_Variable_Type_descriptor();
}
template <> struct is_proto_enum< ::mesos::Secret_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mesos::Secret_Type>() {
  return ::mesos::Secret_Type_descriptor();
}
template <> struct is_proto_enum< ::mesos::Image_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mesos::Image_Type>() {
  return ::mesos::Image_Type_descriptor();
}
template <> struct is_proto_enum< ::mesos::MountPropagation_Mode> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mesos::MountPropagation_Mode>() {
  return ::mesos::MountPropagation_Mode_descriptor();
}
template <> struct is_proto_enum< ::mesos::Volume_Source_SandboxPath_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mesos::Volume_Source_SandboxPath_Type>() {
  return ::mesos::Volume_Source_SandboxPath_Type_descriptor();
}
template <> struct is_proto_enum< ::mesos::Volume_Source_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mesos::Volume_Source_Type>() {
  return ::mesos::Volume_Source_Type_descriptor();
}
template <> struct is_proto_enum< ::mesos::Volume_Mode> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mesos::Volume_Mode>() {
  return ::mesos::Volume_Mode_descriptor();
}
template <> struct is_proto_enum< ::mesos::NetworkInfo_Protocol> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mesos::NetworkInfo_Protocol>() {
  return ::mesos::NetworkInfo_Protocol_descriptor();
}
template <> struct is_proto_enum< ::mesos::CapabilityInfo_Capability> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mesos::CapabilityInfo_Capability>() {
  return ::mesos::CapabilityInfo_Capability_descriptor();
}
template <> struct is_proto_enum< ::mesos::RLimitInfo_RLimit_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mesos::RLimitInfo_RLimit_Type>() {
  return ::mesos::RLimitInfo_RLimit_Type_descriptor();
}
template <> struct is_proto_enum< ::mesos::ContainerInfo_DockerInfo_Network> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mesos::ContainerInfo_DockerInfo_Network>() {
  return ::mesos::ContainerInfo_DockerInfo_Network_descriptor();
}
template <> struct is_proto_enum< ::mesos::ContainerInfo_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mesos::ContainerInfo_Type>() {
  return ::mesos::ContainerInfo_Type_descriptor();
}
template <> struct is_proto_enum< ::mesos::CgroupInfo_Blkio_Operation> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mesos::CgroupInfo_Blkio_Operation>() {
  return ::mesos::CgroupInfo_Blkio_Operation_descriptor();
}
template <> struct is_proto_enum< ::mesos::DiscoveryInfo_Visibility> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mesos::DiscoveryInfo_Visibility>() {
  return ::mesos::DiscoveryInfo_Visibility_descriptor();
}
template <> struct is_proto_enum< ::mesos::Status> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mesos::Status>() {
  return ::mesos::Status_descriptor();
}
template <> struct is_proto_enum< ::mesos::TaskState> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mesos::TaskState>() {
  return ::mesos::TaskState_descriptor();
}
template <> struct is_proto_enum< ::mesos::OperationState> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mesos::OperationState>() {
  return ::mesos::OperationState_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_mesos_2fmesos_2eproto__INCLUDED
