// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mesos/docker/v1.proto

#ifndef PROTOBUF_mesos_2fdocker_2fv1_2eproto__INCLUDED
#define PROTOBUF_mesos_2fdocker_2fv1_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protobuf_mesos_2fdocker_2fv1_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[3];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsImageManifest_Config_LabelsEntry_DoNotUseImpl();
void InitDefaultsImageManifest_Config_LabelsEntry_DoNotUse();
void InitDefaultsImageManifest_ConfigImpl();
void InitDefaultsImageManifest_Config();
void InitDefaultsImageManifestImpl();
void InitDefaultsImageManifest();
inline void InitDefaults() {
  InitDefaultsImageManifest_Config_LabelsEntry_DoNotUse();
  InitDefaultsImageManifest_Config();
  InitDefaultsImageManifest();
}
}  // namespace protobuf_mesos_2fdocker_2fv1_2eproto
namespace docker {
namespace spec {
namespace v1 {
class ImageManifest;
class ImageManifestDefaultTypeInternal;
extern ImageManifestDefaultTypeInternal _ImageManifest_default_instance_;
class ImageManifest_Config;
class ImageManifest_ConfigDefaultTypeInternal;
extern ImageManifest_ConfigDefaultTypeInternal _ImageManifest_Config_default_instance_;
class ImageManifest_Config_LabelsEntry_DoNotUse;
class ImageManifest_Config_LabelsEntry_DoNotUseDefaultTypeInternal;
extern ImageManifest_Config_LabelsEntry_DoNotUseDefaultTypeInternal _ImageManifest_Config_LabelsEntry_DoNotUse_default_instance_;
}  // namespace v1
}  // namespace spec
}  // namespace docker
namespace docker {
namespace spec {
namespace v1 {

// ===================================================================

class ImageManifest_Config_LabelsEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<ImageManifest_Config_LabelsEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<ImageManifest_Config_LabelsEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  ImageManifest_Config_LabelsEntry_DoNotUse();
  ImageManifest_Config_LabelsEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const ImageManifest_Config_LabelsEntry_DoNotUse& other);
  static const ImageManifest_Config_LabelsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ImageManifest_Config_LabelsEntry_DoNotUse*>(&_ImageManifest_Config_LabelsEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) PROTOBUF_FINAL;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class ImageManifest_Config : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:docker.spec.v1.ImageManifest.Config) */ {
 public:
  ImageManifest_Config();
  virtual ~ImageManifest_Config();

  ImageManifest_Config(const ImageManifest_Config& from);

  inline ImageManifest_Config& operator=(const ImageManifest_Config& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ImageManifest_Config(ImageManifest_Config&& from) noexcept
    : ImageManifest_Config() {
    *this = ::std::move(from);
  }

  inline ImageManifest_Config& operator=(ImageManifest_Config&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ImageManifest_Config& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ImageManifest_Config* internal_default_instance() {
    return reinterpret_cast<const ImageManifest_Config*>(
               &_ImageManifest_Config_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(ImageManifest_Config* other);
  friend void swap(ImageManifest_Config& a, ImageManifest_Config& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ImageManifest_Config* New() const PROTOBUF_FINAL { return New(NULL); }

  ImageManifest_Config* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ImageManifest_Config& from);
  void MergeFrom(const ImageManifest_Config& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ImageManifest_Config* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // repeated string Entrypoint = 2;
  int entrypoint_size() const;
  void clear_entrypoint();
  static const int kEntrypointFieldNumber = 2;
  const ::std::string& entrypoint(int index) const;
  ::std::string* mutable_entrypoint(int index);
  void set_entrypoint(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_entrypoint(int index, ::std::string&& value);
  #endif
  void set_entrypoint(int index, const char* value);
  void set_entrypoint(int index, const char* value, size_t size);
  ::std::string* add_entrypoint();
  void add_entrypoint(const ::std::string& value);
  #if LANG_CXX11
  void add_entrypoint(::std::string&& value);
  #endif
  void add_entrypoint(const char* value);
  void add_entrypoint(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& entrypoint() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_entrypoint();

  // repeated string Env = 3;
  int env_size() const;
  void clear_env();
  static const int kEnvFieldNumber = 3;
  const ::std::string& env(int index) const;
  ::std::string* mutable_env(int index);
  void set_env(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_env(int index, ::std::string&& value);
  #endif
  void set_env(int index, const char* value);
  void set_env(int index, const char* value, size_t size);
  ::std::string* add_env();
  void add_env(const ::std::string& value);
  #if LANG_CXX11
  void add_env(::std::string&& value);
  #endif
  void add_env(const char* value);
  void add_env(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& env() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_env();

  // repeated string Cmd = 5;
  int cmd_size() const;
  void clear_cmd();
  static const int kCmdFieldNumber = 5;
  const ::std::string& cmd(int index) const;
  ::std::string* mutable_cmd(int index);
  void set_cmd(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_cmd(int index, ::std::string&& value);
  #endif
  void set_cmd(int index, const char* value);
  void set_cmd(int index, const char* value, size_t size);
  ::std::string* add_cmd();
  void add_cmd(const ::std::string& value);
  #if LANG_CXX11
  void add_cmd(::std::string&& value);
  #endif
  void add_cmd(const char* value);
  void add_cmd(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& cmd() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_cmd();

  // map<string, string> Labels = 9;
  int labels_size() const;
  void clear_labels();
  static const int kLabelsFieldNumber = 9;
  const ::google::protobuf::Map< ::std::string, ::std::string >&
      labels() const;
  ::google::protobuf::Map< ::std::string, ::std::string >*
      mutable_labels();

  // optional string Hostname = 1;
  bool has_hostname() const;
  void clear_hostname();
  static const int kHostnameFieldNumber = 1;
  const ::std::string& hostname() const;
  void set_hostname(const ::std::string& value);
  #if LANG_CXX11
  void set_hostname(::std::string&& value);
  #endif
  void set_hostname(const char* value);
  void set_hostname(const char* value, size_t size);
  ::std::string* mutable_hostname();
  ::std::string* release_hostname();
  void set_allocated_hostname(::std::string* hostname);

  // optional string User = 4;
  bool has_user() const;
  void clear_user();
  static const int kUserFieldNumber = 4;
  const ::std::string& user() const;
  void set_user(const ::std::string& value);
  #if LANG_CXX11
  void set_user(::std::string&& value);
  #endif
  void set_user(const char* value);
  void set_user(const char* value, size_t size);
  ::std::string* mutable_user();
  ::std::string* release_user();
  void set_allocated_user(::std::string* user);

  // optional string WorkingDir = 6;
  bool has_workingdir() const;
  void clear_workingdir();
  static const int kWorkingDirFieldNumber = 6;
  const ::std::string& workingdir() const;
  void set_workingdir(const ::std::string& value);
  #if LANG_CXX11
  void set_workingdir(::std::string&& value);
  #endif
  void set_workingdir(const char* value);
  void set_workingdir(const char* value, size_t size);
  ::std::string* mutable_workingdir();
  ::std::string* release_workingdir();
  void set_allocated_workingdir(::std::string* workingdir);

  // optional string Image = 8;
  bool has_image() const;
  void clear_image();
  static const int kImageFieldNumber = 8;
  const ::std::string& image() const;
  void set_image(const ::std::string& value);
  #if LANG_CXX11
  void set_image(::std::string&& value);
  #endif
  void set_image(const char* value);
  void set_image(const char* value, size_t size);
  ::std::string* mutable_image();
  ::std::string* release_image();
  void set_allocated_image(::std::string* image);

  // @@protoc_insertion_point(class_scope:docker.spec.v1.ImageManifest.Config)
 private:
  void set_has_hostname();
  void clear_has_hostname();
  void set_has_user();
  void clear_has_user();
  void set_has_workingdir();
  void clear_has_workingdir();
  void set_has_image();
  void clear_has_image();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> entrypoint_;
  ::google::protobuf::RepeatedPtrField< ::std::string> env_;
  ::google::protobuf::RepeatedPtrField< ::std::string> cmd_;
  ::google::protobuf::internal::MapField<
      ImageManifest_Config_LabelsEntry_DoNotUse,
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      0 > labels_;
  ::google::protobuf::internal::ArenaStringPtr hostname_;
  ::google::protobuf::internal::ArenaStringPtr user_;
  ::google::protobuf::internal::ArenaStringPtr workingdir_;
  ::google::protobuf::internal::ArenaStringPtr image_;
  friend struct ::protobuf_mesos_2fdocker_2fv1_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fdocker_2fv1_2eproto::InitDefaultsImageManifest_ConfigImpl();
};
// -------------------------------------------------------------------

class ImageManifest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:docker.spec.v1.ImageManifest) */ {
 public:
  ImageManifest();
  virtual ~ImageManifest();

  ImageManifest(const ImageManifest& from);

  inline ImageManifest& operator=(const ImageManifest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ImageManifest(ImageManifest&& from) noexcept
    : ImageManifest() {
    *this = ::std::move(from);
  }

  inline ImageManifest& operator=(ImageManifest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ImageManifest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ImageManifest* internal_default_instance() {
    return reinterpret_cast<const ImageManifest*>(
               &_ImageManifest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(ImageManifest* other);
  friend void swap(ImageManifest& a, ImageManifest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ImageManifest* New() const PROTOBUF_FINAL { return New(NULL); }

  ImageManifest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ImageManifest& from);
  void MergeFrom(const ImageManifest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ImageManifest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef ImageManifest_Config Config;

  // accessors -------------------------------------------------------

  // optional string id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // optional string parent = 2;
  bool has_parent() const;
  void clear_parent();
  static const int kParentFieldNumber = 2;
  const ::std::string& parent() const;
  void set_parent(const ::std::string& value);
  #if LANG_CXX11
  void set_parent(::std::string&& value);
  #endif
  void set_parent(const char* value);
  void set_parent(const char* value, size_t size);
  ::std::string* mutable_parent();
  ::std::string* release_parent();
  void set_allocated_parent(::std::string* parent);

  // optional string comment = 3;
  bool has_comment() const;
  void clear_comment();
  static const int kCommentFieldNumber = 3;
  const ::std::string& comment() const;
  void set_comment(const ::std::string& value);
  #if LANG_CXX11
  void set_comment(::std::string&& value);
  #endif
  void set_comment(const char* value);
  void set_comment(const char* value, size_t size);
  ::std::string* mutable_comment();
  ::std::string* release_comment();
  void set_allocated_comment(::std::string* comment);

  // optional string created = 4;
  bool has_created() const;
  void clear_created();
  static const int kCreatedFieldNumber = 4;
  const ::std::string& created() const;
  void set_created(const ::std::string& value);
  #if LANG_CXX11
  void set_created(::std::string&& value);
  #endif
  void set_created(const char* value);
  void set_created(const char* value, size_t size);
  ::std::string* mutable_created();
  ::std::string* release_created();
  void set_allocated_created(::std::string* created);

  // optional string container = 5;
  bool has_container() const;
  void clear_container();
  static const int kContainerFieldNumber = 5;
  const ::std::string& container() const;
  void set_container(const ::std::string& value);
  #if LANG_CXX11
  void set_container(::std::string&& value);
  #endif
  void set_container(const char* value);
  void set_container(const char* value, size_t size);
  ::std::string* mutable_container();
  ::std::string* release_container();
  void set_allocated_container(::std::string* container);

  // optional string docker_version = 7;
  bool has_docker_version() const;
  void clear_docker_version();
  static const int kDockerVersionFieldNumber = 7;
  const ::std::string& docker_version() const;
  void set_docker_version(const ::std::string& value);
  #if LANG_CXX11
  void set_docker_version(::std::string&& value);
  #endif
  void set_docker_version(const char* value);
  void set_docker_version(const char* value, size_t size);
  ::std::string* mutable_docker_version();
  ::std::string* release_docker_version();
  void set_allocated_docker_version(::std::string* docker_version);

  // optional string author = 8;
  bool has_author() const;
  void clear_author();
  static const int kAuthorFieldNumber = 8;
  const ::std::string& author() const;
  void set_author(const ::std::string& value);
  #if LANG_CXX11
  void set_author(::std::string&& value);
  #endif
  void set_author(const char* value);
  void set_author(const char* value, size_t size);
  ::std::string* mutable_author();
  ::std::string* release_author();
  void set_allocated_author(::std::string* author);

  // optional string architecture = 10;
  bool has_architecture() const;
  void clear_architecture();
  static const int kArchitectureFieldNumber = 10;
  const ::std::string& architecture() const;
  void set_architecture(const ::std::string& value);
  #if LANG_CXX11
  void set_architecture(::std::string&& value);
  #endif
  void set_architecture(const char* value);
  void set_architecture(const char* value, size_t size);
  ::std::string* mutable_architecture();
  ::std::string* release_architecture();
  void set_allocated_architecture(::std::string* architecture);

  // optional string os = 11;
  bool has_os() const;
  void clear_os();
  static const int kOsFieldNumber = 11;
  const ::std::string& os() const;
  void set_os(const ::std::string& value);
  #if LANG_CXX11
  void set_os(::std::string&& value);
  #endif
  void set_os(const char* value);
  void set_os(const char* value, size_t size);
  ::std::string* mutable_os();
  ::std::string* release_os();
  void set_allocated_os(::std::string* os);

  // optional .docker.spec.v1.ImageManifest.Config container_config = 6;
  bool has_container_config() const;
  void clear_container_config();
  static const int kContainerConfigFieldNumber = 6;
  const ::docker::spec::v1::ImageManifest_Config& container_config() const;
  ::docker::spec::v1::ImageManifest_Config* release_container_config();
  ::docker::spec::v1::ImageManifest_Config* mutable_container_config();
  void set_allocated_container_config(::docker::spec::v1::ImageManifest_Config* container_config);

  // optional .docker.spec.v1.ImageManifest.Config config = 9;
  bool has_config() const;
  void clear_config();
  static const int kConfigFieldNumber = 9;
  const ::docker::spec::v1::ImageManifest_Config& config() const;
  ::docker::spec::v1::ImageManifest_Config* release_config();
  ::docker::spec::v1::ImageManifest_Config* mutable_config();
  void set_allocated_config(::docker::spec::v1::ImageManifest_Config* config);

  // optional uint32 Size = 12;
  bool has_size() const;
  void clear_size();
  static const int kSizeFieldNumber = 12;
  ::google::protobuf::uint32 size() const;
  void set_size(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:docker.spec.v1.ImageManifest)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_parent();
  void clear_has_parent();
  void set_has_comment();
  void clear_has_comment();
  void set_has_created();
  void clear_has_created();
  void set_has_container();
  void clear_has_container();
  void set_has_container_config();
  void clear_has_container_config();
  void set_has_docker_version();
  void clear_has_docker_version();
  void set_has_author();
  void clear_has_author();
  void set_has_config();
  void clear_has_config();
  void set_has_architecture();
  void clear_has_architecture();
  void set_has_os();
  void clear_has_os();
  void set_has_size();
  void clear_has_size();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr parent_;
  ::google::protobuf::internal::ArenaStringPtr comment_;
  ::google::protobuf::internal::ArenaStringPtr created_;
  ::google::protobuf::internal::ArenaStringPtr container_;
  ::google::protobuf::internal::ArenaStringPtr docker_version_;
  ::google::protobuf::internal::ArenaStringPtr author_;
  ::google::protobuf::internal::ArenaStringPtr architecture_;
  ::google::protobuf::internal::ArenaStringPtr os_;
  ::docker::spec::v1::ImageManifest_Config* container_config_;
  ::docker::spec::v1::ImageManifest_Config* config_;
  ::google::protobuf::uint32 size_;
  friend struct ::protobuf_mesos_2fdocker_2fv1_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fdocker_2fv1_2eproto::InitDefaultsImageManifestImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// ImageManifest_Config

// optional string Hostname = 1;
inline bool ImageManifest_Config::has_hostname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ImageManifest_Config::set_has_hostname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ImageManifest_Config::clear_has_hostname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ImageManifest_Config::clear_hostname() {
  hostname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_hostname();
}
inline const ::std::string& ImageManifest_Config::hostname() const {
  // @@protoc_insertion_point(field_get:docker.spec.v1.ImageManifest.Config.Hostname)
  return hostname_.GetNoArena();
}
inline void ImageManifest_Config::set_hostname(const ::std::string& value) {
  set_has_hostname();
  hostname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:docker.spec.v1.ImageManifest.Config.Hostname)
}
#if LANG_CXX11
inline void ImageManifest_Config::set_hostname(::std::string&& value) {
  set_has_hostname();
  hostname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:docker.spec.v1.ImageManifest.Config.Hostname)
}
#endif
inline void ImageManifest_Config::set_hostname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_hostname();
  hostname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:docker.spec.v1.ImageManifest.Config.Hostname)
}
inline void ImageManifest_Config::set_hostname(const char* value, size_t size) {
  set_has_hostname();
  hostname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:docker.spec.v1.ImageManifest.Config.Hostname)
}
inline ::std::string* ImageManifest_Config::mutable_hostname() {
  set_has_hostname();
  // @@protoc_insertion_point(field_mutable:docker.spec.v1.ImageManifest.Config.Hostname)
  return hostname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ImageManifest_Config::release_hostname() {
  // @@protoc_insertion_point(field_release:docker.spec.v1.ImageManifest.Config.Hostname)
  clear_has_hostname();
  return hostname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ImageManifest_Config::set_allocated_hostname(::std::string* hostname) {
  if (hostname != NULL) {
    set_has_hostname();
  } else {
    clear_has_hostname();
  }
  hostname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hostname);
  // @@protoc_insertion_point(field_set_allocated:docker.spec.v1.ImageManifest.Config.Hostname)
}

// repeated string Entrypoint = 2;
inline int ImageManifest_Config::entrypoint_size() const {
  return entrypoint_.size();
}
inline void ImageManifest_Config::clear_entrypoint() {
  entrypoint_.Clear();
}
inline const ::std::string& ImageManifest_Config::entrypoint(int index) const {
  // @@protoc_insertion_point(field_get:docker.spec.v1.ImageManifest.Config.Entrypoint)
  return entrypoint_.Get(index);
}
inline ::std::string* ImageManifest_Config::mutable_entrypoint(int index) {
  // @@protoc_insertion_point(field_mutable:docker.spec.v1.ImageManifest.Config.Entrypoint)
  return entrypoint_.Mutable(index);
}
inline void ImageManifest_Config::set_entrypoint(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:docker.spec.v1.ImageManifest.Config.Entrypoint)
  entrypoint_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void ImageManifest_Config::set_entrypoint(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:docker.spec.v1.ImageManifest.Config.Entrypoint)
  entrypoint_.Mutable(index)->assign(std::move(value));
}
#endif
inline void ImageManifest_Config::set_entrypoint(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  entrypoint_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:docker.spec.v1.ImageManifest.Config.Entrypoint)
}
inline void ImageManifest_Config::set_entrypoint(int index, const char* value, size_t size) {
  entrypoint_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:docker.spec.v1.ImageManifest.Config.Entrypoint)
}
inline ::std::string* ImageManifest_Config::add_entrypoint() {
  // @@protoc_insertion_point(field_add_mutable:docker.spec.v1.ImageManifest.Config.Entrypoint)
  return entrypoint_.Add();
}
inline void ImageManifest_Config::add_entrypoint(const ::std::string& value) {
  entrypoint_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:docker.spec.v1.ImageManifest.Config.Entrypoint)
}
#if LANG_CXX11
inline void ImageManifest_Config::add_entrypoint(::std::string&& value) {
  entrypoint_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:docker.spec.v1.ImageManifest.Config.Entrypoint)
}
#endif
inline void ImageManifest_Config::add_entrypoint(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  entrypoint_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:docker.spec.v1.ImageManifest.Config.Entrypoint)
}
inline void ImageManifest_Config::add_entrypoint(const char* value, size_t size) {
  entrypoint_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:docker.spec.v1.ImageManifest.Config.Entrypoint)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ImageManifest_Config::entrypoint() const {
  // @@protoc_insertion_point(field_list:docker.spec.v1.ImageManifest.Config.Entrypoint)
  return entrypoint_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ImageManifest_Config::mutable_entrypoint() {
  // @@protoc_insertion_point(field_mutable_list:docker.spec.v1.ImageManifest.Config.Entrypoint)
  return &entrypoint_;
}

// repeated string Env = 3;
inline int ImageManifest_Config::env_size() const {
  return env_.size();
}
inline void ImageManifest_Config::clear_env() {
  env_.Clear();
}
inline const ::std::string& ImageManifest_Config::env(int index) const {
  // @@protoc_insertion_point(field_get:docker.spec.v1.ImageManifest.Config.Env)
  return env_.Get(index);
}
inline ::std::string* ImageManifest_Config::mutable_env(int index) {
  // @@protoc_insertion_point(field_mutable:docker.spec.v1.ImageManifest.Config.Env)
  return env_.Mutable(index);
}
inline void ImageManifest_Config::set_env(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:docker.spec.v1.ImageManifest.Config.Env)
  env_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void ImageManifest_Config::set_env(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:docker.spec.v1.ImageManifest.Config.Env)
  env_.Mutable(index)->assign(std::move(value));
}
#endif
inline void ImageManifest_Config::set_env(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  env_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:docker.spec.v1.ImageManifest.Config.Env)
}
inline void ImageManifest_Config::set_env(int index, const char* value, size_t size) {
  env_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:docker.spec.v1.ImageManifest.Config.Env)
}
inline ::std::string* ImageManifest_Config::add_env() {
  // @@protoc_insertion_point(field_add_mutable:docker.spec.v1.ImageManifest.Config.Env)
  return env_.Add();
}
inline void ImageManifest_Config::add_env(const ::std::string& value) {
  env_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:docker.spec.v1.ImageManifest.Config.Env)
}
#if LANG_CXX11
inline void ImageManifest_Config::add_env(::std::string&& value) {
  env_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:docker.spec.v1.ImageManifest.Config.Env)
}
#endif
inline void ImageManifest_Config::add_env(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  env_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:docker.spec.v1.ImageManifest.Config.Env)
}
inline void ImageManifest_Config::add_env(const char* value, size_t size) {
  env_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:docker.spec.v1.ImageManifest.Config.Env)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ImageManifest_Config::env() const {
  // @@protoc_insertion_point(field_list:docker.spec.v1.ImageManifest.Config.Env)
  return env_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ImageManifest_Config::mutable_env() {
  // @@protoc_insertion_point(field_mutable_list:docker.spec.v1.ImageManifest.Config.Env)
  return &env_;
}

// optional string User = 4;
inline bool ImageManifest_Config::has_user() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ImageManifest_Config::set_has_user() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ImageManifest_Config::clear_has_user() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ImageManifest_Config::clear_user() {
  user_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_user();
}
inline const ::std::string& ImageManifest_Config::user() const {
  // @@protoc_insertion_point(field_get:docker.spec.v1.ImageManifest.Config.User)
  return user_.GetNoArena();
}
inline void ImageManifest_Config::set_user(const ::std::string& value) {
  set_has_user();
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:docker.spec.v1.ImageManifest.Config.User)
}
#if LANG_CXX11
inline void ImageManifest_Config::set_user(::std::string&& value) {
  set_has_user();
  user_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:docker.spec.v1.ImageManifest.Config.User)
}
#endif
inline void ImageManifest_Config::set_user(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_user();
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:docker.spec.v1.ImageManifest.Config.User)
}
inline void ImageManifest_Config::set_user(const char* value, size_t size) {
  set_has_user();
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:docker.spec.v1.ImageManifest.Config.User)
}
inline ::std::string* ImageManifest_Config::mutable_user() {
  set_has_user();
  // @@protoc_insertion_point(field_mutable:docker.spec.v1.ImageManifest.Config.User)
  return user_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ImageManifest_Config::release_user() {
  // @@protoc_insertion_point(field_release:docker.spec.v1.ImageManifest.Config.User)
  clear_has_user();
  return user_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ImageManifest_Config::set_allocated_user(::std::string* user) {
  if (user != NULL) {
    set_has_user();
  } else {
    clear_has_user();
  }
  user_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user);
  // @@protoc_insertion_point(field_set_allocated:docker.spec.v1.ImageManifest.Config.User)
}

// repeated string Cmd = 5;
inline int ImageManifest_Config::cmd_size() const {
  return cmd_.size();
}
inline void ImageManifest_Config::clear_cmd() {
  cmd_.Clear();
}
inline const ::std::string& ImageManifest_Config::cmd(int index) const {
  // @@protoc_insertion_point(field_get:docker.spec.v1.ImageManifest.Config.Cmd)
  return cmd_.Get(index);
}
inline ::std::string* ImageManifest_Config::mutable_cmd(int index) {
  // @@protoc_insertion_point(field_mutable:docker.spec.v1.ImageManifest.Config.Cmd)
  return cmd_.Mutable(index);
}
inline void ImageManifest_Config::set_cmd(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:docker.spec.v1.ImageManifest.Config.Cmd)
  cmd_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void ImageManifest_Config::set_cmd(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:docker.spec.v1.ImageManifest.Config.Cmd)
  cmd_.Mutable(index)->assign(std::move(value));
}
#endif
inline void ImageManifest_Config::set_cmd(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  cmd_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:docker.spec.v1.ImageManifest.Config.Cmd)
}
inline void ImageManifest_Config::set_cmd(int index, const char* value, size_t size) {
  cmd_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:docker.spec.v1.ImageManifest.Config.Cmd)
}
inline ::std::string* ImageManifest_Config::add_cmd() {
  // @@protoc_insertion_point(field_add_mutable:docker.spec.v1.ImageManifest.Config.Cmd)
  return cmd_.Add();
}
inline void ImageManifest_Config::add_cmd(const ::std::string& value) {
  cmd_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:docker.spec.v1.ImageManifest.Config.Cmd)
}
#if LANG_CXX11
inline void ImageManifest_Config::add_cmd(::std::string&& value) {
  cmd_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:docker.spec.v1.ImageManifest.Config.Cmd)
}
#endif
inline void ImageManifest_Config::add_cmd(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  cmd_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:docker.spec.v1.ImageManifest.Config.Cmd)
}
inline void ImageManifest_Config::add_cmd(const char* value, size_t size) {
  cmd_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:docker.spec.v1.ImageManifest.Config.Cmd)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ImageManifest_Config::cmd() const {
  // @@protoc_insertion_point(field_list:docker.spec.v1.ImageManifest.Config.Cmd)
  return cmd_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ImageManifest_Config::mutable_cmd() {
  // @@protoc_insertion_point(field_mutable_list:docker.spec.v1.ImageManifest.Config.Cmd)
  return &cmd_;
}

// optional string WorkingDir = 6;
inline bool ImageManifest_Config::has_workingdir() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ImageManifest_Config::set_has_workingdir() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ImageManifest_Config::clear_has_workingdir() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ImageManifest_Config::clear_workingdir() {
  workingdir_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_workingdir();
}
inline const ::std::string& ImageManifest_Config::workingdir() const {
  // @@protoc_insertion_point(field_get:docker.spec.v1.ImageManifest.Config.WorkingDir)
  return workingdir_.GetNoArena();
}
inline void ImageManifest_Config::set_workingdir(const ::std::string& value) {
  set_has_workingdir();
  workingdir_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:docker.spec.v1.ImageManifest.Config.WorkingDir)
}
#if LANG_CXX11
inline void ImageManifest_Config::set_workingdir(::std::string&& value) {
  set_has_workingdir();
  workingdir_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:docker.spec.v1.ImageManifest.Config.WorkingDir)
}
#endif
inline void ImageManifest_Config::set_workingdir(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_workingdir();
  workingdir_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:docker.spec.v1.ImageManifest.Config.WorkingDir)
}
inline void ImageManifest_Config::set_workingdir(const char* value, size_t size) {
  set_has_workingdir();
  workingdir_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:docker.spec.v1.ImageManifest.Config.WorkingDir)
}
inline ::std::string* ImageManifest_Config::mutable_workingdir() {
  set_has_workingdir();
  // @@protoc_insertion_point(field_mutable:docker.spec.v1.ImageManifest.Config.WorkingDir)
  return workingdir_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ImageManifest_Config::release_workingdir() {
  // @@protoc_insertion_point(field_release:docker.spec.v1.ImageManifest.Config.WorkingDir)
  clear_has_workingdir();
  return workingdir_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ImageManifest_Config::set_allocated_workingdir(::std::string* workingdir) {
  if (workingdir != NULL) {
    set_has_workingdir();
  } else {
    clear_has_workingdir();
  }
  workingdir_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), workingdir);
  // @@protoc_insertion_point(field_set_allocated:docker.spec.v1.ImageManifest.Config.WorkingDir)
}

// optional string Image = 8;
inline bool ImageManifest_Config::has_image() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ImageManifest_Config::set_has_image() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ImageManifest_Config::clear_has_image() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ImageManifest_Config::clear_image() {
  image_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_image();
}
inline const ::std::string& ImageManifest_Config::image() const {
  // @@protoc_insertion_point(field_get:docker.spec.v1.ImageManifest.Config.Image)
  return image_.GetNoArena();
}
inline void ImageManifest_Config::set_image(const ::std::string& value) {
  set_has_image();
  image_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:docker.spec.v1.ImageManifest.Config.Image)
}
#if LANG_CXX11
inline void ImageManifest_Config::set_image(::std::string&& value) {
  set_has_image();
  image_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:docker.spec.v1.ImageManifest.Config.Image)
}
#endif
inline void ImageManifest_Config::set_image(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_image();
  image_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:docker.spec.v1.ImageManifest.Config.Image)
}
inline void ImageManifest_Config::set_image(const char* value, size_t size) {
  set_has_image();
  image_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:docker.spec.v1.ImageManifest.Config.Image)
}
inline ::std::string* ImageManifest_Config::mutable_image() {
  set_has_image();
  // @@protoc_insertion_point(field_mutable:docker.spec.v1.ImageManifest.Config.Image)
  return image_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ImageManifest_Config::release_image() {
  // @@protoc_insertion_point(field_release:docker.spec.v1.ImageManifest.Config.Image)
  clear_has_image();
  return image_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ImageManifest_Config::set_allocated_image(::std::string* image) {
  if (image != NULL) {
    set_has_image();
  } else {
    clear_has_image();
  }
  image_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), image);
  // @@protoc_insertion_point(field_set_allocated:docker.spec.v1.ImageManifest.Config.Image)
}

// map<string, string> Labels = 9;
inline int ImageManifest_Config::labels_size() const {
  return labels_.size();
}
inline void ImageManifest_Config::clear_labels() {
  labels_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::std::string >&
ImageManifest_Config::labels() const {
  // @@protoc_insertion_point(field_map:docker.spec.v1.ImageManifest.Config.Labels)
  return labels_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::std::string >*
ImageManifest_Config::mutable_labels() {
  // @@protoc_insertion_point(field_mutable_map:docker.spec.v1.ImageManifest.Config.Labels)
  return labels_.MutableMap();
}

// -------------------------------------------------------------------

// ImageManifest

// optional string id = 1;
inline bool ImageManifest::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ImageManifest::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ImageManifest::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ImageManifest::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& ImageManifest::id() const {
  // @@protoc_insertion_point(field_get:docker.spec.v1.ImageManifest.id)
  return id_.GetNoArena();
}
inline void ImageManifest::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:docker.spec.v1.ImageManifest.id)
}
#if LANG_CXX11
inline void ImageManifest::set_id(::std::string&& value) {
  set_has_id();
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:docker.spec.v1.ImageManifest.id)
}
#endif
inline void ImageManifest::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:docker.spec.v1.ImageManifest.id)
}
inline void ImageManifest::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:docker.spec.v1.ImageManifest.id)
}
inline ::std::string* ImageManifest::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:docker.spec.v1.ImageManifest.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ImageManifest::release_id() {
  // @@protoc_insertion_point(field_release:docker.spec.v1.ImageManifest.id)
  clear_has_id();
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ImageManifest::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:docker.spec.v1.ImageManifest.id)
}

// optional string parent = 2;
inline bool ImageManifest::has_parent() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ImageManifest::set_has_parent() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ImageManifest::clear_has_parent() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ImageManifest::clear_parent() {
  parent_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_parent();
}
inline const ::std::string& ImageManifest::parent() const {
  // @@protoc_insertion_point(field_get:docker.spec.v1.ImageManifest.parent)
  return parent_.GetNoArena();
}
inline void ImageManifest::set_parent(const ::std::string& value) {
  set_has_parent();
  parent_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:docker.spec.v1.ImageManifest.parent)
}
#if LANG_CXX11
inline void ImageManifest::set_parent(::std::string&& value) {
  set_has_parent();
  parent_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:docker.spec.v1.ImageManifest.parent)
}
#endif
inline void ImageManifest::set_parent(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_parent();
  parent_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:docker.spec.v1.ImageManifest.parent)
}
inline void ImageManifest::set_parent(const char* value, size_t size) {
  set_has_parent();
  parent_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:docker.spec.v1.ImageManifest.parent)
}
inline ::std::string* ImageManifest::mutable_parent() {
  set_has_parent();
  // @@protoc_insertion_point(field_mutable:docker.spec.v1.ImageManifest.parent)
  return parent_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ImageManifest::release_parent() {
  // @@protoc_insertion_point(field_release:docker.spec.v1.ImageManifest.parent)
  clear_has_parent();
  return parent_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ImageManifest::set_allocated_parent(::std::string* parent) {
  if (parent != NULL) {
    set_has_parent();
  } else {
    clear_has_parent();
  }
  parent_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), parent);
  // @@protoc_insertion_point(field_set_allocated:docker.spec.v1.ImageManifest.parent)
}

// optional string comment = 3;
inline bool ImageManifest::has_comment() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ImageManifest::set_has_comment() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ImageManifest::clear_has_comment() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ImageManifest::clear_comment() {
  comment_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_comment();
}
inline const ::std::string& ImageManifest::comment() const {
  // @@protoc_insertion_point(field_get:docker.spec.v1.ImageManifest.comment)
  return comment_.GetNoArena();
}
inline void ImageManifest::set_comment(const ::std::string& value) {
  set_has_comment();
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:docker.spec.v1.ImageManifest.comment)
}
#if LANG_CXX11
inline void ImageManifest::set_comment(::std::string&& value) {
  set_has_comment();
  comment_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:docker.spec.v1.ImageManifest.comment)
}
#endif
inline void ImageManifest::set_comment(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_comment();
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:docker.spec.v1.ImageManifest.comment)
}
inline void ImageManifest::set_comment(const char* value, size_t size) {
  set_has_comment();
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:docker.spec.v1.ImageManifest.comment)
}
inline ::std::string* ImageManifest::mutable_comment() {
  set_has_comment();
  // @@protoc_insertion_point(field_mutable:docker.spec.v1.ImageManifest.comment)
  return comment_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ImageManifest::release_comment() {
  // @@protoc_insertion_point(field_release:docker.spec.v1.ImageManifest.comment)
  clear_has_comment();
  return comment_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ImageManifest::set_allocated_comment(::std::string* comment) {
  if (comment != NULL) {
    set_has_comment();
  } else {
    clear_has_comment();
  }
  comment_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), comment);
  // @@protoc_insertion_point(field_set_allocated:docker.spec.v1.ImageManifest.comment)
}

// optional string created = 4;
inline bool ImageManifest::has_created() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ImageManifest::set_has_created() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ImageManifest::clear_has_created() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ImageManifest::clear_created() {
  created_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_created();
}
inline const ::std::string& ImageManifest::created() const {
  // @@protoc_insertion_point(field_get:docker.spec.v1.ImageManifest.created)
  return created_.GetNoArena();
}
inline void ImageManifest::set_created(const ::std::string& value) {
  set_has_created();
  created_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:docker.spec.v1.ImageManifest.created)
}
#if LANG_CXX11
inline void ImageManifest::set_created(::std::string&& value) {
  set_has_created();
  created_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:docker.spec.v1.ImageManifest.created)
}
#endif
inline void ImageManifest::set_created(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_created();
  created_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:docker.spec.v1.ImageManifest.created)
}
inline void ImageManifest::set_created(const char* value, size_t size) {
  set_has_created();
  created_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:docker.spec.v1.ImageManifest.created)
}
inline ::std::string* ImageManifest::mutable_created() {
  set_has_created();
  // @@protoc_insertion_point(field_mutable:docker.spec.v1.ImageManifest.created)
  return created_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ImageManifest::release_created() {
  // @@protoc_insertion_point(field_release:docker.spec.v1.ImageManifest.created)
  clear_has_created();
  return created_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ImageManifest::set_allocated_created(::std::string* created) {
  if (created != NULL) {
    set_has_created();
  } else {
    clear_has_created();
  }
  created_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), created);
  // @@protoc_insertion_point(field_set_allocated:docker.spec.v1.ImageManifest.created)
}

// optional string container = 5;
inline bool ImageManifest::has_container() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ImageManifest::set_has_container() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ImageManifest::clear_has_container() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ImageManifest::clear_container() {
  container_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_container();
}
inline const ::std::string& ImageManifest::container() const {
  // @@protoc_insertion_point(field_get:docker.spec.v1.ImageManifest.container)
  return container_.GetNoArena();
}
inline void ImageManifest::set_container(const ::std::string& value) {
  set_has_container();
  container_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:docker.spec.v1.ImageManifest.container)
}
#if LANG_CXX11
inline void ImageManifest::set_container(::std::string&& value) {
  set_has_container();
  container_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:docker.spec.v1.ImageManifest.container)
}
#endif
inline void ImageManifest::set_container(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_container();
  container_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:docker.spec.v1.ImageManifest.container)
}
inline void ImageManifest::set_container(const char* value, size_t size) {
  set_has_container();
  container_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:docker.spec.v1.ImageManifest.container)
}
inline ::std::string* ImageManifest::mutable_container() {
  set_has_container();
  // @@protoc_insertion_point(field_mutable:docker.spec.v1.ImageManifest.container)
  return container_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ImageManifest::release_container() {
  // @@protoc_insertion_point(field_release:docker.spec.v1.ImageManifest.container)
  clear_has_container();
  return container_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ImageManifest::set_allocated_container(::std::string* container) {
  if (container != NULL) {
    set_has_container();
  } else {
    clear_has_container();
  }
  container_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), container);
  // @@protoc_insertion_point(field_set_allocated:docker.spec.v1.ImageManifest.container)
}

// optional .docker.spec.v1.ImageManifest.Config container_config = 6;
inline bool ImageManifest::has_container_config() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ImageManifest::set_has_container_config() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ImageManifest::clear_has_container_config() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ImageManifest::clear_container_config() {
  if (container_config_ != NULL) container_config_->Clear();
  clear_has_container_config();
}
inline const ::docker::spec::v1::ImageManifest_Config& ImageManifest::container_config() const {
  const ::docker::spec::v1::ImageManifest_Config* p = container_config_;
  // @@protoc_insertion_point(field_get:docker.spec.v1.ImageManifest.container_config)
  return p != NULL ? *p : *reinterpret_cast<const ::docker::spec::v1::ImageManifest_Config*>(
      &::docker::spec::v1::_ImageManifest_Config_default_instance_);
}
inline ::docker::spec::v1::ImageManifest_Config* ImageManifest::release_container_config() {
  // @@protoc_insertion_point(field_release:docker.spec.v1.ImageManifest.container_config)
  clear_has_container_config();
  ::docker::spec::v1::ImageManifest_Config* temp = container_config_;
  container_config_ = NULL;
  return temp;
}
inline ::docker::spec::v1::ImageManifest_Config* ImageManifest::mutable_container_config() {
  set_has_container_config();
  if (container_config_ == NULL) {
    container_config_ = new ::docker::spec::v1::ImageManifest_Config;
  }
  // @@protoc_insertion_point(field_mutable:docker.spec.v1.ImageManifest.container_config)
  return container_config_;
}
inline void ImageManifest::set_allocated_container_config(::docker::spec::v1::ImageManifest_Config* container_config) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete container_config_;
  }
  if (container_config) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      container_config = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, container_config, submessage_arena);
    }
    set_has_container_config();
  } else {
    clear_has_container_config();
  }
  container_config_ = container_config;
  // @@protoc_insertion_point(field_set_allocated:docker.spec.v1.ImageManifest.container_config)
}

// optional string docker_version = 7;
inline bool ImageManifest::has_docker_version() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ImageManifest::set_has_docker_version() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ImageManifest::clear_has_docker_version() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ImageManifest::clear_docker_version() {
  docker_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_docker_version();
}
inline const ::std::string& ImageManifest::docker_version() const {
  // @@protoc_insertion_point(field_get:docker.spec.v1.ImageManifest.docker_version)
  return docker_version_.GetNoArena();
}
inline void ImageManifest::set_docker_version(const ::std::string& value) {
  set_has_docker_version();
  docker_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:docker.spec.v1.ImageManifest.docker_version)
}
#if LANG_CXX11
inline void ImageManifest::set_docker_version(::std::string&& value) {
  set_has_docker_version();
  docker_version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:docker.spec.v1.ImageManifest.docker_version)
}
#endif
inline void ImageManifest::set_docker_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_docker_version();
  docker_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:docker.spec.v1.ImageManifest.docker_version)
}
inline void ImageManifest::set_docker_version(const char* value, size_t size) {
  set_has_docker_version();
  docker_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:docker.spec.v1.ImageManifest.docker_version)
}
inline ::std::string* ImageManifest::mutable_docker_version() {
  set_has_docker_version();
  // @@protoc_insertion_point(field_mutable:docker.spec.v1.ImageManifest.docker_version)
  return docker_version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ImageManifest::release_docker_version() {
  // @@protoc_insertion_point(field_release:docker.spec.v1.ImageManifest.docker_version)
  clear_has_docker_version();
  return docker_version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ImageManifest::set_allocated_docker_version(::std::string* docker_version) {
  if (docker_version != NULL) {
    set_has_docker_version();
  } else {
    clear_has_docker_version();
  }
  docker_version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), docker_version);
  // @@protoc_insertion_point(field_set_allocated:docker.spec.v1.ImageManifest.docker_version)
}

// optional string author = 8;
inline bool ImageManifest::has_author() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ImageManifest::set_has_author() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ImageManifest::clear_has_author() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ImageManifest::clear_author() {
  author_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_author();
}
inline const ::std::string& ImageManifest::author() const {
  // @@protoc_insertion_point(field_get:docker.spec.v1.ImageManifest.author)
  return author_.GetNoArena();
}
inline void ImageManifest::set_author(const ::std::string& value) {
  set_has_author();
  author_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:docker.spec.v1.ImageManifest.author)
}
#if LANG_CXX11
inline void ImageManifest::set_author(::std::string&& value) {
  set_has_author();
  author_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:docker.spec.v1.ImageManifest.author)
}
#endif
inline void ImageManifest::set_author(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_author();
  author_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:docker.spec.v1.ImageManifest.author)
}
inline void ImageManifest::set_author(const char* value, size_t size) {
  set_has_author();
  author_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:docker.spec.v1.ImageManifest.author)
}
inline ::std::string* ImageManifest::mutable_author() {
  set_has_author();
  // @@protoc_insertion_point(field_mutable:docker.spec.v1.ImageManifest.author)
  return author_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ImageManifest::release_author() {
  // @@protoc_insertion_point(field_release:docker.spec.v1.ImageManifest.author)
  clear_has_author();
  return author_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ImageManifest::set_allocated_author(::std::string* author) {
  if (author != NULL) {
    set_has_author();
  } else {
    clear_has_author();
  }
  author_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), author);
  // @@protoc_insertion_point(field_set_allocated:docker.spec.v1.ImageManifest.author)
}

// optional .docker.spec.v1.ImageManifest.Config config = 9;
inline bool ImageManifest::has_config() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ImageManifest::set_has_config() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ImageManifest::clear_has_config() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ImageManifest::clear_config() {
  if (config_ != NULL) config_->Clear();
  clear_has_config();
}
inline const ::docker::spec::v1::ImageManifest_Config& ImageManifest::config() const {
  const ::docker::spec::v1::ImageManifest_Config* p = config_;
  // @@protoc_insertion_point(field_get:docker.spec.v1.ImageManifest.config)
  return p != NULL ? *p : *reinterpret_cast<const ::docker::spec::v1::ImageManifest_Config*>(
      &::docker::spec::v1::_ImageManifest_Config_default_instance_);
}
inline ::docker::spec::v1::ImageManifest_Config* ImageManifest::release_config() {
  // @@protoc_insertion_point(field_release:docker.spec.v1.ImageManifest.config)
  clear_has_config();
  ::docker::spec::v1::ImageManifest_Config* temp = config_;
  config_ = NULL;
  return temp;
}
inline ::docker::spec::v1::ImageManifest_Config* ImageManifest::mutable_config() {
  set_has_config();
  if (config_ == NULL) {
    config_ = new ::docker::spec::v1::ImageManifest_Config;
  }
  // @@protoc_insertion_point(field_mutable:docker.spec.v1.ImageManifest.config)
  return config_;
}
inline void ImageManifest::set_allocated_config(::docker::spec::v1::ImageManifest_Config* config) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete config_;
  }
  if (config) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      config = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, config, submessage_arena);
    }
    set_has_config();
  } else {
    clear_has_config();
  }
  config_ = config;
  // @@protoc_insertion_point(field_set_allocated:docker.spec.v1.ImageManifest.config)
}

// optional string architecture = 10;
inline bool ImageManifest::has_architecture() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ImageManifest::set_has_architecture() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ImageManifest::clear_has_architecture() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ImageManifest::clear_architecture() {
  architecture_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_architecture();
}
inline const ::std::string& ImageManifest::architecture() const {
  // @@protoc_insertion_point(field_get:docker.spec.v1.ImageManifest.architecture)
  return architecture_.GetNoArena();
}
inline void ImageManifest::set_architecture(const ::std::string& value) {
  set_has_architecture();
  architecture_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:docker.spec.v1.ImageManifest.architecture)
}
#if LANG_CXX11
inline void ImageManifest::set_architecture(::std::string&& value) {
  set_has_architecture();
  architecture_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:docker.spec.v1.ImageManifest.architecture)
}
#endif
inline void ImageManifest::set_architecture(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_architecture();
  architecture_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:docker.spec.v1.ImageManifest.architecture)
}
inline void ImageManifest::set_architecture(const char* value, size_t size) {
  set_has_architecture();
  architecture_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:docker.spec.v1.ImageManifest.architecture)
}
inline ::std::string* ImageManifest::mutable_architecture() {
  set_has_architecture();
  // @@protoc_insertion_point(field_mutable:docker.spec.v1.ImageManifest.architecture)
  return architecture_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ImageManifest::release_architecture() {
  // @@protoc_insertion_point(field_release:docker.spec.v1.ImageManifest.architecture)
  clear_has_architecture();
  return architecture_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ImageManifest::set_allocated_architecture(::std::string* architecture) {
  if (architecture != NULL) {
    set_has_architecture();
  } else {
    clear_has_architecture();
  }
  architecture_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), architecture);
  // @@protoc_insertion_point(field_set_allocated:docker.spec.v1.ImageManifest.architecture)
}

// optional string os = 11;
inline bool ImageManifest::has_os() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ImageManifest::set_has_os() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ImageManifest::clear_has_os() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ImageManifest::clear_os() {
  os_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_os();
}
inline const ::std::string& ImageManifest::os() const {
  // @@protoc_insertion_point(field_get:docker.spec.v1.ImageManifest.os)
  return os_.GetNoArena();
}
inline void ImageManifest::set_os(const ::std::string& value) {
  set_has_os();
  os_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:docker.spec.v1.ImageManifest.os)
}
#if LANG_CXX11
inline void ImageManifest::set_os(::std::string&& value) {
  set_has_os();
  os_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:docker.spec.v1.ImageManifest.os)
}
#endif
inline void ImageManifest::set_os(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_os();
  os_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:docker.spec.v1.ImageManifest.os)
}
inline void ImageManifest::set_os(const char* value, size_t size) {
  set_has_os();
  os_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:docker.spec.v1.ImageManifest.os)
}
inline ::std::string* ImageManifest::mutable_os() {
  set_has_os();
  // @@protoc_insertion_point(field_mutable:docker.spec.v1.ImageManifest.os)
  return os_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ImageManifest::release_os() {
  // @@protoc_insertion_point(field_release:docker.spec.v1.ImageManifest.os)
  clear_has_os();
  return os_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ImageManifest::set_allocated_os(::std::string* os) {
  if (os != NULL) {
    set_has_os();
  } else {
    clear_has_os();
  }
  os_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), os);
  // @@protoc_insertion_point(field_set_allocated:docker.spec.v1.ImageManifest.os)
}

// optional uint32 Size = 12;
inline bool ImageManifest::has_size() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ImageManifest::set_has_size() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ImageManifest::clear_has_size() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ImageManifest::clear_size() {
  size_ = 0u;
  clear_has_size();
}
inline ::google::protobuf::uint32 ImageManifest::size() const {
  // @@protoc_insertion_point(field_get:docker.spec.v1.ImageManifest.Size)
  return size_;
}
inline void ImageManifest::set_size(::google::protobuf::uint32 value) {
  set_has_size();
  size_ = value;
  // @@protoc_insertion_point(field_set:docker.spec.v1.ImageManifest.Size)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace spec
}  // namespace docker

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_mesos_2fdocker_2fv1_2eproto__INCLUDED
