// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mesos/docker/v2.proto

#ifndef PROTOBUF_mesos_2fdocker_2fv2_2eproto__INCLUDED
#define PROTOBUF_mesos_2fdocker_2fv2_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "mesos/docker/v1.pb.h"
// @@protoc_insertion_point(includes)

namespace protobuf_mesos_2fdocker_2fv2_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[6];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsImageManifest_FsLayerImpl();
void InitDefaultsImageManifest_FsLayer();
void InitDefaultsImageManifest_HistoryImpl();
void InitDefaultsImageManifest_History();
void InitDefaultsImageManifest_Signature_Header_JwkImpl();
void InitDefaultsImageManifest_Signature_Header_Jwk();
void InitDefaultsImageManifest_Signature_HeaderImpl();
void InitDefaultsImageManifest_Signature_Header();
void InitDefaultsImageManifest_SignatureImpl();
void InitDefaultsImageManifest_Signature();
void InitDefaultsImageManifestImpl();
void InitDefaultsImageManifest();
inline void InitDefaults() {
  InitDefaultsImageManifest_FsLayer();
  InitDefaultsImageManifest_History();
  InitDefaultsImageManifest_Signature_Header_Jwk();
  InitDefaultsImageManifest_Signature_Header();
  InitDefaultsImageManifest_Signature();
  InitDefaultsImageManifest();
}
}  // namespace protobuf_mesos_2fdocker_2fv2_2eproto
namespace docker {
namespace spec {
namespace v2 {
class ImageManifest;
class ImageManifestDefaultTypeInternal;
extern ImageManifestDefaultTypeInternal _ImageManifest_default_instance_;
class ImageManifest_FsLayer;
class ImageManifest_FsLayerDefaultTypeInternal;
extern ImageManifest_FsLayerDefaultTypeInternal _ImageManifest_FsLayer_default_instance_;
class ImageManifest_History;
class ImageManifest_HistoryDefaultTypeInternal;
extern ImageManifest_HistoryDefaultTypeInternal _ImageManifest_History_default_instance_;
class ImageManifest_Signature;
class ImageManifest_SignatureDefaultTypeInternal;
extern ImageManifest_SignatureDefaultTypeInternal _ImageManifest_Signature_default_instance_;
class ImageManifest_Signature_Header;
class ImageManifest_Signature_HeaderDefaultTypeInternal;
extern ImageManifest_Signature_HeaderDefaultTypeInternal _ImageManifest_Signature_Header_default_instance_;
class ImageManifest_Signature_Header_Jwk;
class ImageManifest_Signature_Header_JwkDefaultTypeInternal;
extern ImageManifest_Signature_Header_JwkDefaultTypeInternal _ImageManifest_Signature_Header_Jwk_default_instance_;
}  // namespace v2
}  // namespace spec
}  // namespace docker
namespace docker {
namespace spec {
namespace v2 {

// ===================================================================

class ImageManifest_FsLayer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:docker.spec.v2.ImageManifest.FsLayer) */ {
 public:
  ImageManifest_FsLayer();
  virtual ~ImageManifest_FsLayer();

  ImageManifest_FsLayer(const ImageManifest_FsLayer& from);

  inline ImageManifest_FsLayer& operator=(const ImageManifest_FsLayer& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ImageManifest_FsLayer(ImageManifest_FsLayer&& from) noexcept
    : ImageManifest_FsLayer() {
    *this = ::std::move(from);
  }

  inline ImageManifest_FsLayer& operator=(ImageManifest_FsLayer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ImageManifest_FsLayer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ImageManifest_FsLayer* internal_default_instance() {
    return reinterpret_cast<const ImageManifest_FsLayer*>(
               &_ImageManifest_FsLayer_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(ImageManifest_FsLayer* other);
  friend void swap(ImageManifest_FsLayer& a, ImageManifest_FsLayer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ImageManifest_FsLayer* New() const PROTOBUF_FINAL { return New(NULL); }

  ImageManifest_FsLayer* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ImageManifest_FsLayer& from);
  void MergeFrom(const ImageManifest_FsLayer& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ImageManifest_FsLayer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string blobSum = 1;
  bool has_blobsum() const;
  void clear_blobsum();
  static const int kBlobSumFieldNumber = 1;
  const ::std::string& blobsum() const;
  void set_blobsum(const ::std::string& value);
  #if LANG_CXX11
  void set_blobsum(::std::string&& value);
  #endif
  void set_blobsum(const char* value);
  void set_blobsum(const char* value, size_t size);
  ::std::string* mutable_blobsum();
  ::std::string* release_blobsum();
  void set_allocated_blobsum(::std::string* blobsum);

  // @@protoc_insertion_point(class_scope:docker.spec.v2.ImageManifest.FsLayer)
 private:
  void set_has_blobsum();
  void clear_has_blobsum();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr blobsum_;
  friend struct ::protobuf_mesos_2fdocker_2fv2_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fdocker_2fv2_2eproto::InitDefaultsImageManifest_FsLayerImpl();
};
// -------------------------------------------------------------------

class ImageManifest_History : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:docker.spec.v2.ImageManifest.History) */ {
 public:
  ImageManifest_History();
  virtual ~ImageManifest_History();

  ImageManifest_History(const ImageManifest_History& from);

  inline ImageManifest_History& operator=(const ImageManifest_History& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ImageManifest_History(ImageManifest_History&& from) noexcept
    : ImageManifest_History() {
    *this = ::std::move(from);
  }

  inline ImageManifest_History& operator=(ImageManifest_History&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ImageManifest_History& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ImageManifest_History* internal_default_instance() {
    return reinterpret_cast<const ImageManifest_History*>(
               &_ImageManifest_History_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(ImageManifest_History* other);
  friend void swap(ImageManifest_History& a, ImageManifest_History& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ImageManifest_History* New() const PROTOBUF_FINAL { return New(NULL); }

  ImageManifest_History* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ImageManifest_History& from);
  void MergeFrom(const ImageManifest_History& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ImageManifest_History* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string v1Compatibility = 1;
  bool has_v1compatibility() const;
  void clear_v1compatibility();
  static const int kV1CompatibilityFieldNumber = 1;
  const ::std::string& v1compatibility() const;
  void set_v1compatibility(const ::std::string& value);
  #if LANG_CXX11
  void set_v1compatibility(::std::string&& value);
  #endif
  void set_v1compatibility(const char* value);
  void set_v1compatibility(const char* value, size_t size);
  ::std::string* mutable_v1compatibility();
  ::std::string* release_v1compatibility();
  void set_allocated_v1compatibility(::std::string* v1compatibility);

  // optional .docker.spec.v1.ImageManifest v1 = 2;
  bool has_v1() const;
  void clear_v1();
  static const int kV1FieldNumber = 2;
  const ::docker::spec::v1::ImageManifest& v1() const;
  ::docker::spec::v1::ImageManifest* release_v1();
  ::docker::spec::v1::ImageManifest* mutable_v1();
  void set_allocated_v1(::docker::spec::v1::ImageManifest* v1);

  // @@protoc_insertion_point(class_scope:docker.spec.v2.ImageManifest.History)
 private:
  void set_has_v1compatibility();
  void clear_has_v1compatibility();
  void set_has_v1();
  void clear_has_v1();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr v1compatibility_;
  ::docker::spec::v1::ImageManifest* v1_;
  friend struct ::protobuf_mesos_2fdocker_2fv2_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fdocker_2fv2_2eproto::InitDefaultsImageManifest_HistoryImpl();
};
// -------------------------------------------------------------------

class ImageManifest_Signature_Header_Jwk : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:docker.spec.v2.ImageManifest.Signature.Header.Jwk) */ {
 public:
  ImageManifest_Signature_Header_Jwk();
  virtual ~ImageManifest_Signature_Header_Jwk();

  ImageManifest_Signature_Header_Jwk(const ImageManifest_Signature_Header_Jwk& from);

  inline ImageManifest_Signature_Header_Jwk& operator=(const ImageManifest_Signature_Header_Jwk& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ImageManifest_Signature_Header_Jwk(ImageManifest_Signature_Header_Jwk&& from) noexcept
    : ImageManifest_Signature_Header_Jwk() {
    *this = ::std::move(from);
  }

  inline ImageManifest_Signature_Header_Jwk& operator=(ImageManifest_Signature_Header_Jwk&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ImageManifest_Signature_Header_Jwk& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ImageManifest_Signature_Header_Jwk* internal_default_instance() {
    return reinterpret_cast<const ImageManifest_Signature_Header_Jwk*>(
               &_ImageManifest_Signature_Header_Jwk_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(ImageManifest_Signature_Header_Jwk* other);
  friend void swap(ImageManifest_Signature_Header_Jwk& a, ImageManifest_Signature_Header_Jwk& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ImageManifest_Signature_Header_Jwk* New() const PROTOBUF_FINAL { return New(NULL); }

  ImageManifest_Signature_Header_Jwk* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ImageManifest_Signature_Header_Jwk& from);
  void MergeFrom(const ImageManifest_Signature_Header_Jwk& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ImageManifest_Signature_Header_Jwk* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string crv = 1;
  bool has_crv() const;
  void clear_crv();
  static const int kCrvFieldNumber = 1;
  const ::std::string& crv() const;
  void set_crv(const ::std::string& value);
  #if LANG_CXX11
  void set_crv(::std::string&& value);
  #endif
  void set_crv(const char* value);
  void set_crv(const char* value, size_t size);
  ::std::string* mutable_crv();
  ::std::string* release_crv();
  void set_allocated_crv(::std::string* crv);

  // optional string kid = 2;
  bool has_kid() const;
  void clear_kid();
  static const int kKidFieldNumber = 2;
  const ::std::string& kid() const;
  void set_kid(const ::std::string& value);
  #if LANG_CXX11
  void set_kid(::std::string&& value);
  #endif
  void set_kid(const char* value);
  void set_kid(const char* value, size_t size);
  ::std::string* mutable_kid();
  ::std::string* release_kid();
  void set_allocated_kid(::std::string* kid);

  // required string kty = 3;
  bool has_kty() const;
  void clear_kty();
  static const int kKtyFieldNumber = 3;
  const ::std::string& kty() const;
  void set_kty(const ::std::string& value);
  #if LANG_CXX11
  void set_kty(::std::string&& value);
  #endif
  void set_kty(const char* value);
  void set_kty(const char* value, size_t size);
  ::std::string* mutable_kty();
  ::std::string* release_kty();
  void set_allocated_kty(::std::string* kty);

  // optional string x = 4;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 4;
  const ::std::string& x() const;
  void set_x(const ::std::string& value);
  #if LANG_CXX11
  void set_x(::std::string&& value);
  #endif
  void set_x(const char* value);
  void set_x(const char* value, size_t size);
  ::std::string* mutable_x();
  ::std::string* release_x();
  void set_allocated_x(::std::string* x);

  // optional string y = 5;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 5;
  const ::std::string& y() const;
  void set_y(const ::std::string& value);
  #if LANG_CXX11
  void set_y(::std::string&& value);
  #endif
  void set_y(const char* value);
  void set_y(const char* value, size_t size);
  ::std::string* mutable_y();
  ::std::string* release_y();
  void set_allocated_y(::std::string* y);

  // @@protoc_insertion_point(class_scope:docker.spec.v2.ImageManifest.Signature.Header.Jwk)
 private:
  void set_has_crv();
  void clear_has_crv();
  void set_has_kid();
  void clear_has_kid();
  void set_has_kty();
  void clear_has_kty();
  void set_has_x();
  void clear_has_x();
  void set_has_y();
  void clear_has_y();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr crv_;
  ::google::protobuf::internal::ArenaStringPtr kid_;
  ::google::protobuf::internal::ArenaStringPtr kty_;
  ::google::protobuf::internal::ArenaStringPtr x_;
  ::google::protobuf::internal::ArenaStringPtr y_;
  friend struct ::protobuf_mesos_2fdocker_2fv2_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fdocker_2fv2_2eproto::InitDefaultsImageManifest_Signature_Header_JwkImpl();
};
// -------------------------------------------------------------------

class ImageManifest_Signature_Header : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:docker.spec.v2.ImageManifest.Signature.Header) */ {
 public:
  ImageManifest_Signature_Header();
  virtual ~ImageManifest_Signature_Header();

  ImageManifest_Signature_Header(const ImageManifest_Signature_Header& from);

  inline ImageManifest_Signature_Header& operator=(const ImageManifest_Signature_Header& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ImageManifest_Signature_Header(ImageManifest_Signature_Header&& from) noexcept
    : ImageManifest_Signature_Header() {
    *this = ::std::move(from);
  }

  inline ImageManifest_Signature_Header& operator=(ImageManifest_Signature_Header&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ImageManifest_Signature_Header& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ImageManifest_Signature_Header* internal_default_instance() {
    return reinterpret_cast<const ImageManifest_Signature_Header*>(
               &_ImageManifest_Signature_Header_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(ImageManifest_Signature_Header* other);
  friend void swap(ImageManifest_Signature_Header& a, ImageManifest_Signature_Header& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ImageManifest_Signature_Header* New() const PROTOBUF_FINAL { return New(NULL); }

  ImageManifest_Signature_Header* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ImageManifest_Signature_Header& from);
  void MergeFrom(const ImageManifest_Signature_Header& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ImageManifest_Signature_Header* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef ImageManifest_Signature_Header_Jwk Jwk;

  // accessors -------------------------------------------------------

  // required string alg = 2;
  bool has_alg() const;
  void clear_alg();
  static const int kAlgFieldNumber = 2;
  const ::std::string& alg() const;
  void set_alg(const ::std::string& value);
  #if LANG_CXX11
  void set_alg(::std::string&& value);
  #endif
  void set_alg(const char* value);
  void set_alg(const char* value, size_t size);
  ::std::string* mutable_alg();
  ::std::string* release_alg();
  void set_allocated_alg(::std::string* alg);

  // optional .docker.spec.v2.ImageManifest.Signature.Header.Jwk jwk = 1;
  bool has_jwk() const;
  void clear_jwk();
  static const int kJwkFieldNumber = 1;
  const ::docker::spec::v2::ImageManifest_Signature_Header_Jwk& jwk() const;
  ::docker::spec::v2::ImageManifest_Signature_Header_Jwk* release_jwk();
  ::docker::spec::v2::ImageManifest_Signature_Header_Jwk* mutable_jwk();
  void set_allocated_jwk(::docker::spec::v2::ImageManifest_Signature_Header_Jwk* jwk);

  // @@protoc_insertion_point(class_scope:docker.spec.v2.ImageManifest.Signature.Header)
 private:
  void set_has_jwk();
  void clear_has_jwk();
  void set_has_alg();
  void clear_has_alg();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr alg_;
  ::docker::spec::v2::ImageManifest_Signature_Header_Jwk* jwk_;
  friend struct ::protobuf_mesos_2fdocker_2fv2_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fdocker_2fv2_2eproto::InitDefaultsImageManifest_Signature_HeaderImpl();
};
// -------------------------------------------------------------------

class ImageManifest_Signature : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:docker.spec.v2.ImageManifest.Signature) */ {
 public:
  ImageManifest_Signature();
  virtual ~ImageManifest_Signature();

  ImageManifest_Signature(const ImageManifest_Signature& from);

  inline ImageManifest_Signature& operator=(const ImageManifest_Signature& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ImageManifest_Signature(ImageManifest_Signature&& from) noexcept
    : ImageManifest_Signature() {
    *this = ::std::move(from);
  }

  inline ImageManifest_Signature& operator=(ImageManifest_Signature&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ImageManifest_Signature& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ImageManifest_Signature* internal_default_instance() {
    return reinterpret_cast<const ImageManifest_Signature*>(
               &_ImageManifest_Signature_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(ImageManifest_Signature* other);
  friend void swap(ImageManifest_Signature& a, ImageManifest_Signature& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ImageManifest_Signature* New() const PROTOBUF_FINAL { return New(NULL); }

  ImageManifest_Signature* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ImageManifest_Signature& from);
  void MergeFrom(const ImageManifest_Signature& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ImageManifest_Signature* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef ImageManifest_Signature_Header Header;

  // accessors -------------------------------------------------------

  // required string signature = 2;
  bool has_signature() const;
  void clear_signature();
  static const int kSignatureFieldNumber = 2;
  const ::std::string& signature() const;
  void set_signature(const ::std::string& value);
  #if LANG_CXX11
  void set_signature(::std::string&& value);
  #endif
  void set_signature(const char* value);
  void set_signature(const char* value, size_t size);
  ::std::string* mutable_signature();
  ::std::string* release_signature();
  void set_allocated_signature(::std::string* signature);

  // required string protected = 3;
  bool has_protected_() const;
  void clear_protected_();
  static const int kProtectedFieldNumber = 3;
  const ::std::string& protected_() const;
  void set_protected_(const ::std::string& value);
  #if LANG_CXX11
  void set_protected_(::std::string&& value);
  #endif
  void set_protected_(const char* value);
  void set_protected_(const char* value, size_t size);
  ::std::string* mutable_protected_();
  ::std::string* release_protected_();
  void set_allocated_protected_(::std::string* protected_);

  // required .docker.spec.v2.ImageManifest.Signature.Header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::docker::spec::v2::ImageManifest_Signature_Header& header() const;
  ::docker::spec::v2::ImageManifest_Signature_Header* release_header();
  ::docker::spec::v2::ImageManifest_Signature_Header* mutable_header();
  void set_allocated_header(::docker::spec::v2::ImageManifest_Signature_Header* header);

  // @@protoc_insertion_point(class_scope:docker.spec.v2.ImageManifest.Signature)
 private:
  void set_has_header();
  void clear_has_header();
  void set_has_signature();
  void clear_has_signature();
  void set_has_protected_();
  void clear_has_protected_();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr signature_;
  ::google::protobuf::internal::ArenaStringPtr protected__;
  ::docker::spec::v2::ImageManifest_Signature_Header* header_;
  friend struct ::protobuf_mesos_2fdocker_2fv2_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fdocker_2fv2_2eproto::InitDefaultsImageManifest_SignatureImpl();
};
// -------------------------------------------------------------------

class ImageManifest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:docker.spec.v2.ImageManifest) */ {
 public:
  ImageManifest();
  virtual ~ImageManifest();

  ImageManifest(const ImageManifest& from);

  inline ImageManifest& operator=(const ImageManifest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ImageManifest(ImageManifest&& from) noexcept
    : ImageManifest() {
    *this = ::std::move(from);
  }

  inline ImageManifest& operator=(ImageManifest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ImageManifest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ImageManifest* internal_default_instance() {
    return reinterpret_cast<const ImageManifest*>(
               &_ImageManifest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(ImageManifest* other);
  friend void swap(ImageManifest& a, ImageManifest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ImageManifest* New() const PROTOBUF_FINAL { return New(NULL); }

  ImageManifest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ImageManifest& from);
  void MergeFrom(const ImageManifest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ImageManifest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef ImageManifest_FsLayer FsLayer;
  typedef ImageManifest_History History;
  typedef ImageManifest_Signature Signature;

  // accessors -------------------------------------------------------

  // repeated .docker.spec.v2.ImageManifest.FsLayer fsLayers = 4;
  int fslayers_size() const;
  void clear_fslayers();
  static const int kFsLayersFieldNumber = 4;
  const ::docker::spec::v2::ImageManifest_FsLayer& fslayers(int index) const;
  ::docker::spec::v2::ImageManifest_FsLayer* mutable_fslayers(int index);
  ::docker::spec::v2::ImageManifest_FsLayer* add_fslayers();
  ::google::protobuf::RepeatedPtrField< ::docker::spec::v2::ImageManifest_FsLayer >*
      mutable_fslayers();
  const ::google::protobuf::RepeatedPtrField< ::docker::spec::v2::ImageManifest_FsLayer >&
      fslayers() const;

  // repeated .docker.spec.v2.ImageManifest.History history = 5;
  int history_size() const;
  void clear_history();
  static const int kHistoryFieldNumber = 5;
  const ::docker::spec::v2::ImageManifest_History& history(int index) const;
  ::docker::spec::v2::ImageManifest_History* mutable_history(int index);
  ::docker::spec::v2::ImageManifest_History* add_history();
  ::google::protobuf::RepeatedPtrField< ::docker::spec::v2::ImageManifest_History >*
      mutable_history();
  const ::google::protobuf::RepeatedPtrField< ::docker::spec::v2::ImageManifest_History >&
      history() const;

  // repeated .docker.spec.v2.ImageManifest.Signature signatures = 7;
  int signatures_size() const;
  void clear_signatures();
  static const int kSignaturesFieldNumber = 7;
  const ::docker::spec::v2::ImageManifest_Signature& signatures(int index) const;
  ::docker::spec::v2::ImageManifest_Signature* mutable_signatures(int index);
  ::docker::spec::v2::ImageManifest_Signature* add_signatures();
  ::google::protobuf::RepeatedPtrField< ::docker::spec::v2::ImageManifest_Signature >*
      mutable_signatures();
  const ::google::protobuf::RepeatedPtrField< ::docker::spec::v2::ImageManifest_Signature >&
      signatures() const;

  // required string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // required string tag = 2;
  bool has_tag() const;
  void clear_tag();
  static const int kTagFieldNumber = 2;
  const ::std::string& tag() const;
  void set_tag(const ::std::string& value);
  #if LANG_CXX11
  void set_tag(::std::string&& value);
  #endif
  void set_tag(const char* value);
  void set_tag(const char* value, size_t size);
  ::std::string* mutable_tag();
  ::std::string* release_tag();
  void set_allocated_tag(::std::string* tag);

  // required string architecture = 3;
  bool has_architecture() const;
  void clear_architecture();
  static const int kArchitectureFieldNumber = 3;
  const ::std::string& architecture() const;
  void set_architecture(const ::std::string& value);
  #if LANG_CXX11
  void set_architecture(::std::string&& value);
  #endif
  void set_architecture(const char* value);
  void set_architecture(const char* value, size_t size);
  ::std::string* mutable_architecture();
  ::std::string* release_architecture();
  void set_allocated_architecture(::std::string* architecture);

  // required uint32 schemaVersion = 6;
  bool has_schemaversion() const;
  void clear_schemaversion();
  static const int kSchemaVersionFieldNumber = 6;
  ::google::protobuf::uint32 schemaversion() const;
  void set_schemaversion(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:docker.spec.v2.ImageManifest)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_tag();
  void clear_has_tag();
  void set_has_architecture();
  void clear_has_architecture();
  void set_has_schemaversion();
  void clear_has_schemaversion();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::docker::spec::v2::ImageManifest_FsLayer > fslayers_;
  ::google::protobuf::RepeatedPtrField< ::docker::spec::v2::ImageManifest_History > history_;
  ::google::protobuf::RepeatedPtrField< ::docker::spec::v2::ImageManifest_Signature > signatures_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr tag_;
  ::google::protobuf::internal::ArenaStringPtr architecture_;
  ::google::protobuf::uint32 schemaversion_;
  friend struct ::protobuf_mesos_2fdocker_2fv2_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fdocker_2fv2_2eproto::InitDefaultsImageManifestImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ImageManifest_FsLayer

// required string blobSum = 1;
inline bool ImageManifest_FsLayer::has_blobsum() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ImageManifest_FsLayer::set_has_blobsum() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ImageManifest_FsLayer::clear_has_blobsum() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ImageManifest_FsLayer::clear_blobsum() {
  blobsum_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_blobsum();
}
inline const ::std::string& ImageManifest_FsLayer::blobsum() const {
  // @@protoc_insertion_point(field_get:docker.spec.v2.ImageManifest.FsLayer.blobSum)
  return blobsum_.GetNoArena();
}
inline void ImageManifest_FsLayer::set_blobsum(const ::std::string& value) {
  set_has_blobsum();
  blobsum_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:docker.spec.v2.ImageManifest.FsLayer.blobSum)
}
#if LANG_CXX11
inline void ImageManifest_FsLayer::set_blobsum(::std::string&& value) {
  set_has_blobsum();
  blobsum_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:docker.spec.v2.ImageManifest.FsLayer.blobSum)
}
#endif
inline void ImageManifest_FsLayer::set_blobsum(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_blobsum();
  blobsum_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:docker.spec.v2.ImageManifest.FsLayer.blobSum)
}
inline void ImageManifest_FsLayer::set_blobsum(const char* value, size_t size) {
  set_has_blobsum();
  blobsum_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:docker.spec.v2.ImageManifest.FsLayer.blobSum)
}
inline ::std::string* ImageManifest_FsLayer::mutable_blobsum() {
  set_has_blobsum();
  // @@protoc_insertion_point(field_mutable:docker.spec.v2.ImageManifest.FsLayer.blobSum)
  return blobsum_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ImageManifest_FsLayer::release_blobsum() {
  // @@protoc_insertion_point(field_release:docker.spec.v2.ImageManifest.FsLayer.blobSum)
  clear_has_blobsum();
  return blobsum_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ImageManifest_FsLayer::set_allocated_blobsum(::std::string* blobsum) {
  if (blobsum != NULL) {
    set_has_blobsum();
  } else {
    clear_has_blobsum();
  }
  blobsum_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), blobsum);
  // @@protoc_insertion_point(field_set_allocated:docker.spec.v2.ImageManifest.FsLayer.blobSum)
}

// -------------------------------------------------------------------

// ImageManifest_History

// required string v1Compatibility = 1;
inline bool ImageManifest_History::has_v1compatibility() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ImageManifest_History::set_has_v1compatibility() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ImageManifest_History::clear_has_v1compatibility() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ImageManifest_History::clear_v1compatibility() {
  v1compatibility_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_v1compatibility();
}
inline const ::std::string& ImageManifest_History::v1compatibility() const {
  // @@protoc_insertion_point(field_get:docker.spec.v2.ImageManifest.History.v1Compatibility)
  return v1compatibility_.GetNoArena();
}
inline void ImageManifest_History::set_v1compatibility(const ::std::string& value) {
  set_has_v1compatibility();
  v1compatibility_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:docker.spec.v2.ImageManifest.History.v1Compatibility)
}
#if LANG_CXX11
inline void ImageManifest_History::set_v1compatibility(::std::string&& value) {
  set_has_v1compatibility();
  v1compatibility_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:docker.spec.v2.ImageManifest.History.v1Compatibility)
}
#endif
inline void ImageManifest_History::set_v1compatibility(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_v1compatibility();
  v1compatibility_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:docker.spec.v2.ImageManifest.History.v1Compatibility)
}
inline void ImageManifest_History::set_v1compatibility(const char* value, size_t size) {
  set_has_v1compatibility();
  v1compatibility_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:docker.spec.v2.ImageManifest.History.v1Compatibility)
}
inline ::std::string* ImageManifest_History::mutable_v1compatibility() {
  set_has_v1compatibility();
  // @@protoc_insertion_point(field_mutable:docker.spec.v2.ImageManifest.History.v1Compatibility)
  return v1compatibility_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ImageManifest_History::release_v1compatibility() {
  // @@protoc_insertion_point(field_release:docker.spec.v2.ImageManifest.History.v1Compatibility)
  clear_has_v1compatibility();
  return v1compatibility_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ImageManifest_History::set_allocated_v1compatibility(::std::string* v1compatibility) {
  if (v1compatibility != NULL) {
    set_has_v1compatibility();
  } else {
    clear_has_v1compatibility();
  }
  v1compatibility_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), v1compatibility);
  // @@protoc_insertion_point(field_set_allocated:docker.spec.v2.ImageManifest.History.v1Compatibility)
}

// optional .docker.spec.v1.ImageManifest v1 = 2;
inline bool ImageManifest_History::has_v1() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ImageManifest_History::set_has_v1() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ImageManifest_History::clear_has_v1() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::docker::spec::v1::ImageManifest& ImageManifest_History::v1() const {
  const ::docker::spec::v1::ImageManifest* p = v1_;
  // @@protoc_insertion_point(field_get:docker.spec.v2.ImageManifest.History.v1)
  return p != NULL ? *p : *reinterpret_cast<const ::docker::spec::v1::ImageManifest*>(
      &::docker::spec::v1::_ImageManifest_default_instance_);
}
inline ::docker::spec::v1::ImageManifest* ImageManifest_History::release_v1() {
  // @@protoc_insertion_point(field_release:docker.spec.v2.ImageManifest.History.v1)
  clear_has_v1();
  ::docker::spec::v1::ImageManifest* temp = v1_;
  v1_ = NULL;
  return temp;
}
inline ::docker::spec::v1::ImageManifest* ImageManifest_History::mutable_v1() {
  set_has_v1();
  if (v1_ == NULL) {
    v1_ = new ::docker::spec::v1::ImageManifest;
  }
  // @@protoc_insertion_point(field_mutable:docker.spec.v2.ImageManifest.History.v1)
  return v1_;
}
inline void ImageManifest_History::set_allocated_v1(::docker::spec::v1::ImageManifest* v1) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(v1_);
  }
  if (v1) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      v1 = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, v1, submessage_arena);
    }
    set_has_v1();
  } else {
    clear_has_v1();
  }
  v1_ = v1;
  // @@protoc_insertion_point(field_set_allocated:docker.spec.v2.ImageManifest.History.v1)
}

// -------------------------------------------------------------------

// ImageManifest_Signature_Header_Jwk

// optional string crv = 1;
inline bool ImageManifest_Signature_Header_Jwk::has_crv() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ImageManifest_Signature_Header_Jwk::set_has_crv() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ImageManifest_Signature_Header_Jwk::clear_has_crv() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ImageManifest_Signature_Header_Jwk::clear_crv() {
  crv_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_crv();
}
inline const ::std::string& ImageManifest_Signature_Header_Jwk::crv() const {
  // @@protoc_insertion_point(field_get:docker.spec.v2.ImageManifest.Signature.Header.Jwk.crv)
  return crv_.GetNoArena();
}
inline void ImageManifest_Signature_Header_Jwk::set_crv(const ::std::string& value) {
  set_has_crv();
  crv_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:docker.spec.v2.ImageManifest.Signature.Header.Jwk.crv)
}
#if LANG_CXX11
inline void ImageManifest_Signature_Header_Jwk::set_crv(::std::string&& value) {
  set_has_crv();
  crv_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:docker.spec.v2.ImageManifest.Signature.Header.Jwk.crv)
}
#endif
inline void ImageManifest_Signature_Header_Jwk::set_crv(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_crv();
  crv_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:docker.spec.v2.ImageManifest.Signature.Header.Jwk.crv)
}
inline void ImageManifest_Signature_Header_Jwk::set_crv(const char* value, size_t size) {
  set_has_crv();
  crv_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:docker.spec.v2.ImageManifest.Signature.Header.Jwk.crv)
}
inline ::std::string* ImageManifest_Signature_Header_Jwk::mutable_crv() {
  set_has_crv();
  // @@protoc_insertion_point(field_mutable:docker.spec.v2.ImageManifest.Signature.Header.Jwk.crv)
  return crv_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ImageManifest_Signature_Header_Jwk::release_crv() {
  // @@protoc_insertion_point(field_release:docker.spec.v2.ImageManifest.Signature.Header.Jwk.crv)
  clear_has_crv();
  return crv_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ImageManifest_Signature_Header_Jwk::set_allocated_crv(::std::string* crv) {
  if (crv != NULL) {
    set_has_crv();
  } else {
    clear_has_crv();
  }
  crv_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), crv);
  // @@protoc_insertion_point(field_set_allocated:docker.spec.v2.ImageManifest.Signature.Header.Jwk.crv)
}

// optional string kid = 2;
inline bool ImageManifest_Signature_Header_Jwk::has_kid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ImageManifest_Signature_Header_Jwk::set_has_kid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ImageManifest_Signature_Header_Jwk::clear_has_kid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ImageManifest_Signature_Header_Jwk::clear_kid() {
  kid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_kid();
}
inline const ::std::string& ImageManifest_Signature_Header_Jwk::kid() const {
  // @@protoc_insertion_point(field_get:docker.spec.v2.ImageManifest.Signature.Header.Jwk.kid)
  return kid_.GetNoArena();
}
inline void ImageManifest_Signature_Header_Jwk::set_kid(const ::std::string& value) {
  set_has_kid();
  kid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:docker.spec.v2.ImageManifest.Signature.Header.Jwk.kid)
}
#if LANG_CXX11
inline void ImageManifest_Signature_Header_Jwk::set_kid(::std::string&& value) {
  set_has_kid();
  kid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:docker.spec.v2.ImageManifest.Signature.Header.Jwk.kid)
}
#endif
inline void ImageManifest_Signature_Header_Jwk::set_kid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_kid();
  kid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:docker.spec.v2.ImageManifest.Signature.Header.Jwk.kid)
}
inline void ImageManifest_Signature_Header_Jwk::set_kid(const char* value, size_t size) {
  set_has_kid();
  kid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:docker.spec.v2.ImageManifest.Signature.Header.Jwk.kid)
}
inline ::std::string* ImageManifest_Signature_Header_Jwk::mutable_kid() {
  set_has_kid();
  // @@protoc_insertion_point(field_mutable:docker.spec.v2.ImageManifest.Signature.Header.Jwk.kid)
  return kid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ImageManifest_Signature_Header_Jwk::release_kid() {
  // @@protoc_insertion_point(field_release:docker.spec.v2.ImageManifest.Signature.Header.Jwk.kid)
  clear_has_kid();
  return kid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ImageManifest_Signature_Header_Jwk::set_allocated_kid(::std::string* kid) {
  if (kid != NULL) {
    set_has_kid();
  } else {
    clear_has_kid();
  }
  kid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), kid);
  // @@protoc_insertion_point(field_set_allocated:docker.spec.v2.ImageManifest.Signature.Header.Jwk.kid)
}

// required string kty = 3;
inline bool ImageManifest_Signature_Header_Jwk::has_kty() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ImageManifest_Signature_Header_Jwk::set_has_kty() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ImageManifest_Signature_Header_Jwk::clear_has_kty() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ImageManifest_Signature_Header_Jwk::clear_kty() {
  kty_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_kty();
}
inline const ::std::string& ImageManifest_Signature_Header_Jwk::kty() const {
  // @@protoc_insertion_point(field_get:docker.spec.v2.ImageManifest.Signature.Header.Jwk.kty)
  return kty_.GetNoArena();
}
inline void ImageManifest_Signature_Header_Jwk::set_kty(const ::std::string& value) {
  set_has_kty();
  kty_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:docker.spec.v2.ImageManifest.Signature.Header.Jwk.kty)
}
#if LANG_CXX11
inline void ImageManifest_Signature_Header_Jwk::set_kty(::std::string&& value) {
  set_has_kty();
  kty_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:docker.spec.v2.ImageManifest.Signature.Header.Jwk.kty)
}
#endif
inline void ImageManifest_Signature_Header_Jwk::set_kty(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_kty();
  kty_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:docker.spec.v2.ImageManifest.Signature.Header.Jwk.kty)
}
inline void ImageManifest_Signature_Header_Jwk::set_kty(const char* value, size_t size) {
  set_has_kty();
  kty_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:docker.spec.v2.ImageManifest.Signature.Header.Jwk.kty)
}
inline ::std::string* ImageManifest_Signature_Header_Jwk::mutable_kty() {
  set_has_kty();
  // @@protoc_insertion_point(field_mutable:docker.spec.v2.ImageManifest.Signature.Header.Jwk.kty)
  return kty_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ImageManifest_Signature_Header_Jwk::release_kty() {
  // @@protoc_insertion_point(field_release:docker.spec.v2.ImageManifest.Signature.Header.Jwk.kty)
  clear_has_kty();
  return kty_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ImageManifest_Signature_Header_Jwk::set_allocated_kty(::std::string* kty) {
  if (kty != NULL) {
    set_has_kty();
  } else {
    clear_has_kty();
  }
  kty_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), kty);
  // @@protoc_insertion_point(field_set_allocated:docker.spec.v2.ImageManifest.Signature.Header.Jwk.kty)
}

// optional string x = 4;
inline bool ImageManifest_Signature_Header_Jwk::has_x() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ImageManifest_Signature_Header_Jwk::set_has_x() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ImageManifest_Signature_Header_Jwk::clear_has_x() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ImageManifest_Signature_Header_Jwk::clear_x() {
  x_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_x();
}
inline const ::std::string& ImageManifest_Signature_Header_Jwk::x() const {
  // @@protoc_insertion_point(field_get:docker.spec.v2.ImageManifest.Signature.Header.Jwk.x)
  return x_.GetNoArena();
}
inline void ImageManifest_Signature_Header_Jwk::set_x(const ::std::string& value) {
  set_has_x();
  x_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:docker.spec.v2.ImageManifest.Signature.Header.Jwk.x)
}
#if LANG_CXX11
inline void ImageManifest_Signature_Header_Jwk::set_x(::std::string&& value) {
  set_has_x();
  x_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:docker.spec.v2.ImageManifest.Signature.Header.Jwk.x)
}
#endif
inline void ImageManifest_Signature_Header_Jwk::set_x(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_x();
  x_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:docker.spec.v2.ImageManifest.Signature.Header.Jwk.x)
}
inline void ImageManifest_Signature_Header_Jwk::set_x(const char* value, size_t size) {
  set_has_x();
  x_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:docker.spec.v2.ImageManifest.Signature.Header.Jwk.x)
}
inline ::std::string* ImageManifest_Signature_Header_Jwk::mutable_x() {
  set_has_x();
  // @@protoc_insertion_point(field_mutable:docker.spec.v2.ImageManifest.Signature.Header.Jwk.x)
  return x_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ImageManifest_Signature_Header_Jwk::release_x() {
  // @@protoc_insertion_point(field_release:docker.spec.v2.ImageManifest.Signature.Header.Jwk.x)
  clear_has_x();
  return x_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ImageManifest_Signature_Header_Jwk::set_allocated_x(::std::string* x) {
  if (x != NULL) {
    set_has_x();
  } else {
    clear_has_x();
  }
  x_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), x);
  // @@protoc_insertion_point(field_set_allocated:docker.spec.v2.ImageManifest.Signature.Header.Jwk.x)
}

// optional string y = 5;
inline bool ImageManifest_Signature_Header_Jwk::has_y() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ImageManifest_Signature_Header_Jwk::set_has_y() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ImageManifest_Signature_Header_Jwk::clear_has_y() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ImageManifest_Signature_Header_Jwk::clear_y() {
  y_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_y();
}
inline const ::std::string& ImageManifest_Signature_Header_Jwk::y() const {
  // @@protoc_insertion_point(field_get:docker.spec.v2.ImageManifest.Signature.Header.Jwk.y)
  return y_.GetNoArena();
}
inline void ImageManifest_Signature_Header_Jwk::set_y(const ::std::string& value) {
  set_has_y();
  y_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:docker.spec.v2.ImageManifest.Signature.Header.Jwk.y)
}
#if LANG_CXX11
inline void ImageManifest_Signature_Header_Jwk::set_y(::std::string&& value) {
  set_has_y();
  y_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:docker.spec.v2.ImageManifest.Signature.Header.Jwk.y)
}
#endif
inline void ImageManifest_Signature_Header_Jwk::set_y(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_y();
  y_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:docker.spec.v2.ImageManifest.Signature.Header.Jwk.y)
}
inline void ImageManifest_Signature_Header_Jwk::set_y(const char* value, size_t size) {
  set_has_y();
  y_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:docker.spec.v2.ImageManifest.Signature.Header.Jwk.y)
}
inline ::std::string* ImageManifest_Signature_Header_Jwk::mutable_y() {
  set_has_y();
  // @@protoc_insertion_point(field_mutable:docker.spec.v2.ImageManifest.Signature.Header.Jwk.y)
  return y_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ImageManifest_Signature_Header_Jwk::release_y() {
  // @@protoc_insertion_point(field_release:docker.spec.v2.ImageManifest.Signature.Header.Jwk.y)
  clear_has_y();
  return y_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ImageManifest_Signature_Header_Jwk::set_allocated_y(::std::string* y) {
  if (y != NULL) {
    set_has_y();
  } else {
    clear_has_y();
  }
  y_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), y);
  // @@protoc_insertion_point(field_set_allocated:docker.spec.v2.ImageManifest.Signature.Header.Jwk.y)
}

// -------------------------------------------------------------------

// ImageManifest_Signature_Header

// optional .docker.spec.v2.ImageManifest.Signature.Header.Jwk jwk = 1;
inline bool ImageManifest_Signature_Header::has_jwk() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ImageManifest_Signature_Header::set_has_jwk() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ImageManifest_Signature_Header::clear_has_jwk() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ImageManifest_Signature_Header::clear_jwk() {
  if (jwk_ != NULL) jwk_->Clear();
  clear_has_jwk();
}
inline const ::docker::spec::v2::ImageManifest_Signature_Header_Jwk& ImageManifest_Signature_Header::jwk() const {
  const ::docker::spec::v2::ImageManifest_Signature_Header_Jwk* p = jwk_;
  // @@protoc_insertion_point(field_get:docker.spec.v2.ImageManifest.Signature.Header.jwk)
  return p != NULL ? *p : *reinterpret_cast<const ::docker::spec::v2::ImageManifest_Signature_Header_Jwk*>(
      &::docker::spec::v2::_ImageManifest_Signature_Header_Jwk_default_instance_);
}
inline ::docker::spec::v2::ImageManifest_Signature_Header_Jwk* ImageManifest_Signature_Header::release_jwk() {
  // @@protoc_insertion_point(field_release:docker.spec.v2.ImageManifest.Signature.Header.jwk)
  clear_has_jwk();
  ::docker::spec::v2::ImageManifest_Signature_Header_Jwk* temp = jwk_;
  jwk_ = NULL;
  return temp;
}
inline ::docker::spec::v2::ImageManifest_Signature_Header_Jwk* ImageManifest_Signature_Header::mutable_jwk() {
  set_has_jwk();
  if (jwk_ == NULL) {
    jwk_ = new ::docker::spec::v2::ImageManifest_Signature_Header_Jwk;
  }
  // @@protoc_insertion_point(field_mutable:docker.spec.v2.ImageManifest.Signature.Header.jwk)
  return jwk_;
}
inline void ImageManifest_Signature_Header::set_allocated_jwk(::docker::spec::v2::ImageManifest_Signature_Header_Jwk* jwk) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete jwk_;
  }
  if (jwk) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      jwk = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, jwk, submessage_arena);
    }
    set_has_jwk();
  } else {
    clear_has_jwk();
  }
  jwk_ = jwk;
  // @@protoc_insertion_point(field_set_allocated:docker.spec.v2.ImageManifest.Signature.Header.jwk)
}

// required string alg = 2;
inline bool ImageManifest_Signature_Header::has_alg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ImageManifest_Signature_Header::set_has_alg() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ImageManifest_Signature_Header::clear_has_alg() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ImageManifest_Signature_Header::clear_alg() {
  alg_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_alg();
}
inline const ::std::string& ImageManifest_Signature_Header::alg() const {
  // @@protoc_insertion_point(field_get:docker.spec.v2.ImageManifest.Signature.Header.alg)
  return alg_.GetNoArena();
}
inline void ImageManifest_Signature_Header::set_alg(const ::std::string& value) {
  set_has_alg();
  alg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:docker.spec.v2.ImageManifest.Signature.Header.alg)
}
#if LANG_CXX11
inline void ImageManifest_Signature_Header::set_alg(::std::string&& value) {
  set_has_alg();
  alg_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:docker.spec.v2.ImageManifest.Signature.Header.alg)
}
#endif
inline void ImageManifest_Signature_Header::set_alg(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_alg();
  alg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:docker.spec.v2.ImageManifest.Signature.Header.alg)
}
inline void ImageManifest_Signature_Header::set_alg(const char* value, size_t size) {
  set_has_alg();
  alg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:docker.spec.v2.ImageManifest.Signature.Header.alg)
}
inline ::std::string* ImageManifest_Signature_Header::mutable_alg() {
  set_has_alg();
  // @@protoc_insertion_point(field_mutable:docker.spec.v2.ImageManifest.Signature.Header.alg)
  return alg_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ImageManifest_Signature_Header::release_alg() {
  // @@protoc_insertion_point(field_release:docker.spec.v2.ImageManifest.Signature.Header.alg)
  clear_has_alg();
  return alg_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ImageManifest_Signature_Header::set_allocated_alg(::std::string* alg) {
  if (alg != NULL) {
    set_has_alg();
  } else {
    clear_has_alg();
  }
  alg_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), alg);
  // @@protoc_insertion_point(field_set_allocated:docker.spec.v2.ImageManifest.Signature.Header.alg)
}

// -------------------------------------------------------------------

// ImageManifest_Signature

// required .docker.spec.v2.ImageManifest.Signature.Header header = 1;
inline bool ImageManifest_Signature::has_header() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ImageManifest_Signature::set_has_header() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ImageManifest_Signature::clear_has_header() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ImageManifest_Signature::clear_header() {
  if (header_ != NULL) header_->Clear();
  clear_has_header();
}
inline const ::docker::spec::v2::ImageManifest_Signature_Header& ImageManifest_Signature::header() const {
  const ::docker::spec::v2::ImageManifest_Signature_Header* p = header_;
  // @@protoc_insertion_point(field_get:docker.spec.v2.ImageManifest.Signature.header)
  return p != NULL ? *p : *reinterpret_cast<const ::docker::spec::v2::ImageManifest_Signature_Header*>(
      &::docker::spec::v2::_ImageManifest_Signature_Header_default_instance_);
}
inline ::docker::spec::v2::ImageManifest_Signature_Header* ImageManifest_Signature::release_header() {
  // @@protoc_insertion_point(field_release:docker.spec.v2.ImageManifest.Signature.header)
  clear_has_header();
  ::docker::spec::v2::ImageManifest_Signature_Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::docker::spec::v2::ImageManifest_Signature_Header* ImageManifest_Signature::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::docker::spec::v2::ImageManifest_Signature_Header;
  }
  // @@protoc_insertion_point(field_mutable:docker.spec.v2.ImageManifest.Signature.header)
  return header_;
}
inline void ImageManifest_Signature::set_allocated_header(::docker::spec::v2::ImageManifest_Signature_Header* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    set_has_header();
  } else {
    clear_has_header();
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:docker.spec.v2.ImageManifest.Signature.header)
}

// required string signature = 2;
inline bool ImageManifest_Signature::has_signature() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ImageManifest_Signature::set_has_signature() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ImageManifest_Signature::clear_has_signature() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ImageManifest_Signature::clear_signature() {
  signature_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_signature();
}
inline const ::std::string& ImageManifest_Signature::signature() const {
  // @@protoc_insertion_point(field_get:docker.spec.v2.ImageManifest.Signature.signature)
  return signature_.GetNoArena();
}
inline void ImageManifest_Signature::set_signature(const ::std::string& value) {
  set_has_signature();
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:docker.spec.v2.ImageManifest.Signature.signature)
}
#if LANG_CXX11
inline void ImageManifest_Signature::set_signature(::std::string&& value) {
  set_has_signature();
  signature_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:docker.spec.v2.ImageManifest.Signature.signature)
}
#endif
inline void ImageManifest_Signature::set_signature(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_signature();
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:docker.spec.v2.ImageManifest.Signature.signature)
}
inline void ImageManifest_Signature::set_signature(const char* value, size_t size) {
  set_has_signature();
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:docker.spec.v2.ImageManifest.Signature.signature)
}
inline ::std::string* ImageManifest_Signature::mutable_signature() {
  set_has_signature();
  // @@protoc_insertion_point(field_mutable:docker.spec.v2.ImageManifest.Signature.signature)
  return signature_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ImageManifest_Signature::release_signature() {
  // @@protoc_insertion_point(field_release:docker.spec.v2.ImageManifest.Signature.signature)
  clear_has_signature();
  return signature_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ImageManifest_Signature::set_allocated_signature(::std::string* signature) {
  if (signature != NULL) {
    set_has_signature();
  } else {
    clear_has_signature();
  }
  signature_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), signature);
  // @@protoc_insertion_point(field_set_allocated:docker.spec.v2.ImageManifest.Signature.signature)
}

// required string protected = 3;
inline bool ImageManifest_Signature::has_protected_() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ImageManifest_Signature::set_has_protected_() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ImageManifest_Signature::clear_has_protected_() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ImageManifest_Signature::clear_protected_() {
  protected__.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_protected_();
}
inline const ::std::string& ImageManifest_Signature::protected_() const {
  // @@protoc_insertion_point(field_get:docker.spec.v2.ImageManifest.Signature.protected)
  return protected__.GetNoArena();
}
inline void ImageManifest_Signature::set_protected_(const ::std::string& value) {
  set_has_protected_();
  protected__.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:docker.spec.v2.ImageManifest.Signature.protected)
}
#if LANG_CXX11
inline void ImageManifest_Signature::set_protected_(::std::string&& value) {
  set_has_protected_();
  protected__.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:docker.spec.v2.ImageManifest.Signature.protected)
}
#endif
inline void ImageManifest_Signature::set_protected_(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_protected_();
  protected__.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:docker.spec.v2.ImageManifest.Signature.protected)
}
inline void ImageManifest_Signature::set_protected_(const char* value, size_t size) {
  set_has_protected_();
  protected__.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:docker.spec.v2.ImageManifest.Signature.protected)
}
inline ::std::string* ImageManifest_Signature::mutable_protected_() {
  set_has_protected_();
  // @@protoc_insertion_point(field_mutable:docker.spec.v2.ImageManifest.Signature.protected)
  return protected__.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ImageManifest_Signature::release_protected_() {
  // @@protoc_insertion_point(field_release:docker.spec.v2.ImageManifest.Signature.protected)
  clear_has_protected_();
  return protected__.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ImageManifest_Signature::set_allocated_protected_(::std::string* protected_) {
  if (protected_ != NULL) {
    set_has_protected_();
  } else {
    clear_has_protected_();
  }
  protected__.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), protected_);
  // @@protoc_insertion_point(field_set_allocated:docker.spec.v2.ImageManifest.Signature.protected)
}

// -------------------------------------------------------------------

// ImageManifest

// required string name = 1;
inline bool ImageManifest::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ImageManifest::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ImageManifest::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ImageManifest::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& ImageManifest::name() const {
  // @@protoc_insertion_point(field_get:docker.spec.v2.ImageManifest.name)
  return name_.GetNoArena();
}
inline void ImageManifest::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:docker.spec.v2.ImageManifest.name)
}
#if LANG_CXX11
inline void ImageManifest::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:docker.spec.v2.ImageManifest.name)
}
#endif
inline void ImageManifest::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:docker.spec.v2.ImageManifest.name)
}
inline void ImageManifest::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:docker.spec.v2.ImageManifest.name)
}
inline ::std::string* ImageManifest::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:docker.spec.v2.ImageManifest.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ImageManifest::release_name() {
  // @@protoc_insertion_point(field_release:docker.spec.v2.ImageManifest.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ImageManifest::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:docker.spec.v2.ImageManifest.name)
}

// required string tag = 2;
inline bool ImageManifest::has_tag() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ImageManifest::set_has_tag() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ImageManifest::clear_has_tag() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ImageManifest::clear_tag() {
  tag_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_tag();
}
inline const ::std::string& ImageManifest::tag() const {
  // @@protoc_insertion_point(field_get:docker.spec.v2.ImageManifest.tag)
  return tag_.GetNoArena();
}
inline void ImageManifest::set_tag(const ::std::string& value) {
  set_has_tag();
  tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:docker.spec.v2.ImageManifest.tag)
}
#if LANG_CXX11
inline void ImageManifest::set_tag(::std::string&& value) {
  set_has_tag();
  tag_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:docker.spec.v2.ImageManifest.tag)
}
#endif
inline void ImageManifest::set_tag(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_tag();
  tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:docker.spec.v2.ImageManifest.tag)
}
inline void ImageManifest::set_tag(const char* value, size_t size) {
  set_has_tag();
  tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:docker.spec.v2.ImageManifest.tag)
}
inline ::std::string* ImageManifest::mutable_tag() {
  set_has_tag();
  // @@protoc_insertion_point(field_mutable:docker.spec.v2.ImageManifest.tag)
  return tag_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ImageManifest::release_tag() {
  // @@protoc_insertion_point(field_release:docker.spec.v2.ImageManifest.tag)
  clear_has_tag();
  return tag_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ImageManifest::set_allocated_tag(::std::string* tag) {
  if (tag != NULL) {
    set_has_tag();
  } else {
    clear_has_tag();
  }
  tag_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tag);
  // @@protoc_insertion_point(field_set_allocated:docker.spec.v2.ImageManifest.tag)
}

// required string architecture = 3;
inline bool ImageManifest::has_architecture() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ImageManifest::set_has_architecture() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ImageManifest::clear_has_architecture() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ImageManifest::clear_architecture() {
  architecture_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_architecture();
}
inline const ::std::string& ImageManifest::architecture() const {
  // @@protoc_insertion_point(field_get:docker.spec.v2.ImageManifest.architecture)
  return architecture_.GetNoArena();
}
inline void ImageManifest::set_architecture(const ::std::string& value) {
  set_has_architecture();
  architecture_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:docker.spec.v2.ImageManifest.architecture)
}
#if LANG_CXX11
inline void ImageManifest::set_architecture(::std::string&& value) {
  set_has_architecture();
  architecture_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:docker.spec.v2.ImageManifest.architecture)
}
#endif
inline void ImageManifest::set_architecture(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_architecture();
  architecture_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:docker.spec.v2.ImageManifest.architecture)
}
inline void ImageManifest::set_architecture(const char* value, size_t size) {
  set_has_architecture();
  architecture_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:docker.spec.v2.ImageManifest.architecture)
}
inline ::std::string* ImageManifest::mutable_architecture() {
  set_has_architecture();
  // @@protoc_insertion_point(field_mutable:docker.spec.v2.ImageManifest.architecture)
  return architecture_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ImageManifest::release_architecture() {
  // @@protoc_insertion_point(field_release:docker.spec.v2.ImageManifest.architecture)
  clear_has_architecture();
  return architecture_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ImageManifest::set_allocated_architecture(::std::string* architecture) {
  if (architecture != NULL) {
    set_has_architecture();
  } else {
    clear_has_architecture();
  }
  architecture_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), architecture);
  // @@protoc_insertion_point(field_set_allocated:docker.spec.v2.ImageManifest.architecture)
}

// repeated .docker.spec.v2.ImageManifest.FsLayer fsLayers = 4;
inline int ImageManifest::fslayers_size() const {
  return fslayers_.size();
}
inline void ImageManifest::clear_fslayers() {
  fslayers_.Clear();
}
inline const ::docker::spec::v2::ImageManifest_FsLayer& ImageManifest::fslayers(int index) const {
  // @@protoc_insertion_point(field_get:docker.spec.v2.ImageManifest.fsLayers)
  return fslayers_.Get(index);
}
inline ::docker::spec::v2::ImageManifest_FsLayer* ImageManifest::mutable_fslayers(int index) {
  // @@protoc_insertion_point(field_mutable:docker.spec.v2.ImageManifest.fsLayers)
  return fslayers_.Mutable(index);
}
inline ::docker::spec::v2::ImageManifest_FsLayer* ImageManifest::add_fslayers() {
  // @@protoc_insertion_point(field_add:docker.spec.v2.ImageManifest.fsLayers)
  return fslayers_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::docker::spec::v2::ImageManifest_FsLayer >*
ImageManifest::mutable_fslayers() {
  // @@protoc_insertion_point(field_mutable_list:docker.spec.v2.ImageManifest.fsLayers)
  return &fslayers_;
}
inline const ::google::protobuf::RepeatedPtrField< ::docker::spec::v2::ImageManifest_FsLayer >&
ImageManifest::fslayers() const {
  // @@protoc_insertion_point(field_list:docker.spec.v2.ImageManifest.fsLayers)
  return fslayers_;
}

// repeated .docker.spec.v2.ImageManifest.History history = 5;
inline int ImageManifest::history_size() const {
  return history_.size();
}
inline void ImageManifest::clear_history() {
  history_.Clear();
}
inline const ::docker::spec::v2::ImageManifest_History& ImageManifest::history(int index) const {
  // @@protoc_insertion_point(field_get:docker.spec.v2.ImageManifest.history)
  return history_.Get(index);
}
inline ::docker::spec::v2::ImageManifest_History* ImageManifest::mutable_history(int index) {
  // @@protoc_insertion_point(field_mutable:docker.spec.v2.ImageManifest.history)
  return history_.Mutable(index);
}
inline ::docker::spec::v2::ImageManifest_History* ImageManifest::add_history() {
  // @@protoc_insertion_point(field_add:docker.spec.v2.ImageManifest.history)
  return history_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::docker::spec::v2::ImageManifest_History >*
ImageManifest::mutable_history() {
  // @@protoc_insertion_point(field_mutable_list:docker.spec.v2.ImageManifest.history)
  return &history_;
}
inline const ::google::protobuf::RepeatedPtrField< ::docker::spec::v2::ImageManifest_History >&
ImageManifest::history() const {
  // @@protoc_insertion_point(field_list:docker.spec.v2.ImageManifest.history)
  return history_;
}

// required uint32 schemaVersion = 6;
inline bool ImageManifest::has_schemaversion() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ImageManifest::set_has_schemaversion() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ImageManifest::clear_has_schemaversion() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ImageManifest::clear_schemaversion() {
  schemaversion_ = 0u;
  clear_has_schemaversion();
}
inline ::google::protobuf::uint32 ImageManifest::schemaversion() const {
  // @@protoc_insertion_point(field_get:docker.spec.v2.ImageManifest.schemaVersion)
  return schemaversion_;
}
inline void ImageManifest::set_schemaversion(::google::protobuf::uint32 value) {
  set_has_schemaversion();
  schemaversion_ = value;
  // @@protoc_insertion_point(field_set:docker.spec.v2.ImageManifest.schemaVersion)
}

// repeated .docker.spec.v2.ImageManifest.Signature signatures = 7;
inline int ImageManifest::signatures_size() const {
  return signatures_.size();
}
inline void ImageManifest::clear_signatures() {
  signatures_.Clear();
}
inline const ::docker::spec::v2::ImageManifest_Signature& ImageManifest::signatures(int index) const {
  // @@protoc_insertion_point(field_get:docker.spec.v2.ImageManifest.signatures)
  return signatures_.Get(index);
}
inline ::docker::spec::v2::ImageManifest_Signature* ImageManifest::mutable_signatures(int index) {
  // @@protoc_insertion_point(field_mutable:docker.spec.v2.ImageManifest.signatures)
  return signatures_.Mutable(index);
}
inline ::docker::spec::v2::ImageManifest_Signature* ImageManifest::add_signatures() {
  // @@protoc_insertion_point(field_add:docker.spec.v2.ImageManifest.signatures)
  return signatures_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::docker::spec::v2::ImageManifest_Signature >*
ImageManifest::mutable_signatures() {
  // @@protoc_insertion_point(field_mutable_list:docker.spec.v2.ImageManifest.signatures)
  return &signatures_;
}
inline const ::google::protobuf::RepeatedPtrField< ::docker::spec::v2::ImageManifest_Signature >&
ImageManifest::signatures() const {
  // @@protoc_insertion_point(field_list:docker.spec.v2.ImageManifest.signatures)
  return signatures_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v2
}  // namespace spec
}  // namespace docker

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_mesos_2fdocker_2fv2_2eproto__INCLUDED
