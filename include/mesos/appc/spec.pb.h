// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mesos/appc/spec.proto

#ifndef PROTOBUF_mesos_2fappc_2fspec_2eproto__INCLUDED
#define PROTOBUF_mesos_2fappc_2fspec_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protobuf_mesos_2fappc_2fspec_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[6];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsImageManifest_LabelImpl();
void InitDefaultsImageManifest_Label();
void InitDefaultsImageManifest_EnvironmentImpl();
void InitDefaultsImageManifest_Environment();
void InitDefaultsImageManifest_AppImpl();
void InitDefaultsImageManifest_App();
void InitDefaultsImageManifest_AnnotationImpl();
void InitDefaultsImageManifest_Annotation();
void InitDefaultsImageManifest_DependencyImpl();
void InitDefaultsImageManifest_Dependency();
void InitDefaultsImageManifestImpl();
void InitDefaultsImageManifest();
inline void InitDefaults() {
  InitDefaultsImageManifest_Label();
  InitDefaultsImageManifest_Environment();
  InitDefaultsImageManifest_App();
  InitDefaultsImageManifest_Annotation();
  InitDefaultsImageManifest_Dependency();
  InitDefaultsImageManifest();
}
}  // namespace protobuf_mesos_2fappc_2fspec_2eproto
namespace appc {
namespace spec {
class ImageManifest;
class ImageManifestDefaultTypeInternal;
extern ImageManifestDefaultTypeInternal _ImageManifest_default_instance_;
class ImageManifest_Annotation;
class ImageManifest_AnnotationDefaultTypeInternal;
extern ImageManifest_AnnotationDefaultTypeInternal _ImageManifest_Annotation_default_instance_;
class ImageManifest_App;
class ImageManifest_AppDefaultTypeInternal;
extern ImageManifest_AppDefaultTypeInternal _ImageManifest_App_default_instance_;
class ImageManifest_Dependency;
class ImageManifest_DependencyDefaultTypeInternal;
extern ImageManifest_DependencyDefaultTypeInternal _ImageManifest_Dependency_default_instance_;
class ImageManifest_Environment;
class ImageManifest_EnvironmentDefaultTypeInternal;
extern ImageManifest_EnvironmentDefaultTypeInternal _ImageManifest_Environment_default_instance_;
class ImageManifest_Label;
class ImageManifest_LabelDefaultTypeInternal;
extern ImageManifest_LabelDefaultTypeInternal _ImageManifest_Label_default_instance_;
}  // namespace spec
}  // namespace appc
namespace appc {
namespace spec {

// ===================================================================

class ImageManifest_Label : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:appc.spec.ImageManifest.Label) */ {
 public:
  ImageManifest_Label();
  virtual ~ImageManifest_Label();

  ImageManifest_Label(const ImageManifest_Label& from);

  inline ImageManifest_Label& operator=(const ImageManifest_Label& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ImageManifest_Label(ImageManifest_Label&& from) noexcept
    : ImageManifest_Label() {
    *this = ::std::move(from);
  }

  inline ImageManifest_Label& operator=(ImageManifest_Label&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ImageManifest_Label& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ImageManifest_Label* internal_default_instance() {
    return reinterpret_cast<const ImageManifest_Label*>(
               &_ImageManifest_Label_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(ImageManifest_Label* other);
  friend void swap(ImageManifest_Label& a, ImageManifest_Label& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ImageManifest_Label* New() const PROTOBUF_FINAL { return New(NULL); }

  ImageManifest_Label* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ImageManifest_Label& from);
  void MergeFrom(const ImageManifest_Label& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ImageManifest_Label* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // required string value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:appc.spec.ImageManifest.Label)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_value();
  void clear_has_value();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  friend struct ::protobuf_mesos_2fappc_2fspec_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fappc_2fspec_2eproto::InitDefaultsImageManifest_LabelImpl();
};
// -------------------------------------------------------------------

class ImageManifest_Environment : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:appc.spec.ImageManifest.Environment) */ {
 public:
  ImageManifest_Environment();
  virtual ~ImageManifest_Environment();

  ImageManifest_Environment(const ImageManifest_Environment& from);

  inline ImageManifest_Environment& operator=(const ImageManifest_Environment& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ImageManifest_Environment(ImageManifest_Environment&& from) noexcept
    : ImageManifest_Environment() {
    *this = ::std::move(from);
  }

  inline ImageManifest_Environment& operator=(ImageManifest_Environment&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ImageManifest_Environment& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ImageManifest_Environment* internal_default_instance() {
    return reinterpret_cast<const ImageManifest_Environment*>(
               &_ImageManifest_Environment_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(ImageManifest_Environment* other);
  friend void swap(ImageManifest_Environment& a, ImageManifest_Environment& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ImageManifest_Environment* New() const PROTOBUF_FINAL { return New(NULL); }

  ImageManifest_Environment* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ImageManifest_Environment& from);
  void MergeFrom(const ImageManifest_Environment& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ImageManifest_Environment* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // required string value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:appc.spec.ImageManifest.Environment)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_value();
  void clear_has_value();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  friend struct ::protobuf_mesos_2fappc_2fspec_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fappc_2fspec_2eproto::InitDefaultsImageManifest_EnvironmentImpl();
};
// -------------------------------------------------------------------

class ImageManifest_App : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:appc.spec.ImageManifest.App) */ {
 public:
  ImageManifest_App();
  virtual ~ImageManifest_App();

  ImageManifest_App(const ImageManifest_App& from);

  inline ImageManifest_App& operator=(const ImageManifest_App& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ImageManifest_App(ImageManifest_App&& from) noexcept
    : ImageManifest_App() {
    *this = ::std::move(from);
  }

  inline ImageManifest_App& operator=(ImageManifest_App&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ImageManifest_App& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ImageManifest_App* internal_default_instance() {
    return reinterpret_cast<const ImageManifest_App*>(
               &_ImageManifest_App_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(ImageManifest_App* other);
  friend void swap(ImageManifest_App& a, ImageManifest_App& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ImageManifest_App* New() const PROTOBUF_FINAL { return New(NULL); }

  ImageManifest_App* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ImageManifest_App& from);
  void MergeFrom(const ImageManifest_App& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ImageManifest_App* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string exec = 1;
  int exec_size() const;
  void clear_exec();
  static const int kExecFieldNumber = 1;
  const ::std::string& exec(int index) const;
  ::std::string* mutable_exec(int index);
  void set_exec(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_exec(int index, ::std::string&& value);
  #endif
  void set_exec(int index, const char* value);
  void set_exec(int index, const char* value, size_t size);
  ::std::string* add_exec();
  void add_exec(const ::std::string& value);
  #if LANG_CXX11
  void add_exec(::std::string&& value);
  #endif
  void add_exec(const char* value);
  void add_exec(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& exec() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_exec();

  // repeated .appc.spec.ImageManifest.Environment environment = 3;
  int environment_size() const;
  void clear_environment();
  static const int kEnvironmentFieldNumber = 3;
  const ::appc::spec::ImageManifest_Environment& environment(int index) const;
  ::appc::spec::ImageManifest_Environment* mutable_environment(int index);
  ::appc::spec::ImageManifest_Environment* add_environment();
  ::google::protobuf::RepeatedPtrField< ::appc::spec::ImageManifest_Environment >*
      mutable_environment();
  const ::google::protobuf::RepeatedPtrField< ::appc::spec::ImageManifest_Environment >&
      environment() const;

  // optional string workingDirectory = 2;
  bool has_workingdirectory() const;
  void clear_workingdirectory();
  static const int kWorkingDirectoryFieldNumber = 2;
  const ::std::string& workingdirectory() const;
  void set_workingdirectory(const ::std::string& value);
  #if LANG_CXX11
  void set_workingdirectory(::std::string&& value);
  #endif
  void set_workingdirectory(const char* value);
  void set_workingdirectory(const char* value, size_t size);
  ::std::string* mutable_workingdirectory();
  ::std::string* release_workingdirectory();
  void set_allocated_workingdirectory(::std::string* workingdirectory);

  // @@protoc_insertion_point(class_scope:appc.spec.ImageManifest.App)
 private:
  void set_has_workingdirectory();
  void clear_has_workingdirectory();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> exec_;
  ::google::protobuf::RepeatedPtrField< ::appc::spec::ImageManifest_Environment > environment_;
  ::google::protobuf::internal::ArenaStringPtr workingdirectory_;
  friend struct ::protobuf_mesos_2fappc_2fspec_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fappc_2fspec_2eproto::InitDefaultsImageManifest_AppImpl();
};
// -------------------------------------------------------------------

class ImageManifest_Annotation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:appc.spec.ImageManifest.Annotation) */ {
 public:
  ImageManifest_Annotation();
  virtual ~ImageManifest_Annotation();

  ImageManifest_Annotation(const ImageManifest_Annotation& from);

  inline ImageManifest_Annotation& operator=(const ImageManifest_Annotation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ImageManifest_Annotation(ImageManifest_Annotation&& from) noexcept
    : ImageManifest_Annotation() {
    *this = ::std::move(from);
  }

  inline ImageManifest_Annotation& operator=(ImageManifest_Annotation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ImageManifest_Annotation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ImageManifest_Annotation* internal_default_instance() {
    return reinterpret_cast<const ImageManifest_Annotation*>(
               &_ImageManifest_Annotation_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(ImageManifest_Annotation* other);
  friend void swap(ImageManifest_Annotation& a, ImageManifest_Annotation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ImageManifest_Annotation* New() const PROTOBUF_FINAL { return New(NULL); }

  ImageManifest_Annotation* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ImageManifest_Annotation& from);
  void MergeFrom(const ImageManifest_Annotation& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ImageManifest_Annotation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // required string value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:appc.spec.ImageManifest.Annotation)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_value();
  void clear_has_value();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  friend struct ::protobuf_mesos_2fappc_2fspec_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fappc_2fspec_2eproto::InitDefaultsImageManifest_AnnotationImpl();
};
// -------------------------------------------------------------------

class ImageManifest_Dependency : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:appc.spec.ImageManifest.Dependency) */ {
 public:
  ImageManifest_Dependency();
  virtual ~ImageManifest_Dependency();

  ImageManifest_Dependency(const ImageManifest_Dependency& from);

  inline ImageManifest_Dependency& operator=(const ImageManifest_Dependency& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ImageManifest_Dependency(ImageManifest_Dependency&& from) noexcept
    : ImageManifest_Dependency() {
    *this = ::std::move(from);
  }

  inline ImageManifest_Dependency& operator=(ImageManifest_Dependency&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ImageManifest_Dependency& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ImageManifest_Dependency* internal_default_instance() {
    return reinterpret_cast<const ImageManifest_Dependency*>(
               &_ImageManifest_Dependency_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(ImageManifest_Dependency* other);
  friend void swap(ImageManifest_Dependency& a, ImageManifest_Dependency& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ImageManifest_Dependency* New() const PROTOBUF_FINAL { return New(NULL); }

  ImageManifest_Dependency* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ImageManifest_Dependency& from);
  void MergeFrom(const ImageManifest_Dependency& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ImageManifest_Dependency* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .appc.spec.ImageManifest.Label labels = 3;
  int labels_size() const;
  void clear_labels();
  static const int kLabelsFieldNumber = 3;
  const ::appc::spec::ImageManifest_Label& labels(int index) const;
  ::appc::spec::ImageManifest_Label* mutable_labels(int index);
  ::appc::spec::ImageManifest_Label* add_labels();
  ::google::protobuf::RepeatedPtrField< ::appc::spec::ImageManifest_Label >*
      mutable_labels();
  const ::google::protobuf::RepeatedPtrField< ::appc::spec::ImageManifest_Label >&
      labels() const;

  // required string imageName = 1;
  bool has_imagename() const;
  void clear_imagename();
  static const int kImageNameFieldNumber = 1;
  const ::std::string& imagename() const;
  void set_imagename(const ::std::string& value);
  #if LANG_CXX11
  void set_imagename(::std::string&& value);
  #endif
  void set_imagename(const char* value);
  void set_imagename(const char* value, size_t size);
  ::std::string* mutable_imagename();
  ::std::string* release_imagename();
  void set_allocated_imagename(::std::string* imagename);

  // optional string imageID = 2;
  bool has_imageid() const;
  void clear_imageid();
  static const int kImageIDFieldNumber = 2;
  const ::std::string& imageid() const;
  void set_imageid(const ::std::string& value);
  #if LANG_CXX11
  void set_imageid(::std::string&& value);
  #endif
  void set_imageid(const char* value);
  void set_imageid(const char* value, size_t size);
  ::std::string* mutable_imageid();
  ::std::string* release_imageid();
  void set_allocated_imageid(::std::string* imageid);

  // optional uint64 size = 4;
  bool has_size() const;
  void clear_size();
  static const int kSizeFieldNumber = 4;
  ::google::protobuf::uint64 size() const;
  void set_size(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:appc.spec.ImageManifest.Dependency)
 private:
  void set_has_imagename();
  void clear_has_imagename();
  void set_has_imageid();
  void clear_has_imageid();
  void set_has_size();
  void clear_has_size();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::appc::spec::ImageManifest_Label > labels_;
  ::google::protobuf::internal::ArenaStringPtr imagename_;
  ::google::protobuf::internal::ArenaStringPtr imageid_;
  ::google::protobuf::uint64 size_;
  friend struct ::protobuf_mesos_2fappc_2fspec_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fappc_2fspec_2eproto::InitDefaultsImageManifest_DependencyImpl();
};
// -------------------------------------------------------------------

class ImageManifest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:appc.spec.ImageManifest) */ {
 public:
  ImageManifest();
  virtual ~ImageManifest();

  ImageManifest(const ImageManifest& from);

  inline ImageManifest& operator=(const ImageManifest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ImageManifest(ImageManifest&& from) noexcept
    : ImageManifest() {
    *this = ::std::move(from);
  }

  inline ImageManifest& operator=(ImageManifest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ImageManifest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ImageManifest* internal_default_instance() {
    return reinterpret_cast<const ImageManifest*>(
               &_ImageManifest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(ImageManifest* other);
  friend void swap(ImageManifest& a, ImageManifest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ImageManifest* New() const PROTOBUF_FINAL { return New(NULL); }

  ImageManifest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ImageManifest& from);
  void MergeFrom(const ImageManifest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ImageManifest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef ImageManifest_Label Label;
  typedef ImageManifest_Environment Environment;
  typedef ImageManifest_App App;
  typedef ImageManifest_Annotation Annotation;
  typedef ImageManifest_Dependency Dependency;

  // accessors -------------------------------------------------------

  // repeated .appc.spec.ImageManifest.Label labels = 4;
  int labels_size() const;
  void clear_labels();
  static const int kLabelsFieldNumber = 4;
  const ::appc::spec::ImageManifest_Label& labels(int index) const;
  ::appc::spec::ImageManifest_Label* mutable_labels(int index);
  ::appc::spec::ImageManifest_Label* add_labels();
  ::google::protobuf::RepeatedPtrField< ::appc::spec::ImageManifest_Label >*
      mutable_labels();
  const ::google::protobuf::RepeatedPtrField< ::appc::spec::ImageManifest_Label >&
      labels() const;

  // repeated .appc.spec.ImageManifest.Annotation annotations = 5;
  int annotations_size() const;
  void clear_annotations();
  static const int kAnnotationsFieldNumber = 5;
  const ::appc::spec::ImageManifest_Annotation& annotations(int index) const;
  ::appc::spec::ImageManifest_Annotation* mutable_annotations(int index);
  ::appc::spec::ImageManifest_Annotation* add_annotations();
  ::google::protobuf::RepeatedPtrField< ::appc::spec::ImageManifest_Annotation >*
      mutable_annotations();
  const ::google::protobuf::RepeatedPtrField< ::appc::spec::ImageManifest_Annotation >&
      annotations() const;

  // repeated .appc.spec.ImageManifest.Dependency dependencies = 6;
  int dependencies_size() const;
  void clear_dependencies();
  static const int kDependenciesFieldNumber = 6;
  const ::appc::spec::ImageManifest_Dependency& dependencies(int index) const;
  ::appc::spec::ImageManifest_Dependency* mutable_dependencies(int index);
  ::appc::spec::ImageManifest_Dependency* add_dependencies();
  ::google::protobuf::RepeatedPtrField< ::appc::spec::ImageManifest_Dependency >*
      mutable_dependencies();
  const ::google::protobuf::RepeatedPtrField< ::appc::spec::ImageManifest_Dependency >&
      dependencies() const;

  // required string acKind = 1;
  bool has_ackind() const;
  void clear_ackind();
  static const int kAcKindFieldNumber = 1;
  const ::std::string& ackind() const;
  void set_ackind(const ::std::string& value);
  #if LANG_CXX11
  void set_ackind(::std::string&& value);
  #endif
  void set_ackind(const char* value);
  void set_ackind(const char* value, size_t size);
  ::std::string* mutable_ackind();
  ::std::string* release_ackind();
  void set_allocated_ackind(::std::string* ackind);

  // required string acVersion = 2;
  bool has_acversion() const;
  void clear_acversion();
  static const int kAcVersionFieldNumber = 2;
  const ::std::string& acversion() const;
  void set_acversion(const ::std::string& value);
  #if LANG_CXX11
  void set_acversion(::std::string&& value);
  #endif
  void set_acversion(const char* value);
  void set_acversion(const char* value, size_t size);
  ::std::string* mutable_acversion();
  ::std::string* release_acversion();
  void set_allocated_acversion(::std::string* acversion);

  // required string name = 3;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 3;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional .appc.spec.ImageManifest.App app = 7;
  bool has_app() const;
  void clear_app();
  static const int kAppFieldNumber = 7;
  const ::appc::spec::ImageManifest_App& app() const;
  ::appc::spec::ImageManifest_App* release_app();
  ::appc::spec::ImageManifest_App* mutable_app();
  void set_allocated_app(::appc::spec::ImageManifest_App* app);

  // @@protoc_insertion_point(class_scope:appc.spec.ImageManifest)
 private:
  void set_has_ackind();
  void clear_has_ackind();
  void set_has_acversion();
  void clear_has_acversion();
  void set_has_name();
  void clear_has_name();
  void set_has_app();
  void clear_has_app();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::appc::spec::ImageManifest_Label > labels_;
  ::google::protobuf::RepeatedPtrField< ::appc::spec::ImageManifest_Annotation > annotations_;
  ::google::protobuf::RepeatedPtrField< ::appc::spec::ImageManifest_Dependency > dependencies_;
  ::google::protobuf::internal::ArenaStringPtr ackind_;
  ::google::protobuf::internal::ArenaStringPtr acversion_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::appc::spec::ImageManifest_App* app_;
  friend struct ::protobuf_mesos_2fappc_2fspec_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fappc_2fspec_2eproto::InitDefaultsImageManifestImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ImageManifest_Label

// required string name = 1;
inline bool ImageManifest_Label::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ImageManifest_Label::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ImageManifest_Label::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ImageManifest_Label::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& ImageManifest_Label::name() const {
  // @@protoc_insertion_point(field_get:appc.spec.ImageManifest.Label.name)
  return name_.GetNoArena();
}
inline void ImageManifest_Label::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:appc.spec.ImageManifest.Label.name)
}
#if LANG_CXX11
inline void ImageManifest_Label::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:appc.spec.ImageManifest.Label.name)
}
#endif
inline void ImageManifest_Label::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:appc.spec.ImageManifest.Label.name)
}
inline void ImageManifest_Label::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:appc.spec.ImageManifest.Label.name)
}
inline ::std::string* ImageManifest_Label::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:appc.spec.ImageManifest.Label.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ImageManifest_Label::release_name() {
  // @@protoc_insertion_point(field_release:appc.spec.ImageManifest.Label.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ImageManifest_Label::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:appc.spec.ImageManifest.Label.name)
}

// required string value = 2;
inline bool ImageManifest_Label::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ImageManifest_Label::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ImageManifest_Label::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ImageManifest_Label::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_value();
}
inline const ::std::string& ImageManifest_Label::value() const {
  // @@protoc_insertion_point(field_get:appc.spec.ImageManifest.Label.value)
  return value_.GetNoArena();
}
inline void ImageManifest_Label::set_value(const ::std::string& value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:appc.spec.ImageManifest.Label.value)
}
#if LANG_CXX11
inline void ImageManifest_Label::set_value(::std::string&& value) {
  set_has_value();
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:appc.spec.ImageManifest.Label.value)
}
#endif
inline void ImageManifest_Label::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:appc.spec.ImageManifest.Label.value)
}
inline void ImageManifest_Label::set_value(const char* value, size_t size) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:appc.spec.ImageManifest.Label.value)
}
inline ::std::string* ImageManifest_Label::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:appc.spec.ImageManifest.Label.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ImageManifest_Label::release_value() {
  // @@protoc_insertion_point(field_release:appc.spec.ImageManifest.Label.value)
  clear_has_value();
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ImageManifest_Label::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:appc.spec.ImageManifest.Label.value)
}

// -------------------------------------------------------------------

// ImageManifest_Environment

// required string name = 1;
inline bool ImageManifest_Environment::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ImageManifest_Environment::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ImageManifest_Environment::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ImageManifest_Environment::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& ImageManifest_Environment::name() const {
  // @@protoc_insertion_point(field_get:appc.spec.ImageManifest.Environment.name)
  return name_.GetNoArena();
}
inline void ImageManifest_Environment::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:appc.spec.ImageManifest.Environment.name)
}
#if LANG_CXX11
inline void ImageManifest_Environment::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:appc.spec.ImageManifest.Environment.name)
}
#endif
inline void ImageManifest_Environment::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:appc.spec.ImageManifest.Environment.name)
}
inline void ImageManifest_Environment::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:appc.spec.ImageManifest.Environment.name)
}
inline ::std::string* ImageManifest_Environment::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:appc.spec.ImageManifest.Environment.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ImageManifest_Environment::release_name() {
  // @@protoc_insertion_point(field_release:appc.spec.ImageManifest.Environment.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ImageManifest_Environment::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:appc.spec.ImageManifest.Environment.name)
}

// required string value = 2;
inline bool ImageManifest_Environment::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ImageManifest_Environment::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ImageManifest_Environment::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ImageManifest_Environment::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_value();
}
inline const ::std::string& ImageManifest_Environment::value() const {
  // @@protoc_insertion_point(field_get:appc.spec.ImageManifest.Environment.value)
  return value_.GetNoArena();
}
inline void ImageManifest_Environment::set_value(const ::std::string& value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:appc.spec.ImageManifest.Environment.value)
}
#if LANG_CXX11
inline void ImageManifest_Environment::set_value(::std::string&& value) {
  set_has_value();
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:appc.spec.ImageManifest.Environment.value)
}
#endif
inline void ImageManifest_Environment::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:appc.spec.ImageManifest.Environment.value)
}
inline void ImageManifest_Environment::set_value(const char* value, size_t size) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:appc.spec.ImageManifest.Environment.value)
}
inline ::std::string* ImageManifest_Environment::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:appc.spec.ImageManifest.Environment.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ImageManifest_Environment::release_value() {
  // @@protoc_insertion_point(field_release:appc.spec.ImageManifest.Environment.value)
  clear_has_value();
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ImageManifest_Environment::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:appc.spec.ImageManifest.Environment.value)
}

// -------------------------------------------------------------------

// ImageManifest_App

// repeated string exec = 1;
inline int ImageManifest_App::exec_size() const {
  return exec_.size();
}
inline void ImageManifest_App::clear_exec() {
  exec_.Clear();
}
inline const ::std::string& ImageManifest_App::exec(int index) const {
  // @@protoc_insertion_point(field_get:appc.spec.ImageManifest.App.exec)
  return exec_.Get(index);
}
inline ::std::string* ImageManifest_App::mutable_exec(int index) {
  // @@protoc_insertion_point(field_mutable:appc.spec.ImageManifest.App.exec)
  return exec_.Mutable(index);
}
inline void ImageManifest_App::set_exec(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:appc.spec.ImageManifest.App.exec)
  exec_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void ImageManifest_App::set_exec(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:appc.spec.ImageManifest.App.exec)
  exec_.Mutable(index)->assign(std::move(value));
}
#endif
inline void ImageManifest_App::set_exec(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  exec_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:appc.spec.ImageManifest.App.exec)
}
inline void ImageManifest_App::set_exec(int index, const char* value, size_t size) {
  exec_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:appc.spec.ImageManifest.App.exec)
}
inline ::std::string* ImageManifest_App::add_exec() {
  // @@protoc_insertion_point(field_add_mutable:appc.spec.ImageManifest.App.exec)
  return exec_.Add();
}
inline void ImageManifest_App::add_exec(const ::std::string& value) {
  exec_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:appc.spec.ImageManifest.App.exec)
}
#if LANG_CXX11
inline void ImageManifest_App::add_exec(::std::string&& value) {
  exec_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:appc.spec.ImageManifest.App.exec)
}
#endif
inline void ImageManifest_App::add_exec(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  exec_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:appc.spec.ImageManifest.App.exec)
}
inline void ImageManifest_App::add_exec(const char* value, size_t size) {
  exec_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:appc.spec.ImageManifest.App.exec)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ImageManifest_App::exec() const {
  // @@protoc_insertion_point(field_list:appc.spec.ImageManifest.App.exec)
  return exec_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ImageManifest_App::mutable_exec() {
  // @@protoc_insertion_point(field_mutable_list:appc.spec.ImageManifest.App.exec)
  return &exec_;
}

// optional string workingDirectory = 2;
inline bool ImageManifest_App::has_workingdirectory() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ImageManifest_App::set_has_workingdirectory() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ImageManifest_App::clear_has_workingdirectory() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ImageManifest_App::clear_workingdirectory() {
  workingdirectory_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_workingdirectory();
}
inline const ::std::string& ImageManifest_App::workingdirectory() const {
  // @@protoc_insertion_point(field_get:appc.spec.ImageManifest.App.workingDirectory)
  return workingdirectory_.GetNoArena();
}
inline void ImageManifest_App::set_workingdirectory(const ::std::string& value) {
  set_has_workingdirectory();
  workingdirectory_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:appc.spec.ImageManifest.App.workingDirectory)
}
#if LANG_CXX11
inline void ImageManifest_App::set_workingdirectory(::std::string&& value) {
  set_has_workingdirectory();
  workingdirectory_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:appc.spec.ImageManifest.App.workingDirectory)
}
#endif
inline void ImageManifest_App::set_workingdirectory(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_workingdirectory();
  workingdirectory_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:appc.spec.ImageManifest.App.workingDirectory)
}
inline void ImageManifest_App::set_workingdirectory(const char* value, size_t size) {
  set_has_workingdirectory();
  workingdirectory_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:appc.spec.ImageManifest.App.workingDirectory)
}
inline ::std::string* ImageManifest_App::mutable_workingdirectory() {
  set_has_workingdirectory();
  // @@protoc_insertion_point(field_mutable:appc.spec.ImageManifest.App.workingDirectory)
  return workingdirectory_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ImageManifest_App::release_workingdirectory() {
  // @@protoc_insertion_point(field_release:appc.spec.ImageManifest.App.workingDirectory)
  clear_has_workingdirectory();
  return workingdirectory_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ImageManifest_App::set_allocated_workingdirectory(::std::string* workingdirectory) {
  if (workingdirectory != NULL) {
    set_has_workingdirectory();
  } else {
    clear_has_workingdirectory();
  }
  workingdirectory_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), workingdirectory);
  // @@protoc_insertion_point(field_set_allocated:appc.spec.ImageManifest.App.workingDirectory)
}

// repeated .appc.spec.ImageManifest.Environment environment = 3;
inline int ImageManifest_App::environment_size() const {
  return environment_.size();
}
inline void ImageManifest_App::clear_environment() {
  environment_.Clear();
}
inline const ::appc::spec::ImageManifest_Environment& ImageManifest_App::environment(int index) const {
  // @@protoc_insertion_point(field_get:appc.spec.ImageManifest.App.environment)
  return environment_.Get(index);
}
inline ::appc::spec::ImageManifest_Environment* ImageManifest_App::mutable_environment(int index) {
  // @@protoc_insertion_point(field_mutable:appc.spec.ImageManifest.App.environment)
  return environment_.Mutable(index);
}
inline ::appc::spec::ImageManifest_Environment* ImageManifest_App::add_environment() {
  // @@protoc_insertion_point(field_add:appc.spec.ImageManifest.App.environment)
  return environment_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::appc::spec::ImageManifest_Environment >*
ImageManifest_App::mutable_environment() {
  // @@protoc_insertion_point(field_mutable_list:appc.spec.ImageManifest.App.environment)
  return &environment_;
}
inline const ::google::protobuf::RepeatedPtrField< ::appc::spec::ImageManifest_Environment >&
ImageManifest_App::environment() const {
  // @@protoc_insertion_point(field_list:appc.spec.ImageManifest.App.environment)
  return environment_;
}

// -------------------------------------------------------------------

// ImageManifest_Annotation

// required string name = 1;
inline bool ImageManifest_Annotation::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ImageManifest_Annotation::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ImageManifest_Annotation::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ImageManifest_Annotation::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& ImageManifest_Annotation::name() const {
  // @@protoc_insertion_point(field_get:appc.spec.ImageManifest.Annotation.name)
  return name_.GetNoArena();
}
inline void ImageManifest_Annotation::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:appc.spec.ImageManifest.Annotation.name)
}
#if LANG_CXX11
inline void ImageManifest_Annotation::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:appc.spec.ImageManifest.Annotation.name)
}
#endif
inline void ImageManifest_Annotation::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:appc.spec.ImageManifest.Annotation.name)
}
inline void ImageManifest_Annotation::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:appc.spec.ImageManifest.Annotation.name)
}
inline ::std::string* ImageManifest_Annotation::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:appc.spec.ImageManifest.Annotation.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ImageManifest_Annotation::release_name() {
  // @@protoc_insertion_point(field_release:appc.spec.ImageManifest.Annotation.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ImageManifest_Annotation::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:appc.spec.ImageManifest.Annotation.name)
}

// required string value = 2;
inline bool ImageManifest_Annotation::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ImageManifest_Annotation::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ImageManifest_Annotation::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ImageManifest_Annotation::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_value();
}
inline const ::std::string& ImageManifest_Annotation::value() const {
  // @@protoc_insertion_point(field_get:appc.spec.ImageManifest.Annotation.value)
  return value_.GetNoArena();
}
inline void ImageManifest_Annotation::set_value(const ::std::string& value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:appc.spec.ImageManifest.Annotation.value)
}
#if LANG_CXX11
inline void ImageManifest_Annotation::set_value(::std::string&& value) {
  set_has_value();
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:appc.spec.ImageManifest.Annotation.value)
}
#endif
inline void ImageManifest_Annotation::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:appc.spec.ImageManifest.Annotation.value)
}
inline void ImageManifest_Annotation::set_value(const char* value, size_t size) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:appc.spec.ImageManifest.Annotation.value)
}
inline ::std::string* ImageManifest_Annotation::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:appc.spec.ImageManifest.Annotation.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ImageManifest_Annotation::release_value() {
  // @@protoc_insertion_point(field_release:appc.spec.ImageManifest.Annotation.value)
  clear_has_value();
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ImageManifest_Annotation::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:appc.spec.ImageManifest.Annotation.value)
}

// -------------------------------------------------------------------

// ImageManifest_Dependency

// required string imageName = 1;
inline bool ImageManifest_Dependency::has_imagename() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ImageManifest_Dependency::set_has_imagename() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ImageManifest_Dependency::clear_has_imagename() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ImageManifest_Dependency::clear_imagename() {
  imagename_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_imagename();
}
inline const ::std::string& ImageManifest_Dependency::imagename() const {
  // @@protoc_insertion_point(field_get:appc.spec.ImageManifest.Dependency.imageName)
  return imagename_.GetNoArena();
}
inline void ImageManifest_Dependency::set_imagename(const ::std::string& value) {
  set_has_imagename();
  imagename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:appc.spec.ImageManifest.Dependency.imageName)
}
#if LANG_CXX11
inline void ImageManifest_Dependency::set_imagename(::std::string&& value) {
  set_has_imagename();
  imagename_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:appc.spec.ImageManifest.Dependency.imageName)
}
#endif
inline void ImageManifest_Dependency::set_imagename(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_imagename();
  imagename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:appc.spec.ImageManifest.Dependency.imageName)
}
inline void ImageManifest_Dependency::set_imagename(const char* value, size_t size) {
  set_has_imagename();
  imagename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:appc.spec.ImageManifest.Dependency.imageName)
}
inline ::std::string* ImageManifest_Dependency::mutable_imagename() {
  set_has_imagename();
  // @@protoc_insertion_point(field_mutable:appc.spec.ImageManifest.Dependency.imageName)
  return imagename_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ImageManifest_Dependency::release_imagename() {
  // @@protoc_insertion_point(field_release:appc.spec.ImageManifest.Dependency.imageName)
  clear_has_imagename();
  return imagename_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ImageManifest_Dependency::set_allocated_imagename(::std::string* imagename) {
  if (imagename != NULL) {
    set_has_imagename();
  } else {
    clear_has_imagename();
  }
  imagename_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), imagename);
  // @@protoc_insertion_point(field_set_allocated:appc.spec.ImageManifest.Dependency.imageName)
}

// optional string imageID = 2;
inline bool ImageManifest_Dependency::has_imageid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ImageManifest_Dependency::set_has_imageid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ImageManifest_Dependency::clear_has_imageid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ImageManifest_Dependency::clear_imageid() {
  imageid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_imageid();
}
inline const ::std::string& ImageManifest_Dependency::imageid() const {
  // @@protoc_insertion_point(field_get:appc.spec.ImageManifest.Dependency.imageID)
  return imageid_.GetNoArena();
}
inline void ImageManifest_Dependency::set_imageid(const ::std::string& value) {
  set_has_imageid();
  imageid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:appc.spec.ImageManifest.Dependency.imageID)
}
#if LANG_CXX11
inline void ImageManifest_Dependency::set_imageid(::std::string&& value) {
  set_has_imageid();
  imageid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:appc.spec.ImageManifest.Dependency.imageID)
}
#endif
inline void ImageManifest_Dependency::set_imageid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_imageid();
  imageid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:appc.spec.ImageManifest.Dependency.imageID)
}
inline void ImageManifest_Dependency::set_imageid(const char* value, size_t size) {
  set_has_imageid();
  imageid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:appc.spec.ImageManifest.Dependency.imageID)
}
inline ::std::string* ImageManifest_Dependency::mutable_imageid() {
  set_has_imageid();
  // @@protoc_insertion_point(field_mutable:appc.spec.ImageManifest.Dependency.imageID)
  return imageid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ImageManifest_Dependency::release_imageid() {
  // @@protoc_insertion_point(field_release:appc.spec.ImageManifest.Dependency.imageID)
  clear_has_imageid();
  return imageid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ImageManifest_Dependency::set_allocated_imageid(::std::string* imageid) {
  if (imageid != NULL) {
    set_has_imageid();
  } else {
    clear_has_imageid();
  }
  imageid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), imageid);
  // @@protoc_insertion_point(field_set_allocated:appc.spec.ImageManifest.Dependency.imageID)
}

// repeated .appc.spec.ImageManifest.Label labels = 3;
inline int ImageManifest_Dependency::labels_size() const {
  return labels_.size();
}
inline void ImageManifest_Dependency::clear_labels() {
  labels_.Clear();
}
inline const ::appc::spec::ImageManifest_Label& ImageManifest_Dependency::labels(int index) const {
  // @@protoc_insertion_point(field_get:appc.spec.ImageManifest.Dependency.labels)
  return labels_.Get(index);
}
inline ::appc::spec::ImageManifest_Label* ImageManifest_Dependency::mutable_labels(int index) {
  // @@protoc_insertion_point(field_mutable:appc.spec.ImageManifest.Dependency.labels)
  return labels_.Mutable(index);
}
inline ::appc::spec::ImageManifest_Label* ImageManifest_Dependency::add_labels() {
  // @@protoc_insertion_point(field_add:appc.spec.ImageManifest.Dependency.labels)
  return labels_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::appc::spec::ImageManifest_Label >*
ImageManifest_Dependency::mutable_labels() {
  // @@protoc_insertion_point(field_mutable_list:appc.spec.ImageManifest.Dependency.labels)
  return &labels_;
}
inline const ::google::protobuf::RepeatedPtrField< ::appc::spec::ImageManifest_Label >&
ImageManifest_Dependency::labels() const {
  // @@protoc_insertion_point(field_list:appc.spec.ImageManifest.Dependency.labels)
  return labels_;
}

// optional uint64 size = 4;
inline bool ImageManifest_Dependency::has_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ImageManifest_Dependency::set_has_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ImageManifest_Dependency::clear_has_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ImageManifest_Dependency::clear_size() {
  size_ = GOOGLE_ULONGLONG(0);
  clear_has_size();
}
inline ::google::protobuf::uint64 ImageManifest_Dependency::size() const {
  // @@protoc_insertion_point(field_get:appc.spec.ImageManifest.Dependency.size)
  return size_;
}
inline void ImageManifest_Dependency::set_size(::google::protobuf::uint64 value) {
  set_has_size();
  size_ = value;
  // @@protoc_insertion_point(field_set:appc.spec.ImageManifest.Dependency.size)
}

// -------------------------------------------------------------------

// ImageManifest

// required string acKind = 1;
inline bool ImageManifest::has_ackind() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ImageManifest::set_has_ackind() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ImageManifest::clear_has_ackind() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ImageManifest::clear_ackind() {
  ackind_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ackind();
}
inline const ::std::string& ImageManifest::ackind() const {
  // @@protoc_insertion_point(field_get:appc.spec.ImageManifest.acKind)
  return ackind_.GetNoArena();
}
inline void ImageManifest::set_ackind(const ::std::string& value) {
  set_has_ackind();
  ackind_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:appc.spec.ImageManifest.acKind)
}
#if LANG_CXX11
inline void ImageManifest::set_ackind(::std::string&& value) {
  set_has_ackind();
  ackind_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:appc.spec.ImageManifest.acKind)
}
#endif
inline void ImageManifest::set_ackind(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_ackind();
  ackind_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:appc.spec.ImageManifest.acKind)
}
inline void ImageManifest::set_ackind(const char* value, size_t size) {
  set_has_ackind();
  ackind_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:appc.spec.ImageManifest.acKind)
}
inline ::std::string* ImageManifest::mutable_ackind() {
  set_has_ackind();
  // @@protoc_insertion_point(field_mutable:appc.spec.ImageManifest.acKind)
  return ackind_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ImageManifest::release_ackind() {
  // @@protoc_insertion_point(field_release:appc.spec.ImageManifest.acKind)
  clear_has_ackind();
  return ackind_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ImageManifest::set_allocated_ackind(::std::string* ackind) {
  if (ackind != NULL) {
    set_has_ackind();
  } else {
    clear_has_ackind();
  }
  ackind_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ackind);
  // @@protoc_insertion_point(field_set_allocated:appc.spec.ImageManifest.acKind)
}

// required string acVersion = 2;
inline bool ImageManifest::has_acversion() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ImageManifest::set_has_acversion() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ImageManifest::clear_has_acversion() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ImageManifest::clear_acversion() {
  acversion_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_acversion();
}
inline const ::std::string& ImageManifest::acversion() const {
  // @@protoc_insertion_point(field_get:appc.spec.ImageManifest.acVersion)
  return acversion_.GetNoArena();
}
inline void ImageManifest::set_acversion(const ::std::string& value) {
  set_has_acversion();
  acversion_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:appc.spec.ImageManifest.acVersion)
}
#if LANG_CXX11
inline void ImageManifest::set_acversion(::std::string&& value) {
  set_has_acversion();
  acversion_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:appc.spec.ImageManifest.acVersion)
}
#endif
inline void ImageManifest::set_acversion(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_acversion();
  acversion_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:appc.spec.ImageManifest.acVersion)
}
inline void ImageManifest::set_acversion(const char* value, size_t size) {
  set_has_acversion();
  acversion_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:appc.spec.ImageManifest.acVersion)
}
inline ::std::string* ImageManifest::mutable_acversion() {
  set_has_acversion();
  // @@protoc_insertion_point(field_mutable:appc.spec.ImageManifest.acVersion)
  return acversion_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ImageManifest::release_acversion() {
  // @@protoc_insertion_point(field_release:appc.spec.ImageManifest.acVersion)
  clear_has_acversion();
  return acversion_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ImageManifest::set_allocated_acversion(::std::string* acversion) {
  if (acversion != NULL) {
    set_has_acversion();
  } else {
    clear_has_acversion();
  }
  acversion_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), acversion);
  // @@protoc_insertion_point(field_set_allocated:appc.spec.ImageManifest.acVersion)
}

// required string name = 3;
inline bool ImageManifest::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ImageManifest::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ImageManifest::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ImageManifest::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& ImageManifest::name() const {
  // @@protoc_insertion_point(field_get:appc.spec.ImageManifest.name)
  return name_.GetNoArena();
}
inline void ImageManifest::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:appc.spec.ImageManifest.name)
}
#if LANG_CXX11
inline void ImageManifest::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:appc.spec.ImageManifest.name)
}
#endif
inline void ImageManifest::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:appc.spec.ImageManifest.name)
}
inline void ImageManifest::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:appc.spec.ImageManifest.name)
}
inline ::std::string* ImageManifest::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:appc.spec.ImageManifest.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ImageManifest::release_name() {
  // @@protoc_insertion_point(field_release:appc.spec.ImageManifest.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ImageManifest::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:appc.spec.ImageManifest.name)
}

// repeated .appc.spec.ImageManifest.Label labels = 4;
inline int ImageManifest::labels_size() const {
  return labels_.size();
}
inline void ImageManifest::clear_labels() {
  labels_.Clear();
}
inline const ::appc::spec::ImageManifest_Label& ImageManifest::labels(int index) const {
  // @@protoc_insertion_point(field_get:appc.spec.ImageManifest.labels)
  return labels_.Get(index);
}
inline ::appc::spec::ImageManifest_Label* ImageManifest::mutable_labels(int index) {
  // @@protoc_insertion_point(field_mutable:appc.spec.ImageManifest.labels)
  return labels_.Mutable(index);
}
inline ::appc::spec::ImageManifest_Label* ImageManifest::add_labels() {
  // @@protoc_insertion_point(field_add:appc.spec.ImageManifest.labels)
  return labels_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::appc::spec::ImageManifest_Label >*
ImageManifest::mutable_labels() {
  // @@protoc_insertion_point(field_mutable_list:appc.spec.ImageManifest.labels)
  return &labels_;
}
inline const ::google::protobuf::RepeatedPtrField< ::appc::spec::ImageManifest_Label >&
ImageManifest::labels() const {
  // @@protoc_insertion_point(field_list:appc.spec.ImageManifest.labels)
  return labels_;
}

// optional .appc.spec.ImageManifest.App app = 7;
inline bool ImageManifest::has_app() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ImageManifest::set_has_app() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ImageManifest::clear_has_app() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ImageManifest::clear_app() {
  if (app_ != NULL) app_->Clear();
  clear_has_app();
}
inline const ::appc::spec::ImageManifest_App& ImageManifest::app() const {
  const ::appc::spec::ImageManifest_App* p = app_;
  // @@protoc_insertion_point(field_get:appc.spec.ImageManifest.app)
  return p != NULL ? *p : *reinterpret_cast<const ::appc::spec::ImageManifest_App*>(
      &::appc::spec::_ImageManifest_App_default_instance_);
}
inline ::appc::spec::ImageManifest_App* ImageManifest::release_app() {
  // @@protoc_insertion_point(field_release:appc.spec.ImageManifest.app)
  clear_has_app();
  ::appc::spec::ImageManifest_App* temp = app_;
  app_ = NULL;
  return temp;
}
inline ::appc::spec::ImageManifest_App* ImageManifest::mutable_app() {
  set_has_app();
  if (app_ == NULL) {
    app_ = new ::appc::spec::ImageManifest_App;
  }
  // @@protoc_insertion_point(field_mutable:appc.spec.ImageManifest.app)
  return app_;
}
inline void ImageManifest::set_allocated_app(::appc::spec::ImageManifest_App* app) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete app_;
  }
  if (app) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      app = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, app, submessage_arena);
    }
    set_has_app();
  } else {
    clear_has_app();
  }
  app_ = app;
  // @@protoc_insertion_point(field_set_allocated:appc.spec.ImageManifest.app)
}

// repeated .appc.spec.ImageManifest.Annotation annotations = 5;
inline int ImageManifest::annotations_size() const {
  return annotations_.size();
}
inline void ImageManifest::clear_annotations() {
  annotations_.Clear();
}
inline const ::appc::spec::ImageManifest_Annotation& ImageManifest::annotations(int index) const {
  // @@protoc_insertion_point(field_get:appc.spec.ImageManifest.annotations)
  return annotations_.Get(index);
}
inline ::appc::spec::ImageManifest_Annotation* ImageManifest::mutable_annotations(int index) {
  // @@protoc_insertion_point(field_mutable:appc.spec.ImageManifest.annotations)
  return annotations_.Mutable(index);
}
inline ::appc::spec::ImageManifest_Annotation* ImageManifest::add_annotations() {
  // @@protoc_insertion_point(field_add:appc.spec.ImageManifest.annotations)
  return annotations_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::appc::spec::ImageManifest_Annotation >*
ImageManifest::mutable_annotations() {
  // @@protoc_insertion_point(field_mutable_list:appc.spec.ImageManifest.annotations)
  return &annotations_;
}
inline const ::google::protobuf::RepeatedPtrField< ::appc::spec::ImageManifest_Annotation >&
ImageManifest::annotations() const {
  // @@protoc_insertion_point(field_list:appc.spec.ImageManifest.annotations)
  return annotations_;
}

// repeated .appc.spec.ImageManifest.Dependency dependencies = 6;
inline int ImageManifest::dependencies_size() const {
  return dependencies_.size();
}
inline void ImageManifest::clear_dependencies() {
  dependencies_.Clear();
}
inline const ::appc::spec::ImageManifest_Dependency& ImageManifest::dependencies(int index) const {
  // @@protoc_insertion_point(field_get:appc.spec.ImageManifest.dependencies)
  return dependencies_.Get(index);
}
inline ::appc::spec::ImageManifest_Dependency* ImageManifest::mutable_dependencies(int index) {
  // @@protoc_insertion_point(field_mutable:appc.spec.ImageManifest.dependencies)
  return dependencies_.Mutable(index);
}
inline ::appc::spec::ImageManifest_Dependency* ImageManifest::add_dependencies() {
  // @@protoc_insertion_point(field_add:appc.spec.ImageManifest.dependencies)
  return dependencies_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::appc::spec::ImageManifest_Dependency >*
ImageManifest::mutable_dependencies() {
  // @@protoc_insertion_point(field_mutable_list:appc.spec.ImageManifest.dependencies)
  return &dependencies_;
}
inline const ::google::protobuf::RepeatedPtrField< ::appc::spec::ImageManifest_Dependency >&
ImageManifest::dependencies() const {
  // @@protoc_insertion_point(field_list:appc.spec.ImageManifest.dependencies)
  return dependencies_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace spec
}  // namespace appc

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_mesos_2fappc_2fspec_2eproto__INCLUDED
