// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mesos/scheduler/scheduler.proto

#ifndef PROTOBUF_mesos_2fscheduler_2fscheduler_2eproto__INCLUDED
#define PROTOBUF_mesos_2fscheduler_2fscheduler_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "mesos/mesos.pb.h"
// @@protoc_insertion_point(includes)

namespace protobuf_mesos_2fscheduler_2fscheduler_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[31];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsEvent_SubscribedImpl();
void InitDefaultsEvent_Subscribed();
void InitDefaultsEvent_OffersImpl();
void InitDefaultsEvent_Offers();
void InitDefaultsEvent_InverseOffersImpl();
void InitDefaultsEvent_InverseOffers();
void InitDefaultsEvent_RescindImpl();
void InitDefaultsEvent_Rescind();
void InitDefaultsEvent_RescindInverseOfferImpl();
void InitDefaultsEvent_RescindInverseOffer();
void InitDefaultsEvent_UpdateImpl();
void InitDefaultsEvent_Update();
void InitDefaultsEvent_UpdateOperationStatusImpl();
void InitDefaultsEvent_UpdateOperationStatus();
void InitDefaultsEvent_MessageImpl();
void InitDefaultsEvent_Message();
void InitDefaultsEvent_FailureImpl();
void InitDefaultsEvent_Failure();
void InitDefaultsEvent_ErrorImpl();
void InitDefaultsEvent_Error();
void InitDefaultsEventImpl();
void InitDefaultsEvent();
void InitDefaultsResponse_ReconcileOperationsImpl();
void InitDefaultsResponse_ReconcileOperations();
void InitDefaultsResponseImpl();
void InitDefaultsResponse();
void InitDefaultsCall_SubscribeImpl();
void InitDefaultsCall_Subscribe();
void InitDefaultsCall_AcceptImpl();
void InitDefaultsCall_Accept();
void InitDefaultsCall_DeclineImpl();
void InitDefaultsCall_Decline();
void InitDefaultsCall_AcceptInverseOffersImpl();
void InitDefaultsCall_AcceptInverseOffers();
void InitDefaultsCall_DeclineInverseOffersImpl();
void InitDefaultsCall_DeclineInverseOffers();
void InitDefaultsCall_ReviveImpl();
void InitDefaultsCall_Revive();
void InitDefaultsCall_KillImpl();
void InitDefaultsCall_Kill();
void InitDefaultsCall_ShutdownImpl();
void InitDefaultsCall_Shutdown();
void InitDefaultsCall_AcknowledgeImpl();
void InitDefaultsCall_Acknowledge();
void InitDefaultsCall_AcknowledgeOperationStatusImpl();
void InitDefaultsCall_AcknowledgeOperationStatus();
void InitDefaultsCall_Reconcile_TaskImpl();
void InitDefaultsCall_Reconcile_Task();
void InitDefaultsCall_ReconcileImpl();
void InitDefaultsCall_Reconcile();
void InitDefaultsCall_ReconcileOperations_OperationImpl();
void InitDefaultsCall_ReconcileOperations_Operation();
void InitDefaultsCall_ReconcileOperationsImpl();
void InitDefaultsCall_ReconcileOperations();
void InitDefaultsCall_MessageImpl();
void InitDefaultsCall_Message();
void InitDefaultsCall_RequestImpl();
void InitDefaultsCall_Request();
void InitDefaultsCall_SuppressImpl();
void InitDefaultsCall_Suppress();
void InitDefaultsCallImpl();
void InitDefaultsCall();
inline void InitDefaults() {
  InitDefaultsEvent_Subscribed();
  InitDefaultsEvent_Offers();
  InitDefaultsEvent_InverseOffers();
  InitDefaultsEvent_Rescind();
  InitDefaultsEvent_RescindInverseOffer();
  InitDefaultsEvent_Update();
  InitDefaultsEvent_UpdateOperationStatus();
  InitDefaultsEvent_Message();
  InitDefaultsEvent_Failure();
  InitDefaultsEvent_Error();
  InitDefaultsEvent();
  InitDefaultsResponse_ReconcileOperations();
  InitDefaultsResponse();
  InitDefaultsCall_Subscribe();
  InitDefaultsCall_Accept();
  InitDefaultsCall_Decline();
  InitDefaultsCall_AcceptInverseOffers();
  InitDefaultsCall_DeclineInverseOffers();
  InitDefaultsCall_Revive();
  InitDefaultsCall_Kill();
  InitDefaultsCall_Shutdown();
  InitDefaultsCall_Acknowledge();
  InitDefaultsCall_AcknowledgeOperationStatus();
  InitDefaultsCall_Reconcile_Task();
  InitDefaultsCall_Reconcile();
  InitDefaultsCall_ReconcileOperations_Operation();
  InitDefaultsCall_ReconcileOperations();
  InitDefaultsCall_Message();
  InitDefaultsCall_Request();
  InitDefaultsCall_Suppress();
  InitDefaultsCall();
}
}  // namespace protobuf_mesos_2fscheduler_2fscheduler_2eproto
namespace mesos {
namespace scheduler {
class Call;
class CallDefaultTypeInternal;
extern CallDefaultTypeInternal _Call_default_instance_;
class Call_Accept;
class Call_AcceptDefaultTypeInternal;
extern Call_AcceptDefaultTypeInternal _Call_Accept_default_instance_;
class Call_AcceptInverseOffers;
class Call_AcceptInverseOffersDefaultTypeInternal;
extern Call_AcceptInverseOffersDefaultTypeInternal _Call_AcceptInverseOffers_default_instance_;
class Call_Acknowledge;
class Call_AcknowledgeDefaultTypeInternal;
extern Call_AcknowledgeDefaultTypeInternal _Call_Acknowledge_default_instance_;
class Call_AcknowledgeOperationStatus;
class Call_AcknowledgeOperationStatusDefaultTypeInternal;
extern Call_AcknowledgeOperationStatusDefaultTypeInternal _Call_AcknowledgeOperationStatus_default_instance_;
class Call_Decline;
class Call_DeclineDefaultTypeInternal;
extern Call_DeclineDefaultTypeInternal _Call_Decline_default_instance_;
class Call_DeclineInverseOffers;
class Call_DeclineInverseOffersDefaultTypeInternal;
extern Call_DeclineInverseOffersDefaultTypeInternal _Call_DeclineInverseOffers_default_instance_;
class Call_Kill;
class Call_KillDefaultTypeInternal;
extern Call_KillDefaultTypeInternal _Call_Kill_default_instance_;
class Call_Message;
class Call_MessageDefaultTypeInternal;
extern Call_MessageDefaultTypeInternal _Call_Message_default_instance_;
class Call_Reconcile;
class Call_ReconcileDefaultTypeInternal;
extern Call_ReconcileDefaultTypeInternal _Call_Reconcile_default_instance_;
class Call_ReconcileOperations;
class Call_ReconcileOperationsDefaultTypeInternal;
extern Call_ReconcileOperationsDefaultTypeInternal _Call_ReconcileOperations_default_instance_;
class Call_ReconcileOperations_Operation;
class Call_ReconcileOperations_OperationDefaultTypeInternal;
extern Call_ReconcileOperations_OperationDefaultTypeInternal _Call_ReconcileOperations_Operation_default_instance_;
class Call_Reconcile_Task;
class Call_Reconcile_TaskDefaultTypeInternal;
extern Call_Reconcile_TaskDefaultTypeInternal _Call_Reconcile_Task_default_instance_;
class Call_Request;
class Call_RequestDefaultTypeInternal;
extern Call_RequestDefaultTypeInternal _Call_Request_default_instance_;
class Call_Revive;
class Call_ReviveDefaultTypeInternal;
extern Call_ReviveDefaultTypeInternal _Call_Revive_default_instance_;
class Call_Shutdown;
class Call_ShutdownDefaultTypeInternal;
extern Call_ShutdownDefaultTypeInternal _Call_Shutdown_default_instance_;
class Call_Subscribe;
class Call_SubscribeDefaultTypeInternal;
extern Call_SubscribeDefaultTypeInternal _Call_Subscribe_default_instance_;
class Call_Suppress;
class Call_SuppressDefaultTypeInternal;
extern Call_SuppressDefaultTypeInternal _Call_Suppress_default_instance_;
class Event;
class EventDefaultTypeInternal;
extern EventDefaultTypeInternal _Event_default_instance_;
class Event_Error;
class Event_ErrorDefaultTypeInternal;
extern Event_ErrorDefaultTypeInternal _Event_Error_default_instance_;
class Event_Failure;
class Event_FailureDefaultTypeInternal;
extern Event_FailureDefaultTypeInternal _Event_Failure_default_instance_;
class Event_InverseOffers;
class Event_InverseOffersDefaultTypeInternal;
extern Event_InverseOffersDefaultTypeInternal _Event_InverseOffers_default_instance_;
class Event_Message;
class Event_MessageDefaultTypeInternal;
extern Event_MessageDefaultTypeInternal _Event_Message_default_instance_;
class Event_Offers;
class Event_OffersDefaultTypeInternal;
extern Event_OffersDefaultTypeInternal _Event_Offers_default_instance_;
class Event_Rescind;
class Event_RescindDefaultTypeInternal;
extern Event_RescindDefaultTypeInternal _Event_Rescind_default_instance_;
class Event_RescindInverseOffer;
class Event_RescindInverseOfferDefaultTypeInternal;
extern Event_RescindInverseOfferDefaultTypeInternal _Event_RescindInverseOffer_default_instance_;
class Event_Subscribed;
class Event_SubscribedDefaultTypeInternal;
extern Event_SubscribedDefaultTypeInternal _Event_Subscribed_default_instance_;
class Event_Update;
class Event_UpdateDefaultTypeInternal;
extern Event_UpdateDefaultTypeInternal _Event_Update_default_instance_;
class Event_UpdateOperationStatus;
class Event_UpdateOperationStatusDefaultTypeInternal;
extern Event_UpdateOperationStatusDefaultTypeInternal _Event_UpdateOperationStatus_default_instance_;
class Response;
class ResponseDefaultTypeInternal;
extern ResponseDefaultTypeInternal _Response_default_instance_;
class Response_ReconcileOperations;
class Response_ReconcileOperationsDefaultTypeInternal;
extern Response_ReconcileOperationsDefaultTypeInternal _Response_ReconcileOperations_default_instance_;
}  // namespace scheduler
}  // namespace mesos
namespace mesos {
namespace scheduler {

enum Event_Type {
  Event_Type_UNKNOWN = 0,
  Event_Type_SUBSCRIBED = 1,
  Event_Type_OFFERS = 2,
  Event_Type_INVERSE_OFFERS = 9,
  Event_Type_RESCIND = 3,
  Event_Type_RESCIND_INVERSE_OFFER = 10,
  Event_Type_UPDATE = 4,
  Event_Type_UPDATE_OPERATION_STATUS = 11,
  Event_Type_MESSAGE = 5,
  Event_Type_FAILURE = 6,
  Event_Type_ERROR = 7,
  Event_Type_HEARTBEAT = 8
};
bool Event_Type_IsValid(int value);
const Event_Type Event_Type_Type_MIN = Event_Type_UNKNOWN;
const Event_Type Event_Type_Type_MAX = Event_Type_UPDATE_OPERATION_STATUS;
const int Event_Type_Type_ARRAYSIZE = Event_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Event_Type_descriptor();
inline const ::std::string& Event_Type_Name(Event_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Event_Type_descriptor(), value);
}
inline bool Event_Type_Parse(
    const ::std::string& name, Event_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Event_Type>(
    Event_Type_descriptor(), name, value);
}
enum Response_Type {
  Response_Type_UNKNOWN = 0,
  Response_Type_RECONCILE_OPERATIONS = 1
};
bool Response_Type_IsValid(int value);
const Response_Type Response_Type_Type_MIN = Response_Type_UNKNOWN;
const Response_Type Response_Type_Type_MAX = Response_Type_RECONCILE_OPERATIONS;
const int Response_Type_Type_ARRAYSIZE = Response_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Response_Type_descriptor();
inline const ::std::string& Response_Type_Name(Response_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Response_Type_descriptor(), value);
}
inline bool Response_Type_Parse(
    const ::std::string& name, Response_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Response_Type>(
    Response_Type_descriptor(), name, value);
}
enum Call_Type {
  Call_Type_UNKNOWN = 0,
  Call_Type_SUBSCRIBE = 1,
  Call_Type_TEARDOWN = 2,
  Call_Type_ACCEPT = 3,
  Call_Type_DECLINE = 4,
  Call_Type_ACCEPT_INVERSE_OFFERS = 13,
  Call_Type_DECLINE_INVERSE_OFFERS = 14,
  Call_Type_REVIVE = 5,
  Call_Type_KILL = 6,
  Call_Type_SHUTDOWN = 7,
  Call_Type_ACKNOWLEDGE = 8,
  Call_Type_ACKNOWLEDGE_OPERATION_STATUS = 15,
  Call_Type_RECONCILE = 9,
  Call_Type_RECONCILE_OPERATIONS = 16,
  Call_Type_MESSAGE = 10,
  Call_Type_REQUEST = 11,
  Call_Type_SUPPRESS = 12
};
bool Call_Type_IsValid(int value);
const Call_Type Call_Type_Type_MIN = Call_Type_UNKNOWN;
const Call_Type Call_Type_Type_MAX = Call_Type_RECONCILE_OPERATIONS;
const int Call_Type_Type_ARRAYSIZE = Call_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Call_Type_descriptor();
inline const ::std::string& Call_Type_Name(Call_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Call_Type_descriptor(), value);
}
inline bool Call_Type_Parse(
    const ::std::string& name, Call_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Call_Type>(
    Call_Type_descriptor(), name, value);
}
// ===================================================================

class Event_Subscribed : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.scheduler.Event.Subscribed) */ {
 public:
  Event_Subscribed();
  virtual ~Event_Subscribed();

  Event_Subscribed(const Event_Subscribed& from);

  inline Event_Subscribed& operator=(const Event_Subscribed& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Event_Subscribed(Event_Subscribed&& from) noexcept
    : Event_Subscribed() {
    *this = ::std::move(from);
  }

  inline Event_Subscribed& operator=(Event_Subscribed&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Event_Subscribed& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Event_Subscribed* internal_default_instance() {
    return reinterpret_cast<const Event_Subscribed*>(
               &_Event_Subscribed_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void UnsafeArenaSwap(Event_Subscribed* other);
  void Swap(Event_Subscribed* other);
  friend void swap(Event_Subscribed& a, Event_Subscribed& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Event_Subscribed* New() const PROTOBUF_FINAL { return New(NULL); }

  Event_Subscribed* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Event_Subscribed& from);
  void MergeFrom(const Event_Subscribed& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Event_Subscribed* other);
  protected:
  explicit Event_Subscribed(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.FrameworkID framework_id = 1;
  bool has_framework_id() const;
  void clear_framework_id();
  static const int kFrameworkIdFieldNumber = 1;
  private:
  void _slow_mutable_framework_id();
  public:
  const ::mesos::FrameworkID& framework_id() const;
  ::mesos::FrameworkID* release_framework_id();
  ::mesos::FrameworkID* mutable_framework_id();
  void set_allocated_framework_id(::mesos::FrameworkID* framework_id);
  void unsafe_arena_set_allocated_framework_id(
      ::mesos::FrameworkID* framework_id);
  ::mesos::FrameworkID* unsafe_arena_release_framework_id();

  // optional .mesos.MasterInfo master_info = 3;
  bool has_master_info() const;
  void clear_master_info();
  static const int kMasterInfoFieldNumber = 3;
  private:
  void _slow_mutable_master_info();
  public:
  const ::mesos::MasterInfo& master_info() const;
  ::mesos::MasterInfo* release_master_info();
  ::mesos::MasterInfo* mutable_master_info();
  void set_allocated_master_info(::mesos::MasterInfo* master_info);
  void unsafe_arena_set_allocated_master_info(
      ::mesos::MasterInfo* master_info);
  ::mesos::MasterInfo* unsafe_arena_release_master_info();

  // optional double heartbeat_interval_seconds = 2;
  bool has_heartbeat_interval_seconds() const;
  void clear_heartbeat_interval_seconds();
  static const int kHeartbeatIntervalSecondsFieldNumber = 2;
  double heartbeat_interval_seconds() const;
  void set_heartbeat_interval_seconds(double value);

  // @@protoc_insertion_point(class_scope:mesos.scheduler.Event.Subscribed)
 private:
  void set_has_framework_id();
  void clear_has_framework_id();
  void set_has_heartbeat_interval_seconds();
  void clear_has_heartbeat_interval_seconds();
  void set_has_master_info();
  void clear_has_master_info();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::FrameworkID* framework_id_;
  ::mesos::MasterInfo* master_info_;
  double heartbeat_interval_seconds_;
  friend struct ::protobuf_mesos_2fscheduler_2fscheduler_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fscheduler_2fscheduler_2eproto::InitDefaultsEvent_SubscribedImpl();
};
// -------------------------------------------------------------------

class Event_Offers : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.scheduler.Event.Offers) */ {
 public:
  Event_Offers();
  virtual ~Event_Offers();

  Event_Offers(const Event_Offers& from);

  inline Event_Offers& operator=(const Event_Offers& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Event_Offers(Event_Offers&& from) noexcept
    : Event_Offers() {
    *this = ::std::move(from);
  }

  inline Event_Offers& operator=(Event_Offers&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Event_Offers& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Event_Offers* internal_default_instance() {
    return reinterpret_cast<const Event_Offers*>(
               &_Event_Offers_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void UnsafeArenaSwap(Event_Offers* other);
  void Swap(Event_Offers* other);
  friend void swap(Event_Offers& a, Event_Offers& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Event_Offers* New() const PROTOBUF_FINAL { return New(NULL); }

  Event_Offers* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Event_Offers& from);
  void MergeFrom(const Event_Offers& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Event_Offers* other);
  protected:
  explicit Event_Offers(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.Offer offers = 1;
  int offers_size() const;
  void clear_offers();
  static const int kOffersFieldNumber = 1;
  const ::mesos::Offer& offers(int index) const;
  ::mesos::Offer* mutable_offers(int index);
  ::mesos::Offer* add_offers();
  ::google::protobuf::RepeatedPtrField< ::mesos::Offer >*
      mutable_offers();
  const ::google::protobuf::RepeatedPtrField< ::mesos::Offer >&
      offers() const;

  // @@protoc_insertion_point(class_scope:mesos.scheduler.Event.Offers)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Offer > offers_;
  friend struct ::protobuf_mesos_2fscheduler_2fscheduler_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fscheduler_2fscheduler_2eproto::InitDefaultsEvent_OffersImpl();
};
// -------------------------------------------------------------------

class Event_InverseOffers : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.scheduler.Event.InverseOffers) */ {
 public:
  Event_InverseOffers();
  virtual ~Event_InverseOffers();

  Event_InverseOffers(const Event_InverseOffers& from);

  inline Event_InverseOffers& operator=(const Event_InverseOffers& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Event_InverseOffers(Event_InverseOffers&& from) noexcept
    : Event_InverseOffers() {
    *this = ::std::move(from);
  }

  inline Event_InverseOffers& operator=(Event_InverseOffers&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Event_InverseOffers& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Event_InverseOffers* internal_default_instance() {
    return reinterpret_cast<const Event_InverseOffers*>(
               &_Event_InverseOffers_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void UnsafeArenaSwap(Event_InverseOffers* other);
  void Swap(Event_InverseOffers* other);
  friend void swap(Event_InverseOffers& a, Event_InverseOffers& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Event_InverseOffers* New() const PROTOBUF_FINAL { return New(NULL); }

  Event_InverseOffers* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Event_InverseOffers& from);
  void MergeFrom(const Event_InverseOffers& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Event_InverseOffers* other);
  protected:
  explicit Event_InverseOffers(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.InverseOffer inverse_offers = 1;
  int inverse_offers_size() const;
  void clear_inverse_offers();
  static const int kInverseOffersFieldNumber = 1;
  const ::mesos::InverseOffer& inverse_offers(int index) const;
  ::mesos::InverseOffer* mutable_inverse_offers(int index);
  ::mesos::InverseOffer* add_inverse_offers();
  ::google::protobuf::RepeatedPtrField< ::mesos::InverseOffer >*
      mutable_inverse_offers();
  const ::google::protobuf::RepeatedPtrField< ::mesos::InverseOffer >&
      inverse_offers() const;

  // @@protoc_insertion_point(class_scope:mesos.scheduler.Event.InverseOffers)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::InverseOffer > inverse_offers_;
  friend struct ::protobuf_mesos_2fscheduler_2fscheduler_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fscheduler_2fscheduler_2eproto::InitDefaultsEvent_InverseOffersImpl();
};
// -------------------------------------------------------------------

class Event_Rescind : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.scheduler.Event.Rescind) */ {
 public:
  Event_Rescind();
  virtual ~Event_Rescind();

  Event_Rescind(const Event_Rescind& from);

  inline Event_Rescind& operator=(const Event_Rescind& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Event_Rescind(Event_Rescind&& from) noexcept
    : Event_Rescind() {
    *this = ::std::move(from);
  }

  inline Event_Rescind& operator=(Event_Rescind&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Event_Rescind& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Event_Rescind* internal_default_instance() {
    return reinterpret_cast<const Event_Rescind*>(
               &_Event_Rescind_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void UnsafeArenaSwap(Event_Rescind* other);
  void Swap(Event_Rescind* other);
  friend void swap(Event_Rescind& a, Event_Rescind& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Event_Rescind* New() const PROTOBUF_FINAL { return New(NULL); }

  Event_Rescind* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Event_Rescind& from);
  void MergeFrom(const Event_Rescind& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Event_Rescind* other);
  protected:
  explicit Event_Rescind(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.OfferID offer_id = 1;
  bool has_offer_id() const;
  void clear_offer_id();
  static const int kOfferIdFieldNumber = 1;
  private:
  void _slow_mutable_offer_id();
  public:
  const ::mesos::OfferID& offer_id() const;
  ::mesos::OfferID* release_offer_id();
  ::mesos::OfferID* mutable_offer_id();
  void set_allocated_offer_id(::mesos::OfferID* offer_id);
  void unsafe_arena_set_allocated_offer_id(
      ::mesos::OfferID* offer_id);
  ::mesos::OfferID* unsafe_arena_release_offer_id();

  // @@protoc_insertion_point(class_scope:mesos.scheduler.Event.Rescind)
 private:
  void set_has_offer_id();
  void clear_has_offer_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::OfferID* offer_id_;
  friend struct ::protobuf_mesos_2fscheduler_2fscheduler_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fscheduler_2fscheduler_2eproto::InitDefaultsEvent_RescindImpl();
};
// -------------------------------------------------------------------

class Event_RescindInverseOffer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.scheduler.Event.RescindInverseOffer) */ {
 public:
  Event_RescindInverseOffer();
  virtual ~Event_RescindInverseOffer();

  Event_RescindInverseOffer(const Event_RescindInverseOffer& from);

  inline Event_RescindInverseOffer& operator=(const Event_RescindInverseOffer& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Event_RescindInverseOffer(Event_RescindInverseOffer&& from) noexcept
    : Event_RescindInverseOffer() {
    *this = ::std::move(from);
  }

  inline Event_RescindInverseOffer& operator=(Event_RescindInverseOffer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Event_RescindInverseOffer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Event_RescindInverseOffer* internal_default_instance() {
    return reinterpret_cast<const Event_RescindInverseOffer*>(
               &_Event_RescindInverseOffer_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void UnsafeArenaSwap(Event_RescindInverseOffer* other);
  void Swap(Event_RescindInverseOffer* other);
  friend void swap(Event_RescindInverseOffer& a, Event_RescindInverseOffer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Event_RescindInverseOffer* New() const PROTOBUF_FINAL { return New(NULL); }

  Event_RescindInverseOffer* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Event_RescindInverseOffer& from);
  void MergeFrom(const Event_RescindInverseOffer& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Event_RescindInverseOffer* other);
  protected:
  explicit Event_RescindInverseOffer(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.OfferID inverse_offer_id = 1;
  bool has_inverse_offer_id() const;
  void clear_inverse_offer_id();
  static const int kInverseOfferIdFieldNumber = 1;
  private:
  void _slow_mutable_inverse_offer_id();
  public:
  const ::mesos::OfferID& inverse_offer_id() const;
  ::mesos::OfferID* release_inverse_offer_id();
  ::mesos::OfferID* mutable_inverse_offer_id();
  void set_allocated_inverse_offer_id(::mesos::OfferID* inverse_offer_id);
  void unsafe_arena_set_allocated_inverse_offer_id(
      ::mesos::OfferID* inverse_offer_id);
  ::mesos::OfferID* unsafe_arena_release_inverse_offer_id();

  // @@protoc_insertion_point(class_scope:mesos.scheduler.Event.RescindInverseOffer)
 private:
  void set_has_inverse_offer_id();
  void clear_has_inverse_offer_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::OfferID* inverse_offer_id_;
  friend struct ::protobuf_mesos_2fscheduler_2fscheduler_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fscheduler_2fscheduler_2eproto::InitDefaultsEvent_RescindInverseOfferImpl();
};
// -------------------------------------------------------------------

class Event_Update : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.scheduler.Event.Update) */ {
 public:
  Event_Update();
  virtual ~Event_Update();

  Event_Update(const Event_Update& from);

  inline Event_Update& operator=(const Event_Update& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Event_Update(Event_Update&& from) noexcept
    : Event_Update() {
    *this = ::std::move(from);
  }

  inline Event_Update& operator=(Event_Update&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Event_Update& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Event_Update* internal_default_instance() {
    return reinterpret_cast<const Event_Update*>(
               &_Event_Update_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void UnsafeArenaSwap(Event_Update* other);
  void Swap(Event_Update* other);
  friend void swap(Event_Update& a, Event_Update& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Event_Update* New() const PROTOBUF_FINAL { return New(NULL); }

  Event_Update* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Event_Update& from);
  void MergeFrom(const Event_Update& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Event_Update* other);
  protected:
  explicit Event_Update(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.TaskStatus status = 1;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  private:
  void _slow_mutable_status();
  public:
  const ::mesos::TaskStatus& status() const;
  ::mesos::TaskStatus* release_status();
  ::mesos::TaskStatus* mutable_status();
  void set_allocated_status(::mesos::TaskStatus* status);
  void unsafe_arena_set_allocated_status(
      ::mesos::TaskStatus* status);
  ::mesos::TaskStatus* unsafe_arena_release_status();

  // @@protoc_insertion_point(class_scope:mesos.scheduler.Event.Update)
 private:
  void set_has_status();
  void clear_has_status();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::TaskStatus* status_;
  friend struct ::protobuf_mesos_2fscheduler_2fscheduler_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fscheduler_2fscheduler_2eproto::InitDefaultsEvent_UpdateImpl();
};
// -------------------------------------------------------------------

class Event_UpdateOperationStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.scheduler.Event.UpdateOperationStatus) */ {
 public:
  Event_UpdateOperationStatus();
  virtual ~Event_UpdateOperationStatus();

  Event_UpdateOperationStatus(const Event_UpdateOperationStatus& from);

  inline Event_UpdateOperationStatus& operator=(const Event_UpdateOperationStatus& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Event_UpdateOperationStatus(Event_UpdateOperationStatus&& from) noexcept
    : Event_UpdateOperationStatus() {
    *this = ::std::move(from);
  }

  inline Event_UpdateOperationStatus& operator=(Event_UpdateOperationStatus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Event_UpdateOperationStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Event_UpdateOperationStatus* internal_default_instance() {
    return reinterpret_cast<const Event_UpdateOperationStatus*>(
               &_Event_UpdateOperationStatus_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void UnsafeArenaSwap(Event_UpdateOperationStatus* other);
  void Swap(Event_UpdateOperationStatus* other);
  friend void swap(Event_UpdateOperationStatus& a, Event_UpdateOperationStatus& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Event_UpdateOperationStatus* New() const PROTOBUF_FINAL { return New(NULL); }

  Event_UpdateOperationStatus* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Event_UpdateOperationStatus& from);
  void MergeFrom(const Event_UpdateOperationStatus& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Event_UpdateOperationStatus* other);
  protected:
  explicit Event_UpdateOperationStatus(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.OperationStatus status = 1;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  private:
  void _slow_mutable_status();
  public:
  const ::mesos::OperationStatus& status() const;
  ::mesos::OperationStatus* release_status();
  ::mesos::OperationStatus* mutable_status();
  void set_allocated_status(::mesos::OperationStatus* status);
  void unsafe_arena_set_allocated_status(
      ::mesos::OperationStatus* status);
  ::mesos::OperationStatus* unsafe_arena_release_status();

  // @@protoc_insertion_point(class_scope:mesos.scheduler.Event.UpdateOperationStatus)
 private:
  void set_has_status();
  void clear_has_status();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::OperationStatus* status_;
  friend struct ::protobuf_mesos_2fscheduler_2fscheduler_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fscheduler_2fscheduler_2eproto::InitDefaultsEvent_UpdateOperationStatusImpl();
};
// -------------------------------------------------------------------

class Event_Message : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.scheduler.Event.Message) */ {
 public:
  Event_Message();
  virtual ~Event_Message();

  Event_Message(const Event_Message& from);

  inline Event_Message& operator=(const Event_Message& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Event_Message(Event_Message&& from) noexcept
    : Event_Message() {
    *this = ::std::move(from);
  }

  inline Event_Message& operator=(Event_Message&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Event_Message& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Event_Message* internal_default_instance() {
    return reinterpret_cast<const Event_Message*>(
               &_Event_Message_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void UnsafeArenaSwap(Event_Message* other);
  void Swap(Event_Message* other);
  friend void swap(Event_Message& a, Event_Message& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Event_Message* New() const PROTOBUF_FINAL { return New(NULL); }

  Event_Message* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Event_Message& from);
  void MergeFrom(const Event_Message& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Event_Message* other);
  protected:
  explicit Event_Message(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes data = 3;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 3;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_data();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_data(
      ::std::string* data);

  // required .mesos.SlaveID slave_id = 1;
  bool has_slave_id() const;
  void clear_slave_id();
  static const int kSlaveIdFieldNumber = 1;
  private:
  void _slow_mutable_slave_id();
  public:
  const ::mesos::SlaveID& slave_id() const;
  ::mesos::SlaveID* release_slave_id();
  ::mesos::SlaveID* mutable_slave_id();
  void set_allocated_slave_id(::mesos::SlaveID* slave_id);
  void unsafe_arena_set_allocated_slave_id(
      ::mesos::SlaveID* slave_id);
  ::mesos::SlaveID* unsafe_arena_release_slave_id();

  // required .mesos.ExecutorID executor_id = 2;
  bool has_executor_id() const;
  void clear_executor_id();
  static const int kExecutorIdFieldNumber = 2;
  private:
  void _slow_mutable_executor_id();
  public:
  const ::mesos::ExecutorID& executor_id() const;
  ::mesos::ExecutorID* release_executor_id();
  ::mesos::ExecutorID* mutable_executor_id();
  void set_allocated_executor_id(::mesos::ExecutorID* executor_id);
  void unsafe_arena_set_allocated_executor_id(
      ::mesos::ExecutorID* executor_id);
  ::mesos::ExecutorID* unsafe_arena_release_executor_id();

  // @@protoc_insertion_point(class_scope:mesos.scheduler.Event.Message)
 private:
  void set_has_slave_id();
  void clear_has_slave_id();
  void set_has_executor_id();
  void clear_has_executor_id();
  void set_has_data();
  void clear_has_data();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  ::mesos::SlaveID* slave_id_;
  ::mesos::ExecutorID* executor_id_;
  friend struct ::protobuf_mesos_2fscheduler_2fscheduler_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fscheduler_2fscheduler_2eproto::InitDefaultsEvent_MessageImpl();
};
// -------------------------------------------------------------------

class Event_Failure : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.scheduler.Event.Failure) */ {
 public:
  Event_Failure();
  virtual ~Event_Failure();

  Event_Failure(const Event_Failure& from);

  inline Event_Failure& operator=(const Event_Failure& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Event_Failure(Event_Failure&& from) noexcept
    : Event_Failure() {
    *this = ::std::move(from);
  }

  inline Event_Failure& operator=(Event_Failure&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Event_Failure& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Event_Failure* internal_default_instance() {
    return reinterpret_cast<const Event_Failure*>(
               &_Event_Failure_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void UnsafeArenaSwap(Event_Failure* other);
  void Swap(Event_Failure* other);
  friend void swap(Event_Failure& a, Event_Failure& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Event_Failure* New() const PROTOBUF_FINAL { return New(NULL); }

  Event_Failure* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Event_Failure& from);
  void MergeFrom(const Event_Failure& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Event_Failure* other);
  protected:
  explicit Event_Failure(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mesos.SlaveID slave_id = 1;
  bool has_slave_id() const;
  void clear_slave_id();
  static const int kSlaveIdFieldNumber = 1;
  private:
  void _slow_mutable_slave_id();
  public:
  const ::mesos::SlaveID& slave_id() const;
  ::mesos::SlaveID* release_slave_id();
  ::mesos::SlaveID* mutable_slave_id();
  void set_allocated_slave_id(::mesos::SlaveID* slave_id);
  void unsafe_arena_set_allocated_slave_id(
      ::mesos::SlaveID* slave_id);
  ::mesos::SlaveID* unsafe_arena_release_slave_id();

  // optional .mesos.ExecutorID executor_id = 2;
  bool has_executor_id() const;
  void clear_executor_id();
  static const int kExecutorIdFieldNumber = 2;
  private:
  void _slow_mutable_executor_id();
  public:
  const ::mesos::ExecutorID& executor_id() const;
  ::mesos::ExecutorID* release_executor_id();
  ::mesos::ExecutorID* mutable_executor_id();
  void set_allocated_executor_id(::mesos::ExecutorID* executor_id);
  void unsafe_arena_set_allocated_executor_id(
      ::mesos::ExecutorID* executor_id);
  ::mesos::ExecutorID* unsafe_arena_release_executor_id();

  // optional int32 status = 3;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 3;
  ::google::protobuf::int32 status() const;
  void set_status(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:mesos.scheduler.Event.Failure)
 private:
  void set_has_slave_id();
  void clear_has_slave_id();
  void set_has_executor_id();
  void clear_has_executor_id();
  void set_has_status();
  void clear_has_status();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::SlaveID* slave_id_;
  ::mesos::ExecutorID* executor_id_;
  ::google::protobuf::int32 status_;
  friend struct ::protobuf_mesos_2fscheduler_2fscheduler_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fscheduler_2fscheduler_2eproto::InitDefaultsEvent_FailureImpl();
};
// -------------------------------------------------------------------

class Event_Error : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.scheduler.Event.Error) */ {
 public:
  Event_Error();
  virtual ~Event_Error();

  Event_Error(const Event_Error& from);

  inline Event_Error& operator=(const Event_Error& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Event_Error(Event_Error&& from) noexcept
    : Event_Error() {
    *this = ::std::move(from);
  }

  inline Event_Error& operator=(Event_Error&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Event_Error& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Event_Error* internal_default_instance() {
    return reinterpret_cast<const Event_Error*>(
               &_Event_Error_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void UnsafeArenaSwap(Event_Error* other);
  void Swap(Event_Error* other);
  friend void swap(Event_Error& a, Event_Error& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Event_Error* New() const PROTOBUF_FINAL { return New(NULL); }

  Event_Error* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Event_Error& from);
  void MergeFrom(const Event_Error& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Event_Error* other);
  protected:
  explicit Event_Error(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string message = 1;
  bool has_message() const;
  void clear_message();
  static const int kMessageFieldNumber = 1;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_message();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_message(
      ::std::string* message);

  // @@protoc_insertion_point(class_scope:mesos.scheduler.Event.Error)
 private:
  void set_has_message();
  void clear_has_message();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  friend struct ::protobuf_mesos_2fscheduler_2fscheduler_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fscheduler_2fscheduler_2eproto::InitDefaultsEvent_ErrorImpl();
};
// -------------------------------------------------------------------

class Event : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.scheduler.Event) */ {
 public:
  Event();
  virtual ~Event();

  Event(const Event& from);

  inline Event& operator=(const Event& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Event(Event&& from) noexcept
    : Event() {
    *this = ::std::move(from);
  }

  inline Event& operator=(Event&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Event& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Event* internal_default_instance() {
    return reinterpret_cast<const Event*>(
               &_Event_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void UnsafeArenaSwap(Event* other);
  void Swap(Event* other);
  friend void swap(Event& a, Event& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Event* New() const PROTOBUF_FINAL { return New(NULL); }

  Event* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Event& from);
  void MergeFrom(const Event& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Event* other);
  protected:
  explicit Event(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Event_Subscribed Subscribed;
  typedef Event_Offers Offers;
  typedef Event_InverseOffers InverseOffers;
  typedef Event_Rescind Rescind;
  typedef Event_RescindInverseOffer RescindInverseOffer;
  typedef Event_Update Update;
  typedef Event_UpdateOperationStatus UpdateOperationStatus;
  typedef Event_Message Message;
  typedef Event_Failure Failure;
  typedef Event_Error Error;

  typedef Event_Type Type;
  static const Type UNKNOWN =
    Event_Type_UNKNOWN;
  static const Type SUBSCRIBED =
    Event_Type_SUBSCRIBED;
  static const Type OFFERS =
    Event_Type_OFFERS;
  static const Type INVERSE_OFFERS =
    Event_Type_INVERSE_OFFERS;
  static const Type RESCIND =
    Event_Type_RESCIND;
  static const Type RESCIND_INVERSE_OFFER =
    Event_Type_RESCIND_INVERSE_OFFER;
  static const Type UPDATE =
    Event_Type_UPDATE;
  static const Type UPDATE_OPERATION_STATUS =
    Event_Type_UPDATE_OPERATION_STATUS;
  static const Type MESSAGE =
    Event_Type_MESSAGE;
  static const Type FAILURE =
    Event_Type_FAILURE;
  static const Type ERROR =
    Event_Type_ERROR;
  static const Type HEARTBEAT =
    Event_Type_HEARTBEAT;
  static inline bool Type_IsValid(int value) {
    return Event_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Event_Type_Type_MIN;
  static const Type Type_MAX =
    Event_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Event_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Event_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Event_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Event_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .mesos.scheduler.Event.Subscribed subscribed = 2;
  bool has_subscribed() const;
  void clear_subscribed();
  static const int kSubscribedFieldNumber = 2;
  private:
  void _slow_mutable_subscribed();
  public:
  const ::mesos::scheduler::Event_Subscribed& subscribed() const;
  ::mesos::scheduler::Event_Subscribed* release_subscribed();
  ::mesos::scheduler::Event_Subscribed* mutable_subscribed();
  void set_allocated_subscribed(::mesos::scheduler::Event_Subscribed* subscribed);
  void unsafe_arena_set_allocated_subscribed(
      ::mesos::scheduler::Event_Subscribed* subscribed);
  ::mesos::scheduler::Event_Subscribed* unsafe_arena_release_subscribed();

  // optional .mesos.scheduler.Event.Offers offers = 3;
  bool has_offers() const;
  void clear_offers();
  static const int kOffersFieldNumber = 3;
  private:
  void _slow_mutable_offers();
  public:
  const ::mesos::scheduler::Event_Offers& offers() const;
  ::mesos::scheduler::Event_Offers* release_offers();
  ::mesos::scheduler::Event_Offers* mutable_offers();
  void set_allocated_offers(::mesos::scheduler::Event_Offers* offers);
  void unsafe_arena_set_allocated_offers(
      ::mesos::scheduler::Event_Offers* offers);
  ::mesos::scheduler::Event_Offers* unsafe_arena_release_offers();

  // optional .mesos.scheduler.Event.Rescind rescind = 4;
  bool has_rescind() const;
  void clear_rescind();
  static const int kRescindFieldNumber = 4;
  private:
  void _slow_mutable_rescind();
  public:
  const ::mesos::scheduler::Event_Rescind& rescind() const;
  ::mesos::scheduler::Event_Rescind* release_rescind();
  ::mesos::scheduler::Event_Rescind* mutable_rescind();
  void set_allocated_rescind(::mesos::scheduler::Event_Rescind* rescind);
  void unsafe_arena_set_allocated_rescind(
      ::mesos::scheduler::Event_Rescind* rescind);
  ::mesos::scheduler::Event_Rescind* unsafe_arena_release_rescind();

  // optional .mesos.scheduler.Event.Update update = 5;
  bool has_update() const;
  void clear_update();
  static const int kUpdateFieldNumber = 5;
  private:
  void _slow_mutable_update();
  public:
  const ::mesos::scheduler::Event_Update& update() const;
  ::mesos::scheduler::Event_Update* release_update();
  ::mesos::scheduler::Event_Update* mutable_update();
  void set_allocated_update(::mesos::scheduler::Event_Update* update);
  void unsafe_arena_set_allocated_update(
      ::mesos::scheduler::Event_Update* update);
  ::mesos::scheduler::Event_Update* unsafe_arena_release_update();

  // optional .mesos.scheduler.Event.Message message = 6;
  bool has_message() const;
  void clear_message();
  static const int kMessageFieldNumber = 6;
  private:
  void _slow_mutable_message();
  public:
  const ::mesos::scheduler::Event_Message& message() const;
  ::mesos::scheduler::Event_Message* release_message();
  ::mesos::scheduler::Event_Message* mutable_message();
  void set_allocated_message(::mesos::scheduler::Event_Message* message);
  void unsafe_arena_set_allocated_message(
      ::mesos::scheduler::Event_Message* message);
  ::mesos::scheduler::Event_Message* unsafe_arena_release_message();

  // optional .mesos.scheduler.Event.Failure failure = 7;
  bool has_failure() const;
  void clear_failure();
  static const int kFailureFieldNumber = 7;
  private:
  void _slow_mutable_failure();
  public:
  const ::mesos::scheduler::Event_Failure& failure() const;
  ::mesos::scheduler::Event_Failure* release_failure();
  ::mesos::scheduler::Event_Failure* mutable_failure();
  void set_allocated_failure(::mesos::scheduler::Event_Failure* failure);
  void unsafe_arena_set_allocated_failure(
      ::mesos::scheduler::Event_Failure* failure);
  ::mesos::scheduler::Event_Failure* unsafe_arena_release_failure();

  // optional .mesos.scheduler.Event.Error error = 8;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 8;
  private:
  void _slow_mutable_error();
  public:
  const ::mesos::scheduler::Event_Error& error() const;
  ::mesos::scheduler::Event_Error* release_error();
  ::mesos::scheduler::Event_Error* mutable_error();
  void set_allocated_error(::mesos::scheduler::Event_Error* error);
  void unsafe_arena_set_allocated_error(
      ::mesos::scheduler::Event_Error* error);
  ::mesos::scheduler::Event_Error* unsafe_arena_release_error();

  // optional .mesos.scheduler.Event.InverseOffers inverse_offers = 9;
  bool has_inverse_offers() const;
  void clear_inverse_offers();
  static const int kInverseOffersFieldNumber = 9;
  private:
  void _slow_mutable_inverse_offers();
  public:
  const ::mesos::scheduler::Event_InverseOffers& inverse_offers() const;
  ::mesos::scheduler::Event_InverseOffers* release_inverse_offers();
  ::mesos::scheduler::Event_InverseOffers* mutable_inverse_offers();
  void set_allocated_inverse_offers(::mesos::scheduler::Event_InverseOffers* inverse_offers);
  void unsafe_arena_set_allocated_inverse_offers(
      ::mesos::scheduler::Event_InverseOffers* inverse_offers);
  ::mesos::scheduler::Event_InverseOffers* unsafe_arena_release_inverse_offers();

  // optional .mesos.scheduler.Event.RescindInverseOffer rescind_inverse_offer = 10;
  bool has_rescind_inverse_offer() const;
  void clear_rescind_inverse_offer();
  static const int kRescindInverseOfferFieldNumber = 10;
  private:
  void _slow_mutable_rescind_inverse_offer();
  public:
  const ::mesos::scheduler::Event_RescindInverseOffer& rescind_inverse_offer() const;
  ::mesos::scheduler::Event_RescindInverseOffer* release_rescind_inverse_offer();
  ::mesos::scheduler::Event_RescindInverseOffer* mutable_rescind_inverse_offer();
  void set_allocated_rescind_inverse_offer(::mesos::scheduler::Event_RescindInverseOffer* rescind_inverse_offer);
  void unsafe_arena_set_allocated_rescind_inverse_offer(
      ::mesos::scheduler::Event_RescindInverseOffer* rescind_inverse_offer);
  ::mesos::scheduler::Event_RescindInverseOffer* unsafe_arena_release_rescind_inverse_offer();

  // optional .mesos.scheduler.Event.UpdateOperationStatus update_operation_status = 11;
  bool has_update_operation_status() const;
  void clear_update_operation_status();
  static const int kUpdateOperationStatusFieldNumber = 11;
  private:
  void _slow_mutable_update_operation_status();
  public:
  const ::mesos::scheduler::Event_UpdateOperationStatus& update_operation_status() const;
  ::mesos::scheduler::Event_UpdateOperationStatus* release_update_operation_status();
  ::mesos::scheduler::Event_UpdateOperationStatus* mutable_update_operation_status();
  void set_allocated_update_operation_status(::mesos::scheduler::Event_UpdateOperationStatus* update_operation_status);
  void unsafe_arena_set_allocated_update_operation_status(
      ::mesos::scheduler::Event_UpdateOperationStatus* update_operation_status);
  ::mesos::scheduler::Event_UpdateOperationStatus* unsafe_arena_release_update_operation_status();

  // optional .mesos.scheduler.Event.Type type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::mesos::scheduler::Event_Type type() const;
  void set_type(::mesos::scheduler::Event_Type value);

  // @@protoc_insertion_point(class_scope:mesos.scheduler.Event)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_subscribed();
  void clear_has_subscribed();
  void set_has_offers();
  void clear_has_offers();
  void set_has_inverse_offers();
  void clear_has_inverse_offers();
  void set_has_rescind();
  void clear_has_rescind();
  void set_has_rescind_inverse_offer();
  void clear_has_rescind_inverse_offer();
  void set_has_update();
  void clear_has_update();
  void set_has_update_operation_status();
  void clear_has_update_operation_status();
  void set_has_message();
  void clear_has_message();
  void set_has_failure();
  void clear_has_failure();
  void set_has_error();
  void clear_has_error();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::scheduler::Event_Subscribed* subscribed_;
  ::mesos::scheduler::Event_Offers* offers_;
  ::mesos::scheduler::Event_Rescind* rescind_;
  ::mesos::scheduler::Event_Update* update_;
  ::mesos::scheduler::Event_Message* message_;
  ::mesos::scheduler::Event_Failure* failure_;
  ::mesos::scheduler::Event_Error* error_;
  ::mesos::scheduler::Event_InverseOffers* inverse_offers_;
  ::mesos::scheduler::Event_RescindInverseOffer* rescind_inverse_offer_;
  ::mesos::scheduler::Event_UpdateOperationStatus* update_operation_status_;
  int type_;
  friend struct ::protobuf_mesos_2fscheduler_2fscheduler_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fscheduler_2fscheduler_2eproto::InitDefaultsEventImpl();
};
// -------------------------------------------------------------------

class Response_ReconcileOperations : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.scheduler.Response.ReconcileOperations) */ {
 public:
  Response_ReconcileOperations();
  virtual ~Response_ReconcileOperations();

  Response_ReconcileOperations(const Response_ReconcileOperations& from);

  inline Response_ReconcileOperations& operator=(const Response_ReconcileOperations& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Response_ReconcileOperations(Response_ReconcileOperations&& from) noexcept
    : Response_ReconcileOperations() {
    *this = ::std::move(from);
  }

  inline Response_ReconcileOperations& operator=(Response_ReconcileOperations&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Response_ReconcileOperations& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Response_ReconcileOperations* internal_default_instance() {
    return reinterpret_cast<const Response_ReconcileOperations*>(
               &_Response_ReconcileOperations_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void UnsafeArenaSwap(Response_ReconcileOperations* other);
  void Swap(Response_ReconcileOperations* other);
  friend void swap(Response_ReconcileOperations& a, Response_ReconcileOperations& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Response_ReconcileOperations* New() const PROTOBUF_FINAL { return New(NULL); }

  Response_ReconcileOperations* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Response_ReconcileOperations& from);
  void MergeFrom(const Response_ReconcileOperations& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Response_ReconcileOperations* other);
  protected:
  explicit Response_ReconcileOperations(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.OperationStatus operation_statuses = 1;
  int operation_statuses_size() const;
  void clear_operation_statuses();
  static const int kOperationStatusesFieldNumber = 1;
  const ::mesos::OperationStatus& operation_statuses(int index) const;
  ::mesos::OperationStatus* mutable_operation_statuses(int index);
  ::mesos::OperationStatus* add_operation_statuses();
  ::google::protobuf::RepeatedPtrField< ::mesos::OperationStatus >*
      mutable_operation_statuses();
  const ::google::protobuf::RepeatedPtrField< ::mesos::OperationStatus >&
      operation_statuses() const;

  // @@protoc_insertion_point(class_scope:mesos.scheduler.Response.ReconcileOperations)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::OperationStatus > operation_statuses_;
  friend struct ::protobuf_mesos_2fscheduler_2fscheduler_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fscheduler_2fscheduler_2eproto::InitDefaultsResponse_ReconcileOperationsImpl();
};
// -------------------------------------------------------------------

class Response : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.scheduler.Response) */ {
 public:
  Response();
  virtual ~Response();

  Response(const Response& from);

  inline Response& operator=(const Response& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Response(Response&& from) noexcept
    : Response() {
    *this = ::std::move(from);
  }

  inline Response& operator=(Response&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Response& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Response* internal_default_instance() {
    return reinterpret_cast<const Response*>(
               &_Response_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void UnsafeArenaSwap(Response* other);
  void Swap(Response* other);
  friend void swap(Response& a, Response& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Response* New() const PROTOBUF_FINAL { return New(NULL); }

  Response* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Response& from);
  void MergeFrom(const Response& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Response* other);
  protected:
  explicit Response(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Response_ReconcileOperations ReconcileOperations;

  typedef Response_Type Type;
  static const Type UNKNOWN =
    Response_Type_UNKNOWN;
  static const Type RECONCILE_OPERATIONS =
    Response_Type_RECONCILE_OPERATIONS;
  static inline bool Type_IsValid(int value) {
    return Response_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Response_Type_Type_MIN;
  static const Type Type_MAX =
    Response_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Response_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Response_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Response_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Response_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .mesos.scheduler.Response.ReconcileOperations reconcile_operations = 2;
  bool has_reconcile_operations() const;
  void clear_reconcile_operations();
  static const int kReconcileOperationsFieldNumber = 2;
  private:
  void _slow_mutable_reconcile_operations();
  public:
  const ::mesos::scheduler::Response_ReconcileOperations& reconcile_operations() const;
  ::mesos::scheduler::Response_ReconcileOperations* release_reconcile_operations();
  ::mesos::scheduler::Response_ReconcileOperations* mutable_reconcile_operations();
  void set_allocated_reconcile_operations(::mesos::scheduler::Response_ReconcileOperations* reconcile_operations);
  void unsafe_arena_set_allocated_reconcile_operations(
      ::mesos::scheduler::Response_ReconcileOperations* reconcile_operations);
  ::mesos::scheduler::Response_ReconcileOperations* unsafe_arena_release_reconcile_operations();

  // optional .mesos.scheduler.Response.Type type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::mesos::scheduler::Response_Type type() const;
  void set_type(::mesos::scheduler::Response_Type value);

  // @@protoc_insertion_point(class_scope:mesos.scheduler.Response)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_reconcile_operations();
  void clear_has_reconcile_operations();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::scheduler::Response_ReconcileOperations* reconcile_operations_;
  int type_;
  friend struct ::protobuf_mesos_2fscheduler_2fscheduler_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fscheduler_2fscheduler_2eproto::InitDefaultsResponseImpl();
};
// -------------------------------------------------------------------

class Call_Subscribe : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.scheduler.Call.Subscribe) */ {
 public:
  Call_Subscribe();
  virtual ~Call_Subscribe();

  Call_Subscribe(const Call_Subscribe& from);

  inline Call_Subscribe& operator=(const Call_Subscribe& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Call_Subscribe(Call_Subscribe&& from) noexcept
    : Call_Subscribe() {
    *this = ::std::move(from);
  }

  inline Call_Subscribe& operator=(Call_Subscribe&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Call_Subscribe& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Call_Subscribe* internal_default_instance() {
    return reinterpret_cast<const Call_Subscribe*>(
               &_Call_Subscribe_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void UnsafeArenaSwap(Call_Subscribe* other);
  void Swap(Call_Subscribe* other);
  friend void swap(Call_Subscribe& a, Call_Subscribe& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Call_Subscribe* New() const PROTOBUF_FINAL { return New(NULL); }

  Call_Subscribe* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Call_Subscribe& from);
  void MergeFrom(const Call_Subscribe& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Call_Subscribe* other);
  protected:
  explicit Call_Subscribe(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string suppressed_roles = 3;
  int suppressed_roles_size() const;
  void clear_suppressed_roles();
  static const int kSuppressedRolesFieldNumber = 3;
  const ::std::string& suppressed_roles(int index) const;
  ::std::string* mutable_suppressed_roles(int index);
  void set_suppressed_roles(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_suppressed_roles(int index, ::std::string&& value);
  #endif
  void set_suppressed_roles(int index, const char* value);
  void set_suppressed_roles(int index, const char* value, size_t size);
  ::std::string* add_suppressed_roles();
  void add_suppressed_roles(const ::std::string& value);
  #if LANG_CXX11
  void add_suppressed_roles(::std::string&& value);
  #endif
  void add_suppressed_roles(const char* value);
  void add_suppressed_roles(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& suppressed_roles() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_suppressed_roles();

  // required .mesos.FrameworkInfo framework_info = 1;
  bool has_framework_info() const;
  void clear_framework_info();
  static const int kFrameworkInfoFieldNumber = 1;
  private:
  void _slow_mutable_framework_info();
  public:
  const ::mesos::FrameworkInfo& framework_info() const;
  ::mesos::FrameworkInfo* release_framework_info();
  ::mesos::FrameworkInfo* mutable_framework_info();
  void set_allocated_framework_info(::mesos::FrameworkInfo* framework_info);
  void unsafe_arena_set_allocated_framework_info(
      ::mesos::FrameworkInfo* framework_info);
  ::mesos::FrameworkInfo* unsafe_arena_release_framework_info();

  // optional bool force = 2;
  bool has_force() const;
  void clear_force();
  static const int kForceFieldNumber = 2;
  bool force() const;
  void set_force(bool value);

  // @@protoc_insertion_point(class_scope:mesos.scheduler.Call.Subscribe)
 private:
  void set_has_framework_info();
  void clear_has_framework_info();
  void set_has_force();
  void clear_has_force();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> suppressed_roles_;
  ::mesos::FrameworkInfo* framework_info_;
  bool force_;
  friend struct ::protobuf_mesos_2fscheduler_2fscheduler_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fscheduler_2fscheduler_2eproto::InitDefaultsCall_SubscribeImpl();
};
// -------------------------------------------------------------------

class Call_Accept : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.scheduler.Call.Accept) */ {
 public:
  Call_Accept();
  virtual ~Call_Accept();

  Call_Accept(const Call_Accept& from);

  inline Call_Accept& operator=(const Call_Accept& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Call_Accept(Call_Accept&& from) noexcept
    : Call_Accept() {
    *this = ::std::move(from);
  }

  inline Call_Accept& operator=(Call_Accept&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Call_Accept& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Call_Accept* internal_default_instance() {
    return reinterpret_cast<const Call_Accept*>(
               &_Call_Accept_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    14;

  void UnsafeArenaSwap(Call_Accept* other);
  void Swap(Call_Accept* other);
  friend void swap(Call_Accept& a, Call_Accept& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Call_Accept* New() const PROTOBUF_FINAL { return New(NULL); }

  Call_Accept* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Call_Accept& from);
  void MergeFrom(const Call_Accept& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Call_Accept* other);
  protected:
  explicit Call_Accept(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.OfferID offer_ids = 1;
  int offer_ids_size() const;
  void clear_offer_ids();
  static const int kOfferIdsFieldNumber = 1;
  const ::mesos::OfferID& offer_ids(int index) const;
  ::mesos::OfferID* mutable_offer_ids(int index);
  ::mesos::OfferID* add_offer_ids();
  ::google::protobuf::RepeatedPtrField< ::mesos::OfferID >*
      mutable_offer_ids();
  const ::google::protobuf::RepeatedPtrField< ::mesos::OfferID >&
      offer_ids() const;

  // repeated .mesos.Offer.Operation operations = 2;
  int operations_size() const;
  void clear_operations();
  static const int kOperationsFieldNumber = 2;
  const ::mesos::Offer_Operation& operations(int index) const;
  ::mesos::Offer_Operation* mutable_operations(int index);
  ::mesos::Offer_Operation* add_operations();
  ::google::protobuf::RepeatedPtrField< ::mesos::Offer_Operation >*
      mutable_operations();
  const ::google::protobuf::RepeatedPtrField< ::mesos::Offer_Operation >&
      operations() const;

  // optional .mesos.Filters filters = 3;
  bool has_filters() const;
  void clear_filters();
  static const int kFiltersFieldNumber = 3;
  private:
  void _slow_mutable_filters();
  public:
  const ::mesos::Filters& filters() const;
  ::mesos::Filters* release_filters();
  ::mesos::Filters* mutable_filters();
  void set_allocated_filters(::mesos::Filters* filters);
  void unsafe_arena_set_allocated_filters(
      ::mesos::Filters* filters);
  ::mesos::Filters* unsafe_arena_release_filters();

  // @@protoc_insertion_point(class_scope:mesos.scheduler.Call.Accept)
 private:
  void set_has_filters();
  void clear_has_filters();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::OfferID > offer_ids_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Offer_Operation > operations_;
  ::mesos::Filters* filters_;
  friend struct ::protobuf_mesos_2fscheduler_2fscheduler_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fscheduler_2fscheduler_2eproto::InitDefaultsCall_AcceptImpl();
};
// -------------------------------------------------------------------

class Call_Decline : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.scheduler.Call.Decline) */ {
 public:
  Call_Decline();
  virtual ~Call_Decline();

  Call_Decline(const Call_Decline& from);

  inline Call_Decline& operator=(const Call_Decline& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Call_Decline(Call_Decline&& from) noexcept
    : Call_Decline() {
    *this = ::std::move(from);
  }

  inline Call_Decline& operator=(Call_Decline&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Call_Decline& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Call_Decline* internal_default_instance() {
    return reinterpret_cast<const Call_Decline*>(
               &_Call_Decline_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    15;

  void UnsafeArenaSwap(Call_Decline* other);
  void Swap(Call_Decline* other);
  friend void swap(Call_Decline& a, Call_Decline& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Call_Decline* New() const PROTOBUF_FINAL { return New(NULL); }

  Call_Decline* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Call_Decline& from);
  void MergeFrom(const Call_Decline& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Call_Decline* other);
  protected:
  explicit Call_Decline(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.OfferID offer_ids = 1;
  int offer_ids_size() const;
  void clear_offer_ids();
  static const int kOfferIdsFieldNumber = 1;
  const ::mesos::OfferID& offer_ids(int index) const;
  ::mesos::OfferID* mutable_offer_ids(int index);
  ::mesos::OfferID* add_offer_ids();
  ::google::protobuf::RepeatedPtrField< ::mesos::OfferID >*
      mutable_offer_ids();
  const ::google::protobuf::RepeatedPtrField< ::mesos::OfferID >&
      offer_ids() const;

  // optional .mesos.Filters filters = 2;
  bool has_filters() const;
  void clear_filters();
  static const int kFiltersFieldNumber = 2;
  private:
  void _slow_mutable_filters();
  public:
  const ::mesos::Filters& filters() const;
  ::mesos::Filters* release_filters();
  ::mesos::Filters* mutable_filters();
  void set_allocated_filters(::mesos::Filters* filters);
  void unsafe_arena_set_allocated_filters(
      ::mesos::Filters* filters);
  ::mesos::Filters* unsafe_arena_release_filters();

  // @@protoc_insertion_point(class_scope:mesos.scheduler.Call.Decline)
 private:
  void set_has_filters();
  void clear_has_filters();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::OfferID > offer_ids_;
  ::mesos::Filters* filters_;
  friend struct ::protobuf_mesos_2fscheduler_2fscheduler_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fscheduler_2fscheduler_2eproto::InitDefaultsCall_DeclineImpl();
};
// -------------------------------------------------------------------

class Call_AcceptInverseOffers : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.scheduler.Call.AcceptInverseOffers) */ {
 public:
  Call_AcceptInverseOffers();
  virtual ~Call_AcceptInverseOffers();

  Call_AcceptInverseOffers(const Call_AcceptInverseOffers& from);

  inline Call_AcceptInverseOffers& operator=(const Call_AcceptInverseOffers& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Call_AcceptInverseOffers(Call_AcceptInverseOffers&& from) noexcept
    : Call_AcceptInverseOffers() {
    *this = ::std::move(from);
  }

  inline Call_AcceptInverseOffers& operator=(Call_AcceptInverseOffers&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Call_AcceptInverseOffers& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Call_AcceptInverseOffers* internal_default_instance() {
    return reinterpret_cast<const Call_AcceptInverseOffers*>(
               &_Call_AcceptInverseOffers_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    16;

  void UnsafeArenaSwap(Call_AcceptInverseOffers* other);
  void Swap(Call_AcceptInverseOffers* other);
  friend void swap(Call_AcceptInverseOffers& a, Call_AcceptInverseOffers& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Call_AcceptInverseOffers* New() const PROTOBUF_FINAL { return New(NULL); }

  Call_AcceptInverseOffers* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Call_AcceptInverseOffers& from);
  void MergeFrom(const Call_AcceptInverseOffers& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Call_AcceptInverseOffers* other);
  protected:
  explicit Call_AcceptInverseOffers(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.OfferID inverse_offer_ids = 1;
  int inverse_offer_ids_size() const;
  void clear_inverse_offer_ids();
  static const int kInverseOfferIdsFieldNumber = 1;
  const ::mesos::OfferID& inverse_offer_ids(int index) const;
  ::mesos::OfferID* mutable_inverse_offer_ids(int index);
  ::mesos::OfferID* add_inverse_offer_ids();
  ::google::protobuf::RepeatedPtrField< ::mesos::OfferID >*
      mutable_inverse_offer_ids();
  const ::google::protobuf::RepeatedPtrField< ::mesos::OfferID >&
      inverse_offer_ids() const;

  // optional .mesos.Filters filters = 2;
  bool has_filters() const;
  void clear_filters();
  static const int kFiltersFieldNumber = 2;
  private:
  void _slow_mutable_filters();
  public:
  const ::mesos::Filters& filters() const;
  ::mesos::Filters* release_filters();
  ::mesos::Filters* mutable_filters();
  void set_allocated_filters(::mesos::Filters* filters);
  void unsafe_arena_set_allocated_filters(
      ::mesos::Filters* filters);
  ::mesos::Filters* unsafe_arena_release_filters();

  // @@protoc_insertion_point(class_scope:mesos.scheduler.Call.AcceptInverseOffers)
 private:
  void set_has_filters();
  void clear_has_filters();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::OfferID > inverse_offer_ids_;
  ::mesos::Filters* filters_;
  friend struct ::protobuf_mesos_2fscheduler_2fscheduler_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fscheduler_2fscheduler_2eproto::InitDefaultsCall_AcceptInverseOffersImpl();
};
// -------------------------------------------------------------------

class Call_DeclineInverseOffers : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.scheduler.Call.DeclineInverseOffers) */ {
 public:
  Call_DeclineInverseOffers();
  virtual ~Call_DeclineInverseOffers();

  Call_DeclineInverseOffers(const Call_DeclineInverseOffers& from);

  inline Call_DeclineInverseOffers& operator=(const Call_DeclineInverseOffers& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Call_DeclineInverseOffers(Call_DeclineInverseOffers&& from) noexcept
    : Call_DeclineInverseOffers() {
    *this = ::std::move(from);
  }

  inline Call_DeclineInverseOffers& operator=(Call_DeclineInverseOffers&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Call_DeclineInverseOffers& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Call_DeclineInverseOffers* internal_default_instance() {
    return reinterpret_cast<const Call_DeclineInverseOffers*>(
               &_Call_DeclineInverseOffers_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    17;

  void UnsafeArenaSwap(Call_DeclineInverseOffers* other);
  void Swap(Call_DeclineInverseOffers* other);
  friend void swap(Call_DeclineInverseOffers& a, Call_DeclineInverseOffers& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Call_DeclineInverseOffers* New() const PROTOBUF_FINAL { return New(NULL); }

  Call_DeclineInverseOffers* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Call_DeclineInverseOffers& from);
  void MergeFrom(const Call_DeclineInverseOffers& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Call_DeclineInverseOffers* other);
  protected:
  explicit Call_DeclineInverseOffers(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.OfferID inverse_offer_ids = 1;
  int inverse_offer_ids_size() const;
  void clear_inverse_offer_ids();
  static const int kInverseOfferIdsFieldNumber = 1;
  const ::mesos::OfferID& inverse_offer_ids(int index) const;
  ::mesos::OfferID* mutable_inverse_offer_ids(int index);
  ::mesos::OfferID* add_inverse_offer_ids();
  ::google::protobuf::RepeatedPtrField< ::mesos::OfferID >*
      mutable_inverse_offer_ids();
  const ::google::protobuf::RepeatedPtrField< ::mesos::OfferID >&
      inverse_offer_ids() const;

  // optional .mesos.Filters filters = 2;
  bool has_filters() const;
  void clear_filters();
  static const int kFiltersFieldNumber = 2;
  private:
  void _slow_mutable_filters();
  public:
  const ::mesos::Filters& filters() const;
  ::mesos::Filters* release_filters();
  ::mesos::Filters* mutable_filters();
  void set_allocated_filters(::mesos::Filters* filters);
  void unsafe_arena_set_allocated_filters(
      ::mesos::Filters* filters);
  ::mesos::Filters* unsafe_arena_release_filters();

  // @@protoc_insertion_point(class_scope:mesos.scheduler.Call.DeclineInverseOffers)
 private:
  void set_has_filters();
  void clear_has_filters();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::OfferID > inverse_offer_ids_;
  ::mesos::Filters* filters_;
  friend struct ::protobuf_mesos_2fscheduler_2fscheduler_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fscheduler_2fscheduler_2eproto::InitDefaultsCall_DeclineInverseOffersImpl();
};
// -------------------------------------------------------------------

class Call_Revive : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.scheduler.Call.Revive) */ {
 public:
  Call_Revive();
  virtual ~Call_Revive();

  Call_Revive(const Call_Revive& from);

  inline Call_Revive& operator=(const Call_Revive& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Call_Revive(Call_Revive&& from) noexcept
    : Call_Revive() {
    *this = ::std::move(from);
  }

  inline Call_Revive& operator=(Call_Revive&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Call_Revive& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Call_Revive* internal_default_instance() {
    return reinterpret_cast<const Call_Revive*>(
               &_Call_Revive_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    18;

  void UnsafeArenaSwap(Call_Revive* other);
  void Swap(Call_Revive* other);
  friend void swap(Call_Revive& a, Call_Revive& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Call_Revive* New() const PROTOBUF_FINAL { return New(NULL); }

  Call_Revive* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Call_Revive& from);
  void MergeFrom(const Call_Revive& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Call_Revive* other);
  protected:
  explicit Call_Revive(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string roles = 1;
  int roles_size() const;
  void clear_roles();
  static const int kRolesFieldNumber = 1;
  const ::std::string& roles(int index) const;
  ::std::string* mutable_roles(int index);
  void set_roles(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_roles(int index, ::std::string&& value);
  #endif
  void set_roles(int index, const char* value);
  void set_roles(int index, const char* value, size_t size);
  ::std::string* add_roles();
  void add_roles(const ::std::string& value);
  #if LANG_CXX11
  void add_roles(::std::string&& value);
  #endif
  void add_roles(const char* value);
  void add_roles(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& roles() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_roles();

  // @@protoc_insertion_point(class_scope:mesos.scheduler.Call.Revive)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> roles_;
  friend struct ::protobuf_mesos_2fscheduler_2fscheduler_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fscheduler_2fscheduler_2eproto::InitDefaultsCall_ReviveImpl();
};
// -------------------------------------------------------------------

class Call_Kill : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.scheduler.Call.Kill) */ {
 public:
  Call_Kill();
  virtual ~Call_Kill();

  Call_Kill(const Call_Kill& from);

  inline Call_Kill& operator=(const Call_Kill& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Call_Kill(Call_Kill&& from) noexcept
    : Call_Kill() {
    *this = ::std::move(from);
  }

  inline Call_Kill& operator=(Call_Kill&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Call_Kill& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Call_Kill* internal_default_instance() {
    return reinterpret_cast<const Call_Kill*>(
               &_Call_Kill_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    19;

  void UnsafeArenaSwap(Call_Kill* other);
  void Swap(Call_Kill* other);
  friend void swap(Call_Kill& a, Call_Kill& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Call_Kill* New() const PROTOBUF_FINAL { return New(NULL); }

  Call_Kill* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Call_Kill& from);
  void MergeFrom(const Call_Kill& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Call_Kill* other);
  protected:
  explicit Call_Kill(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.TaskID task_id = 1;
  bool has_task_id() const;
  void clear_task_id();
  static const int kTaskIdFieldNumber = 1;
  private:
  void _slow_mutable_task_id();
  public:
  const ::mesos::TaskID& task_id() const;
  ::mesos::TaskID* release_task_id();
  ::mesos::TaskID* mutable_task_id();
  void set_allocated_task_id(::mesos::TaskID* task_id);
  void unsafe_arena_set_allocated_task_id(
      ::mesos::TaskID* task_id);
  ::mesos::TaskID* unsafe_arena_release_task_id();

  // optional .mesos.SlaveID slave_id = 2;
  bool has_slave_id() const;
  void clear_slave_id();
  static const int kSlaveIdFieldNumber = 2;
  private:
  void _slow_mutable_slave_id();
  public:
  const ::mesos::SlaveID& slave_id() const;
  ::mesos::SlaveID* release_slave_id();
  ::mesos::SlaveID* mutable_slave_id();
  void set_allocated_slave_id(::mesos::SlaveID* slave_id);
  void unsafe_arena_set_allocated_slave_id(
      ::mesos::SlaveID* slave_id);
  ::mesos::SlaveID* unsafe_arena_release_slave_id();

  // optional .mesos.KillPolicy kill_policy = 3;
  bool has_kill_policy() const;
  void clear_kill_policy();
  static const int kKillPolicyFieldNumber = 3;
  private:
  void _slow_mutable_kill_policy();
  public:
  const ::mesos::KillPolicy& kill_policy() const;
  ::mesos::KillPolicy* release_kill_policy();
  ::mesos::KillPolicy* mutable_kill_policy();
  void set_allocated_kill_policy(::mesos::KillPolicy* kill_policy);
  void unsafe_arena_set_allocated_kill_policy(
      ::mesos::KillPolicy* kill_policy);
  ::mesos::KillPolicy* unsafe_arena_release_kill_policy();

  // @@protoc_insertion_point(class_scope:mesos.scheduler.Call.Kill)
 private:
  void set_has_task_id();
  void clear_has_task_id();
  void set_has_slave_id();
  void clear_has_slave_id();
  void set_has_kill_policy();
  void clear_has_kill_policy();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::TaskID* task_id_;
  ::mesos::SlaveID* slave_id_;
  ::mesos::KillPolicy* kill_policy_;
  friend struct ::protobuf_mesos_2fscheduler_2fscheduler_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fscheduler_2fscheduler_2eproto::InitDefaultsCall_KillImpl();
};
// -------------------------------------------------------------------

class Call_Shutdown : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.scheduler.Call.Shutdown) */ {
 public:
  Call_Shutdown();
  virtual ~Call_Shutdown();

  Call_Shutdown(const Call_Shutdown& from);

  inline Call_Shutdown& operator=(const Call_Shutdown& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Call_Shutdown(Call_Shutdown&& from) noexcept
    : Call_Shutdown() {
    *this = ::std::move(from);
  }

  inline Call_Shutdown& operator=(Call_Shutdown&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Call_Shutdown& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Call_Shutdown* internal_default_instance() {
    return reinterpret_cast<const Call_Shutdown*>(
               &_Call_Shutdown_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    20;

  void UnsafeArenaSwap(Call_Shutdown* other);
  void Swap(Call_Shutdown* other);
  friend void swap(Call_Shutdown& a, Call_Shutdown& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Call_Shutdown* New() const PROTOBUF_FINAL { return New(NULL); }

  Call_Shutdown* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Call_Shutdown& from);
  void MergeFrom(const Call_Shutdown& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Call_Shutdown* other);
  protected:
  explicit Call_Shutdown(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.ExecutorID executor_id = 1;
  bool has_executor_id() const;
  void clear_executor_id();
  static const int kExecutorIdFieldNumber = 1;
  private:
  void _slow_mutable_executor_id();
  public:
  const ::mesos::ExecutorID& executor_id() const;
  ::mesos::ExecutorID* release_executor_id();
  ::mesos::ExecutorID* mutable_executor_id();
  void set_allocated_executor_id(::mesos::ExecutorID* executor_id);
  void unsafe_arena_set_allocated_executor_id(
      ::mesos::ExecutorID* executor_id);
  ::mesos::ExecutorID* unsafe_arena_release_executor_id();

  // required .mesos.SlaveID slave_id = 2;
  bool has_slave_id() const;
  void clear_slave_id();
  static const int kSlaveIdFieldNumber = 2;
  private:
  void _slow_mutable_slave_id();
  public:
  const ::mesos::SlaveID& slave_id() const;
  ::mesos::SlaveID* release_slave_id();
  ::mesos::SlaveID* mutable_slave_id();
  void set_allocated_slave_id(::mesos::SlaveID* slave_id);
  void unsafe_arena_set_allocated_slave_id(
      ::mesos::SlaveID* slave_id);
  ::mesos::SlaveID* unsafe_arena_release_slave_id();

  // @@protoc_insertion_point(class_scope:mesos.scheduler.Call.Shutdown)
 private:
  void set_has_executor_id();
  void clear_has_executor_id();
  void set_has_slave_id();
  void clear_has_slave_id();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::ExecutorID* executor_id_;
  ::mesos::SlaveID* slave_id_;
  friend struct ::protobuf_mesos_2fscheduler_2fscheduler_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fscheduler_2fscheduler_2eproto::InitDefaultsCall_ShutdownImpl();
};
// -------------------------------------------------------------------

class Call_Acknowledge : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.scheduler.Call.Acknowledge) */ {
 public:
  Call_Acknowledge();
  virtual ~Call_Acknowledge();

  Call_Acknowledge(const Call_Acknowledge& from);

  inline Call_Acknowledge& operator=(const Call_Acknowledge& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Call_Acknowledge(Call_Acknowledge&& from) noexcept
    : Call_Acknowledge() {
    *this = ::std::move(from);
  }

  inline Call_Acknowledge& operator=(Call_Acknowledge&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Call_Acknowledge& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Call_Acknowledge* internal_default_instance() {
    return reinterpret_cast<const Call_Acknowledge*>(
               &_Call_Acknowledge_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    21;

  void UnsafeArenaSwap(Call_Acknowledge* other);
  void Swap(Call_Acknowledge* other);
  friend void swap(Call_Acknowledge& a, Call_Acknowledge& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Call_Acknowledge* New() const PROTOBUF_FINAL { return New(NULL); }

  Call_Acknowledge* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Call_Acknowledge& from);
  void MergeFrom(const Call_Acknowledge& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Call_Acknowledge* other);
  protected:
  explicit Call_Acknowledge(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes uuid = 3;
  bool has_uuid() const;
  void clear_uuid();
  static const int kUuidFieldNumber = 3;
  const ::std::string& uuid() const;
  void set_uuid(const ::std::string& value);
  #if LANG_CXX11
  void set_uuid(::std::string&& value);
  #endif
  void set_uuid(const char* value);
  void set_uuid(const void* value, size_t size);
  ::std::string* mutable_uuid();
  ::std::string* release_uuid();
  void set_allocated_uuid(::std::string* uuid);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_uuid();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_uuid(
      ::std::string* uuid);

  // required .mesos.SlaveID slave_id = 1;
  bool has_slave_id() const;
  void clear_slave_id();
  static const int kSlaveIdFieldNumber = 1;
  private:
  void _slow_mutable_slave_id();
  public:
  const ::mesos::SlaveID& slave_id() const;
  ::mesos::SlaveID* release_slave_id();
  ::mesos::SlaveID* mutable_slave_id();
  void set_allocated_slave_id(::mesos::SlaveID* slave_id);
  void unsafe_arena_set_allocated_slave_id(
      ::mesos::SlaveID* slave_id);
  ::mesos::SlaveID* unsafe_arena_release_slave_id();

  // required .mesos.TaskID task_id = 2;
  bool has_task_id() const;
  void clear_task_id();
  static const int kTaskIdFieldNumber = 2;
  private:
  void _slow_mutable_task_id();
  public:
  const ::mesos::TaskID& task_id() const;
  ::mesos::TaskID* release_task_id();
  ::mesos::TaskID* mutable_task_id();
  void set_allocated_task_id(::mesos::TaskID* task_id);
  void unsafe_arena_set_allocated_task_id(
      ::mesos::TaskID* task_id);
  ::mesos::TaskID* unsafe_arena_release_task_id();

  // @@protoc_insertion_point(class_scope:mesos.scheduler.Call.Acknowledge)
 private:
  void set_has_slave_id();
  void clear_has_slave_id();
  void set_has_task_id();
  void clear_has_task_id();
  void set_has_uuid();
  void clear_has_uuid();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr uuid_;
  ::mesos::SlaveID* slave_id_;
  ::mesos::TaskID* task_id_;
  friend struct ::protobuf_mesos_2fscheduler_2fscheduler_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fscheduler_2fscheduler_2eproto::InitDefaultsCall_AcknowledgeImpl();
};
// -------------------------------------------------------------------

class Call_AcknowledgeOperationStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.scheduler.Call.AcknowledgeOperationStatus) */ {
 public:
  Call_AcknowledgeOperationStatus();
  virtual ~Call_AcknowledgeOperationStatus();

  Call_AcknowledgeOperationStatus(const Call_AcknowledgeOperationStatus& from);

  inline Call_AcknowledgeOperationStatus& operator=(const Call_AcknowledgeOperationStatus& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Call_AcknowledgeOperationStatus(Call_AcknowledgeOperationStatus&& from) noexcept
    : Call_AcknowledgeOperationStatus() {
    *this = ::std::move(from);
  }

  inline Call_AcknowledgeOperationStatus& operator=(Call_AcknowledgeOperationStatus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Call_AcknowledgeOperationStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Call_AcknowledgeOperationStatus* internal_default_instance() {
    return reinterpret_cast<const Call_AcknowledgeOperationStatus*>(
               &_Call_AcknowledgeOperationStatus_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    22;

  void UnsafeArenaSwap(Call_AcknowledgeOperationStatus* other);
  void Swap(Call_AcknowledgeOperationStatus* other);
  friend void swap(Call_AcknowledgeOperationStatus& a, Call_AcknowledgeOperationStatus& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Call_AcknowledgeOperationStatus* New() const PROTOBUF_FINAL { return New(NULL); }

  Call_AcknowledgeOperationStatus* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Call_AcknowledgeOperationStatus& from);
  void MergeFrom(const Call_AcknowledgeOperationStatus& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Call_AcknowledgeOperationStatus* other);
  protected:
  explicit Call_AcknowledgeOperationStatus(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes uuid = 3;
  bool has_uuid() const;
  void clear_uuid();
  static const int kUuidFieldNumber = 3;
  const ::std::string& uuid() const;
  void set_uuid(const ::std::string& value);
  #if LANG_CXX11
  void set_uuid(::std::string&& value);
  #endif
  void set_uuid(const char* value);
  void set_uuid(const void* value, size_t size);
  ::std::string* mutable_uuid();
  ::std::string* release_uuid();
  void set_allocated_uuid(::std::string* uuid);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_uuid();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_uuid(
      ::std::string* uuid);

  // optional .mesos.SlaveID slave_id = 1;
  bool has_slave_id() const;
  void clear_slave_id();
  static const int kSlaveIdFieldNumber = 1;
  private:
  void _slow_mutable_slave_id();
  public:
  const ::mesos::SlaveID& slave_id() const;
  ::mesos::SlaveID* release_slave_id();
  ::mesos::SlaveID* mutable_slave_id();
  void set_allocated_slave_id(::mesos::SlaveID* slave_id);
  void unsafe_arena_set_allocated_slave_id(
      ::mesos::SlaveID* slave_id);
  ::mesos::SlaveID* unsafe_arena_release_slave_id();

  // optional .mesos.ResourceProviderID resource_provider_id = 2;
  bool has_resource_provider_id() const;
  void clear_resource_provider_id();
  static const int kResourceProviderIdFieldNumber = 2;
  private:
  void _slow_mutable_resource_provider_id();
  public:
  const ::mesos::ResourceProviderID& resource_provider_id() const;
  ::mesos::ResourceProviderID* release_resource_provider_id();
  ::mesos::ResourceProviderID* mutable_resource_provider_id();
  void set_allocated_resource_provider_id(::mesos::ResourceProviderID* resource_provider_id);
  void unsafe_arena_set_allocated_resource_provider_id(
      ::mesos::ResourceProviderID* resource_provider_id);
  ::mesos::ResourceProviderID* unsafe_arena_release_resource_provider_id();

  // required .mesos.OperationID operation_id = 4;
  bool has_operation_id() const;
  void clear_operation_id();
  static const int kOperationIdFieldNumber = 4;
  private:
  void _slow_mutable_operation_id();
  public:
  const ::mesos::OperationID& operation_id() const;
  ::mesos::OperationID* release_operation_id();
  ::mesos::OperationID* mutable_operation_id();
  void set_allocated_operation_id(::mesos::OperationID* operation_id);
  void unsafe_arena_set_allocated_operation_id(
      ::mesos::OperationID* operation_id);
  ::mesos::OperationID* unsafe_arena_release_operation_id();

  // @@protoc_insertion_point(class_scope:mesos.scheduler.Call.AcknowledgeOperationStatus)
 private:
  void set_has_slave_id();
  void clear_has_slave_id();
  void set_has_resource_provider_id();
  void clear_has_resource_provider_id();
  void set_has_uuid();
  void clear_has_uuid();
  void set_has_operation_id();
  void clear_has_operation_id();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr uuid_;
  ::mesos::SlaveID* slave_id_;
  ::mesos::ResourceProviderID* resource_provider_id_;
  ::mesos::OperationID* operation_id_;
  friend struct ::protobuf_mesos_2fscheduler_2fscheduler_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fscheduler_2fscheduler_2eproto::InitDefaultsCall_AcknowledgeOperationStatusImpl();
};
// -------------------------------------------------------------------

class Call_Reconcile_Task : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.scheduler.Call.Reconcile.Task) */ {
 public:
  Call_Reconcile_Task();
  virtual ~Call_Reconcile_Task();

  Call_Reconcile_Task(const Call_Reconcile_Task& from);

  inline Call_Reconcile_Task& operator=(const Call_Reconcile_Task& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Call_Reconcile_Task(Call_Reconcile_Task&& from) noexcept
    : Call_Reconcile_Task() {
    *this = ::std::move(from);
  }

  inline Call_Reconcile_Task& operator=(Call_Reconcile_Task&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Call_Reconcile_Task& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Call_Reconcile_Task* internal_default_instance() {
    return reinterpret_cast<const Call_Reconcile_Task*>(
               &_Call_Reconcile_Task_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    23;

  void UnsafeArenaSwap(Call_Reconcile_Task* other);
  void Swap(Call_Reconcile_Task* other);
  friend void swap(Call_Reconcile_Task& a, Call_Reconcile_Task& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Call_Reconcile_Task* New() const PROTOBUF_FINAL { return New(NULL); }

  Call_Reconcile_Task* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Call_Reconcile_Task& from);
  void MergeFrom(const Call_Reconcile_Task& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Call_Reconcile_Task* other);
  protected:
  explicit Call_Reconcile_Task(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.TaskID task_id = 1;
  bool has_task_id() const;
  void clear_task_id();
  static const int kTaskIdFieldNumber = 1;
  private:
  void _slow_mutable_task_id();
  public:
  const ::mesos::TaskID& task_id() const;
  ::mesos::TaskID* release_task_id();
  ::mesos::TaskID* mutable_task_id();
  void set_allocated_task_id(::mesos::TaskID* task_id);
  void unsafe_arena_set_allocated_task_id(
      ::mesos::TaskID* task_id);
  ::mesos::TaskID* unsafe_arena_release_task_id();

  // optional .mesos.SlaveID slave_id = 2;
  bool has_slave_id() const;
  void clear_slave_id();
  static const int kSlaveIdFieldNumber = 2;
  private:
  void _slow_mutable_slave_id();
  public:
  const ::mesos::SlaveID& slave_id() const;
  ::mesos::SlaveID* release_slave_id();
  ::mesos::SlaveID* mutable_slave_id();
  void set_allocated_slave_id(::mesos::SlaveID* slave_id);
  void unsafe_arena_set_allocated_slave_id(
      ::mesos::SlaveID* slave_id);
  ::mesos::SlaveID* unsafe_arena_release_slave_id();

  // @@protoc_insertion_point(class_scope:mesos.scheduler.Call.Reconcile.Task)
 private:
  void set_has_task_id();
  void clear_has_task_id();
  void set_has_slave_id();
  void clear_has_slave_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::TaskID* task_id_;
  ::mesos::SlaveID* slave_id_;
  friend struct ::protobuf_mesos_2fscheduler_2fscheduler_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fscheduler_2fscheduler_2eproto::InitDefaultsCall_Reconcile_TaskImpl();
};
// -------------------------------------------------------------------

class Call_Reconcile : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.scheduler.Call.Reconcile) */ {
 public:
  Call_Reconcile();
  virtual ~Call_Reconcile();

  Call_Reconcile(const Call_Reconcile& from);

  inline Call_Reconcile& operator=(const Call_Reconcile& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Call_Reconcile(Call_Reconcile&& from) noexcept
    : Call_Reconcile() {
    *this = ::std::move(from);
  }

  inline Call_Reconcile& operator=(Call_Reconcile&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Call_Reconcile& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Call_Reconcile* internal_default_instance() {
    return reinterpret_cast<const Call_Reconcile*>(
               &_Call_Reconcile_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    24;

  void UnsafeArenaSwap(Call_Reconcile* other);
  void Swap(Call_Reconcile* other);
  friend void swap(Call_Reconcile& a, Call_Reconcile& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Call_Reconcile* New() const PROTOBUF_FINAL { return New(NULL); }

  Call_Reconcile* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Call_Reconcile& from);
  void MergeFrom(const Call_Reconcile& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Call_Reconcile* other);
  protected:
  explicit Call_Reconcile(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Call_Reconcile_Task Task;

  // accessors -------------------------------------------------------

  // repeated .mesos.scheduler.Call.Reconcile.Task tasks = 1;
  int tasks_size() const;
  void clear_tasks();
  static const int kTasksFieldNumber = 1;
  const ::mesos::scheduler::Call_Reconcile_Task& tasks(int index) const;
  ::mesos::scheduler::Call_Reconcile_Task* mutable_tasks(int index);
  ::mesos::scheduler::Call_Reconcile_Task* add_tasks();
  ::google::protobuf::RepeatedPtrField< ::mesos::scheduler::Call_Reconcile_Task >*
      mutable_tasks();
  const ::google::protobuf::RepeatedPtrField< ::mesos::scheduler::Call_Reconcile_Task >&
      tasks() const;

  // @@protoc_insertion_point(class_scope:mesos.scheduler.Call.Reconcile)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::scheduler::Call_Reconcile_Task > tasks_;
  friend struct ::protobuf_mesos_2fscheduler_2fscheduler_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fscheduler_2fscheduler_2eproto::InitDefaultsCall_ReconcileImpl();
};
// -------------------------------------------------------------------

class Call_ReconcileOperations_Operation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.scheduler.Call.ReconcileOperations.Operation) */ {
 public:
  Call_ReconcileOperations_Operation();
  virtual ~Call_ReconcileOperations_Operation();

  Call_ReconcileOperations_Operation(const Call_ReconcileOperations_Operation& from);

  inline Call_ReconcileOperations_Operation& operator=(const Call_ReconcileOperations_Operation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Call_ReconcileOperations_Operation(Call_ReconcileOperations_Operation&& from) noexcept
    : Call_ReconcileOperations_Operation() {
    *this = ::std::move(from);
  }

  inline Call_ReconcileOperations_Operation& operator=(Call_ReconcileOperations_Operation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Call_ReconcileOperations_Operation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Call_ReconcileOperations_Operation* internal_default_instance() {
    return reinterpret_cast<const Call_ReconcileOperations_Operation*>(
               &_Call_ReconcileOperations_Operation_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    25;

  void UnsafeArenaSwap(Call_ReconcileOperations_Operation* other);
  void Swap(Call_ReconcileOperations_Operation* other);
  friend void swap(Call_ReconcileOperations_Operation& a, Call_ReconcileOperations_Operation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Call_ReconcileOperations_Operation* New() const PROTOBUF_FINAL { return New(NULL); }

  Call_ReconcileOperations_Operation* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Call_ReconcileOperations_Operation& from);
  void MergeFrom(const Call_ReconcileOperations_Operation& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Call_ReconcileOperations_Operation* other);
  protected:
  explicit Call_ReconcileOperations_Operation(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.OperationID operation_id = 1;
  bool has_operation_id() const;
  void clear_operation_id();
  static const int kOperationIdFieldNumber = 1;
  private:
  void _slow_mutable_operation_id();
  public:
  const ::mesos::OperationID& operation_id() const;
  ::mesos::OperationID* release_operation_id();
  ::mesos::OperationID* mutable_operation_id();
  void set_allocated_operation_id(::mesos::OperationID* operation_id);
  void unsafe_arena_set_allocated_operation_id(
      ::mesos::OperationID* operation_id);
  ::mesos::OperationID* unsafe_arena_release_operation_id();

  // optional .mesos.SlaveID slave_id = 2;
  bool has_slave_id() const;
  void clear_slave_id();
  static const int kSlaveIdFieldNumber = 2;
  private:
  void _slow_mutable_slave_id();
  public:
  const ::mesos::SlaveID& slave_id() const;
  ::mesos::SlaveID* release_slave_id();
  ::mesos::SlaveID* mutable_slave_id();
  void set_allocated_slave_id(::mesos::SlaveID* slave_id);
  void unsafe_arena_set_allocated_slave_id(
      ::mesos::SlaveID* slave_id);
  ::mesos::SlaveID* unsafe_arena_release_slave_id();

  // optional .mesos.ResourceProviderID resource_provider_id = 3;
  bool has_resource_provider_id() const;
  void clear_resource_provider_id();
  static const int kResourceProviderIdFieldNumber = 3;
  private:
  void _slow_mutable_resource_provider_id();
  public:
  const ::mesos::ResourceProviderID& resource_provider_id() const;
  ::mesos::ResourceProviderID* release_resource_provider_id();
  ::mesos::ResourceProviderID* mutable_resource_provider_id();
  void set_allocated_resource_provider_id(::mesos::ResourceProviderID* resource_provider_id);
  void unsafe_arena_set_allocated_resource_provider_id(
      ::mesos::ResourceProviderID* resource_provider_id);
  ::mesos::ResourceProviderID* unsafe_arena_release_resource_provider_id();

  // @@protoc_insertion_point(class_scope:mesos.scheduler.Call.ReconcileOperations.Operation)
 private:
  void set_has_operation_id();
  void clear_has_operation_id();
  void set_has_slave_id();
  void clear_has_slave_id();
  void set_has_resource_provider_id();
  void clear_has_resource_provider_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::OperationID* operation_id_;
  ::mesos::SlaveID* slave_id_;
  ::mesos::ResourceProviderID* resource_provider_id_;
  friend struct ::protobuf_mesos_2fscheduler_2fscheduler_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fscheduler_2fscheduler_2eproto::InitDefaultsCall_ReconcileOperations_OperationImpl();
};
// -------------------------------------------------------------------

class Call_ReconcileOperations : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.scheduler.Call.ReconcileOperations) */ {
 public:
  Call_ReconcileOperations();
  virtual ~Call_ReconcileOperations();

  Call_ReconcileOperations(const Call_ReconcileOperations& from);

  inline Call_ReconcileOperations& operator=(const Call_ReconcileOperations& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Call_ReconcileOperations(Call_ReconcileOperations&& from) noexcept
    : Call_ReconcileOperations() {
    *this = ::std::move(from);
  }

  inline Call_ReconcileOperations& operator=(Call_ReconcileOperations&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Call_ReconcileOperations& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Call_ReconcileOperations* internal_default_instance() {
    return reinterpret_cast<const Call_ReconcileOperations*>(
               &_Call_ReconcileOperations_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    26;

  void UnsafeArenaSwap(Call_ReconcileOperations* other);
  void Swap(Call_ReconcileOperations* other);
  friend void swap(Call_ReconcileOperations& a, Call_ReconcileOperations& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Call_ReconcileOperations* New() const PROTOBUF_FINAL { return New(NULL); }

  Call_ReconcileOperations* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Call_ReconcileOperations& from);
  void MergeFrom(const Call_ReconcileOperations& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Call_ReconcileOperations* other);
  protected:
  explicit Call_ReconcileOperations(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Call_ReconcileOperations_Operation Operation;

  // accessors -------------------------------------------------------

  // repeated .mesos.scheduler.Call.ReconcileOperations.Operation operations = 1;
  int operations_size() const;
  void clear_operations();
  static const int kOperationsFieldNumber = 1;
  const ::mesos::scheduler::Call_ReconcileOperations_Operation& operations(int index) const;
  ::mesos::scheduler::Call_ReconcileOperations_Operation* mutable_operations(int index);
  ::mesos::scheduler::Call_ReconcileOperations_Operation* add_operations();
  ::google::protobuf::RepeatedPtrField< ::mesos::scheduler::Call_ReconcileOperations_Operation >*
      mutable_operations();
  const ::google::protobuf::RepeatedPtrField< ::mesos::scheduler::Call_ReconcileOperations_Operation >&
      operations() const;

  // @@protoc_insertion_point(class_scope:mesos.scheduler.Call.ReconcileOperations)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::scheduler::Call_ReconcileOperations_Operation > operations_;
  friend struct ::protobuf_mesos_2fscheduler_2fscheduler_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fscheduler_2fscheduler_2eproto::InitDefaultsCall_ReconcileOperationsImpl();
};
// -------------------------------------------------------------------

class Call_Message : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.scheduler.Call.Message) */ {
 public:
  Call_Message();
  virtual ~Call_Message();

  Call_Message(const Call_Message& from);

  inline Call_Message& operator=(const Call_Message& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Call_Message(Call_Message&& from) noexcept
    : Call_Message() {
    *this = ::std::move(from);
  }

  inline Call_Message& operator=(Call_Message&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Call_Message& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Call_Message* internal_default_instance() {
    return reinterpret_cast<const Call_Message*>(
               &_Call_Message_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    27;

  void UnsafeArenaSwap(Call_Message* other);
  void Swap(Call_Message* other);
  friend void swap(Call_Message& a, Call_Message& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Call_Message* New() const PROTOBUF_FINAL { return New(NULL); }

  Call_Message* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Call_Message& from);
  void MergeFrom(const Call_Message& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Call_Message* other);
  protected:
  explicit Call_Message(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes data = 3;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 3;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_data();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_data(
      ::std::string* data);

  // required .mesos.SlaveID slave_id = 1;
  bool has_slave_id() const;
  void clear_slave_id();
  static const int kSlaveIdFieldNumber = 1;
  private:
  void _slow_mutable_slave_id();
  public:
  const ::mesos::SlaveID& slave_id() const;
  ::mesos::SlaveID* release_slave_id();
  ::mesos::SlaveID* mutable_slave_id();
  void set_allocated_slave_id(::mesos::SlaveID* slave_id);
  void unsafe_arena_set_allocated_slave_id(
      ::mesos::SlaveID* slave_id);
  ::mesos::SlaveID* unsafe_arena_release_slave_id();

  // required .mesos.ExecutorID executor_id = 2;
  bool has_executor_id() const;
  void clear_executor_id();
  static const int kExecutorIdFieldNumber = 2;
  private:
  void _slow_mutable_executor_id();
  public:
  const ::mesos::ExecutorID& executor_id() const;
  ::mesos::ExecutorID* release_executor_id();
  ::mesos::ExecutorID* mutable_executor_id();
  void set_allocated_executor_id(::mesos::ExecutorID* executor_id);
  void unsafe_arena_set_allocated_executor_id(
      ::mesos::ExecutorID* executor_id);
  ::mesos::ExecutorID* unsafe_arena_release_executor_id();

  // @@protoc_insertion_point(class_scope:mesos.scheduler.Call.Message)
 private:
  void set_has_slave_id();
  void clear_has_slave_id();
  void set_has_executor_id();
  void clear_has_executor_id();
  void set_has_data();
  void clear_has_data();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  ::mesos::SlaveID* slave_id_;
  ::mesos::ExecutorID* executor_id_;
  friend struct ::protobuf_mesos_2fscheduler_2fscheduler_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fscheduler_2fscheduler_2eproto::InitDefaultsCall_MessageImpl();
};
// -------------------------------------------------------------------

class Call_Request : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.scheduler.Call.Request) */ {
 public:
  Call_Request();
  virtual ~Call_Request();

  Call_Request(const Call_Request& from);

  inline Call_Request& operator=(const Call_Request& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Call_Request(Call_Request&& from) noexcept
    : Call_Request() {
    *this = ::std::move(from);
  }

  inline Call_Request& operator=(Call_Request&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Call_Request& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Call_Request* internal_default_instance() {
    return reinterpret_cast<const Call_Request*>(
               &_Call_Request_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    28;

  void UnsafeArenaSwap(Call_Request* other);
  void Swap(Call_Request* other);
  friend void swap(Call_Request& a, Call_Request& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Call_Request* New() const PROTOBUF_FINAL { return New(NULL); }

  Call_Request* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Call_Request& from);
  void MergeFrom(const Call_Request& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Call_Request* other);
  protected:
  explicit Call_Request(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.Request requests = 1;
  int requests_size() const;
  void clear_requests();
  static const int kRequestsFieldNumber = 1;
  const ::mesos::Request& requests(int index) const;
  ::mesos::Request* mutable_requests(int index);
  ::mesos::Request* add_requests();
  ::google::protobuf::RepeatedPtrField< ::mesos::Request >*
      mutable_requests();
  const ::google::protobuf::RepeatedPtrField< ::mesos::Request >&
      requests() const;

  // @@protoc_insertion_point(class_scope:mesos.scheduler.Call.Request)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Request > requests_;
  friend struct ::protobuf_mesos_2fscheduler_2fscheduler_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fscheduler_2fscheduler_2eproto::InitDefaultsCall_RequestImpl();
};
// -------------------------------------------------------------------

class Call_Suppress : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.scheduler.Call.Suppress) */ {
 public:
  Call_Suppress();
  virtual ~Call_Suppress();

  Call_Suppress(const Call_Suppress& from);

  inline Call_Suppress& operator=(const Call_Suppress& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Call_Suppress(Call_Suppress&& from) noexcept
    : Call_Suppress() {
    *this = ::std::move(from);
  }

  inline Call_Suppress& operator=(Call_Suppress&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Call_Suppress& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Call_Suppress* internal_default_instance() {
    return reinterpret_cast<const Call_Suppress*>(
               &_Call_Suppress_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    29;

  void UnsafeArenaSwap(Call_Suppress* other);
  void Swap(Call_Suppress* other);
  friend void swap(Call_Suppress& a, Call_Suppress& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Call_Suppress* New() const PROTOBUF_FINAL { return New(NULL); }

  Call_Suppress* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Call_Suppress& from);
  void MergeFrom(const Call_Suppress& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Call_Suppress* other);
  protected:
  explicit Call_Suppress(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string roles = 1;
  int roles_size() const;
  void clear_roles();
  static const int kRolesFieldNumber = 1;
  const ::std::string& roles(int index) const;
  ::std::string* mutable_roles(int index);
  void set_roles(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_roles(int index, ::std::string&& value);
  #endif
  void set_roles(int index, const char* value);
  void set_roles(int index, const char* value, size_t size);
  ::std::string* add_roles();
  void add_roles(const ::std::string& value);
  #if LANG_CXX11
  void add_roles(::std::string&& value);
  #endif
  void add_roles(const char* value);
  void add_roles(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& roles() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_roles();

  // @@protoc_insertion_point(class_scope:mesos.scheduler.Call.Suppress)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> roles_;
  friend struct ::protobuf_mesos_2fscheduler_2fscheduler_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fscheduler_2fscheduler_2eproto::InitDefaultsCall_SuppressImpl();
};
// -------------------------------------------------------------------

class Call : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.scheduler.Call) */ {
 public:
  Call();
  virtual ~Call();

  Call(const Call& from);

  inline Call& operator=(const Call& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Call(Call&& from) noexcept
    : Call() {
    *this = ::std::move(from);
  }

  inline Call& operator=(Call&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Call& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Call* internal_default_instance() {
    return reinterpret_cast<const Call*>(
               &_Call_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    30;

  void UnsafeArenaSwap(Call* other);
  void Swap(Call* other);
  friend void swap(Call& a, Call& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Call* New() const PROTOBUF_FINAL { return New(NULL); }

  Call* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Call& from);
  void MergeFrom(const Call& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Call* other);
  protected:
  explicit Call(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Call_Subscribe Subscribe;
  typedef Call_Accept Accept;
  typedef Call_Decline Decline;
  typedef Call_AcceptInverseOffers AcceptInverseOffers;
  typedef Call_DeclineInverseOffers DeclineInverseOffers;
  typedef Call_Revive Revive;
  typedef Call_Kill Kill;
  typedef Call_Shutdown Shutdown;
  typedef Call_Acknowledge Acknowledge;
  typedef Call_AcknowledgeOperationStatus AcknowledgeOperationStatus;
  typedef Call_Reconcile Reconcile;
  typedef Call_ReconcileOperations ReconcileOperations;
  typedef Call_Message Message;
  typedef Call_Request Request;
  typedef Call_Suppress Suppress;

  typedef Call_Type Type;
  static const Type UNKNOWN =
    Call_Type_UNKNOWN;
  static const Type SUBSCRIBE =
    Call_Type_SUBSCRIBE;
  static const Type TEARDOWN =
    Call_Type_TEARDOWN;
  static const Type ACCEPT =
    Call_Type_ACCEPT;
  static const Type DECLINE =
    Call_Type_DECLINE;
  static const Type ACCEPT_INVERSE_OFFERS =
    Call_Type_ACCEPT_INVERSE_OFFERS;
  static const Type DECLINE_INVERSE_OFFERS =
    Call_Type_DECLINE_INVERSE_OFFERS;
  static const Type REVIVE =
    Call_Type_REVIVE;
  static const Type KILL =
    Call_Type_KILL;
  static const Type SHUTDOWN =
    Call_Type_SHUTDOWN;
  static const Type ACKNOWLEDGE =
    Call_Type_ACKNOWLEDGE;
  static const Type ACKNOWLEDGE_OPERATION_STATUS =
    Call_Type_ACKNOWLEDGE_OPERATION_STATUS;
  static const Type RECONCILE =
    Call_Type_RECONCILE;
  static const Type RECONCILE_OPERATIONS =
    Call_Type_RECONCILE_OPERATIONS;
  static const Type MESSAGE =
    Call_Type_MESSAGE;
  static const Type REQUEST =
    Call_Type_REQUEST;
  static const Type SUPPRESS =
    Call_Type_SUPPRESS;
  static inline bool Type_IsValid(int value) {
    return Call_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Call_Type_Type_MIN;
  static const Type Type_MAX =
    Call_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Call_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Call_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Call_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Call_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .mesos.FrameworkID framework_id = 1;
  bool has_framework_id() const;
  void clear_framework_id();
  static const int kFrameworkIdFieldNumber = 1;
  private:
  void _slow_mutable_framework_id();
  public:
  const ::mesos::FrameworkID& framework_id() const;
  ::mesos::FrameworkID* release_framework_id();
  ::mesos::FrameworkID* mutable_framework_id();
  void set_allocated_framework_id(::mesos::FrameworkID* framework_id);
  void unsafe_arena_set_allocated_framework_id(
      ::mesos::FrameworkID* framework_id);
  ::mesos::FrameworkID* unsafe_arena_release_framework_id();

  // optional .mesos.scheduler.Call.Subscribe subscribe = 3;
  bool has_subscribe() const;
  void clear_subscribe();
  static const int kSubscribeFieldNumber = 3;
  private:
  void _slow_mutable_subscribe();
  public:
  const ::mesos::scheduler::Call_Subscribe& subscribe() const;
  ::mesos::scheduler::Call_Subscribe* release_subscribe();
  ::mesos::scheduler::Call_Subscribe* mutable_subscribe();
  void set_allocated_subscribe(::mesos::scheduler::Call_Subscribe* subscribe);
  void unsafe_arena_set_allocated_subscribe(
      ::mesos::scheduler::Call_Subscribe* subscribe);
  ::mesos::scheduler::Call_Subscribe* unsafe_arena_release_subscribe();

  // optional .mesos.scheduler.Call.Accept accept = 4;
  bool has_accept() const;
  void clear_accept();
  static const int kAcceptFieldNumber = 4;
  private:
  void _slow_mutable_accept();
  public:
  const ::mesos::scheduler::Call_Accept& accept() const;
  ::mesos::scheduler::Call_Accept* release_accept();
  ::mesos::scheduler::Call_Accept* mutable_accept();
  void set_allocated_accept(::mesos::scheduler::Call_Accept* accept);
  void unsafe_arena_set_allocated_accept(
      ::mesos::scheduler::Call_Accept* accept);
  ::mesos::scheduler::Call_Accept* unsafe_arena_release_accept();

  // optional .mesos.scheduler.Call.Decline decline = 5;
  bool has_decline() const;
  void clear_decline();
  static const int kDeclineFieldNumber = 5;
  private:
  void _slow_mutable_decline();
  public:
  const ::mesos::scheduler::Call_Decline& decline() const;
  ::mesos::scheduler::Call_Decline* release_decline();
  ::mesos::scheduler::Call_Decline* mutable_decline();
  void set_allocated_decline(::mesos::scheduler::Call_Decline* decline);
  void unsafe_arena_set_allocated_decline(
      ::mesos::scheduler::Call_Decline* decline);
  ::mesos::scheduler::Call_Decline* unsafe_arena_release_decline();

  // optional .mesos.scheduler.Call.Kill kill = 6;
  bool has_kill() const;
  void clear_kill();
  static const int kKillFieldNumber = 6;
  private:
  void _slow_mutable_kill();
  public:
  const ::mesos::scheduler::Call_Kill& kill() const;
  ::mesos::scheduler::Call_Kill* release_kill();
  ::mesos::scheduler::Call_Kill* mutable_kill();
  void set_allocated_kill(::mesos::scheduler::Call_Kill* kill);
  void unsafe_arena_set_allocated_kill(
      ::mesos::scheduler::Call_Kill* kill);
  ::mesos::scheduler::Call_Kill* unsafe_arena_release_kill();

  // optional .mesos.scheduler.Call.Shutdown shutdown = 7;
  bool has_shutdown() const;
  void clear_shutdown();
  static const int kShutdownFieldNumber = 7;
  private:
  void _slow_mutable_shutdown();
  public:
  const ::mesos::scheduler::Call_Shutdown& shutdown() const;
  ::mesos::scheduler::Call_Shutdown* release_shutdown();
  ::mesos::scheduler::Call_Shutdown* mutable_shutdown();
  void set_allocated_shutdown(::mesos::scheduler::Call_Shutdown* shutdown);
  void unsafe_arena_set_allocated_shutdown(
      ::mesos::scheduler::Call_Shutdown* shutdown);
  ::mesos::scheduler::Call_Shutdown* unsafe_arena_release_shutdown();

  // optional .mesos.scheduler.Call.Acknowledge acknowledge = 8;
  bool has_acknowledge() const;
  void clear_acknowledge();
  static const int kAcknowledgeFieldNumber = 8;
  private:
  void _slow_mutable_acknowledge();
  public:
  const ::mesos::scheduler::Call_Acknowledge& acknowledge() const;
  ::mesos::scheduler::Call_Acknowledge* release_acknowledge();
  ::mesos::scheduler::Call_Acknowledge* mutable_acknowledge();
  void set_allocated_acknowledge(::mesos::scheduler::Call_Acknowledge* acknowledge);
  void unsafe_arena_set_allocated_acknowledge(
      ::mesos::scheduler::Call_Acknowledge* acknowledge);
  ::mesos::scheduler::Call_Acknowledge* unsafe_arena_release_acknowledge();

  // optional .mesos.scheduler.Call.Reconcile reconcile = 9;
  bool has_reconcile() const;
  void clear_reconcile();
  static const int kReconcileFieldNumber = 9;
  private:
  void _slow_mutable_reconcile();
  public:
  const ::mesos::scheduler::Call_Reconcile& reconcile() const;
  ::mesos::scheduler::Call_Reconcile* release_reconcile();
  ::mesos::scheduler::Call_Reconcile* mutable_reconcile();
  void set_allocated_reconcile(::mesos::scheduler::Call_Reconcile* reconcile);
  void unsafe_arena_set_allocated_reconcile(
      ::mesos::scheduler::Call_Reconcile* reconcile);
  ::mesos::scheduler::Call_Reconcile* unsafe_arena_release_reconcile();

  // optional .mesos.scheduler.Call.Message message = 10;
  bool has_message() const;
  void clear_message();
  static const int kMessageFieldNumber = 10;
  private:
  void _slow_mutable_message();
  public:
  const ::mesos::scheduler::Call_Message& message() const;
  ::mesos::scheduler::Call_Message* release_message();
  ::mesos::scheduler::Call_Message* mutable_message();
  void set_allocated_message(::mesos::scheduler::Call_Message* message);
  void unsafe_arena_set_allocated_message(
      ::mesos::scheduler::Call_Message* message);
  ::mesos::scheduler::Call_Message* unsafe_arena_release_message();

  // optional .mesos.scheduler.Call.Request request = 11;
  bool has_request() const;
  void clear_request();
  static const int kRequestFieldNumber = 11;
  private:
  void _slow_mutable_request();
  public:
  const ::mesos::scheduler::Call_Request& request() const;
  ::mesos::scheduler::Call_Request* release_request();
  ::mesos::scheduler::Call_Request* mutable_request();
  void set_allocated_request(::mesos::scheduler::Call_Request* request);
  void unsafe_arena_set_allocated_request(
      ::mesos::scheduler::Call_Request* request);
  ::mesos::scheduler::Call_Request* unsafe_arena_release_request();

  // optional .mesos.scheduler.Call.AcceptInverseOffers accept_inverse_offers = 13;
  bool has_accept_inverse_offers() const;
  void clear_accept_inverse_offers();
  static const int kAcceptInverseOffersFieldNumber = 13;
  private:
  void _slow_mutable_accept_inverse_offers();
  public:
  const ::mesos::scheduler::Call_AcceptInverseOffers& accept_inverse_offers() const;
  ::mesos::scheduler::Call_AcceptInverseOffers* release_accept_inverse_offers();
  ::mesos::scheduler::Call_AcceptInverseOffers* mutable_accept_inverse_offers();
  void set_allocated_accept_inverse_offers(::mesos::scheduler::Call_AcceptInverseOffers* accept_inverse_offers);
  void unsafe_arena_set_allocated_accept_inverse_offers(
      ::mesos::scheduler::Call_AcceptInverseOffers* accept_inverse_offers);
  ::mesos::scheduler::Call_AcceptInverseOffers* unsafe_arena_release_accept_inverse_offers();

  // optional .mesos.scheduler.Call.DeclineInverseOffers decline_inverse_offers = 14;
  bool has_decline_inverse_offers() const;
  void clear_decline_inverse_offers();
  static const int kDeclineInverseOffersFieldNumber = 14;
  private:
  void _slow_mutable_decline_inverse_offers();
  public:
  const ::mesos::scheduler::Call_DeclineInverseOffers& decline_inverse_offers() const;
  ::mesos::scheduler::Call_DeclineInverseOffers* release_decline_inverse_offers();
  ::mesos::scheduler::Call_DeclineInverseOffers* mutable_decline_inverse_offers();
  void set_allocated_decline_inverse_offers(::mesos::scheduler::Call_DeclineInverseOffers* decline_inverse_offers);
  void unsafe_arena_set_allocated_decline_inverse_offers(
      ::mesos::scheduler::Call_DeclineInverseOffers* decline_inverse_offers);
  ::mesos::scheduler::Call_DeclineInverseOffers* unsafe_arena_release_decline_inverse_offers();

  // optional .mesos.scheduler.Call.Revive revive = 15;
  bool has_revive() const;
  void clear_revive();
  static const int kReviveFieldNumber = 15;
  private:
  void _slow_mutable_revive();
  public:
  const ::mesos::scheduler::Call_Revive& revive() const;
  ::mesos::scheduler::Call_Revive* release_revive();
  ::mesos::scheduler::Call_Revive* mutable_revive();
  void set_allocated_revive(::mesos::scheduler::Call_Revive* revive);
  void unsafe_arena_set_allocated_revive(
      ::mesos::scheduler::Call_Revive* revive);
  ::mesos::scheduler::Call_Revive* unsafe_arena_release_revive();

  // optional .mesos.scheduler.Call.Suppress suppress = 16;
  bool has_suppress() const;
  void clear_suppress();
  static const int kSuppressFieldNumber = 16;
  private:
  void _slow_mutable_suppress();
  public:
  const ::mesos::scheduler::Call_Suppress& suppress() const;
  ::mesos::scheduler::Call_Suppress* release_suppress();
  ::mesos::scheduler::Call_Suppress* mutable_suppress();
  void set_allocated_suppress(::mesos::scheduler::Call_Suppress* suppress);
  void unsafe_arena_set_allocated_suppress(
      ::mesos::scheduler::Call_Suppress* suppress);
  ::mesos::scheduler::Call_Suppress* unsafe_arena_release_suppress();

  // optional .mesos.scheduler.Call.AcknowledgeOperationStatus acknowledge_operation_status = 17;
  bool has_acknowledge_operation_status() const;
  void clear_acknowledge_operation_status();
  static const int kAcknowledgeOperationStatusFieldNumber = 17;
  private:
  void _slow_mutable_acknowledge_operation_status();
  public:
  const ::mesos::scheduler::Call_AcknowledgeOperationStatus& acknowledge_operation_status() const;
  ::mesos::scheduler::Call_AcknowledgeOperationStatus* release_acknowledge_operation_status();
  ::mesos::scheduler::Call_AcknowledgeOperationStatus* mutable_acknowledge_operation_status();
  void set_allocated_acknowledge_operation_status(::mesos::scheduler::Call_AcknowledgeOperationStatus* acknowledge_operation_status);
  void unsafe_arena_set_allocated_acknowledge_operation_status(
      ::mesos::scheduler::Call_AcknowledgeOperationStatus* acknowledge_operation_status);
  ::mesos::scheduler::Call_AcknowledgeOperationStatus* unsafe_arena_release_acknowledge_operation_status();

  // optional .mesos.scheduler.Call.ReconcileOperations reconcile_operations = 18;
  bool has_reconcile_operations() const;
  void clear_reconcile_operations();
  static const int kReconcileOperationsFieldNumber = 18;
  private:
  void _slow_mutable_reconcile_operations();
  public:
  const ::mesos::scheduler::Call_ReconcileOperations& reconcile_operations() const;
  ::mesos::scheduler::Call_ReconcileOperations* release_reconcile_operations();
  ::mesos::scheduler::Call_ReconcileOperations* mutable_reconcile_operations();
  void set_allocated_reconcile_operations(::mesos::scheduler::Call_ReconcileOperations* reconcile_operations);
  void unsafe_arena_set_allocated_reconcile_operations(
      ::mesos::scheduler::Call_ReconcileOperations* reconcile_operations);
  ::mesos::scheduler::Call_ReconcileOperations* unsafe_arena_release_reconcile_operations();

  // optional .mesos.scheduler.Call.Type type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::mesos::scheduler::Call_Type type() const;
  void set_type(::mesos::scheduler::Call_Type value);

  // @@protoc_insertion_point(class_scope:mesos.scheduler.Call)
 private:
  void set_has_framework_id();
  void clear_has_framework_id();
  void set_has_type();
  void clear_has_type();
  void set_has_subscribe();
  void clear_has_subscribe();
  void set_has_accept();
  void clear_has_accept();
  void set_has_decline();
  void clear_has_decline();
  void set_has_accept_inverse_offers();
  void clear_has_accept_inverse_offers();
  void set_has_decline_inverse_offers();
  void clear_has_decline_inverse_offers();
  void set_has_revive();
  void clear_has_revive();
  void set_has_kill();
  void clear_has_kill();
  void set_has_shutdown();
  void clear_has_shutdown();
  void set_has_acknowledge();
  void clear_has_acknowledge();
  void set_has_acknowledge_operation_status();
  void clear_has_acknowledge_operation_status();
  void set_has_reconcile();
  void clear_has_reconcile();
  void set_has_reconcile_operations();
  void clear_has_reconcile_operations();
  void set_has_message();
  void clear_has_message();
  void set_has_request();
  void clear_has_request();
  void set_has_suppress();
  void clear_has_suppress();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::FrameworkID* framework_id_;
  ::mesos::scheduler::Call_Subscribe* subscribe_;
  ::mesos::scheduler::Call_Accept* accept_;
  ::mesos::scheduler::Call_Decline* decline_;
  ::mesos::scheduler::Call_Kill* kill_;
  ::mesos::scheduler::Call_Shutdown* shutdown_;
  ::mesos::scheduler::Call_Acknowledge* acknowledge_;
  ::mesos::scheduler::Call_Reconcile* reconcile_;
  ::mesos::scheduler::Call_Message* message_;
  ::mesos::scheduler::Call_Request* request_;
  ::mesos::scheduler::Call_AcceptInverseOffers* accept_inverse_offers_;
  ::mesos::scheduler::Call_DeclineInverseOffers* decline_inverse_offers_;
  ::mesos::scheduler::Call_Revive* revive_;
  ::mesos::scheduler::Call_Suppress* suppress_;
  ::mesos::scheduler::Call_AcknowledgeOperationStatus* acknowledge_operation_status_;
  ::mesos::scheduler::Call_ReconcileOperations* reconcile_operations_;
  int type_;
  friend struct ::protobuf_mesos_2fscheduler_2fscheduler_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fscheduler_2fscheduler_2eproto::InitDefaultsCallImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Event_Subscribed

// required .mesos.FrameworkID framework_id = 1;
inline bool Event_Subscribed::has_framework_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Event_Subscribed::set_has_framework_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Event_Subscribed::clear_has_framework_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::mesos::FrameworkID& Event_Subscribed::framework_id() const {
  const ::mesos::FrameworkID* p = framework_id_;
  // @@protoc_insertion_point(field_get:mesos.scheduler.Event.Subscribed.framework_id)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::FrameworkID*>(
      &::mesos::_FrameworkID_default_instance_);
}
inline ::mesos::FrameworkID* Event_Subscribed::release_framework_id() {
  // @@protoc_insertion_point(field_release:mesos.scheduler.Event.Subscribed.framework_id)
  clear_has_framework_id();
  ::mesos::FrameworkID* temp = framework_id_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  framework_id_ = NULL;
  return temp;
}
inline ::mesos::FrameworkID* Event_Subscribed::unsafe_arena_release_framework_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.scheduler.Event.Subscribed.framework_id)
  clear_has_framework_id();
  ::mesos::FrameworkID* temp = framework_id_;
  framework_id_ = NULL;
  return temp;
}
inline ::mesos::FrameworkID* Event_Subscribed::mutable_framework_id() {
  set_has_framework_id();
  if (framework_id_ == NULL) {
    _slow_mutable_framework_id();
  }
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Event.Subscribed.framework_id)
  return framework_id_;
}
inline void Event_Subscribed::set_allocated_framework_id(::mesos::FrameworkID* framework_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(framework_id_);
  }
  if (framework_id) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(framework_id)->GetArena();
    if (message_arena != submessage_arena) {
      framework_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, framework_id, submessage_arena);
    }
    set_has_framework_id();
  } else {
    clear_has_framework_id();
  }
  framework_id_ = framework_id;
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Event.Subscribed.framework_id)
}

// optional double heartbeat_interval_seconds = 2;
inline bool Event_Subscribed::has_heartbeat_interval_seconds() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Event_Subscribed::set_has_heartbeat_interval_seconds() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Event_Subscribed::clear_has_heartbeat_interval_seconds() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Event_Subscribed::clear_heartbeat_interval_seconds() {
  heartbeat_interval_seconds_ = 0;
  clear_has_heartbeat_interval_seconds();
}
inline double Event_Subscribed::heartbeat_interval_seconds() const {
  // @@protoc_insertion_point(field_get:mesos.scheduler.Event.Subscribed.heartbeat_interval_seconds)
  return heartbeat_interval_seconds_;
}
inline void Event_Subscribed::set_heartbeat_interval_seconds(double value) {
  set_has_heartbeat_interval_seconds();
  heartbeat_interval_seconds_ = value;
  // @@protoc_insertion_point(field_set:mesos.scheduler.Event.Subscribed.heartbeat_interval_seconds)
}

// optional .mesos.MasterInfo master_info = 3;
inline bool Event_Subscribed::has_master_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Event_Subscribed::set_has_master_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Event_Subscribed::clear_has_master_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::mesos::MasterInfo& Event_Subscribed::master_info() const {
  const ::mesos::MasterInfo* p = master_info_;
  // @@protoc_insertion_point(field_get:mesos.scheduler.Event.Subscribed.master_info)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::MasterInfo*>(
      &::mesos::_MasterInfo_default_instance_);
}
inline ::mesos::MasterInfo* Event_Subscribed::release_master_info() {
  // @@protoc_insertion_point(field_release:mesos.scheduler.Event.Subscribed.master_info)
  clear_has_master_info();
  ::mesos::MasterInfo* temp = master_info_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  master_info_ = NULL;
  return temp;
}
inline ::mesos::MasterInfo* Event_Subscribed::unsafe_arena_release_master_info() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.scheduler.Event.Subscribed.master_info)
  clear_has_master_info();
  ::mesos::MasterInfo* temp = master_info_;
  master_info_ = NULL;
  return temp;
}
inline ::mesos::MasterInfo* Event_Subscribed::mutable_master_info() {
  set_has_master_info();
  if (master_info_ == NULL) {
    _slow_mutable_master_info();
  }
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Event.Subscribed.master_info)
  return master_info_;
}
inline void Event_Subscribed::set_allocated_master_info(::mesos::MasterInfo* master_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(master_info_);
  }
  if (master_info) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(master_info)->GetArena();
    if (message_arena != submessage_arena) {
      master_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, master_info, submessage_arena);
    }
    set_has_master_info();
  } else {
    clear_has_master_info();
  }
  master_info_ = master_info;
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Event.Subscribed.master_info)
}

// -------------------------------------------------------------------

// Event_Offers

// repeated .mesos.Offer offers = 1;
inline int Event_Offers::offers_size() const {
  return offers_.size();
}
inline const ::mesos::Offer& Event_Offers::offers(int index) const {
  // @@protoc_insertion_point(field_get:mesos.scheduler.Event.Offers.offers)
  return offers_.Get(index);
}
inline ::mesos::Offer* Event_Offers::mutable_offers(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Event.Offers.offers)
  return offers_.Mutable(index);
}
inline ::mesos::Offer* Event_Offers::add_offers() {
  // @@protoc_insertion_point(field_add:mesos.scheduler.Event.Offers.offers)
  return offers_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Offer >*
Event_Offers::mutable_offers() {
  // @@protoc_insertion_point(field_mutable_list:mesos.scheduler.Event.Offers.offers)
  return &offers_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Offer >&
Event_Offers::offers() const {
  // @@protoc_insertion_point(field_list:mesos.scheduler.Event.Offers.offers)
  return offers_;
}

// -------------------------------------------------------------------

// Event_InverseOffers

// repeated .mesos.InverseOffer inverse_offers = 1;
inline int Event_InverseOffers::inverse_offers_size() const {
  return inverse_offers_.size();
}
inline const ::mesos::InverseOffer& Event_InverseOffers::inverse_offers(int index) const {
  // @@protoc_insertion_point(field_get:mesos.scheduler.Event.InverseOffers.inverse_offers)
  return inverse_offers_.Get(index);
}
inline ::mesos::InverseOffer* Event_InverseOffers::mutable_inverse_offers(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Event.InverseOffers.inverse_offers)
  return inverse_offers_.Mutable(index);
}
inline ::mesos::InverseOffer* Event_InverseOffers::add_inverse_offers() {
  // @@protoc_insertion_point(field_add:mesos.scheduler.Event.InverseOffers.inverse_offers)
  return inverse_offers_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::InverseOffer >*
Event_InverseOffers::mutable_inverse_offers() {
  // @@protoc_insertion_point(field_mutable_list:mesos.scheduler.Event.InverseOffers.inverse_offers)
  return &inverse_offers_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::InverseOffer >&
Event_InverseOffers::inverse_offers() const {
  // @@protoc_insertion_point(field_list:mesos.scheduler.Event.InverseOffers.inverse_offers)
  return inverse_offers_;
}

// -------------------------------------------------------------------

// Event_Rescind

// required .mesos.OfferID offer_id = 1;
inline bool Event_Rescind::has_offer_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Event_Rescind::set_has_offer_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Event_Rescind::clear_has_offer_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::mesos::OfferID& Event_Rescind::offer_id() const {
  const ::mesos::OfferID* p = offer_id_;
  // @@protoc_insertion_point(field_get:mesos.scheduler.Event.Rescind.offer_id)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::OfferID*>(
      &::mesos::_OfferID_default_instance_);
}
inline ::mesos::OfferID* Event_Rescind::release_offer_id() {
  // @@protoc_insertion_point(field_release:mesos.scheduler.Event.Rescind.offer_id)
  clear_has_offer_id();
  ::mesos::OfferID* temp = offer_id_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  offer_id_ = NULL;
  return temp;
}
inline ::mesos::OfferID* Event_Rescind::unsafe_arena_release_offer_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.scheduler.Event.Rescind.offer_id)
  clear_has_offer_id();
  ::mesos::OfferID* temp = offer_id_;
  offer_id_ = NULL;
  return temp;
}
inline ::mesos::OfferID* Event_Rescind::mutable_offer_id() {
  set_has_offer_id();
  if (offer_id_ == NULL) {
    _slow_mutable_offer_id();
  }
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Event.Rescind.offer_id)
  return offer_id_;
}
inline void Event_Rescind::set_allocated_offer_id(::mesos::OfferID* offer_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(offer_id_);
  }
  if (offer_id) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(offer_id)->GetArena();
    if (message_arena != submessage_arena) {
      offer_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, offer_id, submessage_arena);
    }
    set_has_offer_id();
  } else {
    clear_has_offer_id();
  }
  offer_id_ = offer_id;
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Event.Rescind.offer_id)
}

// -------------------------------------------------------------------

// Event_RescindInverseOffer

// required .mesos.OfferID inverse_offer_id = 1;
inline bool Event_RescindInverseOffer::has_inverse_offer_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Event_RescindInverseOffer::set_has_inverse_offer_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Event_RescindInverseOffer::clear_has_inverse_offer_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::mesos::OfferID& Event_RescindInverseOffer::inverse_offer_id() const {
  const ::mesos::OfferID* p = inverse_offer_id_;
  // @@protoc_insertion_point(field_get:mesos.scheduler.Event.RescindInverseOffer.inverse_offer_id)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::OfferID*>(
      &::mesos::_OfferID_default_instance_);
}
inline ::mesos::OfferID* Event_RescindInverseOffer::release_inverse_offer_id() {
  // @@protoc_insertion_point(field_release:mesos.scheduler.Event.RescindInverseOffer.inverse_offer_id)
  clear_has_inverse_offer_id();
  ::mesos::OfferID* temp = inverse_offer_id_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  inverse_offer_id_ = NULL;
  return temp;
}
inline ::mesos::OfferID* Event_RescindInverseOffer::unsafe_arena_release_inverse_offer_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.scheduler.Event.RescindInverseOffer.inverse_offer_id)
  clear_has_inverse_offer_id();
  ::mesos::OfferID* temp = inverse_offer_id_;
  inverse_offer_id_ = NULL;
  return temp;
}
inline ::mesos::OfferID* Event_RescindInverseOffer::mutable_inverse_offer_id() {
  set_has_inverse_offer_id();
  if (inverse_offer_id_ == NULL) {
    _slow_mutable_inverse_offer_id();
  }
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Event.RescindInverseOffer.inverse_offer_id)
  return inverse_offer_id_;
}
inline void Event_RescindInverseOffer::set_allocated_inverse_offer_id(::mesos::OfferID* inverse_offer_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(inverse_offer_id_);
  }
  if (inverse_offer_id) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(inverse_offer_id)->GetArena();
    if (message_arena != submessage_arena) {
      inverse_offer_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, inverse_offer_id, submessage_arena);
    }
    set_has_inverse_offer_id();
  } else {
    clear_has_inverse_offer_id();
  }
  inverse_offer_id_ = inverse_offer_id;
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Event.RescindInverseOffer.inverse_offer_id)
}

// -------------------------------------------------------------------

// Event_Update

// required .mesos.TaskStatus status = 1;
inline bool Event_Update::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Event_Update::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Event_Update::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::mesos::TaskStatus& Event_Update::status() const {
  const ::mesos::TaskStatus* p = status_;
  // @@protoc_insertion_point(field_get:mesos.scheduler.Event.Update.status)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::TaskStatus*>(
      &::mesos::_TaskStatus_default_instance_);
}
inline ::mesos::TaskStatus* Event_Update::release_status() {
  // @@protoc_insertion_point(field_release:mesos.scheduler.Event.Update.status)
  clear_has_status();
  ::mesos::TaskStatus* temp = status_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  status_ = NULL;
  return temp;
}
inline ::mesos::TaskStatus* Event_Update::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.scheduler.Event.Update.status)
  clear_has_status();
  ::mesos::TaskStatus* temp = status_;
  status_ = NULL;
  return temp;
}
inline ::mesos::TaskStatus* Event_Update::mutable_status() {
  set_has_status();
  if (status_ == NULL) {
    _slow_mutable_status();
  }
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Event.Update.status)
  return status_;
}
inline void Event_Update::set_allocated_status(::mesos::TaskStatus* status) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(status_);
  }
  if (status) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(status)->GetArena();
    if (message_arena != submessage_arena) {
      status = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    set_has_status();
  } else {
    clear_has_status();
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Event.Update.status)
}

// -------------------------------------------------------------------

// Event_UpdateOperationStatus

// required .mesos.OperationStatus status = 1;
inline bool Event_UpdateOperationStatus::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Event_UpdateOperationStatus::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Event_UpdateOperationStatus::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::mesos::OperationStatus& Event_UpdateOperationStatus::status() const {
  const ::mesos::OperationStatus* p = status_;
  // @@protoc_insertion_point(field_get:mesos.scheduler.Event.UpdateOperationStatus.status)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::OperationStatus*>(
      &::mesos::_OperationStatus_default_instance_);
}
inline ::mesos::OperationStatus* Event_UpdateOperationStatus::release_status() {
  // @@protoc_insertion_point(field_release:mesos.scheduler.Event.UpdateOperationStatus.status)
  clear_has_status();
  ::mesos::OperationStatus* temp = status_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  status_ = NULL;
  return temp;
}
inline ::mesos::OperationStatus* Event_UpdateOperationStatus::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.scheduler.Event.UpdateOperationStatus.status)
  clear_has_status();
  ::mesos::OperationStatus* temp = status_;
  status_ = NULL;
  return temp;
}
inline ::mesos::OperationStatus* Event_UpdateOperationStatus::mutable_status() {
  set_has_status();
  if (status_ == NULL) {
    _slow_mutable_status();
  }
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Event.UpdateOperationStatus.status)
  return status_;
}
inline void Event_UpdateOperationStatus::set_allocated_status(::mesos::OperationStatus* status) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(status_);
  }
  if (status) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(status)->GetArena();
    if (message_arena != submessage_arena) {
      status = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    set_has_status();
  } else {
    clear_has_status();
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Event.UpdateOperationStatus.status)
}

// -------------------------------------------------------------------

// Event_Message

// required .mesos.SlaveID slave_id = 1;
inline bool Event_Message::has_slave_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Event_Message::set_has_slave_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Event_Message::clear_has_slave_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::mesos::SlaveID& Event_Message::slave_id() const {
  const ::mesos::SlaveID* p = slave_id_;
  // @@protoc_insertion_point(field_get:mesos.scheduler.Event.Message.slave_id)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::SlaveID*>(
      &::mesos::_SlaveID_default_instance_);
}
inline ::mesos::SlaveID* Event_Message::release_slave_id() {
  // @@protoc_insertion_point(field_release:mesos.scheduler.Event.Message.slave_id)
  clear_has_slave_id();
  ::mesos::SlaveID* temp = slave_id_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  slave_id_ = NULL;
  return temp;
}
inline ::mesos::SlaveID* Event_Message::unsafe_arena_release_slave_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.scheduler.Event.Message.slave_id)
  clear_has_slave_id();
  ::mesos::SlaveID* temp = slave_id_;
  slave_id_ = NULL;
  return temp;
}
inline ::mesos::SlaveID* Event_Message::mutable_slave_id() {
  set_has_slave_id();
  if (slave_id_ == NULL) {
    _slow_mutable_slave_id();
  }
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Event.Message.slave_id)
  return slave_id_;
}
inline void Event_Message::set_allocated_slave_id(::mesos::SlaveID* slave_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(slave_id_);
  }
  if (slave_id) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(slave_id)->GetArena();
    if (message_arena != submessage_arena) {
      slave_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, slave_id, submessage_arena);
    }
    set_has_slave_id();
  } else {
    clear_has_slave_id();
  }
  slave_id_ = slave_id;
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Event.Message.slave_id)
}

// required .mesos.ExecutorID executor_id = 2;
inline bool Event_Message::has_executor_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Event_Message::set_has_executor_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Event_Message::clear_has_executor_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::mesos::ExecutorID& Event_Message::executor_id() const {
  const ::mesos::ExecutorID* p = executor_id_;
  // @@protoc_insertion_point(field_get:mesos.scheduler.Event.Message.executor_id)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ExecutorID*>(
      &::mesos::_ExecutorID_default_instance_);
}
inline ::mesos::ExecutorID* Event_Message::release_executor_id() {
  // @@protoc_insertion_point(field_release:mesos.scheduler.Event.Message.executor_id)
  clear_has_executor_id();
  ::mesos::ExecutorID* temp = executor_id_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  executor_id_ = NULL;
  return temp;
}
inline ::mesos::ExecutorID* Event_Message::unsafe_arena_release_executor_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.scheduler.Event.Message.executor_id)
  clear_has_executor_id();
  ::mesos::ExecutorID* temp = executor_id_;
  executor_id_ = NULL;
  return temp;
}
inline ::mesos::ExecutorID* Event_Message::mutable_executor_id() {
  set_has_executor_id();
  if (executor_id_ == NULL) {
    _slow_mutable_executor_id();
  }
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Event.Message.executor_id)
  return executor_id_;
}
inline void Event_Message::set_allocated_executor_id(::mesos::ExecutorID* executor_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(executor_id_);
  }
  if (executor_id) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(executor_id)->GetArena();
    if (message_arena != submessage_arena) {
      executor_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, executor_id, submessage_arena);
    }
    set_has_executor_id();
  } else {
    clear_has_executor_id();
  }
  executor_id_ = executor_id;
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Event.Message.executor_id)
}

// required bytes data = 3;
inline bool Event_Message::has_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Event_Message::set_has_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Event_Message::clear_has_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Event_Message::clear_data() {
  data_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_data();
}
inline const ::std::string& Event_Message::data() const {
  // @@protoc_insertion_point(field_get:mesos.scheduler.Event.Message.data)
  return data_.Get();
}
inline void Event_Message::set_data(const ::std::string& value) {
  set_has_data();
  data_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.scheduler.Event.Message.data)
}
#if LANG_CXX11
inline void Event_Message::set_data(::std::string&& value) {
  set_has_data();
  data_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.scheduler.Event.Message.data)
}
#endif
inline void Event_Message::set_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_data();
  data_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.scheduler.Event.Message.data)
}
inline void Event_Message::set_data(const void* value,
    size_t size) {
  set_has_data();
  data_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.scheduler.Event.Message.data)
}
inline ::std::string* Event_Message::mutable_data() {
  set_has_data();
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Event.Message.data)
  return data_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* Event_Message::release_data() {
  // @@protoc_insertion_point(field_release:mesos.scheduler.Event.Message.data)
  clear_has_data();
  return data_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void Event_Message::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    set_has_data();
  } else {
    clear_has_data();
  }
  data_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Event.Message.data)
}
inline ::std::string* Event_Message::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.scheduler.Event.Message.data)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_data();
  return data_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void Event_Message::unsafe_arena_set_allocated_data(
    ::std::string* data) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (data != NULL) {
    set_has_data();
  } else {
    clear_has_data();
  }
  data_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      data, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.scheduler.Event.Message.data)
}

// -------------------------------------------------------------------

// Event_Failure

// optional .mesos.SlaveID slave_id = 1;
inline bool Event_Failure::has_slave_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Event_Failure::set_has_slave_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Event_Failure::clear_has_slave_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::mesos::SlaveID& Event_Failure::slave_id() const {
  const ::mesos::SlaveID* p = slave_id_;
  // @@protoc_insertion_point(field_get:mesos.scheduler.Event.Failure.slave_id)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::SlaveID*>(
      &::mesos::_SlaveID_default_instance_);
}
inline ::mesos::SlaveID* Event_Failure::release_slave_id() {
  // @@protoc_insertion_point(field_release:mesos.scheduler.Event.Failure.slave_id)
  clear_has_slave_id();
  ::mesos::SlaveID* temp = slave_id_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  slave_id_ = NULL;
  return temp;
}
inline ::mesos::SlaveID* Event_Failure::unsafe_arena_release_slave_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.scheduler.Event.Failure.slave_id)
  clear_has_slave_id();
  ::mesos::SlaveID* temp = slave_id_;
  slave_id_ = NULL;
  return temp;
}
inline ::mesos::SlaveID* Event_Failure::mutable_slave_id() {
  set_has_slave_id();
  if (slave_id_ == NULL) {
    _slow_mutable_slave_id();
  }
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Event.Failure.slave_id)
  return slave_id_;
}
inline void Event_Failure::set_allocated_slave_id(::mesos::SlaveID* slave_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(slave_id_);
  }
  if (slave_id) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(slave_id)->GetArena();
    if (message_arena != submessage_arena) {
      slave_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, slave_id, submessage_arena);
    }
    set_has_slave_id();
  } else {
    clear_has_slave_id();
  }
  slave_id_ = slave_id;
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Event.Failure.slave_id)
}

// optional .mesos.ExecutorID executor_id = 2;
inline bool Event_Failure::has_executor_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Event_Failure::set_has_executor_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Event_Failure::clear_has_executor_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::mesos::ExecutorID& Event_Failure::executor_id() const {
  const ::mesos::ExecutorID* p = executor_id_;
  // @@protoc_insertion_point(field_get:mesos.scheduler.Event.Failure.executor_id)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ExecutorID*>(
      &::mesos::_ExecutorID_default_instance_);
}
inline ::mesos::ExecutorID* Event_Failure::release_executor_id() {
  // @@protoc_insertion_point(field_release:mesos.scheduler.Event.Failure.executor_id)
  clear_has_executor_id();
  ::mesos::ExecutorID* temp = executor_id_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  executor_id_ = NULL;
  return temp;
}
inline ::mesos::ExecutorID* Event_Failure::unsafe_arena_release_executor_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.scheduler.Event.Failure.executor_id)
  clear_has_executor_id();
  ::mesos::ExecutorID* temp = executor_id_;
  executor_id_ = NULL;
  return temp;
}
inline ::mesos::ExecutorID* Event_Failure::mutable_executor_id() {
  set_has_executor_id();
  if (executor_id_ == NULL) {
    _slow_mutable_executor_id();
  }
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Event.Failure.executor_id)
  return executor_id_;
}
inline void Event_Failure::set_allocated_executor_id(::mesos::ExecutorID* executor_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(executor_id_);
  }
  if (executor_id) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(executor_id)->GetArena();
    if (message_arena != submessage_arena) {
      executor_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, executor_id, submessage_arena);
    }
    set_has_executor_id();
  } else {
    clear_has_executor_id();
  }
  executor_id_ = executor_id;
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Event.Failure.executor_id)
}

// optional int32 status = 3;
inline bool Event_Failure::has_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Event_Failure::set_has_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Event_Failure::clear_has_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Event_Failure::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 Event_Failure::status() const {
  // @@protoc_insertion_point(field_get:mesos.scheduler.Event.Failure.status)
  return status_;
}
inline void Event_Failure::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:mesos.scheduler.Event.Failure.status)
}

// -------------------------------------------------------------------

// Event_Error

// required string message = 1;
inline bool Event_Error::has_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Event_Error::set_has_message() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Event_Error::clear_has_message() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Event_Error::clear_message() {
  message_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_message();
}
inline const ::std::string& Event_Error::message() const {
  // @@protoc_insertion_point(field_get:mesos.scheduler.Event.Error.message)
  return message_.Get();
}
inline void Event_Error::set_message(const ::std::string& value) {
  set_has_message();
  message_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.scheduler.Event.Error.message)
}
#if LANG_CXX11
inline void Event_Error::set_message(::std::string&& value) {
  set_has_message();
  message_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.scheduler.Event.Error.message)
}
#endif
inline void Event_Error::set_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_message();
  message_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.scheduler.Event.Error.message)
}
inline void Event_Error::set_message(const char* value,
    size_t size) {
  set_has_message();
  message_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.scheduler.Event.Error.message)
}
inline ::std::string* Event_Error::mutable_message() {
  set_has_message();
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Event.Error.message)
  return message_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* Event_Error::release_message() {
  // @@protoc_insertion_point(field_release:mesos.scheduler.Event.Error.message)
  clear_has_message();
  return message_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void Event_Error::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    set_has_message();
  } else {
    clear_has_message();
  }
  message_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Event.Error.message)
}
inline ::std::string* Event_Error::unsafe_arena_release_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.scheduler.Event.Error.message)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_message();
  return message_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void Event_Error::unsafe_arena_set_allocated_message(
    ::std::string* message) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (message != NULL) {
    set_has_message();
  } else {
    clear_has_message();
  }
  message_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      message, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.scheduler.Event.Error.message)
}

// -------------------------------------------------------------------

// Event

// optional .mesos.scheduler.Event.Type type = 1;
inline bool Event::has_type() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Event::set_has_type() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Event::clear_has_type() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Event::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::mesos::scheduler::Event_Type Event::type() const {
  // @@protoc_insertion_point(field_get:mesos.scheduler.Event.type)
  return static_cast< ::mesos::scheduler::Event_Type >(type_);
}
inline void Event::set_type(::mesos::scheduler::Event_Type value) {
  assert(::mesos::scheduler::Event_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:mesos.scheduler.Event.type)
}

// optional .mesos.scheduler.Event.Subscribed subscribed = 2;
inline bool Event::has_subscribed() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Event::set_has_subscribed() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Event::clear_has_subscribed() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Event::clear_subscribed() {
  if (subscribed_ != NULL) subscribed_->Clear();
  clear_has_subscribed();
}
inline const ::mesos::scheduler::Event_Subscribed& Event::subscribed() const {
  const ::mesos::scheduler::Event_Subscribed* p = subscribed_;
  // @@protoc_insertion_point(field_get:mesos.scheduler.Event.subscribed)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::scheduler::Event_Subscribed*>(
      &::mesos::scheduler::_Event_Subscribed_default_instance_);
}
inline ::mesos::scheduler::Event_Subscribed* Event::release_subscribed() {
  // @@protoc_insertion_point(field_release:mesos.scheduler.Event.subscribed)
  clear_has_subscribed();
  ::mesos::scheduler::Event_Subscribed* temp = subscribed_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  subscribed_ = NULL;
  return temp;
}
inline ::mesos::scheduler::Event_Subscribed* Event::unsafe_arena_release_subscribed() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.scheduler.Event.subscribed)
  clear_has_subscribed();
  ::mesos::scheduler::Event_Subscribed* temp = subscribed_;
  subscribed_ = NULL;
  return temp;
}
inline ::mesos::scheduler::Event_Subscribed* Event::mutable_subscribed() {
  set_has_subscribed();
  if (subscribed_ == NULL) {
    _slow_mutable_subscribed();
  }
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Event.subscribed)
  return subscribed_;
}
inline void Event::set_allocated_subscribed(::mesos::scheduler::Event_Subscribed* subscribed) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete subscribed_;
  }
  if (subscribed) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(subscribed);
    if (message_arena != submessage_arena) {
      subscribed = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, subscribed, submessage_arena);
    }
    set_has_subscribed();
  } else {
    clear_has_subscribed();
  }
  subscribed_ = subscribed;
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Event.subscribed)
}

// optional .mesos.scheduler.Event.Offers offers = 3;
inline bool Event::has_offers() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Event::set_has_offers() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Event::clear_has_offers() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Event::clear_offers() {
  if (offers_ != NULL) offers_->Clear();
  clear_has_offers();
}
inline const ::mesos::scheduler::Event_Offers& Event::offers() const {
  const ::mesos::scheduler::Event_Offers* p = offers_;
  // @@protoc_insertion_point(field_get:mesos.scheduler.Event.offers)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::scheduler::Event_Offers*>(
      &::mesos::scheduler::_Event_Offers_default_instance_);
}
inline ::mesos::scheduler::Event_Offers* Event::release_offers() {
  // @@protoc_insertion_point(field_release:mesos.scheduler.Event.offers)
  clear_has_offers();
  ::mesos::scheduler::Event_Offers* temp = offers_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  offers_ = NULL;
  return temp;
}
inline ::mesos::scheduler::Event_Offers* Event::unsafe_arena_release_offers() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.scheduler.Event.offers)
  clear_has_offers();
  ::mesos::scheduler::Event_Offers* temp = offers_;
  offers_ = NULL;
  return temp;
}
inline ::mesos::scheduler::Event_Offers* Event::mutable_offers() {
  set_has_offers();
  if (offers_ == NULL) {
    _slow_mutable_offers();
  }
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Event.offers)
  return offers_;
}
inline void Event::set_allocated_offers(::mesos::scheduler::Event_Offers* offers) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete offers_;
  }
  if (offers) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(offers);
    if (message_arena != submessage_arena) {
      offers = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, offers, submessage_arena);
    }
    set_has_offers();
  } else {
    clear_has_offers();
  }
  offers_ = offers;
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Event.offers)
}

// optional .mesos.scheduler.Event.InverseOffers inverse_offers = 9;
inline bool Event::has_inverse_offers() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Event::set_has_inverse_offers() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Event::clear_has_inverse_offers() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Event::clear_inverse_offers() {
  if (inverse_offers_ != NULL) inverse_offers_->Clear();
  clear_has_inverse_offers();
}
inline const ::mesos::scheduler::Event_InverseOffers& Event::inverse_offers() const {
  const ::mesos::scheduler::Event_InverseOffers* p = inverse_offers_;
  // @@protoc_insertion_point(field_get:mesos.scheduler.Event.inverse_offers)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::scheduler::Event_InverseOffers*>(
      &::mesos::scheduler::_Event_InverseOffers_default_instance_);
}
inline ::mesos::scheduler::Event_InverseOffers* Event::release_inverse_offers() {
  // @@protoc_insertion_point(field_release:mesos.scheduler.Event.inverse_offers)
  clear_has_inverse_offers();
  ::mesos::scheduler::Event_InverseOffers* temp = inverse_offers_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  inverse_offers_ = NULL;
  return temp;
}
inline ::mesos::scheduler::Event_InverseOffers* Event::unsafe_arena_release_inverse_offers() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.scheduler.Event.inverse_offers)
  clear_has_inverse_offers();
  ::mesos::scheduler::Event_InverseOffers* temp = inverse_offers_;
  inverse_offers_ = NULL;
  return temp;
}
inline ::mesos::scheduler::Event_InverseOffers* Event::mutable_inverse_offers() {
  set_has_inverse_offers();
  if (inverse_offers_ == NULL) {
    _slow_mutable_inverse_offers();
  }
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Event.inverse_offers)
  return inverse_offers_;
}
inline void Event::set_allocated_inverse_offers(::mesos::scheduler::Event_InverseOffers* inverse_offers) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete inverse_offers_;
  }
  if (inverse_offers) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(inverse_offers);
    if (message_arena != submessage_arena) {
      inverse_offers = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, inverse_offers, submessage_arena);
    }
    set_has_inverse_offers();
  } else {
    clear_has_inverse_offers();
  }
  inverse_offers_ = inverse_offers;
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Event.inverse_offers)
}

// optional .mesos.scheduler.Event.Rescind rescind = 4;
inline bool Event::has_rescind() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Event::set_has_rescind() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Event::clear_has_rescind() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Event::clear_rescind() {
  if (rescind_ != NULL) rescind_->Clear();
  clear_has_rescind();
}
inline const ::mesos::scheduler::Event_Rescind& Event::rescind() const {
  const ::mesos::scheduler::Event_Rescind* p = rescind_;
  // @@protoc_insertion_point(field_get:mesos.scheduler.Event.rescind)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::scheduler::Event_Rescind*>(
      &::mesos::scheduler::_Event_Rescind_default_instance_);
}
inline ::mesos::scheduler::Event_Rescind* Event::release_rescind() {
  // @@protoc_insertion_point(field_release:mesos.scheduler.Event.rescind)
  clear_has_rescind();
  ::mesos::scheduler::Event_Rescind* temp = rescind_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  rescind_ = NULL;
  return temp;
}
inline ::mesos::scheduler::Event_Rescind* Event::unsafe_arena_release_rescind() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.scheduler.Event.rescind)
  clear_has_rescind();
  ::mesos::scheduler::Event_Rescind* temp = rescind_;
  rescind_ = NULL;
  return temp;
}
inline ::mesos::scheduler::Event_Rescind* Event::mutable_rescind() {
  set_has_rescind();
  if (rescind_ == NULL) {
    _slow_mutable_rescind();
  }
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Event.rescind)
  return rescind_;
}
inline void Event::set_allocated_rescind(::mesos::scheduler::Event_Rescind* rescind) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete rescind_;
  }
  if (rescind) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(rescind);
    if (message_arena != submessage_arena) {
      rescind = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, rescind, submessage_arena);
    }
    set_has_rescind();
  } else {
    clear_has_rescind();
  }
  rescind_ = rescind;
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Event.rescind)
}

// optional .mesos.scheduler.Event.RescindInverseOffer rescind_inverse_offer = 10;
inline bool Event::has_rescind_inverse_offer() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Event::set_has_rescind_inverse_offer() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Event::clear_has_rescind_inverse_offer() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Event::clear_rescind_inverse_offer() {
  if (rescind_inverse_offer_ != NULL) rescind_inverse_offer_->Clear();
  clear_has_rescind_inverse_offer();
}
inline const ::mesos::scheduler::Event_RescindInverseOffer& Event::rescind_inverse_offer() const {
  const ::mesos::scheduler::Event_RescindInverseOffer* p = rescind_inverse_offer_;
  // @@protoc_insertion_point(field_get:mesos.scheduler.Event.rescind_inverse_offer)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::scheduler::Event_RescindInverseOffer*>(
      &::mesos::scheduler::_Event_RescindInverseOffer_default_instance_);
}
inline ::mesos::scheduler::Event_RescindInverseOffer* Event::release_rescind_inverse_offer() {
  // @@protoc_insertion_point(field_release:mesos.scheduler.Event.rescind_inverse_offer)
  clear_has_rescind_inverse_offer();
  ::mesos::scheduler::Event_RescindInverseOffer* temp = rescind_inverse_offer_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  rescind_inverse_offer_ = NULL;
  return temp;
}
inline ::mesos::scheduler::Event_RescindInverseOffer* Event::unsafe_arena_release_rescind_inverse_offer() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.scheduler.Event.rescind_inverse_offer)
  clear_has_rescind_inverse_offer();
  ::mesos::scheduler::Event_RescindInverseOffer* temp = rescind_inverse_offer_;
  rescind_inverse_offer_ = NULL;
  return temp;
}
inline ::mesos::scheduler::Event_RescindInverseOffer* Event::mutable_rescind_inverse_offer() {
  set_has_rescind_inverse_offer();
  if (rescind_inverse_offer_ == NULL) {
    _slow_mutable_rescind_inverse_offer();
  }
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Event.rescind_inverse_offer)
  return rescind_inverse_offer_;
}
inline void Event::set_allocated_rescind_inverse_offer(::mesos::scheduler::Event_RescindInverseOffer* rescind_inverse_offer) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete rescind_inverse_offer_;
  }
  if (rescind_inverse_offer) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(rescind_inverse_offer);
    if (message_arena != submessage_arena) {
      rescind_inverse_offer = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, rescind_inverse_offer, submessage_arena);
    }
    set_has_rescind_inverse_offer();
  } else {
    clear_has_rescind_inverse_offer();
  }
  rescind_inverse_offer_ = rescind_inverse_offer;
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Event.rescind_inverse_offer)
}

// optional .mesos.scheduler.Event.Update update = 5;
inline bool Event::has_update() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Event::set_has_update() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Event::clear_has_update() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Event::clear_update() {
  if (update_ != NULL) update_->Clear();
  clear_has_update();
}
inline const ::mesos::scheduler::Event_Update& Event::update() const {
  const ::mesos::scheduler::Event_Update* p = update_;
  // @@protoc_insertion_point(field_get:mesos.scheduler.Event.update)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::scheduler::Event_Update*>(
      &::mesos::scheduler::_Event_Update_default_instance_);
}
inline ::mesos::scheduler::Event_Update* Event::release_update() {
  // @@protoc_insertion_point(field_release:mesos.scheduler.Event.update)
  clear_has_update();
  ::mesos::scheduler::Event_Update* temp = update_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  update_ = NULL;
  return temp;
}
inline ::mesos::scheduler::Event_Update* Event::unsafe_arena_release_update() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.scheduler.Event.update)
  clear_has_update();
  ::mesos::scheduler::Event_Update* temp = update_;
  update_ = NULL;
  return temp;
}
inline ::mesos::scheduler::Event_Update* Event::mutable_update() {
  set_has_update();
  if (update_ == NULL) {
    _slow_mutable_update();
  }
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Event.update)
  return update_;
}
inline void Event::set_allocated_update(::mesos::scheduler::Event_Update* update) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete update_;
  }
  if (update) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(update);
    if (message_arena != submessage_arena) {
      update = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, update, submessage_arena);
    }
    set_has_update();
  } else {
    clear_has_update();
  }
  update_ = update;
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Event.update)
}

// optional .mesos.scheduler.Event.UpdateOperationStatus update_operation_status = 11;
inline bool Event::has_update_operation_status() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Event::set_has_update_operation_status() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Event::clear_has_update_operation_status() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Event::clear_update_operation_status() {
  if (update_operation_status_ != NULL) update_operation_status_->Clear();
  clear_has_update_operation_status();
}
inline const ::mesos::scheduler::Event_UpdateOperationStatus& Event::update_operation_status() const {
  const ::mesos::scheduler::Event_UpdateOperationStatus* p = update_operation_status_;
  // @@protoc_insertion_point(field_get:mesos.scheduler.Event.update_operation_status)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::scheduler::Event_UpdateOperationStatus*>(
      &::mesos::scheduler::_Event_UpdateOperationStatus_default_instance_);
}
inline ::mesos::scheduler::Event_UpdateOperationStatus* Event::release_update_operation_status() {
  // @@protoc_insertion_point(field_release:mesos.scheduler.Event.update_operation_status)
  clear_has_update_operation_status();
  ::mesos::scheduler::Event_UpdateOperationStatus* temp = update_operation_status_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  update_operation_status_ = NULL;
  return temp;
}
inline ::mesos::scheduler::Event_UpdateOperationStatus* Event::unsafe_arena_release_update_operation_status() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.scheduler.Event.update_operation_status)
  clear_has_update_operation_status();
  ::mesos::scheduler::Event_UpdateOperationStatus* temp = update_operation_status_;
  update_operation_status_ = NULL;
  return temp;
}
inline ::mesos::scheduler::Event_UpdateOperationStatus* Event::mutable_update_operation_status() {
  set_has_update_operation_status();
  if (update_operation_status_ == NULL) {
    _slow_mutable_update_operation_status();
  }
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Event.update_operation_status)
  return update_operation_status_;
}
inline void Event::set_allocated_update_operation_status(::mesos::scheduler::Event_UpdateOperationStatus* update_operation_status) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete update_operation_status_;
  }
  if (update_operation_status) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(update_operation_status);
    if (message_arena != submessage_arena) {
      update_operation_status = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, update_operation_status, submessage_arena);
    }
    set_has_update_operation_status();
  } else {
    clear_has_update_operation_status();
  }
  update_operation_status_ = update_operation_status;
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Event.update_operation_status)
}

// optional .mesos.scheduler.Event.Message message = 6;
inline bool Event::has_message() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Event::set_has_message() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Event::clear_has_message() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Event::clear_message() {
  if (message_ != NULL) message_->Clear();
  clear_has_message();
}
inline const ::mesos::scheduler::Event_Message& Event::message() const {
  const ::mesos::scheduler::Event_Message* p = message_;
  // @@protoc_insertion_point(field_get:mesos.scheduler.Event.message)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::scheduler::Event_Message*>(
      &::mesos::scheduler::_Event_Message_default_instance_);
}
inline ::mesos::scheduler::Event_Message* Event::release_message() {
  // @@protoc_insertion_point(field_release:mesos.scheduler.Event.message)
  clear_has_message();
  ::mesos::scheduler::Event_Message* temp = message_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  message_ = NULL;
  return temp;
}
inline ::mesos::scheduler::Event_Message* Event::unsafe_arena_release_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.scheduler.Event.message)
  clear_has_message();
  ::mesos::scheduler::Event_Message* temp = message_;
  message_ = NULL;
  return temp;
}
inline ::mesos::scheduler::Event_Message* Event::mutable_message() {
  set_has_message();
  if (message_ == NULL) {
    _slow_mutable_message();
  }
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Event.message)
  return message_;
}
inline void Event::set_allocated_message(::mesos::scheduler::Event_Message* message) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete message_;
  }
  if (message) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(message);
    if (message_arena != submessage_arena) {
      message = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, message, submessage_arena);
    }
    set_has_message();
  } else {
    clear_has_message();
  }
  message_ = message;
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Event.message)
}

// optional .mesos.scheduler.Event.Failure failure = 7;
inline bool Event::has_failure() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Event::set_has_failure() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Event::clear_has_failure() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Event::clear_failure() {
  if (failure_ != NULL) failure_->Clear();
  clear_has_failure();
}
inline const ::mesos::scheduler::Event_Failure& Event::failure() const {
  const ::mesos::scheduler::Event_Failure* p = failure_;
  // @@protoc_insertion_point(field_get:mesos.scheduler.Event.failure)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::scheduler::Event_Failure*>(
      &::mesos::scheduler::_Event_Failure_default_instance_);
}
inline ::mesos::scheduler::Event_Failure* Event::release_failure() {
  // @@protoc_insertion_point(field_release:mesos.scheduler.Event.failure)
  clear_has_failure();
  ::mesos::scheduler::Event_Failure* temp = failure_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  failure_ = NULL;
  return temp;
}
inline ::mesos::scheduler::Event_Failure* Event::unsafe_arena_release_failure() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.scheduler.Event.failure)
  clear_has_failure();
  ::mesos::scheduler::Event_Failure* temp = failure_;
  failure_ = NULL;
  return temp;
}
inline ::mesos::scheduler::Event_Failure* Event::mutable_failure() {
  set_has_failure();
  if (failure_ == NULL) {
    _slow_mutable_failure();
  }
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Event.failure)
  return failure_;
}
inline void Event::set_allocated_failure(::mesos::scheduler::Event_Failure* failure) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete failure_;
  }
  if (failure) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(failure);
    if (message_arena != submessage_arena) {
      failure = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, failure, submessage_arena);
    }
    set_has_failure();
  } else {
    clear_has_failure();
  }
  failure_ = failure;
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Event.failure)
}

// optional .mesos.scheduler.Event.Error error = 8;
inline bool Event::has_error() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Event::set_has_error() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Event::clear_has_error() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Event::clear_error() {
  if (error_ != NULL) error_->Clear();
  clear_has_error();
}
inline const ::mesos::scheduler::Event_Error& Event::error() const {
  const ::mesos::scheduler::Event_Error* p = error_;
  // @@protoc_insertion_point(field_get:mesos.scheduler.Event.error)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::scheduler::Event_Error*>(
      &::mesos::scheduler::_Event_Error_default_instance_);
}
inline ::mesos::scheduler::Event_Error* Event::release_error() {
  // @@protoc_insertion_point(field_release:mesos.scheduler.Event.error)
  clear_has_error();
  ::mesos::scheduler::Event_Error* temp = error_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  error_ = NULL;
  return temp;
}
inline ::mesos::scheduler::Event_Error* Event::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.scheduler.Event.error)
  clear_has_error();
  ::mesos::scheduler::Event_Error* temp = error_;
  error_ = NULL;
  return temp;
}
inline ::mesos::scheduler::Event_Error* Event::mutable_error() {
  set_has_error();
  if (error_ == NULL) {
    _slow_mutable_error();
  }
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Event.error)
  return error_;
}
inline void Event::set_allocated_error(::mesos::scheduler::Event_Error* error) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete error_;
  }
  if (error) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(error);
    if (message_arena != submessage_arena) {
      error = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    set_has_error();
  } else {
    clear_has_error();
  }
  error_ = error;
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Event.error)
}

// -------------------------------------------------------------------

// Response_ReconcileOperations

// repeated .mesos.OperationStatus operation_statuses = 1;
inline int Response_ReconcileOperations::operation_statuses_size() const {
  return operation_statuses_.size();
}
inline const ::mesos::OperationStatus& Response_ReconcileOperations::operation_statuses(int index) const {
  // @@protoc_insertion_point(field_get:mesos.scheduler.Response.ReconcileOperations.operation_statuses)
  return operation_statuses_.Get(index);
}
inline ::mesos::OperationStatus* Response_ReconcileOperations::mutable_operation_statuses(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Response.ReconcileOperations.operation_statuses)
  return operation_statuses_.Mutable(index);
}
inline ::mesos::OperationStatus* Response_ReconcileOperations::add_operation_statuses() {
  // @@protoc_insertion_point(field_add:mesos.scheduler.Response.ReconcileOperations.operation_statuses)
  return operation_statuses_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::OperationStatus >*
Response_ReconcileOperations::mutable_operation_statuses() {
  // @@protoc_insertion_point(field_mutable_list:mesos.scheduler.Response.ReconcileOperations.operation_statuses)
  return &operation_statuses_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::OperationStatus >&
Response_ReconcileOperations::operation_statuses() const {
  // @@protoc_insertion_point(field_list:mesos.scheduler.Response.ReconcileOperations.operation_statuses)
  return operation_statuses_;
}

// -------------------------------------------------------------------

// Response

// optional .mesos.scheduler.Response.Type type = 1;
inline bool Response::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Response::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Response::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Response::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::mesos::scheduler::Response_Type Response::type() const {
  // @@protoc_insertion_point(field_get:mesos.scheduler.Response.type)
  return static_cast< ::mesos::scheduler::Response_Type >(type_);
}
inline void Response::set_type(::mesos::scheduler::Response_Type value) {
  assert(::mesos::scheduler::Response_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:mesos.scheduler.Response.type)
}

// optional .mesos.scheduler.Response.ReconcileOperations reconcile_operations = 2;
inline bool Response::has_reconcile_operations() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Response::set_has_reconcile_operations() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Response::clear_has_reconcile_operations() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Response::clear_reconcile_operations() {
  if (reconcile_operations_ != NULL) reconcile_operations_->Clear();
  clear_has_reconcile_operations();
}
inline const ::mesos::scheduler::Response_ReconcileOperations& Response::reconcile_operations() const {
  const ::mesos::scheduler::Response_ReconcileOperations* p = reconcile_operations_;
  // @@protoc_insertion_point(field_get:mesos.scheduler.Response.reconcile_operations)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::scheduler::Response_ReconcileOperations*>(
      &::mesos::scheduler::_Response_ReconcileOperations_default_instance_);
}
inline ::mesos::scheduler::Response_ReconcileOperations* Response::release_reconcile_operations() {
  // @@protoc_insertion_point(field_release:mesos.scheduler.Response.reconcile_operations)
  clear_has_reconcile_operations();
  ::mesos::scheduler::Response_ReconcileOperations* temp = reconcile_operations_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  reconcile_operations_ = NULL;
  return temp;
}
inline ::mesos::scheduler::Response_ReconcileOperations* Response::unsafe_arena_release_reconcile_operations() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.scheduler.Response.reconcile_operations)
  clear_has_reconcile_operations();
  ::mesos::scheduler::Response_ReconcileOperations* temp = reconcile_operations_;
  reconcile_operations_ = NULL;
  return temp;
}
inline ::mesos::scheduler::Response_ReconcileOperations* Response::mutable_reconcile_operations() {
  set_has_reconcile_operations();
  if (reconcile_operations_ == NULL) {
    _slow_mutable_reconcile_operations();
  }
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Response.reconcile_operations)
  return reconcile_operations_;
}
inline void Response::set_allocated_reconcile_operations(::mesos::scheduler::Response_ReconcileOperations* reconcile_operations) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reconcile_operations_;
  }
  if (reconcile_operations) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(reconcile_operations);
    if (message_arena != submessage_arena) {
      reconcile_operations = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, reconcile_operations, submessage_arena);
    }
    set_has_reconcile_operations();
  } else {
    clear_has_reconcile_operations();
  }
  reconcile_operations_ = reconcile_operations;
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Response.reconcile_operations)
}

// -------------------------------------------------------------------

// Call_Subscribe

// required .mesos.FrameworkInfo framework_info = 1;
inline bool Call_Subscribe::has_framework_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Call_Subscribe::set_has_framework_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Call_Subscribe::clear_has_framework_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::mesos::FrameworkInfo& Call_Subscribe::framework_info() const {
  const ::mesos::FrameworkInfo* p = framework_info_;
  // @@protoc_insertion_point(field_get:mesos.scheduler.Call.Subscribe.framework_info)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::FrameworkInfo*>(
      &::mesos::_FrameworkInfo_default_instance_);
}
inline ::mesos::FrameworkInfo* Call_Subscribe::release_framework_info() {
  // @@protoc_insertion_point(field_release:mesos.scheduler.Call.Subscribe.framework_info)
  clear_has_framework_info();
  ::mesos::FrameworkInfo* temp = framework_info_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  framework_info_ = NULL;
  return temp;
}
inline ::mesos::FrameworkInfo* Call_Subscribe::unsafe_arena_release_framework_info() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.scheduler.Call.Subscribe.framework_info)
  clear_has_framework_info();
  ::mesos::FrameworkInfo* temp = framework_info_;
  framework_info_ = NULL;
  return temp;
}
inline ::mesos::FrameworkInfo* Call_Subscribe::mutable_framework_info() {
  set_has_framework_info();
  if (framework_info_ == NULL) {
    _slow_mutable_framework_info();
  }
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Call.Subscribe.framework_info)
  return framework_info_;
}
inline void Call_Subscribe::set_allocated_framework_info(::mesos::FrameworkInfo* framework_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(framework_info_);
  }
  if (framework_info) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(framework_info)->GetArena();
    if (message_arena != submessage_arena) {
      framework_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, framework_info, submessage_arena);
    }
    set_has_framework_info();
  } else {
    clear_has_framework_info();
  }
  framework_info_ = framework_info;
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Call.Subscribe.framework_info)
}

// optional bool force = 2;
inline bool Call_Subscribe::has_force() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Call_Subscribe::set_has_force() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Call_Subscribe::clear_has_force() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Call_Subscribe::clear_force() {
  force_ = false;
  clear_has_force();
}
inline bool Call_Subscribe::force() const {
  // @@protoc_insertion_point(field_get:mesos.scheduler.Call.Subscribe.force)
  return force_;
}
inline void Call_Subscribe::set_force(bool value) {
  set_has_force();
  force_ = value;
  // @@protoc_insertion_point(field_set:mesos.scheduler.Call.Subscribe.force)
}

// repeated string suppressed_roles = 3;
inline int Call_Subscribe::suppressed_roles_size() const {
  return suppressed_roles_.size();
}
inline void Call_Subscribe::clear_suppressed_roles() {
  suppressed_roles_.Clear();
}
inline const ::std::string& Call_Subscribe::suppressed_roles(int index) const {
  // @@protoc_insertion_point(field_get:mesos.scheduler.Call.Subscribe.suppressed_roles)
  return suppressed_roles_.Get(index);
}
inline ::std::string* Call_Subscribe::mutable_suppressed_roles(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Call.Subscribe.suppressed_roles)
  return suppressed_roles_.Mutable(index);
}
inline void Call_Subscribe::set_suppressed_roles(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:mesos.scheduler.Call.Subscribe.suppressed_roles)
  suppressed_roles_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Call_Subscribe::set_suppressed_roles(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:mesos.scheduler.Call.Subscribe.suppressed_roles)
  suppressed_roles_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Call_Subscribe::set_suppressed_roles(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  suppressed_roles_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.scheduler.Call.Subscribe.suppressed_roles)
}
inline void Call_Subscribe::set_suppressed_roles(int index, const char* value, size_t size) {
  suppressed_roles_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.scheduler.Call.Subscribe.suppressed_roles)
}
inline ::std::string* Call_Subscribe::add_suppressed_roles() {
  // @@protoc_insertion_point(field_add_mutable:mesos.scheduler.Call.Subscribe.suppressed_roles)
  return suppressed_roles_.Add();
}
inline void Call_Subscribe::add_suppressed_roles(const ::std::string& value) {
  suppressed_roles_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:mesos.scheduler.Call.Subscribe.suppressed_roles)
}
#if LANG_CXX11
inline void Call_Subscribe::add_suppressed_roles(::std::string&& value) {
  suppressed_roles_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:mesos.scheduler.Call.Subscribe.suppressed_roles)
}
#endif
inline void Call_Subscribe::add_suppressed_roles(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  suppressed_roles_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:mesos.scheduler.Call.Subscribe.suppressed_roles)
}
inline void Call_Subscribe::add_suppressed_roles(const char* value, size_t size) {
  suppressed_roles_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:mesos.scheduler.Call.Subscribe.suppressed_roles)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Call_Subscribe::suppressed_roles() const {
  // @@protoc_insertion_point(field_list:mesos.scheduler.Call.Subscribe.suppressed_roles)
  return suppressed_roles_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Call_Subscribe::mutable_suppressed_roles() {
  // @@protoc_insertion_point(field_mutable_list:mesos.scheduler.Call.Subscribe.suppressed_roles)
  return &suppressed_roles_;
}

// -------------------------------------------------------------------

// Call_Accept

// repeated .mesos.OfferID offer_ids = 1;
inline int Call_Accept::offer_ids_size() const {
  return offer_ids_.size();
}
inline const ::mesos::OfferID& Call_Accept::offer_ids(int index) const {
  // @@protoc_insertion_point(field_get:mesos.scheduler.Call.Accept.offer_ids)
  return offer_ids_.Get(index);
}
inline ::mesos::OfferID* Call_Accept::mutable_offer_ids(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Call.Accept.offer_ids)
  return offer_ids_.Mutable(index);
}
inline ::mesos::OfferID* Call_Accept::add_offer_ids() {
  // @@protoc_insertion_point(field_add:mesos.scheduler.Call.Accept.offer_ids)
  return offer_ids_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::OfferID >*
Call_Accept::mutable_offer_ids() {
  // @@protoc_insertion_point(field_mutable_list:mesos.scheduler.Call.Accept.offer_ids)
  return &offer_ids_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::OfferID >&
Call_Accept::offer_ids() const {
  // @@protoc_insertion_point(field_list:mesos.scheduler.Call.Accept.offer_ids)
  return offer_ids_;
}

// repeated .mesos.Offer.Operation operations = 2;
inline int Call_Accept::operations_size() const {
  return operations_.size();
}
inline const ::mesos::Offer_Operation& Call_Accept::operations(int index) const {
  // @@protoc_insertion_point(field_get:mesos.scheduler.Call.Accept.operations)
  return operations_.Get(index);
}
inline ::mesos::Offer_Operation* Call_Accept::mutable_operations(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Call.Accept.operations)
  return operations_.Mutable(index);
}
inline ::mesos::Offer_Operation* Call_Accept::add_operations() {
  // @@protoc_insertion_point(field_add:mesos.scheduler.Call.Accept.operations)
  return operations_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Offer_Operation >*
Call_Accept::mutable_operations() {
  // @@protoc_insertion_point(field_mutable_list:mesos.scheduler.Call.Accept.operations)
  return &operations_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Offer_Operation >&
Call_Accept::operations() const {
  // @@protoc_insertion_point(field_list:mesos.scheduler.Call.Accept.operations)
  return operations_;
}

// optional .mesos.Filters filters = 3;
inline bool Call_Accept::has_filters() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Call_Accept::set_has_filters() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Call_Accept::clear_has_filters() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::mesos::Filters& Call_Accept::filters() const {
  const ::mesos::Filters* p = filters_;
  // @@protoc_insertion_point(field_get:mesos.scheduler.Call.Accept.filters)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::Filters*>(
      &::mesos::_Filters_default_instance_);
}
inline ::mesos::Filters* Call_Accept::release_filters() {
  // @@protoc_insertion_point(field_release:mesos.scheduler.Call.Accept.filters)
  clear_has_filters();
  ::mesos::Filters* temp = filters_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  filters_ = NULL;
  return temp;
}
inline ::mesos::Filters* Call_Accept::unsafe_arena_release_filters() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.scheduler.Call.Accept.filters)
  clear_has_filters();
  ::mesos::Filters* temp = filters_;
  filters_ = NULL;
  return temp;
}
inline ::mesos::Filters* Call_Accept::mutable_filters() {
  set_has_filters();
  if (filters_ == NULL) {
    _slow_mutable_filters();
  }
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Call.Accept.filters)
  return filters_;
}
inline void Call_Accept::set_allocated_filters(::mesos::Filters* filters) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(filters_);
  }
  if (filters) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(filters)->GetArena();
    if (message_arena != submessage_arena) {
      filters = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, filters, submessage_arena);
    }
    set_has_filters();
  } else {
    clear_has_filters();
  }
  filters_ = filters;
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Call.Accept.filters)
}

// -------------------------------------------------------------------

// Call_Decline

// repeated .mesos.OfferID offer_ids = 1;
inline int Call_Decline::offer_ids_size() const {
  return offer_ids_.size();
}
inline const ::mesos::OfferID& Call_Decline::offer_ids(int index) const {
  // @@protoc_insertion_point(field_get:mesos.scheduler.Call.Decline.offer_ids)
  return offer_ids_.Get(index);
}
inline ::mesos::OfferID* Call_Decline::mutable_offer_ids(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Call.Decline.offer_ids)
  return offer_ids_.Mutable(index);
}
inline ::mesos::OfferID* Call_Decline::add_offer_ids() {
  // @@protoc_insertion_point(field_add:mesos.scheduler.Call.Decline.offer_ids)
  return offer_ids_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::OfferID >*
Call_Decline::mutable_offer_ids() {
  // @@protoc_insertion_point(field_mutable_list:mesos.scheduler.Call.Decline.offer_ids)
  return &offer_ids_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::OfferID >&
Call_Decline::offer_ids() const {
  // @@protoc_insertion_point(field_list:mesos.scheduler.Call.Decline.offer_ids)
  return offer_ids_;
}

// optional .mesos.Filters filters = 2;
inline bool Call_Decline::has_filters() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Call_Decline::set_has_filters() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Call_Decline::clear_has_filters() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::mesos::Filters& Call_Decline::filters() const {
  const ::mesos::Filters* p = filters_;
  // @@protoc_insertion_point(field_get:mesos.scheduler.Call.Decline.filters)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::Filters*>(
      &::mesos::_Filters_default_instance_);
}
inline ::mesos::Filters* Call_Decline::release_filters() {
  // @@protoc_insertion_point(field_release:mesos.scheduler.Call.Decline.filters)
  clear_has_filters();
  ::mesos::Filters* temp = filters_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  filters_ = NULL;
  return temp;
}
inline ::mesos::Filters* Call_Decline::unsafe_arena_release_filters() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.scheduler.Call.Decline.filters)
  clear_has_filters();
  ::mesos::Filters* temp = filters_;
  filters_ = NULL;
  return temp;
}
inline ::mesos::Filters* Call_Decline::mutable_filters() {
  set_has_filters();
  if (filters_ == NULL) {
    _slow_mutable_filters();
  }
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Call.Decline.filters)
  return filters_;
}
inline void Call_Decline::set_allocated_filters(::mesos::Filters* filters) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(filters_);
  }
  if (filters) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(filters)->GetArena();
    if (message_arena != submessage_arena) {
      filters = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, filters, submessage_arena);
    }
    set_has_filters();
  } else {
    clear_has_filters();
  }
  filters_ = filters;
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Call.Decline.filters)
}

// -------------------------------------------------------------------

// Call_AcceptInverseOffers

// repeated .mesos.OfferID inverse_offer_ids = 1;
inline int Call_AcceptInverseOffers::inverse_offer_ids_size() const {
  return inverse_offer_ids_.size();
}
inline const ::mesos::OfferID& Call_AcceptInverseOffers::inverse_offer_ids(int index) const {
  // @@protoc_insertion_point(field_get:mesos.scheduler.Call.AcceptInverseOffers.inverse_offer_ids)
  return inverse_offer_ids_.Get(index);
}
inline ::mesos::OfferID* Call_AcceptInverseOffers::mutable_inverse_offer_ids(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Call.AcceptInverseOffers.inverse_offer_ids)
  return inverse_offer_ids_.Mutable(index);
}
inline ::mesos::OfferID* Call_AcceptInverseOffers::add_inverse_offer_ids() {
  // @@protoc_insertion_point(field_add:mesos.scheduler.Call.AcceptInverseOffers.inverse_offer_ids)
  return inverse_offer_ids_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::OfferID >*
Call_AcceptInverseOffers::mutable_inverse_offer_ids() {
  // @@protoc_insertion_point(field_mutable_list:mesos.scheduler.Call.AcceptInverseOffers.inverse_offer_ids)
  return &inverse_offer_ids_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::OfferID >&
Call_AcceptInverseOffers::inverse_offer_ids() const {
  // @@protoc_insertion_point(field_list:mesos.scheduler.Call.AcceptInverseOffers.inverse_offer_ids)
  return inverse_offer_ids_;
}

// optional .mesos.Filters filters = 2;
inline bool Call_AcceptInverseOffers::has_filters() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Call_AcceptInverseOffers::set_has_filters() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Call_AcceptInverseOffers::clear_has_filters() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::mesos::Filters& Call_AcceptInverseOffers::filters() const {
  const ::mesos::Filters* p = filters_;
  // @@protoc_insertion_point(field_get:mesos.scheduler.Call.AcceptInverseOffers.filters)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::Filters*>(
      &::mesos::_Filters_default_instance_);
}
inline ::mesos::Filters* Call_AcceptInverseOffers::release_filters() {
  // @@protoc_insertion_point(field_release:mesos.scheduler.Call.AcceptInverseOffers.filters)
  clear_has_filters();
  ::mesos::Filters* temp = filters_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  filters_ = NULL;
  return temp;
}
inline ::mesos::Filters* Call_AcceptInverseOffers::unsafe_arena_release_filters() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.scheduler.Call.AcceptInverseOffers.filters)
  clear_has_filters();
  ::mesos::Filters* temp = filters_;
  filters_ = NULL;
  return temp;
}
inline ::mesos::Filters* Call_AcceptInverseOffers::mutable_filters() {
  set_has_filters();
  if (filters_ == NULL) {
    _slow_mutable_filters();
  }
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Call.AcceptInverseOffers.filters)
  return filters_;
}
inline void Call_AcceptInverseOffers::set_allocated_filters(::mesos::Filters* filters) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(filters_);
  }
  if (filters) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(filters)->GetArena();
    if (message_arena != submessage_arena) {
      filters = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, filters, submessage_arena);
    }
    set_has_filters();
  } else {
    clear_has_filters();
  }
  filters_ = filters;
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Call.AcceptInverseOffers.filters)
}

// -------------------------------------------------------------------

// Call_DeclineInverseOffers

// repeated .mesos.OfferID inverse_offer_ids = 1;
inline int Call_DeclineInverseOffers::inverse_offer_ids_size() const {
  return inverse_offer_ids_.size();
}
inline const ::mesos::OfferID& Call_DeclineInverseOffers::inverse_offer_ids(int index) const {
  // @@protoc_insertion_point(field_get:mesos.scheduler.Call.DeclineInverseOffers.inverse_offer_ids)
  return inverse_offer_ids_.Get(index);
}
inline ::mesos::OfferID* Call_DeclineInverseOffers::mutable_inverse_offer_ids(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Call.DeclineInverseOffers.inverse_offer_ids)
  return inverse_offer_ids_.Mutable(index);
}
inline ::mesos::OfferID* Call_DeclineInverseOffers::add_inverse_offer_ids() {
  // @@protoc_insertion_point(field_add:mesos.scheduler.Call.DeclineInverseOffers.inverse_offer_ids)
  return inverse_offer_ids_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::OfferID >*
Call_DeclineInverseOffers::mutable_inverse_offer_ids() {
  // @@protoc_insertion_point(field_mutable_list:mesos.scheduler.Call.DeclineInverseOffers.inverse_offer_ids)
  return &inverse_offer_ids_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::OfferID >&
Call_DeclineInverseOffers::inverse_offer_ids() const {
  // @@protoc_insertion_point(field_list:mesos.scheduler.Call.DeclineInverseOffers.inverse_offer_ids)
  return inverse_offer_ids_;
}

// optional .mesos.Filters filters = 2;
inline bool Call_DeclineInverseOffers::has_filters() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Call_DeclineInverseOffers::set_has_filters() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Call_DeclineInverseOffers::clear_has_filters() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::mesos::Filters& Call_DeclineInverseOffers::filters() const {
  const ::mesos::Filters* p = filters_;
  // @@protoc_insertion_point(field_get:mesos.scheduler.Call.DeclineInverseOffers.filters)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::Filters*>(
      &::mesos::_Filters_default_instance_);
}
inline ::mesos::Filters* Call_DeclineInverseOffers::release_filters() {
  // @@protoc_insertion_point(field_release:mesos.scheduler.Call.DeclineInverseOffers.filters)
  clear_has_filters();
  ::mesos::Filters* temp = filters_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  filters_ = NULL;
  return temp;
}
inline ::mesos::Filters* Call_DeclineInverseOffers::unsafe_arena_release_filters() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.scheduler.Call.DeclineInverseOffers.filters)
  clear_has_filters();
  ::mesos::Filters* temp = filters_;
  filters_ = NULL;
  return temp;
}
inline ::mesos::Filters* Call_DeclineInverseOffers::mutable_filters() {
  set_has_filters();
  if (filters_ == NULL) {
    _slow_mutable_filters();
  }
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Call.DeclineInverseOffers.filters)
  return filters_;
}
inline void Call_DeclineInverseOffers::set_allocated_filters(::mesos::Filters* filters) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(filters_);
  }
  if (filters) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(filters)->GetArena();
    if (message_arena != submessage_arena) {
      filters = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, filters, submessage_arena);
    }
    set_has_filters();
  } else {
    clear_has_filters();
  }
  filters_ = filters;
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Call.DeclineInverseOffers.filters)
}

// -------------------------------------------------------------------

// Call_Revive

// repeated string roles = 1;
inline int Call_Revive::roles_size() const {
  return roles_.size();
}
inline void Call_Revive::clear_roles() {
  roles_.Clear();
}
inline const ::std::string& Call_Revive::roles(int index) const {
  // @@protoc_insertion_point(field_get:mesos.scheduler.Call.Revive.roles)
  return roles_.Get(index);
}
inline ::std::string* Call_Revive::mutable_roles(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Call.Revive.roles)
  return roles_.Mutable(index);
}
inline void Call_Revive::set_roles(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:mesos.scheduler.Call.Revive.roles)
  roles_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Call_Revive::set_roles(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:mesos.scheduler.Call.Revive.roles)
  roles_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Call_Revive::set_roles(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  roles_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.scheduler.Call.Revive.roles)
}
inline void Call_Revive::set_roles(int index, const char* value, size_t size) {
  roles_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.scheduler.Call.Revive.roles)
}
inline ::std::string* Call_Revive::add_roles() {
  // @@protoc_insertion_point(field_add_mutable:mesos.scheduler.Call.Revive.roles)
  return roles_.Add();
}
inline void Call_Revive::add_roles(const ::std::string& value) {
  roles_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:mesos.scheduler.Call.Revive.roles)
}
#if LANG_CXX11
inline void Call_Revive::add_roles(::std::string&& value) {
  roles_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:mesos.scheduler.Call.Revive.roles)
}
#endif
inline void Call_Revive::add_roles(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  roles_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:mesos.scheduler.Call.Revive.roles)
}
inline void Call_Revive::add_roles(const char* value, size_t size) {
  roles_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:mesos.scheduler.Call.Revive.roles)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Call_Revive::roles() const {
  // @@protoc_insertion_point(field_list:mesos.scheduler.Call.Revive.roles)
  return roles_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Call_Revive::mutable_roles() {
  // @@protoc_insertion_point(field_mutable_list:mesos.scheduler.Call.Revive.roles)
  return &roles_;
}

// -------------------------------------------------------------------

// Call_Kill

// required .mesos.TaskID task_id = 1;
inline bool Call_Kill::has_task_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Call_Kill::set_has_task_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Call_Kill::clear_has_task_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::mesos::TaskID& Call_Kill::task_id() const {
  const ::mesos::TaskID* p = task_id_;
  // @@protoc_insertion_point(field_get:mesos.scheduler.Call.Kill.task_id)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::TaskID*>(
      &::mesos::_TaskID_default_instance_);
}
inline ::mesos::TaskID* Call_Kill::release_task_id() {
  // @@protoc_insertion_point(field_release:mesos.scheduler.Call.Kill.task_id)
  clear_has_task_id();
  ::mesos::TaskID* temp = task_id_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  task_id_ = NULL;
  return temp;
}
inline ::mesos::TaskID* Call_Kill::unsafe_arena_release_task_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.scheduler.Call.Kill.task_id)
  clear_has_task_id();
  ::mesos::TaskID* temp = task_id_;
  task_id_ = NULL;
  return temp;
}
inline ::mesos::TaskID* Call_Kill::mutable_task_id() {
  set_has_task_id();
  if (task_id_ == NULL) {
    _slow_mutable_task_id();
  }
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Call.Kill.task_id)
  return task_id_;
}
inline void Call_Kill::set_allocated_task_id(::mesos::TaskID* task_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(task_id_);
  }
  if (task_id) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(task_id)->GetArena();
    if (message_arena != submessage_arena) {
      task_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, task_id, submessage_arena);
    }
    set_has_task_id();
  } else {
    clear_has_task_id();
  }
  task_id_ = task_id;
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Call.Kill.task_id)
}

// optional .mesos.SlaveID slave_id = 2;
inline bool Call_Kill::has_slave_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Call_Kill::set_has_slave_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Call_Kill::clear_has_slave_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::mesos::SlaveID& Call_Kill::slave_id() const {
  const ::mesos::SlaveID* p = slave_id_;
  // @@protoc_insertion_point(field_get:mesos.scheduler.Call.Kill.slave_id)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::SlaveID*>(
      &::mesos::_SlaveID_default_instance_);
}
inline ::mesos::SlaveID* Call_Kill::release_slave_id() {
  // @@protoc_insertion_point(field_release:mesos.scheduler.Call.Kill.slave_id)
  clear_has_slave_id();
  ::mesos::SlaveID* temp = slave_id_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  slave_id_ = NULL;
  return temp;
}
inline ::mesos::SlaveID* Call_Kill::unsafe_arena_release_slave_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.scheduler.Call.Kill.slave_id)
  clear_has_slave_id();
  ::mesos::SlaveID* temp = slave_id_;
  slave_id_ = NULL;
  return temp;
}
inline ::mesos::SlaveID* Call_Kill::mutable_slave_id() {
  set_has_slave_id();
  if (slave_id_ == NULL) {
    _slow_mutable_slave_id();
  }
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Call.Kill.slave_id)
  return slave_id_;
}
inline void Call_Kill::set_allocated_slave_id(::mesos::SlaveID* slave_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(slave_id_);
  }
  if (slave_id) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(slave_id)->GetArena();
    if (message_arena != submessage_arena) {
      slave_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, slave_id, submessage_arena);
    }
    set_has_slave_id();
  } else {
    clear_has_slave_id();
  }
  slave_id_ = slave_id;
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Call.Kill.slave_id)
}

// optional .mesos.KillPolicy kill_policy = 3;
inline bool Call_Kill::has_kill_policy() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Call_Kill::set_has_kill_policy() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Call_Kill::clear_has_kill_policy() {
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::mesos::KillPolicy& Call_Kill::kill_policy() const {
  const ::mesos::KillPolicy* p = kill_policy_;
  // @@protoc_insertion_point(field_get:mesos.scheduler.Call.Kill.kill_policy)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::KillPolicy*>(
      &::mesos::_KillPolicy_default_instance_);
}
inline ::mesos::KillPolicy* Call_Kill::release_kill_policy() {
  // @@protoc_insertion_point(field_release:mesos.scheduler.Call.Kill.kill_policy)
  clear_has_kill_policy();
  ::mesos::KillPolicy* temp = kill_policy_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  kill_policy_ = NULL;
  return temp;
}
inline ::mesos::KillPolicy* Call_Kill::unsafe_arena_release_kill_policy() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.scheduler.Call.Kill.kill_policy)
  clear_has_kill_policy();
  ::mesos::KillPolicy* temp = kill_policy_;
  kill_policy_ = NULL;
  return temp;
}
inline ::mesos::KillPolicy* Call_Kill::mutable_kill_policy() {
  set_has_kill_policy();
  if (kill_policy_ == NULL) {
    _slow_mutable_kill_policy();
  }
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Call.Kill.kill_policy)
  return kill_policy_;
}
inline void Call_Kill::set_allocated_kill_policy(::mesos::KillPolicy* kill_policy) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(kill_policy_);
  }
  if (kill_policy) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(kill_policy)->GetArena();
    if (message_arena != submessage_arena) {
      kill_policy = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, kill_policy, submessage_arena);
    }
    set_has_kill_policy();
  } else {
    clear_has_kill_policy();
  }
  kill_policy_ = kill_policy;
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Call.Kill.kill_policy)
}

// -------------------------------------------------------------------

// Call_Shutdown

// required .mesos.ExecutorID executor_id = 1;
inline bool Call_Shutdown::has_executor_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Call_Shutdown::set_has_executor_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Call_Shutdown::clear_has_executor_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::mesos::ExecutorID& Call_Shutdown::executor_id() const {
  const ::mesos::ExecutorID* p = executor_id_;
  // @@protoc_insertion_point(field_get:mesos.scheduler.Call.Shutdown.executor_id)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ExecutorID*>(
      &::mesos::_ExecutorID_default_instance_);
}
inline ::mesos::ExecutorID* Call_Shutdown::release_executor_id() {
  // @@protoc_insertion_point(field_release:mesos.scheduler.Call.Shutdown.executor_id)
  clear_has_executor_id();
  ::mesos::ExecutorID* temp = executor_id_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  executor_id_ = NULL;
  return temp;
}
inline ::mesos::ExecutorID* Call_Shutdown::unsafe_arena_release_executor_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.scheduler.Call.Shutdown.executor_id)
  clear_has_executor_id();
  ::mesos::ExecutorID* temp = executor_id_;
  executor_id_ = NULL;
  return temp;
}
inline ::mesos::ExecutorID* Call_Shutdown::mutable_executor_id() {
  set_has_executor_id();
  if (executor_id_ == NULL) {
    _slow_mutable_executor_id();
  }
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Call.Shutdown.executor_id)
  return executor_id_;
}
inline void Call_Shutdown::set_allocated_executor_id(::mesos::ExecutorID* executor_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(executor_id_);
  }
  if (executor_id) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(executor_id)->GetArena();
    if (message_arena != submessage_arena) {
      executor_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, executor_id, submessage_arena);
    }
    set_has_executor_id();
  } else {
    clear_has_executor_id();
  }
  executor_id_ = executor_id;
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Call.Shutdown.executor_id)
}

// required .mesos.SlaveID slave_id = 2;
inline bool Call_Shutdown::has_slave_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Call_Shutdown::set_has_slave_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Call_Shutdown::clear_has_slave_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::mesos::SlaveID& Call_Shutdown::slave_id() const {
  const ::mesos::SlaveID* p = slave_id_;
  // @@protoc_insertion_point(field_get:mesos.scheduler.Call.Shutdown.slave_id)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::SlaveID*>(
      &::mesos::_SlaveID_default_instance_);
}
inline ::mesos::SlaveID* Call_Shutdown::release_slave_id() {
  // @@protoc_insertion_point(field_release:mesos.scheduler.Call.Shutdown.slave_id)
  clear_has_slave_id();
  ::mesos::SlaveID* temp = slave_id_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  slave_id_ = NULL;
  return temp;
}
inline ::mesos::SlaveID* Call_Shutdown::unsafe_arena_release_slave_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.scheduler.Call.Shutdown.slave_id)
  clear_has_slave_id();
  ::mesos::SlaveID* temp = slave_id_;
  slave_id_ = NULL;
  return temp;
}
inline ::mesos::SlaveID* Call_Shutdown::mutable_slave_id() {
  set_has_slave_id();
  if (slave_id_ == NULL) {
    _slow_mutable_slave_id();
  }
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Call.Shutdown.slave_id)
  return slave_id_;
}
inline void Call_Shutdown::set_allocated_slave_id(::mesos::SlaveID* slave_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(slave_id_);
  }
  if (slave_id) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(slave_id)->GetArena();
    if (message_arena != submessage_arena) {
      slave_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, slave_id, submessage_arena);
    }
    set_has_slave_id();
  } else {
    clear_has_slave_id();
  }
  slave_id_ = slave_id;
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Call.Shutdown.slave_id)
}

// -------------------------------------------------------------------

// Call_Acknowledge

// required .mesos.SlaveID slave_id = 1;
inline bool Call_Acknowledge::has_slave_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Call_Acknowledge::set_has_slave_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Call_Acknowledge::clear_has_slave_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::mesos::SlaveID& Call_Acknowledge::slave_id() const {
  const ::mesos::SlaveID* p = slave_id_;
  // @@protoc_insertion_point(field_get:mesos.scheduler.Call.Acknowledge.slave_id)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::SlaveID*>(
      &::mesos::_SlaveID_default_instance_);
}
inline ::mesos::SlaveID* Call_Acknowledge::release_slave_id() {
  // @@protoc_insertion_point(field_release:mesos.scheduler.Call.Acknowledge.slave_id)
  clear_has_slave_id();
  ::mesos::SlaveID* temp = slave_id_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  slave_id_ = NULL;
  return temp;
}
inline ::mesos::SlaveID* Call_Acknowledge::unsafe_arena_release_slave_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.scheduler.Call.Acknowledge.slave_id)
  clear_has_slave_id();
  ::mesos::SlaveID* temp = slave_id_;
  slave_id_ = NULL;
  return temp;
}
inline ::mesos::SlaveID* Call_Acknowledge::mutable_slave_id() {
  set_has_slave_id();
  if (slave_id_ == NULL) {
    _slow_mutable_slave_id();
  }
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Call.Acknowledge.slave_id)
  return slave_id_;
}
inline void Call_Acknowledge::set_allocated_slave_id(::mesos::SlaveID* slave_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(slave_id_);
  }
  if (slave_id) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(slave_id)->GetArena();
    if (message_arena != submessage_arena) {
      slave_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, slave_id, submessage_arena);
    }
    set_has_slave_id();
  } else {
    clear_has_slave_id();
  }
  slave_id_ = slave_id;
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Call.Acknowledge.slave_id)
}

// required .mesos.TaskID task_id = 2;
inline bool Call_Acknowledge::has_task_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Call_Acknowledge::set_has_task_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Call_Acknowledge::clear_has_task_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::mesos::TaskID& Call_Acknowledge::task_id() const {
  const ::mesos::TaskID* p = task_id_;
  // @@protoc_insertion_point(field_get:mesos.scheduler.Call.Acknowledge.task_id)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::TaskID*>(
      &::mesos::_TaskID_default_instance_);
}
inline ::mesos::TaskID* Call_Acknowledge::release_task_id() {
  // @@protoc_insertion_point(field_release:mesos.scheduler.Call.Acknowledge.task_id)
  clear_has_task_id();
  ::mesos::TaskID* temp = task_id_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  task_id_ = NULL;
  return temp;
}
inline ::mesos::TaskID* Call_Acknowledge::unsafe_arena_release_task_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.scheduler.Call.Acknowledge.task_id)
  clear_has_task_id();
  ::mesos::TaskID* temp = task_id_;
  task_id_ = NULL;
  return temp;
}
inline ::mesos::TaskID* Call_Acknowledge::mutable_task_id() {
  set_has_task_id();
  if (task_id_ == NULL) {
    _slow_mutable_task_id();
  }
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Call.Acknowledge.task_id)
  return task_id_;
}
inline void Call_Acknowledge::set_allocated_task_id(::mesos::TaskID* task_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(task_id_);
  }
  if (task_id) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(task_id)->GetArena();
    if (message_arena != submessage_arena) {
      task_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, task_id, submessage_arena);
    }
    set_has_task_id();
  } else {
    clear_has_task_id();
  }
  task_id_ = task_id;
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Call.Acknowledge.task_id)
}

// required bytes uuid = 3;
inline bool Call_Acknowledge::has_uuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Call_Acknowledge::set_has_uuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Call_Acknowledge::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Call_Acknowledge::clear_uuid() {
  uuid_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_uuid();
}
inline const ::std::string& Call_Acknowledge::uuid() const {
  // @@protoc_insertion_point(field_get:mesos.scheduler.Call.Acknowledge.uuid)
  return uuid_.Get();
}
inline void Call_Acknowledge::set_uuid(const ::std::string& value) {
  set_has_uuid();
  uuid_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.scheduler.Call.Acknowledge.uuid)
}
#if LANG_CXX11
inline void Call_Acknowledge::set_uuid(::std::string&& value) {
  set_has_uuid();
  uuid_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.scheduler.Call.Acknowledge.uuid)
}
#endif
inline void Call_Acknowledge::set_uuid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_uuid();
  uuid_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.scheduler.Call.Acknowledge.uuid)
}
inline void Call_Acknowledge::set_uuid(const void* value,
    size_t size) {
  set_has_uuid();
  uuid_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.scheduler.Call.Acknowledge.uuid)
}
inline ::std::string* Call_Acknowledge::mutable_uuid() {
  set_has_uuid();
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Call.Acknowledge.uuid)
  return uuid_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* Call_Acknowledge::release_uuid() {
  // @@protoc_insertion_point(field_release:mesos.scheduler.Call.Acknowledge.uuid)
  clear_has_uuid();
  return uuid_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void Call_Acknowledge::set_allocated_uuid(::std::string* uuid) {
  if (uuid != NULL) {
    set_has_uuid();
  } else {
    clear_has_uuid();
  }
  uuid_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), uuid,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Call.Acknowledge.uuid)
}
inline ::std::string* Call_Acknowledge::unsafe_arena_release_uuid() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.scheduler.Call.Acknowledge.uuid)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_uuid();
  return uuid_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void Call_Acknowledge::unsafe_arena_set_allocated_uuid(
    ::std::string* uuid) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (uuid != NULL) {
    set_has_uuid();
  } else {
    clear_has_uuid();
  }
  uuid_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      uuid, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.scheduler.Call.Acknowledge.uuid)
}

// -------------------------------------------------------------------

// Call_AcknowledgeOperationStatus

// optional .mesos.SlaveID slave_id = 1;
inline bool Call_AcknowledgeOperationStatus::has_slave_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Call_AcknowledgeOperationStatus::set_has_slave_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Call_AcknowledgeOperationStatus::clear_has_slave_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::mesos::SlaveID& Call_AcknowledgeOperationStatus::slave_id() const {
  const ::mesos::SlaveID* p = slave_id_;
  // @@protoc_insertion_point(field_get:mesos.scheduler.Call.AcknowledgeOperationStatus.slave_id)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::SlaveID*>(
      &::mesos::_SlaveID_default_instance_);
}
inline ::mesos::SlaveID* Call_AcknowledgeOperationStatus::release_slave_id() {
  // @@protoc_insertion_point(field_release:mesos.scheduler.Call.AcknowledgeOperationStatus.slave_id)
  clear_has_slave_id();
  ::mesos::SlaveID* temp = slave_id_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  slave_id_ = NULL;
  return temp;
}
inline ::mesos::SlaveID* Call_AcknowledgeOperationStatus::unsafe_arena_release_slave_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.scheduler.Call.AcknowledgeOperationStatus.slave_id)
  clear_has_slave_id();
  ::mesos::SlaveID* temp = slave_id_;
  slave_id_ = NULL;
  return temp;
}
inline ::mesos::SlaveID* Call_AcknowledgeOperationStatus::mutable_slave_id() {
  set_has_slave_id();
  if (slave_id_ == NULL) {
    _slow_mutable_slave_id();
  }
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Call.AcknowledgeOperationStatus.slave_id)
  return slave_id_;
}
inline void Call_AcknowledgeOperationStatus::set_allocated_slave_id(::mesos::SlaveID* slave_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(slave_id_);
  }
  if (slave_id) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(slave_id)->GetArena();
    if (message_arena != submessage_arena) {
      slave_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, slave_id, submessage_arena);
    }
    set_has_slave_id();
  } else {
    clear_has_slave_id();
  }
  slave_id_ = slave_id;
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Call.AcknowledgeOperationStatus.slave_id)
}

// optional .mesos.ResourceProviderID resource_provider_id = 2;
inline bool Call_AcknowledgeOperationStatus::has_resource_provider_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Call_AcknowledgeOperationStatus::set_has_resource_provider_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Call_AcknowledgeOperationStatus::clear_has_resource_provider_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::mesos::ResourceProviderID& Call_AcknowledgeOperationStatus::resource_provider_id() const {
  const ::mesos::ResourceProviderID* p = resource_provider_id_;
  // @@protoc_insertion_point(field_get:mesos.scheduler.Call.AcknowledgeOperationStatus.resource_provider_id)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ResourceProviderID*>(
      &::mesos::_ResourceProviderID_default_instance_);
}
inline ::mesos::ResourceProviderID* Call_AcknowledgeOperationStatus::release_resource_provider_id() {
  // @@protoc_insertion_point(field_release:mesos.scheduler.Call.AcknowledgeOperationStatus.resource_provider_id)
  clear_has_resource_provider_id();
  ::mesos::ResourceProviderID* temp = resource_provider_id_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  resource_provider_id_ = NULL;
  return temp;
}
inline ::mesos::ResourceProviderID* Call_AcknowledgeOperationStatus::unsafe_arena_release_resource_provider_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.scheduler.Call.AcknowledgeOperationStatus.resource_provider_id)
  clear_has_resource_provider_id();
  ::mesos::ResourceProviderID* temp = resource_provider_id_;
  resource_provider_id_ = NULL;
  return temp;
}
inline ::mesos::ResourceProviderID* Call_AcknowledgeOperationStatus::mutable_resource_provider_id() {
  set_has_resource_provider_id();
  if (resource_provider_id_ == NULL) {
    _slow_mutable_resource_provider_id();
  }
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Call.AcknowledgeOperationStatus.resource_provider_id)
  return resource_provider_id_;
}
inline void Call_AcknowledgeOperationStatus::set_allocated_resource_provider_id(::mesos::ResourceProviderID* resource_provider_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(resource_provider_id_);
  }
  if (resource_provider_id) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(resource_provider_id)->GetArena();
    if (message_arena != submessage_arena) {
      resource_provider_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, resource_provider_id, submessage_arena);
    }
    set_has_resource_provider_id();
  } else {
    clear_has_resource_provider_id();
  }
  resource_provider_id_ = resource_provider_id;
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Call.AcknowledgeOperationStatus.resource_provider_id)
}

// required bytes uuid = 3;
inline bool Call_AcknowledgeOperationStatus::has_uuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Call_AcknowledgeOperationStatus::set_has_uuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Call_AcknowledgeOperationStatus::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Call_AcknowledgeOperationStatus::clear_uuid() {
  uuid_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_uuid();
}
inline const ::std::string& Call_AcknowledgeOperationStatus::uuid() const {
  // @@protoc_insertion_point(field_get:mesos.scheduler.Call.AcknowledgeOperationStatus.uuid)
  return uuid_.Get();
}
inline void Call_AcknowledgeOperationStatus::set_uuid(const ::std::string& value) {
  set_has_uuid();
  uuid_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.scheduler.Call.AcknowledgeOperationStatus.uuid)
}
#if LANG_CXX11
inline void Call_AcknowledgeOperationStatus::set_uuid(::std::string&& value) {
  set_has_uuid();
  uuid_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.scheduler.Call.AcknowledgeOperationStatus.uuid)
}
#endif
inline void Call_AcknowledgeOperationStatus::set_uuid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_uuid();
  uuid_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.scheduler.Call.AcknowledgeOperationStatus.uuid)
}
inline void Call_AcknowledgeOperationStatus::set_uuid(const void* value,
    size_t size) {
  set_has_uuid();
  uuid_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.scheduler.Call.AcknowledgeOperationStatus.uuid)
}
inline ::std::string* Call_AcknowledgeOperationStatus::mutable_uuid() {
  set_has_uuid();
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Call.AcknowledgeOperationStatus.uuid)
  return uuid_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* Call_AcknowledgeOperationStatus::release_uuid() {
  // @@protoc_insertion_point(field_release:mesos.scheduler.Call.AcknowledgeOperationStatus.uuid)
  clear_has_uuid();
  return uuid_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void Call_AcknowledgeOperationStatus::set_allocated_uuid(::std::string* uuid) {
  if (uuid != NULL) {
    set_has_uuid();
  } else {
    clear_has_uuid();
  }
  uuid_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), uuid,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Call.AcknowledgeOperationStatus.uuid)
}
inline ::std::string* Call_AcknowledgeOperationStatus::unsafe_arena_release_uuid() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.scheduler.Call.AcknowledgeOperationStatus.uuid)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_uuid();
  return uuid_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void Call_AcknowledgeOperationStatus::unsafe_arena_set_allocated_uuid(
    ::std::string* uuid) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (uuid != NULL) {
    set_has_uuid();
  } else {
    clear_has_uuid();
  }
  uuid_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      uuid, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.scheduler.Call.AcknowledgeOperationStatus.uuid)
}

// required .mesos.OperationID operation_id = 4;
inline bool Call_AcknowledgeOperationStatus::has_operation_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Call_AcknowledgeOperationStatus::set_has_operation_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Call_AcknowledgeOperationStatus::clear_has_operation_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::mesos::OperationID& Call_AcknowledgeOperationStatus::operation_id() const {
  const ::mesos::OperationID* p = operation_id_;
  // @@protoc_insertion_point(field_get:mesos.scheduler.Call.AcknowledgeOperationStatus.operation_id)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::OperationID*>(
      &::mesos::_OperationID_default_instance_);
}
inline ::mesos::OperationID* Call_AcknowledgeOperationStatus::release_operation_id() {
  // @@protoc_insertion_point(field_release:mesos.scheduler.Call.AcknowledgeOperationStatus.operation_id)
  clear_has_operation_id();
  ::mesos::OperationID* temp = operation_id_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  operation_id_ = NULL;
  return temp;
}
inline ::mesos::OperationID* Call_AcknowledgeOperationStatus::unsafe_arena_release_operation_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.scheduler.Call.AcknowledgeOperationStatus.operation_id)
  clear_has_operation_id();
  ::mesos::OperationID* temp = operation_id_;
  operation_id_ = NULL;
  return temp;
}
inline ::mesos::OperationID* Call_AcknowledgeOperationStatus::mutable_operation_id() {
  set_has_operation_id();
  if (operation_id_ == NULL) {
    _slow_mutable_operation_id();
  }
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Call.AcknowledgeOperationStatus.operation_id)
  return operation_id_;
}
inline void Call_AcknowledgeOperationStatus::set_allocated_operation_id(::mesos::OperationID* operation_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(operation_id_);
  }
  if (operation_id) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(operation_id)->GetArena();
    if (message_arena != submessage_arena) {
      operation_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, operation_id, submessage_arena);
    }
    set_has_operation_id();
  } else {
    clear_has_operation_id();
  }
  operation_id_ = operation_id;
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Call.AcknowledgeOperationStatus.operation_id)
}

// -------------------------------------------------------------------

// Call_Reconcile_Task

// required .mesos.TaskID task_id = 1;
inline bool Call_Reconcile_Task::has_task_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Call_Reconcile_Task::set_has_task_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Call_Reconcile_Task::clear_has_task_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::mesos::TaskID& Call_Reconcile_Task::task_id() const {
  const ::mesos::TaskID* p = task_id_;
  // @@protoc_insertion_point(field_get:mesos.scheduler.Call.Reconcile.Task.task_id)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::TaskID*>(
      &::mesos::_TaskID_default_instance_);
}
inline ::mesos::TaskID* Call_Reconcile_Task::release_task_id() {
  // @@protoc_insertion_point(field_release:mesos.scheduler.Call.Reconcile.Task.task_id)
  clear_has_task_id();
  ::mesos::TaskID* temp = task_id_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  task_id_ = NULL;
  return temp;
}
inline ::mesos::TaskID* Call_Reconcile_Task::unsafe_arena_release_task_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.scheduler.Call.Reconcile.Task.task_id)
  clear_has_task_id();
  ::mesos::TaskID* temp = task_id_;
  task_id_ = NULL;
  return temp;
}
inline ::mesos::TaskID* Call_Reconcile_Task::mutable_task_id() {
  set_has_task_id();
  if (task_id_ == NULL) {
    _slow_mutable_task_id();
  }
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Call.Reconcile.Task.task_id)
  return task_id_;
}
inline void Call_Reconcile_Task::set_allocated_task_id(::mesos::TaskID* task_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(task_id_);
  }
  if (task_id) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(task_id)->GetArena();
    if (message_arena != submessage_arena) {
      task_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, task_id, submessage_arena);
    }
    set_has_task_id();
  } else {
    clear_has_task_id();
  }
  task_id_ = task_id;
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Call.Reconcile.Task.task_id)
}

// optional .mesos.SlaveID slave_id = 2;
inline bool Call_Reconcile_Task::has_slave_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Call_Reconcile_Task::set_has_slave_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Call_Reconcile_Task::clear_has_slave_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::mesos::SlaveID& Call_Reconcile_Task::slave_id() const {
  const ::mesos::SlaveID* p = slave_id_;
  // @@protoc_insertion_point(field_get:mesos.scheduler.Call.Reconcile.Task.slave_id)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::SlaveID*>(
      &::mesos::_SlaveID_default_instance_);
}
inline ::mesos::SlaveID* Call_Reconcile_Task::release_slave_id() {
  // @@protoc_insertion_point(field_release:mesos.scheduler.Call.Reconcile.Task.slave_id)
  clear_has_slave_id();
  ::mesos::SlaveID* temp = slave_id_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  slave_id_ = NULL;
  return temp;
}
inline ::mesos::SlaveID* Call_Reconcile_Task::unsafe_arena_release_slave_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.scheduler.Call.Reconcile.Task.slave_id)
  clear_has_slave_id();
  ::mesos::SlaveID* temp = slave_id_;
  slave_id_ = NULL;
  return temp;
}
inline ::mesos::SlaveID* Call_Reconcile_Task::mutable_slave_id() {
  set_has_slave_id();
  if (slave_id_ == NULL) {
    _slow_mutable_slave_id();
  }
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Call.Reconcile.Task.slave_id)
  return slave_id_;
}
inline void Call_Reconcile_Task::set_allocated_slave_id(::mesos::SlaveID* slave_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(slave_id_);
  }
  if (slave_id) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(slave_id)->GetArena();
    if (message_arena != submessage_arena) {
      slave_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, slave_id, submessage_arena);
    }
    set_has_slave_id();
  } else {
    clear_has_slave_id();
  }
  slave_id_ = slave_id;
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Call.Reconcile.Task.slave_id)
}

// -------------------------------------------------------------------

// Call_Reconcile

// repeated .mesos.scheduler.Call.Reconcile.Task tasks = 1;
inline int Call_Reconcile::tasks_size() const {
  return tasks_.size();
}
inline void Call_Reconcile::clear_tasks() {
  tasks_.Clear();
}
inline const ::mesos::scheduler::Call_Reconcile_Task& Call_Reconcile::tasks(int index) const {
  // @@protoc_insertion_point(field_get:mesos.scheduler.Call.Reconcile.tasks)
  return tasks_.Get(index);
}
inline ::mesos::scheduler::Call_Reconcile_Task* Call_Reconcile::mutable_tasks(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Call.Reconcile.tasks)
  return tasks_.Mutable(index);
}
inline ::mesos::scheduler::Call_Reconcile_Task* Call_Reconcile::add_tasks() {
  // @@protoc_insertion_point(field_add:mesos.scheduler.Call.Reconcile.tasks)
  return tasks_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::scheduler::Call_Reconcile_Task >*
Call_Reconcile::mutable_tasks() {
  // @@protoc_insertion_point(field_mutable_list:mesos.scheduler.Call.Reconcile.tasks)
  return &tasks_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::scheduler::Call_Reconcile_Task >&
Call_Reconcile::tasks() const {
  // @@protoc_insertion_point(field_list:mesos.scheduler.Call.Reconcile.tasks)
  return tasks_;
}

// -------------------------------------------------------------------

// Call_ReconcileOperations_Operation

// required .mesos.OperationID operation_id = 1;
inline bool Call_ReconcileOperations_Operation::has_operation_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Call_ReconcileOperations_Operation::set_has_operation_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Call_ReconcileOperations_Operation::clear_has_operation_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::mesos::OperationID& Call_ReconcileOperations_Operation::operation_id() const {
  const ::mesos::OperationID* p = operation_id_;
  // @@protoc_insertion_point(field_get:mesos.scheduler.Call.ReconcileOperations.Operation.operation_id)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::OperationID*>(
      &::mesos::_OperationID_default_instance_);
}
inline ::mesos::OperationID* Call_ReconcileOperations_Operation::release_operation_id() {
  // @@protoc_insertion_point(field_release:mesos.scheduler.Call.ReconcileOperations.Operation.operation_id)
  clear_has_operation_id();
  ::mesos::OperationID* temp = operation_id_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  operation_id_ = NULL;
  return temp;
}
inline ::mesos::OperationID* Call_ReconcileOperations_Operation::unsafe_arena_release_operation_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.scheduler.Call.ReconcileOperations.Operation.operation_id)
  clear_has_operation_id();
  ::mesos::OperationID* temp = operation_id_;
  operation_id_ = NULL;
  return temp;
}
inline ::mesos::OperationID* Call_ReconcileOperations_Operation::mutable_operation_id() {
  set_has_operation_id();
  if (operation_id_ == NULL) {
    _slow_mutable_operation_id();
  }
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Call.ReconcileOperations.Operation.operation_id)
  return operation_id_;
}
inline void Call_ReconcileOperations_Operation::set_allocated_operation_id(::mesos::OperationID* operation_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(operation_id_);
  }
  if (operation_id) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(operation_id)->GetArena();
    if (message_arena != submessage_arena) {
      operation_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, operation_id, submessage_arena);
    }
    set_has_operation_id();
  } else {
    clear_has_operation_id();
  }
  operation_id_ = operation_id;
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Call.ReconcileOperations.Operation.operation_id)
}

// optional .mesos.SlaveID slave_id = 2;
inline bool Call_ReconcileOperations_Operation::has_slave_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Call_ReconcileOperations_Operation::set_has_slave_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Call_ReconcileOperations_Operation::clear_has_slave_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::mesos::SlaveID& Call_ReconcileOperations_Operation::slave_id() const {
  const ::mesos::SlaveID* p = slave_id_;
  // @@protoc_insertion_point(field_get:mesos.scheduler.Call.ReconcileOperations.Operation.slave_id)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::SlaveID*>(
      &::mesos::_SlaveID_default_instance_);
}
inline ::mesos::SlaveID* Call_ReconcileOperations_Operation::release_slave_id() {
  // @@protoc_insertion_point(field_release:mesos.scheduler.Call.ReconcileOperations.Operation.slave_id)
  clear_has_slave_id();
  ::mesos::SlaveID* temp = slave_id_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  slave_id_ = NULL;
  return temp;
}
inline ::mesos::SlaveID* Call_ReconcileOperations_Operation::unsafe_arena_release_slave_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.scheduler.Call.ReconcileOperations.Operation.slave_id)
  clear_has_slave_id();
  ::mesos::SlaveID* temp = slave_id_;
  slave_id_ = NULL;
  return temp;
}
inline ::mesos::SlaveID* Call_ReconcileOperations_Operation::mutable_slave_id() {
  set_has_slave_id();
  if (slave_id_ == NULL) {
    _slow_mutable_slave_id();
  }
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Call.ReconcileOperations.Operation.slave_id)
  return slave_id_;
}
inline void Call_ReconcileOperations_Operation::set_allocated_slave_id(::mesos::SlaveID* slave_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(slave_id_);
  }
  if (slave_id) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(slave_id)->GetArena();
    if (message_arena != submessage_arena) {
      slave_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, slave_id, submessage_arena);
    }
    set_has_slave_id();
  } else {
    clear_has_slave_id();
  }
  slave_id_ = slave_id;
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Call.ReconcileOperations.Operation.slave_id)
}

// optional .mesos.ResourceProviderID resource_provider_id = 3;
inline bool Call_ReconcileOperations_Operation::has_resource_provider_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Call_ReconcileOperations_Operation::set_has_resource_provider_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Call_ReconcileOperations_Operation::clear_has_resource_provider_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::mesos::ResourceProviderID& Call_ReconcileOperations_Operation::resource_provider_id() const {
  const ::mesos::ResourceProviderID* p = resource_provider_id_;
  // @@protoc_insertion_point(field_get:mesos.scheduler.Call.ReconcileOperations.Operation.resource_provider_id)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ResourceProviderID*>(
      &::mesos::_ResourceProviderID_default_instance_);
}
inline ::mesos::ResourceProviderID* Call_ReconcileOperations_Operation::release_resource_provider_id() {
  // @@protoc_insertion_point(field_release:mesos.scheduler.Call.ReconcileOperations.Operation.resource_provider_id)
  clear_has_resource_provider_id();
  ::mesos::ResourceProviderID* temp = resource_provider_id_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  resource_provider_id_ = NULL;
  return temp;
}
inline ::mesos::ResourceProviderID* Call_ReconcileOperations_Operation::unsafe_arena_release_resource_provider_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.scheduler.Call.ReconcileOperations.Operation.resource_provider_id)
  clear_has_resource_provider_id();
  ::mesos::ResourceProviderID* temp = resource_provider_id_;
  resource_provider_id_ = NULL;
  return temp;
}
inline ::mesos::ResourceProviderID* Call_ReconcileOperations_Operation::mutable_resource_provider_id() {
  set_has_resource_provider_id();
  if (resource_provider_id_ == NULL) {
    _slow_mutable_resource_provider_id();
  }
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Call.ReconcileOperations.Operation.resource_provider_id)
  return resource_provider_id_;
}
inline void Call_ReconcileOperations_Operation::set_allocated_resource_provider_id(::mesos::ResourceProviderID* resource_provider_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(resource_provider_id_);
  }
  if (resource_provider_id) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(resource_provider_id)->GetArena();
    if (message_arena != submessage_arena) {
      resource_provider_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, resource_provider_id, submessage_arena);
    }
    set_has_resource_provider_id();
  } else {
    clear_has_resource_provider_id();
  }
  resource_provider_id_ = resource_provider_id;
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Call.ReconcileOperations.Operation.resource_provider_id)
}

// -------------------------------------------------------------------

// Call_ReconcileOperations

// repeated .mesos.scheduler.Call.ReconcileOperations.Operation operations = 1;
inline int Call_ReconcileOperations::operations_size() const {
  return operations_.size();
}
inline void Call_ReconcileOperations::clear_operations() {
  operations_.Clear();
}
inline const ::mesos::scheduler::Call_ReconcileOperations_Operation& Call_ReconcileOperations::operations(int index) const {
  // @@protoc_insertion_point(field_get:mesos.scheduler.Call.ReconcileOperations.operations)
  return operations_.Get(index);
}
inline ::mesos::scheduler::Call_ReconcileOperations_Operation* Call_ReconcileOperations::mutable_operations(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Call.ReconcileOperations.operations)
  return operations_.Mutable(index);
}
inline ::mesos::scheduler::Call_ReconcileOperations_Operation* Call_ReconcileOperations::add_operations() {
  // @@protoc_insertion_point(field_add:mesos.scheduler.Call.ReconcileOperations.operations)
  return operations_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::scheduler::Call_ReconcileOperations_Operation >*
Call_ReconcileOperations::mutable_operations() {
  // @@protoc_insertion_point(field_mutable_list:mesos.scheduler.Call.ReconcileOperations.operations)
  return &operations_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::scheduler::Call_ReconcileOperations_Operation >&
Call_ReconcileOperations::operations() const {
  // @@protoc_insertion_point(field_list:mesos.scheduler.Call.ReconcileOperations.operations)
  return operations_;
}

// -------------------------------------------------------------------

// Call_Message

// required .mesos.SlaveID slave_id = 1;
inline bool Call_Message::has_slave_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Call_Message::set_has_slave_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Call_Message::clear_has_slave_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::mesos::SlaveID& Call_Message::slave_id() const {
  const ::mesos::SlaveID* p = slave_id_;
  // @@protoc_insertion_point(field_get:mesos.scheduler.Call.Message.slave_id)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::SlaveID*>(
      &::mesos::_SlaveID_default_instance_);
}
inline ::mesos::SlaveID* Call_Message::release_slave_id() {
  // @@protoc_insertion_point(field_release:mesos.scheduler.Call.Message.slave_id)
  clear_has_slave_id();
  ::mesos::SlaveID* temp = slave_id_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  slave_id_ = NULL;
  return temp;
}
inline ::mesos::SlaveID* Call_Message::unsafe_arena_release_slave_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.scheduler.Call.Message.slave_id)
  clear_has_slave_id();
  ::mesos::SlaveID* temp = slave_id_;
  slave_id_ = NULL;
  return temp;
}
inline ::mesos::SlaveID* Call_Message::mutable_slave_id() {
  set_has_slave_id();
  if (slave_id_ == NULL) {
    _slow_mutable_slave_id();
  }
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Call.Message.slave_id)
  return slave_id_;
}
inline void Call_Message::set_allocated_slave_id(::mesos::SlaveID* slave_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(slave_id_);
  }
  if (slave_id) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(slave_id)->GetArena();
    if (message_arena != submessage_arena) {
      slave_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, slave_id, submessage_arena);
    }
    set_has_slave_id();
  } else {
    clear_has_slave_id();
  }
  slave_id_ = slave_id;
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Call.Message.slave_id)
}

// required .mesos.ExecutorID executor_id = 2;
inline bool Call_Message::has_executor_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Call_Message::set_has_executor_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Call_Message::clear_has_executor_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::mesos::ExecutorID& Call_Message::executor_id() const {
  const ::mesos::ExecutorID* p = executor_id_;
  // @@protoc_insertion_point(field_get:mesos.scheduler.Call.Message.executor_id)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ExecutorID*>(
      &::mesos::_ExecutorID_default_instance_);
}
inline ::mesos::ExecutorID* Call_Message::release_executor_id() {
  // @@protoc_insertion_point(field_release:mesos.scheduler.Call.Message.executor_id)
  clear_has_executor_id();
  ::mesos::ExecutorID* temp = executor_id_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  executor_id_ = NULL;
  return temp;
}
inline ::mesos::ExecutorID* Call_Message::unsafe_arena_release_executor_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.scheduler.Call.Message.executor_id)
  clear_has_executor_id();
  ::mesos::ExecutorID* temp = executor_id_;
  executor_id_ = NULL;
  return temp;
}
inline ::mesos::ExecutorID* Call_Message::mutable_executor_id() {
  set_has_executor_id();
  if (executor_id_ == NULL) {
    _slow_mutable_executor_id();
  }
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Call.Message.executor_id)
  return executor_id_;
}
inline void Call_Message::set_allocated_executor_id(::mesos::ExecutorID* executor_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(executor_id_);
  }
  if (executor_id) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(executor_id)->GetArena();
    if (message_arena != submessage_arena) {
      executor_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, executor_id, submessage_arena);
    }
    set_has_executor_id();
  } else {
    clear_has_executor_id();
  }
  executor_id_ = executor_id;
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Call.Message.executor_id)
}

// required bytes data = 3;
inline bool Call_Message::has_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Call_Message::set_has_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Call_Message::clear_has_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Call_Message::clear_data() {
  data_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_data();
}
inline const ::std::string& Call_Message::data() const {
  // @@protoc_insertion_point(field_get:mesos.scheduler.Call.Message.data)
  return data_.Get();
}
inline void Call_Message::set_data(const ::std::string& value) {
  set_has_data();
  data_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:mesos.scheduler.Call.Message.data)
}
#if LANG_CXX11
inline void Call_Message::set_data(::std::string&& value) {
  set_has_data();
  data_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:mesos.scheduler.Call.Message.data)
}
#endif
inline void Call_Message::set_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_data();
  data_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:mesos.scheduler.Call.Message.data)
}
inline void Call_Message::set_data(const void* value,
    size_t size) {
  set_has_data();
  data_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:mesos.scheduler.Call.Message.data)
}
inline ::std::string* Call_Message::mutable_data() {
  set_has_data();
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Call.Message.data)
  return data_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* Call_Message::release_data() {
  // @@protoc_insertion_point(field_release:mesos.scheduler.Call.Message.data)
  clear_has_data();
  return data_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void Call_Message::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    set_has_data();
  } else {
    clear_has_data();
  }
  data_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Call.Message.data)
}
inline ::std::string* Call_Message::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.scheduler.Call.Message.data)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_data();
  return data_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void Call_Message::unsafe_arena_set_allocated_data(
    ::std::string* data) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (data != NULL) {
    set_has_data();
  } else {
    clear_has_data();
  }
  data_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      data, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mesos.scheduler.Call.Message.data)
}

// -------------------------------------------------------------------

// Call_Request

// repeated .mesos.Request requests = 1;
inline int Call_Request::requests_size() const {
  return requests_.size();
}
inline const ::mesos::Request& Call_Request::requests(int index) const {
  // @@protoc_insertion_point(field_get:mesos.scheduler.Call.Request.requests)
  return requests_.Get(index);
}
inline ::mesos::Request* Call_Request::mutable_requests(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Call.Request.requests)
  return requests_.Mutable(index);
}
inline ::mesos::Request* Call_Request::add_requests() {
  // @@protoc_insertion_point(field_add:mesos.scheduler.Call.Request.requests)
  return requests_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Request >*
Call_Request::mutable_requests() {
  // @@protoc_insertion_point(field_mutable_list:mesos.scheduler.Call.Request.requests)
  return &requests_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Request >&
Call_Request::requests() const {
  // @@protoc_insertion_point(field_list:mesos.scheduler.Call.Request.requests)
  return requests_;
}

// -------------------------------------------------------------------

// Call_Suppress

// repeated string roles = 1;
inline int Call_Suppress::roles_size() const {
  return roles_.size();
}
inline void Call_Suppress::clear_roles() {
  roles_.Clear();
}
inline const ::std::string& Call_Suppress::roles(int index) const {
  // @@protoc_insertion_point(field_get:mesos.scheduler.Call.Suppress.roles)
  return roles_.Get(index);
}
inline ::std::string* Call_Suppress::mutable_roles(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Call.Suppress.roles)
  return roles_.Mutable(index);
}
inline void Call_Suppress::set_roles(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:mesos.scheduler.Call.Suppress.roles)
  roles_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Call_Suppress::set_roles(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:mesos.scheduler.Call.Suppress.roles)
  roles_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Call_Suppress::set_roles(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  roles_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.scheduler.Call.Suppress.roles)
}
inline void Call_Suppress::set_roles(int index, const char* value, size_t size) {
  roles_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.scheduler.Call.Suppress.roles)
}
inline ::std::string* Call_Suppress::add_roles() {
  // @@protoc_insertion_point(field_add_mutable:mesos.scheduler.Call.Suppress.roles)
  return roles_.Add();
}
inline void Call_Suppress::add_roles(const ::std::string& value) {
  roles_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:mesos.scheduler.Call.Suppress.roles)
}
#if LANG_CXX11
inline void Call_Suppress::add_roles(::std::string&& value) {
  roles_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:mesos.scheduler.Call.Suppress.roles)
}
#endif
inline void Call_Suppress::add_roles(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  roles_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:mesos.scheduler.Call.Suppress.roles)
}
inline void Call_Suppress::add_roles(const char* value, size_t size) {
  roles_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:mesos.scheduler.Call.Suppress.roles)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Call_Suppress::roles() const {
  // @@protoc_insertion_point(field_list:mesos.scheduler.Call.Suppress.roles)
  return roles_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Call_Suppress::mutable_roles() {
  // @@protoc_insertion_point(field_mutable_list:mesos.scheduler.Call.Suppress.roles)
  return &roles_;
}

// -------------------------------------------------------------------

// Call

// optional .mesos.FrameworkID framework_id = 1;
inline bool Call::has_framework_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Call::set_has_framework_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Call::clear_has_framework_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::mesos::FrameworkID& Call::framework_id() const {
  const ::mesos::FrameworkID* p = framework_id_;
  // @@protoc_insertion_point(field_get:mesos.scheduler.Call.framework_id)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::FrameworkID*>(
      &::mesos::_FrameworkID_default_instance_);
}
inline ::mesos::FrameworkID* Call::release_framework_id() {
  // @@protoc_insertion_point(field_release:mesos.scheduler.Call.framework_id)
  clear_has_framework_id();
  ::mesos::FrameworkID* temp = framework_id_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  framework_id_ = NULL;
  return temp;
}
inline ::mesos::FrameworkID* Call::unsafe_arena_release_framework_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.scheduler.Call.framework_id)
  clear_has_framework_id();
  ::mesos::FrameworkID* temp = framework_id_;
  framework_id_ = NULL;
  return temp;
}
inline ::mesos::FrameworkID* Call::mutable_framework_id() {
  set_has_framework_id();
  if (framework_id_ == NULL) {
    _slow_mutable_framework_id();
  }
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Call.framework_id)
  return framework_id_;
}
inline void Call::set_allocated_framework_id(::mesos::FrameworkID* framework_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(framework_id_);
  }
  if (framework_id) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(framework_id)->GetArena();
    if (message_arena != submessage_arena) {
      framework_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, framework_id, submessage_arena);
    }
    set_has_framework_id();
  } else {
    clear_has_framework_id();
  }
  framework_id_ = framework_id;
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Call.framework_id)
}

// optional .mesos.scheduler.Call.Type type = 2;
inline bool Call::has_type() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Call::set_has_type() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Call::clear_has_type() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Call::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::mesos::scheduler::Call_Type Call::type() const {
  // @@protoc_insertion_point(field_get:mesos.scheduler.Call.type)
  return static_cast< ::mesos::scheduler::Call_Type >(type_);
}
inline void Call::set_type(::mesos::scheduler::Call_Type value) {
  assert(::mesos::scheduler::Call_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:mesos.scheduler.Call.type)
}

// optional .mesos.scheduler.Call.Subscribe subscribe = 3;
inline bool Call::has_subscribe() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Call::set_has_subscribe() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Call::clear_has_subscribe() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Call::clear_subscribe() {
  if (subscribe_ != NULL) subscribe_->Clear();
  clear_has_subscribe();
}
inline const ::mesos::scheduler::Call_Subscribe& Call::subscribe() const {
  const ::mesos::scheduler::Call_Subscribe* p = subscribe_;
  // @@protoc_insertion_point(field_get:mesos.scheduler.Call.subscribe)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::scheduler::Call_Subscribe*>(
      &::mesos::scheduler::_Call_Subscribe_default_instance_);
}
inline ::mesos::scheduler::Call_Subscribe* Call::release_subscribe() {
  // @@protoc_insertion_point(field_release:mesos.scheduler.Call.subscribe)
  clear_has_subscribe();
  ::mesos::scheduler::Call_Subscribe* temp = subscribe_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  subscribe_ = NULL;
  return temp;
}
inline ::mesos::scheduler::Call_Subscribe* Call::unsafe_arena_release_subscribe() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.scheduler.Call.subscribe)
  clear_has_subscribe();
  ::mesos::scheduler::Call_Subscribe* temp = subscribe_;
  subscribe_ = NULL;
  return temp;
}
inline ::mesos::scheduler::Call_Subscribe* Call::mutable_subscribe() {
  set_has_subscribe();
  if (subscribe_ == NULL) {
    _slow_mutable_subscribe();
  }
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Call.subscribe)
  return subscribe_;
}
inline void Call::set_allocated_subscribe(::mesos::scheduler::Call_Subscribe* subscribe) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete subscribe_;
  }
  if (subscribe) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(subscribe);
    if (message_arena != submessage_arena) {
      subscribe = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, subscribe, submessage_arena);
    }
    set_has_subscribe();
  } else {
    clear_has_subscribe();
  }
  subscribe_ = subscribe;
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Call.subscribe)
}

// optional .mesos.scheduler.Call.Accept accept = 4;
inline bool Call::has_accept() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Call::set_has_accept() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Call::clear_has_accept() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Call::clear_accept() {
  if (accept_ != NULL) accept_->Clear();
  clear_has_accept();
}
inline const ::mesos::scheduler::Call_Accept& Call::accept() const {
  const ::mesos::scheduler::Call_Accept* p = accept_;
  // @@protoc_insertion_point(field_get:mesos.scheduler.Call.accept)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::scheduler::Call_Accept*>(
      &::mesos::scheduler::_Call_Accept_default_instance_);
}
inline ::mesos::scheduler::Call_Accept* Call::release_accept() {
  // @@protoc_insertion_point(field_release:mesos.scheduler.Call.accept)
  clear_has_accept();
  ::mesos::scheduler::Call_Accept* temp = accept_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  accept_ = NULL;
  return temp;
}
inline ::mesos::scheduler::Call_Accept* Call::unsafe_arena_release_accept() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.scheduler.Call.accept)
  clear_has_accept();
  ::mesos::scheduler::Call_Accept* temp = accept_;
  accept_ = NULL;
  return temp;
}
inline ::mesos::scheduler::Call_Accept* Call::mutable_accept() {
  set_has_accept();
  if (accept_ == NULL) {
    _slow_mutable_accept();
  }
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Call.accept)
  return accept_;
}
inline void Call::set_allocated_accept(::mesos::scheduler::Call_Accept* accept) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete accept_;
  }
  if (accept) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(accept);
    if (message_arena != submessage_arena) {
      accept = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, accept, submessage_arena);
    }
    set_has_accept();
  } else {
    clear_has_accept();
  }
  accept_ = accept;
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Call.accept)
}

// optional .mesos.scheduler.Call.Decline decline = 5;
inline bool Call::has_decline() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Call::set_has_decline() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Call::clear_has_decline() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Call::clear_decline() {
  if (decline_ != NULL) decline_->Clear();
  clear_has_decline();
}
inline const ::mesos::scheduler::Call_Decline& Call::decline() const {
  const ::mesos::scheduler::Call_Decline* p = decline_;
  // @@protoc_insertion_point(field_get:mesos.scheduler.Call.decline)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::scheduler::Call_Decline*>(
      &::mesos::scheduler::_Call_Decline_default_instance_);
}
inline ::mesos::scheduler::Call_Decline* Call::release_decline() {
  // @@protoc_insertion_point(field_release:mesos.scheduler.Call.decline)
  clear_has_decline();
  ::mesos::scheduler::Call_Decline* temp = decline_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  decline_ = NULL;
  return temp;
}
inline ::mesos::scheduler::Call_Decline* Call::unsafe_arena_release_decline() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.scheduler.Call.decline)
  clear_has_decline();
  ::mesos::scheduler::Call_Decline* temp = decline_;
  decline_ = NULL;
  return temp;
}
inline ::mesos::scheduler::Call_Decline* Call::mutable_decline() {
  set_has_decline();
  if (decline_ == NULL) {
    _slow_mutable_decline();
  }
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Call.decline)
  return decline_;
}
inline void Call::set_allocated_decline(::mesos::scheduler::Call_Decline* decline) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete decline_;
  }
  if (decline) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(decline);
    if (message_arena != submessage_arena) {
      decline = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, decline, submessage_arena);
    }
    set_has_decline();
  } else {
    clear_has_decline();
  }
  decline_ = decline;
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Call.decline)
}

// optional .mesos.scheduler.Call.AcceptInverseOffers accept_inverse_offers = 13;
inline bool Call::has_accept_inverse_offers() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Call::set_has_accept_inverse_offers() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Call::clear_has_accept_inverse_offers() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Call::clear_accept_inverse_offers() {
  if (accept_inverse_offers_ != NULL) accept_inverse_offers_->Clear();
  clear_has_accept_inverse_offers();
}
inline const ::mesos::scheduler::Call_AcceptInverseOffers& Call::accept_inverse_offers() const {
  const ::mesos::scheduler::Call_AcceptInverseOffers* p = accept_inverse_offers_;
  // @@protoc_insertion_point(field_get:mesos.scheduler.Call.accept_inverse_offers)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::scheduler::Call_AcceptInverseOffers*>(
      &::mesos::scheduler::_Call_AcceptInverseOffers_default_instance_);
}
inline ::mesos::scheduler::Call_AcceptInverseOffers* Call::release_accept_inverse_offers() {
  // @@protoc_insertion_point(field_release:mesos.scheduler.Call.accept_inverse_offers)
  clear_has_accept_inverse_offers();
  ::mesos::scheduler::Call_AcceptInverseOffers* temp = accept_inverse_offers_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  accept_inverse_offers_ = NULL;
  return temp;
}
inline ::mesos::scheduler::Call_AcceptInverseOffers* Call::unsafe_arena_release_accept_inverse_offers() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.scheduler.Call.accept_inverse_offers)
  clear_has_accept_inverse_offers();
  ::mesos::scheduler::Call_AcceptInverseOffers* temp = accept_inverse_offers_;
  accept_inverse_offers_ = NULL;
  return temp;
}
inline ::mesos::scheduler::Call_AcceptInverseOffers* Call::mutable_accept_inverse_offers() {
  set_has_accept_inverse_offers();
  if (accept_inverse_offers_ == NULL) {
    _slow_mutable_accept_inverse_offers();
  }
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Call.accept_inverse_offers)
  return accept_inverse_offers_;
}
inline void Call::set_allocated_accept_inverse_offers(::mesos::scheduler::Call_AcceptInverseOffers* accept_inverse_offers) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete accept_inverse_offers_;
  }
  if (accept_inverse_offers) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(accept_inverse_offers);
    if (message_arena != submessage_arena) {
      accept_inverse_offers = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, accept_inverse_offers, submessage_arena);
    }
    set_has_accept_inverse_offers();
  } else {
    clear_has_accept_inverse_offers();
  }
  accept_inverse_offers_ = accept_inverse_offers;
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Call.accept_inverse_offers)
}

// optional .mesos.scheduler.Call.DeclineInverseOffers decline_inverse_offers = 14;
inline bool Call::has_decline_inverse_offers() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Call::set_has_decline_inverse_offers() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Call::clear_has_decline_inverse_offers() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Call::clear_decline_inverse_offers() {
  if (decline_inverse_offers_ != NULL) decline_inverse_offers_->Clear();
  clear_has_decline_inverse_offers();
}
inline const ::mesos::scheduler::Call_DeclineInverseOffers& Call::decline_inverse_offers() const {
  const ::mesos::scheduler::Call_DeclineInverseOffers* p = decline_inverse_offers_;
  // @@protoc_insertion_point(field_get:mesos.scheduler.Call.decline_inverse_offers)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::scheduler::Call_DeclineInverseOffers*>(
      &::mesos::scheduler::_Call_DeclineInverseOffers_default_instance_);
}
inline ::mesos::scheduler::Call_DeclineInverseOffers* Call::release_decline_inverse_offers() {
  // @@protoc_insertion_point(field_release:mesos.scheduler.Call.decline_inverse_offers)
  clear_has_decline_inverse_offers();
  ::mesos::scheduler::Call_DeclineInverseOffers* temp = decline_inverse_offers_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  decline_inverse_offers_ = NULL;
  return temp;
}
inline ::mesos::scheduler::Call_DeclineInverseOffers* Call::unsafe_arena_release_decline_inverse_offers() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.scheduler.Call.decline_inverse_offers)
  clear_has_decline_inverse_offers();
  ::mesos::scheduler::Call_DeclineInverseOffers* temp = decline_inverse_offers_;
  decline_inverse_offers_ = NULL;
  return temp;
}
inline ::mesos::scheduler::Call_DeclineInverseOffers* Call::mutable_decline_inverse_offers() {
  set_has_decline_inverse_offers();
  if (decline_inverse_offers_ == NULL) {
    _slow_mutable_decline_inverse_offers();
  }
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Call.decline_inverse_offers)
  return decline_inverse_offers_;
}
inline void Call::set_allocated_decline_inverse_offers(::mesos::scheduler::Call_DeclineInverseOffers* decline_inverse_offers) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete decline_inverse_offers_;
  }
  if (decline_inverse_offers) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(decline_inverse_offers);
    if (message_arena != submessage_arena) {
      decline_inverse_offers = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, decline_inverse_offers, submessage_arena);
    }
    set_has_decline_inverse_offers();
  } else {
    clear_has_decline_inverse_offers();
  }
  decline_inverse_offers_ = decline_inverse_offers;
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Call.decline_inverse_offers)
}

// optional .mesos.scheduler.Call.Revive revive = 15;
inline bool Call::has_revive() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Call::set_has_revive() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Call::clear_has_revive() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Call::clear_revive() {
  if (revive_ != NULL) revive_->Clear();
  clear_has_revive();
}
inline const ::mesos::scheduler::Call_Revive& Call::revive() const {
  const ::mesos::scheduler::Call_Revive* p = revive_;
  // @@protoc_insertion_point(field_get:mesos.scheduler.Call.revive)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::scheduler::Call_Revive*>(
      &::mesos::scheduler::_Call_Revive_default_instance_);
}
inline ::mesos::scheduler::Call_Revive* Call::release_revive() {
  // @@protoc_insertion_point(field_release:mesos.scheduler.Call.revive)
  clear_has_revive();
  ::mesos::scheduler::Call_Revive* temp = revive_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  revive_ = NULL;
  return temp;
}
inline ::mesos::scheduler::Call_Revive* Call::unsafe_arena_release_revive() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.scheduler.Call.revive)
  clear_has_revive();
  ::mesos::scheduler::Call_Revive* temp = revive_;
  revive_ = NULL;
  return temp;
}
inline ::mesos::scheduler::Call_Revive* Call::mutable_revive() {
  set_has_revive();
  if (revive_ == NULL) {
    _slow_mutable_revive();
  }
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Call.revive)
  return revive_;
}
inline void Call::set_allocated_revive(::mesos::scheduler::Call_Revive* revive) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete revive_;
  }
  if (revive) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(revive);
    if (message_arena != submessage_arena) {
      revive = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, revive, submessage_arena);
    }
    set_has_revive();
  } else {
    clear_has_revive();
  }
  revive_ = revive;
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Call.revive)
}

// optional .mesos.scheduler.Call.Kill kill = 6;
inline bool Call::has_kill() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Call::set_has_kill() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Call::clear_has_kill() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Call::clear_kill() {
  if (kill_ != NULL) kill_->Clear();
  clear_has_kill();
}
inline const ::mesos::scheduler::Call_Kill& Call::kill() const {
  const ::mesos::scheduler::Call_Kill* p = kill_;
  // @@protoc_insertion_point(field_get:mesos.scheduler.Call.kill)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::scheduler::Call_Kill*>(
      &::mesos::scheduler::_Call_Kill_default_instance_);
}
inline ::mesos::scheduler::Call_Kill* Call::release_kill() {
  // @@protoc_insertion_point(field_release:mesos.scheduler.Call.kill)
  clear_has_kill();
  ::mesos::scheduler::Call_Kill* temp = kill_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  kill_ = NULL;
  return temp;
}
inline ::mesos::scheduler::Call_Kill* Call::unsafe_arena_release_kill() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.scheduler.Call.kill)
  clear_has_kill();
  ::mesos::scheduler::Call_Kill* temp = kill_;
  kill_ = NULL;
  return temp;
}
inline ::mesos::scheduler::Call_Kill* Call::mutable_kill() {
  set_has_kill();
  if (kill_ == NULL) {
    _slow_mutable_kill();
  }
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Call.kill)
  return kill_;
}
inline void Call::set_allocated_kill(::mesos::scheduler::Call_Kill* kill) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete kill_;
  }
  if (kill) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(kill);
    if (message_arena != submessage_arena) {
      kill = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, kill, submessage_arena);
    }
    set_has_kill();
  } else {
    clear_has_kill();
  }
  kill_ = kill;
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Call.kill)
}

// optional .mesos.scheduler.Call.Shutdown shutdown = 7;
inline bool Call::has_shutdown() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Call::set_has_shutdown() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Call::clear_has_shutdown() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Call::clear_shutdown() {
  if (shutdown_ != NULL) shutdown_->Clear();
  clear_has_shutdown();
}
inline const ::mesos::scheduler::Call_Shutdown& Call::shutdown() const {
  const ::mesos::scheduler::Call_Shutdown* p = shutdown_;
  // @@protoc_insertion_point(field_get:mesos.scheduler.Call.shutdown)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::scheduler::Call_Shutdown*>(
      &::mesos::scheduler::_Call_Shutdown_default_instance_);
}
inline ::mesos::scheduler::Call_Shutdown* Call::release_shutdown() {
  // @@protoc_insertion_point(field_release:mesos.scheduler.Call.shutdown)
  clear_has_shutdown();
  ::mesos::scheduler::Call_Shutdown* temp = shutdown_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  shutdown_ = NULL;
  return temp;
}
inline ::mesos::scheduler::Call_Shutdown* Call::unsafe_arena_release_shutdown() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.scheduler.Call.shutdown)
  clear_has_shutdown();
  ::mesos::scheduler::Call_Shutdown* temp = shutdown_;
  shutdown_ = NULL;
  return temp;
}
inline ::mesos::scheduler::Call_Shutdown* Call::mutable_shutdown() {
  set_has_shutdown();
  if (shutdown_ == NULL) {
    _slow_mutable_shutdown();
  }
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Call.shutdown)
  return shutdown_;
}
inline void Call::set_allocated_shutdown(::mesos::scheduler::Call_Shutdown* shutdown) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete shutdown_;
  }
  if (shutdown) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(shutdown);
    if (message_arena != submessage_arena) {
      shutdown = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, shutdown, submessage_arena);
    }
    set_has_shutdown();
  } else {
    clear_has_shutdown();
  }
  shutdown_ = shutdown;
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Call.shutdown)
}

// optional .mesos.scheduler.Call.Acknowledge acknowledge = 8;
inline bool Call::has_acknowledge() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Call::set_has_acknowledge() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Call::clear_has_acknowledge() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Call::clear_acknowledge() {
  if (acknowledge_ != NULL) acknowledge_->Clear();
  clear_has_acknowledge();
}
inline const ::mesos::scheduler::Call_Acknowledge& Call::acknowledge() const {
  const ::mesos::scheduler::Call_Acknowledge* p = acknowledge_;
  // @@protoc_insertion_point(field_get:mesos.scheduler.Call.acknowledge)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::scheduler::Call_Acknowledge*>(
      &::mesos::scheduler::_Call_Acknowledge_default_instance_);
}
inline ::mesos::scheduler::Call_Acknowledge* Call::release_acknowledge() {
  // @@protoc_insertion_point(field_release:mesos.scheduler.Call.acknowledge)
  clear_has_acknowledge();
  ::mesos::scheduler::Call_Acknowledge* temp = acknowledge_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  acknowledge_ = NULL;
  return temp;
}
inline ::mesos::scheduler::Call_Acknowledge* Call::unsafe_arena_release_acknowledge() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.scheduler.Call.acknowledge)
  clear_has_acknowledge();
  ::mesos::scheduler::Call_Acknowledge* temp = acknowledge_;
  acknowledge_ = NULL;
  return temp;
}
inline ::mesos::scheduler::Call_Acknowledge* Call::mutable_acknowledge() {
  set_has_acknowledge();
  if (acknowledge_ == NULL) {
    _slow_mutable_acknowledge();
  }
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Call.acknowledge)
  return acknowledge_;
}
inline void Call::set_allocated_acknowledge(::mesos::scheduler::Call_Acknowledge* acknowledge) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete acknowledge_;
  }
  if (acknowledge) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(acknowledge);
    if (message_arena != submessage_arena) {
      acknowledge = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, acknowledge, submessage_arena);
    }
    set_has_acknowledge();
  } else {
    clear_has_acknowledge();
  }
  acknowledge_ = acknowledge;
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Call.acknowledge)
}

// optional .mesos.scheduler.Call.AcknowledgeOperationStatus acknowledge_operation_status = 17;
inline bool Call::has_acknowledge_operation_status() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Call::set_has_acknowledge_operation_status() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Call::clear_has_acknowledge_operation_status() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Call::clear_acknowledge_operation_status() {
  if (acknowledge_operation_status_ != NULL) acknowledge_operation_status_->Clear();
  clear_has_acknowledge_operation_status();
}
inline const ::mesos::scheduler::Call_AcknowledgeOperationStatus& Call::acknowledge_operation_status() const {
  const ::mesos::scheduler::Call_AcknowledgeOperationStatus* p = acknowledge_operation_status_;
  // @@protoc_insertion_point(field_get:mesos.scheduler.Call.acknowledge_operation_status)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::scheduler::Call_AcknowledgeOperationStatus*>(
      &::mesos::scheduler::_Call_AcknowledgeOperationStatus_default_instance_);
}
inline ::mesos::scheduler::Call_AcknowledgeOperationStatus* Call::release_acknowledge_operation_status() {
  // @@protoc_insertion_point(field_release:mesos.scheduler.Call.acknowledge_operation_status)
  clear_has_acknowledge_operation_status();
  ::mesos::scheduler::Call_AcknowledgeOperationStatus* temp = acknowledge_operation_status_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  acknowledge_operation_status_ = NULL;
  return temp;
}
inline ::mesos::scheduler::Call_AcknowledgeOperationStatus* Call::unsafe_arena_release_acknowledge_operation_status() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.scheduler.Call.acknowledge_operation_status)
  clear_has_acknowledge_operation_status();
  ::mesos::scheduler::Call_AcknowledgeOperationStatus* temp = acknowledge_operation_status_;
  acknowledge_operation_status_ = NULL;
  return temp;
}
inline ::mesos::scheduler::Call_AcknowledgeOperationStatus* Call::mutable_acknowledge_operation_status() {
  set_has_acknowledge_operation_status();
  if (acknowledge_operation_status_ == NULL) {
    _slow_mutable_acknowledge_operation_status();
  }
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Call.acknowledge_operation_status)
  return acknowledge_operation_status_;
}
inline void Call::set_allocated_acknowledge_operation_status(::mesos::scheduler::Call_AcknowledgeOperationStatus* acknowledge_operation_status) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete acknowledge_operation_status_;
  }
  if (acknowledge_operation_status) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(acknowledge_operation_status);
    if (message_arena != submessage_arena) {
      acknowledge_operation_status = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, acknowledge_operation_status, submessage_arena);
    }
    set_has_acknowledge_operation_status();
  } else {
    clear_has_acknowledge_operation_status();
  }
  acknowledge_operation_status_ = acknowledge_operation_status;
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Call.acknowledge_operation_status)
}

// optional .mesos.scheduler.Call.Reconcile reconcile = 9;
inline bool Call::has_reconcile() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Call::set_has_reconcile() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Call::clear_has_reconcile() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Call::clear_reconcile() {
  if (reconcile_ != NULL) reconcile_->Clear();
  clear_has_reconcile();
}
inline const ::mesos::scheduler::Call_Reconcile& Call::reconcile() const {
  const ::mesos::scheduler::Call_Reconcile* p = reconcile_;
  // @@protoc_insertion_point(field_get:mesos.scheduler.Call.reconcile)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::scheduler::Call_Reconcile*>(
      &::mesos::scheduler::_Call_Reconcile_default_instance_);
}
inline ::mesos::scheduler::Call_Reconcile* Call::release_reconcile() {
  // @@protoc_insertion_point(field_release:mesos.scheduler.Call.reconcile)
  clear_has_reconcile();
  ::mesos::scheduler::Call_Reconcile* temp = reconcile_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  reconcile_ = NULL;
  return temp;
}
inline ::mesos::scheduler::Call_Reconcile* Call::unsafe_arena_release_reconcile() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.scheduler.Call.reconcile)
  clear_has_reconcile();
  ::mesos::scheduler::Call_Reconcile* temp = reconcile_;
  reconcile_ = NULL;
  return temp;
}
inline ::mesos::scheduler::Call_Reconcile* Call::mutable_reconcile() {
  set_has_reconcile();
  if (reconcile_ == NULL) {
    _slow_mutable_reconcile();
  }
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Call.reconcile)
  return reconcile_;
}
inline void Call::set_allocated_reconcile(::mesos::scheduler::Call_Reconcile* reconcile) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reconcile_;
  }
  if (reconcile) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(reconcile);
    if (message_arena != submessage_arena) {
      reconcile = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, reconcile, submessage_arena);
    }
    set_has_reconcile();
  } else {
    clear_has_reconcile();
  }
  reconcile_ = reconcile;
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Call.reconcile)
}

// optional .mesos.scheduler.Call.ReconcileOperations reconcile_operations = 18;
inline bool Call::has_reconcile_operations() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Call::set_has_reconcile_operations() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Call::clear_has_reconcile_operations() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Call::clear_reconcile_operations() {
  if (reconcile_operations_ != NULL) reconcile_operations_->Clear();
  clear_has_reconcile_operations();
}
inline const ::mesos::scheduler::Call_ReconcileOperations& Call::reconcile_operations() const {
  const ::mesos::scheduler::Call_ReconcileOperations* p = reconcile_operations_;
  // @@protoc_insertion_point(field_get:mesos.scheduler.Call.reconcile_operations)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::scheduler::Call_ReconcileOperations*>(
      &::mesos::scheduler::_Call_ReconcileOperations_default_instance_);
}
inline ::mesos::scheduler::Call_ReconcileOperations* Call::release_reconcile_operations() {
  // @@protoc_insertion_point(field_release:mesos.scheduler.Call.reconcile_operations)
  clear_has_reconcile_operations();
  ::mesos::scheduler::Call_ReconcileOperations* temp = reconcile_operations_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  reconcile_operations_ = NULL;
  return temp;
}
inline ::mesos::scheduler::Call_ReconcileOperations* Call::unsafe_arena_release_reconcile_operations() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.scheduler.Call.reconcile_operations)
  clear_has_reconcile_operations();
  ::mesos::scheduler::Call_ReconcileOperations* temp = reconcile_operations_;
  reconcile_operations_ = NULL;
  return temp;
}
inline ::mesos::scheduler::Call_ReconcileOperations* Call::mutable_reconcile_operations() {
  set_has_reconcile_operations();
  if (reconcile_operations_ == NULL) {
    _slow_mutable_reconcile_operations();
  }
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Call.reconcile_operations)
  return reconcile_operations_;
}
inline void Call::set_allocated_reconcile_operations(::mesos::scheduler::Call_ReconcileOperations* reconcile_operations) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reconcile_operations_;
  }
  if (reconcile_operations) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(reconcile_operations);
    if (message_arena != submessage_arena) {
      reconcile_operations = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, reconcile_operations, submessage_arena);
    }
    set_has_reconcile_operations();
  } else {
    clear_has_reconcile_operations();
  }
  reconcile_operations_ = reconcile_operations;
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Call.reconcile_operations)
}

// optional .mesos.scheduler.Call.Message message = 10;
inline bool Call::has_message() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Call::set_has_message() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Call::clear_has_message() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Call::clear_message() {
  if (message_ != NULL) message_->Clear();
  clear_has_message();
}
inline const ::mesos::scheduler::Call_Message& Call::message() const {
  const ::mesos::scheduler::Call_Message* p = message_;
  // @@protoc_insertion_point(field_get:mesos.scheduler.Call.message)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::scheduler::Call_Message*>(
      &::mesos::scheduler::_Call_Message_default_instance_);
}
inline ::mesos::scheduler::Call_Message* Call::release_message() {
  // @@protoc_insertion_point(field_release:mesos.scheduler.Call.message)
  clear_has_message();
  ::mesos::scheduler::Call_Message* temp = message_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  message_ = NULL;
  return temp;
}
inline ::mesos::scheduler::Call_Message* Call::unsafe_arena_release_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.scheduler.Call.message)
  clear_has_message();
  ::mesos::scheduler::Call_Message* temp = message_;
  message_ = NULL;
  return temp;
}
inline ::mesos::scheduler::Call_Message* Call::mutable_message() {
  set_has_message();
  if (message_ == NULL) {
    _slow_mutable_message();
  }
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Call.message)
  return message_;
}
inline void Call::set_allocated_message(::mesos::scheduler::Call_Message* message) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete message_;
  }
  if (message) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(message);
    if (message_arena != submessage_arena) {
      message = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, message, submessage_arena);
    }
    set_has_message();
  } else {
    clear_has_message();
  }
  message_ = message;
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Call.message)
}

// optional .mesos.scheduler.Call.Request request = 11;
inline bool Call::has_request() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Call::set_has_request() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Call::clear_has_request() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Call::clear_request() {
  if (request_ != NULL) request_->Clear();
  clear_has_request();
}
inline const ::mesos::scheduler::Call_Request& Call::request() const {
  const ::mesos::scheduler::Call_Request* p = request_;
  // @@protoc_insertion_point(field_get:mesos.scheduler.Call.request)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::scheduler::Call_Request*>(
      &::mesos::scheduler::_Call_Request_default_instance_);
}
inline ::mesos::scheduler::Call_Request* Call::release_request() {
  // @@protoc_insertion_point(field_release:mesos.scheduler.Call.request)
  clear_has_request();
  ::mesos::scheduler::Call_Request* temp = request_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  request_ = NULL;
  return temp;
}
inline ::mesos::scheduler::Call_Request* Call::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.scheduler.Call.request)
  clear_has_request();
  ::mesos::scheduler::Call_Request* temp = request_;
  request_ = NULL;
  return temp;
}
inline ::mesos::scheduler::Call_Request* Call::mutable_request() {
  set_has_request();
  if (request_ == NULL) {
    _slow_mutable_request();
  }
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Call.request)
  return request_;
}
inline void Call::set_allocated_request(::mesos::scheduler::Call_Request* request) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete request_;
  }
  if (request) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(request);
    if (message_arena != submessage_arena) {
      request = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    set_has_request();
  } else {
    clear_has_request();
  }
  request_ = request;
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Call.request)
}

// optional .mesos.scheduler.Call.Suppress suppress = 16;
inline bool Call::has_suppress() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Call::set_has_suppress() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Call::clear_has_suppress() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Call::clear_suppress() {
  if (suppress_ != NULL) suppress_->Clear();
  clear_has_suppress();
}
inline const ::mesos::scheduler::Call_Suppress& Call::suppress() const {
  const ::mesos::scheduler::Call_Suppress* p = suppress_;
  // @@protoc_insertion_point(field_get:mesos.scheduler.Call.suppress)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::scheduler::Call_Suppress*>(
      &::mesos::scheduler::_Call_Suppress_default_instance_);
}
inline ::mesos::scheduler::Call_Suppress* Call::release_suppress() {
  // @@protoc_insertion_point(field_release:mesos.scheduler.Call.suppress)
  clear_has_suppress();
  ::mesos::scheduler::Call_Suppress* temp = suppress_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  suppress_ = NULL;
  return temp;
}
inline ::mesos::scheduler::Call_Suppress* Call::unsafe_arena_release_suppress() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mesos.scheduler.Call.suppress)
  clear_has_suppress();
  ::mesos::scheduler::Call_Suppress* temp = suppress_;
  suppress_ = NULL;
  return temp;
}
inline ::mesos::scheduler::Call_Suppress* Call::mutable_suppress() {
  set_has_suppress();
  if (suppress_ == NULL) {
    _slow_mutable_suppress();
  }
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Call.suppress)
  return suppress_;
}
inline void Call::set_allocated_suppress(::mesos::scheduler::Call_Suppress* suppress) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete suppress_;
  }
  if (suppress) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(suppress);
    if (message_arena != submessage_arena) {
      suppress = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, suppress, submessage_arena);
    }
    set_has_suppress();
  } else {
    clear_has_suppress();
  }
  suppress_ = suppress;
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Call.suppress)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace scheduler
}  // namespace mesos

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::mesos::scheduler::Event_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mesos::scheduler::Event_Type>() {
  return ::mesos::scheduler::Event_Type_descriptor();
}
template <> struct is_proto_enum< ::mesos::scheduler::Response_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mesos::scheduler::Response_Type>() {
  return ::mesos::scheduler::Response_Type_descriptor();
}
template <> struct is_proto_enum< ::mesos::scheduler::Call_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mesos::scheduler::Call_Type>() {
  return ::mesos::scheduler::Call_Type_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_mesos_2fscheduler_2fscheduler_2eproto__INCLUDED
