// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mesos/authorizer/acls.proto

#ifndef PROTOBUF_mesos_2fauthorizer_2facls_2eproto__INCLUDED
#define PROTOBUF_mesos_2fauthorizer_2facls_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protobuf_mesos_2fauthorizer_2facls_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[47];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsACL_EntityImpl();
void InitDefaultsACL_Entity();
void InitDefaultsACL_RegisterFrameworkImpl();
void InitDefaultsACL_RegisterFramework();
void InitDefaultsACL_RunTaskImpl();
void InitDefaultsACL_RunTask();
void InitDefaultsACL_TeardownFrameworkImpl();
void InitDefaultsACL_TeardownFramework();
void InitDefaultsACL_ReserveResourcesImpl();
void InitDefaultsACL_ReserveResources();
void InitDefaultsACL_UnreserveResourcesImpl();
void InitDefaultsACL_UnreserveResources();
void InitDefaultsACL_CreateVolumeImpl();
void InitDefaultsACL_CreateVolume();
void InitDefaultsACL_DestroyVolumeImpl();
void InitDefaultsACL_DestroyVolume();
void InitDefaultsACL_ResizeVolumeImpl();
void InitDefaultsACL_ResizeVolume();
void InitDefaultsACL_GetQuotaImpl();
void InitDefaultsACL_GetQuota();
void InitDefaultsACL_UpdateQuotaImpl();
void InitDefaultsACL_UpdateQuota();
void InitDefaultsACL_ViewRoleImpl();
void InitDefaultsACL_ViewRole();
void InitDefaultsACL_UpdateWeightImpl();
void InitDefaultsACL_UpdateWeight();
void InitDefaultsACL_GetEndpointImpl();
void InitDefaultsACL_GetEndpoint();
void InitDefaultsACL_ViewFrameworkImpl();
void InitDefaultsACL_ViewFramework();
void InitDefaultsACL_ViewTaskImpl();
void InitDefaultsACL_ViewTask();
void InitDefaultsACL_ViewExecutorImpl();
void InitDefaultsACL_ViewExecutor();
void InitDefaultsACL_AccessSandboxImpl();
void InitDefaultsACL_AccessSandbox();
void InitDefaultsACL_AccessMesosLogImpl();
void InitDefaultsACL_AccessMesosLog();
void InitDefaultsACL_ViewFlagsImpl();
void InitDefaultsACL_ViewFlags();
void InitDefaultsACL_LaunchNestedContainerAsUserImpl();
void InitDefaultsACL_LaunchNestedContainerAsUser();
void InitDefaultsACL_LaunchNestedContainerUnderParentWithUserImpl();
void InitDefaultsACL_LaunchNestedContainerUnderParentWithUser();
void InitDefaultsACL_LaunchNestedContainerSessionAsUserImpl();
void InitDefaultsACL_LaunchNestedContainerSessionAsUser();
void InitDefaultsACL_LaunchNestedContainerSessionUnderParentWithUserImpl();
void InitDefaultsACL_LaunchNestedContainerSessionUnderParentWithUser();
void InitDefaultsACL_AttachContainerInputImpl();
void InitDefaultsACL_AttachContainerInput();
void InitDefaultsACL_AttachContainerOutputImpl();
void InitDefaultsACL_AttachContainerOutput();
void InitDefaultsACL_KillNestedContainerImpl();
void InitDefaultsACL_KillNestedContainer();
void InitDefaultsACL_WaitNestedContainerImpl();
void InitDefaultsACL_WaitNestedContainer();
void InitDefaultsACL_ViewContainerImpl();
void InitDefaultsACL_ViewContainer();
void InitDefaultsACL_RemoveNestedContainerImpl();
void InitDefaultsACL_RemoveNestedContainer();
void InitDefaultsACL_SetLogLevelImpl();
void InitDefaultsACL_SetLogLevel();
void InitDefaultsACL_RegisterAgentImpl();
void InitDefaultsACL_RegisterAgent();
void InitDefaultsACL_UpdateMaintenanceScheduleImpl();
void InitDefaultsACL_UpdateMaintenanceSchedule();
void InitDefaultsACL_GetMaintenanceScheduleImpl();
void InitDefaultsACL_GetMaintenanceSchedule();
void InitDefaultsACL_StartMaintenanceImpl();
void InitDefaultsACL_StartMaintenance();
void InitDefaultsACL_StopMaintenanceImpl();
void InitDefaultsACL_StopMaintenance();
void InitDefaultsACL_GetMaintenanceStatusImpl();
void InitDefaultsACL_GetMaintenanceStatus();
void InitDefaultsACL_MarkAgentGoneImpl();
void InitDefaultsACL_MarkAgentGone();
void InitDefaultsACL_LaunchStandaloneContainerImpl();
void InitDefaultsACL_LaunchStandaloneContainer();
void InitDefaultsACL_KillStandaloneContainerImpl();
void InitDefaultsACL_KillStandaloneContainer();
void InitDefaultsACL_WaitStandaloneContainerImpl();
void InitDefaultsACL_WaitStandaloneContainer();
void InitDefaultsACL_RemoveStandaloneContainerImpl();
void InitDefaultsACL_RemoveStandaloneContainer();
void InitDefaultsACL_ViewStandaloneContainerImpl();
void InitDefaultsACL_ViewStandaloneContainer();
void InitDefaultsACL_ModifyResourceProviderConfigImpl();
void InitDefaultsACL_ModifyResourceProviderConfig();
void InitDefaultsACL_PruneImagesImpl();
void InitDefaultsACL_PruneImages();
void InitDefaultsACLImpl();
void InitDefaultsACL();
void InitDefaultsACLsImpl();
void InitDefaultsACLs();
inline void InitDefaults() {
  InitDefaultsACL_Entity();
  InitDefaultsACL_RegisterFramework();
  InitDefaultsACL_RunTask();
  InitDefaultsACL_TeardownFramework();
  InitDefaultsACL_ReserveResources();
  InitDefaultsACL_UnreserveResources();
  InitDefaultsACL_CreateVolume();
  InitDefaultsACL_DestroyVolume();
  InitDefaultsACL_ResizeVolume();
  InitDefaultsACL_GetQuota();
  InitDefaultsACL_UpdateQuota();
  InitDefaultsACL_ViewRole();
  InitDefaultsACL_UpdateWeight();
  InitDefaultsACL_GetEndpoint();
  InitDefaultsACL_ViewFramework();
  InitDefaultsACL_ViewTask();
  InitDefaultsACL_ViewExecutor();
  InitDefaultsACL_AccessSandbox();
  InitDefaultsACL_AccessMesosLog();
  InitDefaultsACL_ViewFlags();
  InitDefaultsACL_LaunchNestedContainerAsUser();
  InitDefaultsACL_LaunchNestedContainerUnderParentWithUser();
  InitDefaultsACL_LaunchNestedContainerSessionAsUser();
  InitDefaultsACL_LaunchNestedContainerSessionUnderParentWithUser();
  InitDefaultsACL_AttachContainerInput();
  InitDefaultsACL_AttachContainerOutput();
  InitDefaultsACL_KillNestedContainer();
  InitDefaultsACL_WaitNestedContainer();
  InitDefaultsACL_ViewContainer();
  InitDefaultsACL_RemoveNestedContainer();
  InitDefaultsACL_SetLogLevel();
  InitDefaultsACL_RegisterAgent();
  InitDefaultsACL_UpdateMaintenanceSchedule();
  InitDefaultsACL_GetMaintenanceSchedule();
  InitDefaultsACL_StartMaintenance();
  InitDefaultsACL_StopMaintenance();
  InitDefaultsACL_GetMaintenanceStatus();
  InitDefaultsACL_MarkAgentGone();
  InitDefaultsACL_LaunchStandaloneContainer();
  InitDefaultsACL_KillStandaloneContainer();
  InitDefaultsACL_WaitStandaloneContainer();
  InitDefaultsACL_RemoveStandaloneContainer();
  InitDefaultsACL_ViewStandaloneContainer();
  InitDefaultsACL_ModifyResourceProviderConfig();
  InitDefaultsACL_PruneImages();
  InitDefaultsACL();
  InitDefaultsACLs();
}
}  // namespace protobuf_mesos_2fauthorizer_2facls_2eproto
namespace mesos {
class ACL;
class ACLDefaultTypeInternal;
extern ACLDefaultTypeInternal _ACL_default_instance_;
class ACL_AccessMesosLog;
class ACL_AccessMesosLogDefaultTypeInternal;
extern ACL_AccessMesosLogDefaultTypeInternal _ACL_AccessMesosLog_default_instance_;
class ACL_AccessSandbox;
class ACL_AccessSandboxDefaultTypeInternal;
extern ACL_AccessSandboxDefaultTypeInternal _ACL_AccessSandbox_default_instance_;
class ACL_AttachContainerInput;
class ACL_AttachContainerInputDefaultTypeInternal;
extern ACL_AttachContainerInputDefaultTypeInternal _ACL_AttachContainerInput_default_instance_;
class ACL_AttachContainerOutput;
class ACL_AttachContainerOutputDefaultTypeInternal;
extern ACL_AttachContainerOutputDefaultTypeInternal _ACL_AttachContainerOutput_default_instance_;
class ACL_CreateVolume;
class ACL_CreateVolumeDefaultTypeInternal;
extern ACL_CreateVolumeDefaultTypeInternal _ACL_CreateVolume_default_instance_;
class ACL_DestroyVolume;
class ACL_DestroyVolumeDefaultTypeInternal;
extern ACL_DestroyVolumeDefaultTypeInternal _ACL_DestroyVolume_default_instance_;
class ACL_Entity;
class ACL_EntityDefaultTypeInternal;
extern ACL_EntityDefaultTypeInternal _ACL_Entity_default_instance_;
class ACL_GetEndpoint;
class ACL_GetEndpointDefaultTypeInternal;
extern ACL_GetEndpointDefaultTypeInternal _ACL_GetEndpoint_default_instance_;
class ACL_GetMaintenanceSchedule;
class ACL_GetMaintenanceScheduleDefaultTypeInternal;
extern ACL_GetMaintenanceScheduleDefaultTypeInternal _ACL_GetMaintenanceSchedule_default_instance_;
class ACL_GetMaintenanceStatus;
class ACL_GetMaintenanceStatusDefaultTypeInternal;
extern ACL_GetMaintenanceStatusDefaultTypeInternal _ACL_GetMaintenanceStatus_default_instance_;
class ACL_GetQuota;
class ACL_GetQuotaDefaultTypeInternal;
extern ACL_GetQuotaDefaultTypeInternal _ACL_GetQuota_default_instance_;
class ACL_KillNestedContainer;
class ACL_KillNestedContainerDefaultTypeInternal;
extern ACL_KillNestedContainerDefaultTypeInternal _ACL_KillNestedContainer_default_instance_;
class ACL_KillStandaloneContainer;
class ACL_KillStandaloneContainerDefaultTypeInternal;
extern ACL_KillStandaloneContainerDefaultTypeInternal _ACL_KillStandaloneContainer_default_instance_;
class ACL_LaunchNestedContainerAsUser;
class ACL_LaunchNestedContainerAsUserDefaultTypeInternal;
extern ACL_LaunchNestedContainerAsUserDefaultTypeInternal _ACL_LaunchNestedContainerAsUser_default_instance_;
class ACL_LaunchNestedContainerSessionAsUser;
class ACL_LaunchNestedContainerSessionAsUserDefaultTypeInternal;
extern ACL_LaunchNestedContainerSessionAsUserDefaultTypeInternal _ACL_LaunchNestedContainerSessionAsUser_default_instance_;
class ACL_LaunchNestedContainerSessionUnderParentWithUser;
class ACL_LaunchNestedContainerSessionUnderParentWithUserDefaultTypeInternal;
extern ACL_LaunchNestedContainerSessionUnderParentWithUserDefaultTypeInternal _ACL_LaunchNestedContainerSessionUnderParentWithUser_default_instance_;
class ACL_LaunchNestedContainerUnderParentWithUser;
class ACL_LaunchNestedContainerUnderParentWithUserDefaultTypeInternal;
extern ACL_LaunchNestedContainerUnderParentWithUserDefaultTypeInternal _ACL_LaunchNestedContainerUnderParentWithUser_default_instance_;
class ACL_LaunchStandaloneContainer;
class ACL_LaunchStandaloneContainerDefaultTypeInternal;
extern ACL_LaunchStandaloneContainerDefaultTypeInternal _ACL_LaunchStandaloneContainer_default_instance_;
class ACL_MarkAgentGone;
class ACL_MarkAgentGoneDefaultTypeInternal;
extern ACL_MarkAgentGoneDefaultTypeInternal _ACL_MarkAgentGone_default_instance_;
class ACL_ModifyResourceProviderConfig;
class ACL_ModifyResourceProviderConfigDefaultTypeInternal;
extern ACL_ModifyResourceProviderConfigDefaultTypeInternal _ACL_ModifyResourceProviderConfig_default_instance_;
class ACL_PruneImages;
class ACL_PruneImagesDefaultTypeInternal;
extern ACL_PruneImagesDefaultTypeInternal _ACL_PruneImages_default_instance_;
class ACL_RegisterAgent;
class ACL_RegisterAgentDefaultTypeInternal;
extern ACL_RegisterAgentDefaultTypeInternal _ACL_RegisterAgent_default_instance_;
class ACL_RegisterFramework;
class ACL_RegisterFrameworkDefaultTypeInternal;
extern ACL_RegisterFrameworkDefaultTypeInternal _ACL_RegisterFramework_default_instance_;
class ACL_RemoveNestedContainer;
class ACL_RemoveNestedContainerDefaultTypeInternal;
extern ACL_RemoveNestedContainerDefaultTypeInternal _ACL_RemoveNestedContainer_default_instance_;
class ACL_RemoveStandaloneContainer;
class ACL_RemoveStandaloneContainerDefaultTypeInternal;
extern ACL_RemoveStandaloneContainerDefaultTypeInternal _ACL_RemoveStandaloneContainer_default_instance_;
class ACL_ReserveResources;
class ACL_ReserveResourcesDefaultTypeInternal;
extern ACL_ReserveResourcesDefaultTypeInternal _ACL_ReserveResources_default_instance_;
class ACL_ResizeVolume;
class ACL_ResizeVolumeDefaultTypeInternal;
extern ACL_ResizeVolumeDefaultTypeInternal _ACL_ResizeVolume_default_instance_;
class ACL_RunTask;
class ACL_RunTaskDefaultTypeInternal;
extern ACL_RunTaskDefaultTypeInternal _ACL_RunTask_default_instance_;
class ACL_SetLogLevel;
class ACL_SetLogLevelDefaultTypeInternal;
extern ACL_SetLogLevelDefaultTypeInternal _ACL_SetLogLevel_default_instance_;
class ACL_StartMaintenance;
class ACL_StartMaintenanceDefaultTypeInternal;
extern ACL_StartMaintenanceDefaultTypeInternal _ACL_StartMaintenance_default_instance_;
class ACL_StopMaintenance;
class ACL_StopMaintenanceDefaultTypeInternal;
extern ACL_StopMaintenanceDefaultTypeInternal _ACL_StopMaintenance_default_instance_;
class ACL_TeardownFramework;
class ACL_TeardownFrameworkDefaultTypeInternal;
extern ACL_TeardownFrameworkDefaultTypeInternal _ACL_TeardownFramework_default_instance_;
class ACL_UnreserveResources;
class ACL_UnreserveResourcesDefaultTypeInternal;
extern ACL_UnreserveResourcesDefaultTypeInternal _ACL_UnreserveResources_default_instance_;
class ACL_UpdateMaintenanceSchedule;
class ACL_UpdateMaintenanceScheduleDefaultTypeInternal;
extern ACL_UpdateMaintenanceScheduleDefaultTypeInternal _ACL_UpdateMaintenanceSchedule_default_instance_;
class ACL_UpdateQuota;
class ACL_UpdateQuotaDefaultTypeInternal;
extern ACL_UpdateQuotaDefaultTypeInternal _ACL_UpdateQuota_default_instance_;
class ACL_UpdateWeight;
class ACL_UpdateWeightDefaultTypeInternal;
extern ACL_UpdateWeightDefaultTypeInternal _ACL_UpdateWeight_default_instance_;
class ACL_ViewContainer;
class ACL_ViewContainerDefaultTypeInternal;
extern ACL_ViewContainerDefaultTypeInternal _ACL_ViewContainer_default_instance_;
class ACL_ViewExecutor;
class ACL_ViewExecutorDefaultTypeInternal;
extern ACL_ViewExecutorDefaultTypeInternal _ACL_ViewExecutor_default_instance_;
class ACL_ViewFlags;
class ACL_ViewFlagsDefaultTypeInternal;
extern ACL_ViewFlagsDefaultTypeInternal _ACL_ViewFlags_default_instance_;
class ACL_ViewFramework;
class ACL_ViewFrameworkDefaultTypeInternal;
extern ACL_ViewFrameworkDefaultTypeInternal _ACL_ViewFramework_default_instance_;
class ACL_ViewRole;
class ACL_ViewRoleDefaultTypeInternal;
extern ACL_ViewRoleDefaultTypeInternal _ACL_ViewRole_default_instance_;
class ACL_ViewStandaloneContainer;
class ACL_ViewStandaloneContainerDefaultTypeInternal;
extern ACL_ViewStandaloneContainerDefaultTypeInternal _ACL_ViewStandaloneContainer_default_instance_;
class ACL_ViewTask;
class ACL_ViewTaskDefaultTypeInternal;
extern ACL_ViewTaskDefaultTypeInternal _ACL_ViewTask_default_instance_;
class ACL_WaitNestedContainer;
class ACL_WaitNestedContainerDefaultTypeInternal;
extern ACL_WaitNestedContainerDefaultTypeInternal _ACL_WaitNestedContainer_default_instance_;
class ACL_WaitStandaloneContainer;
class ACL_WaitStandaloneContainerDefaultTypeInternal;
extern ACL_WaitStandaloneContainerDefaultTypeInternal _ACL_WaitStandaloneContainer_default_instance_;
class ACLs;
class ACLsDefaultTypeInternal;
extern ACLsDefaultTypeInternal _ACLs_default_instance_;
}  // namespace mesos
namespace mesos {

enum ACL_Entity_Type {
  ACL_Entity_Type_SOME = 0,
  ACL_Entity_Type_ANY = 1,
  ACL_Entity_Type_NONE = 2
};
bool ACL_Entity_Type_IsValid(int value);
const ACL_Entity_Type ACL_Entity_Type_Type_MIN = ACL_Entity_Type_SOME;
const ACL_Entity_Type ACL_Entity_Type_Type_MAX = ACL_Entity_Type_NONE;
const int ACL_Entity_Type_Type_ARRAYSIZE = ACL_Entity_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* ACL_Entity_Type_descriptor();
inline const ::std::string& ACL_Entity_Type_Name(ACL_Entity_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    ACL_Entity_Type_descriptor(), value);
}
inline bool ACL_Entity_Type_Parse(
    const ::std::string& name, ACL_Entity_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ACL_Entity_Type>(
    ACL_Entity_Type_descriptor(), name, value);
}
// ===================================================================

class ACL_Entity : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.ACL.Entity) */ {
 public:
  ACL_Entity();
  virtual ~ACL_Entity();

  ACL_Entity(const ACL_Entity& from);

  inline ACL_Entity& operator=(const ACL_Entity& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ACL_Entity(ACL_Entity&& from) noexcept
    : ACL_Entity() {
    *this = ::std::move(from);
  }

  inline ACL_Entity& operator=(ACL_Entity&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACL_Entity& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ACL_Entity* internal_default_instance() {
    return reinterpret_cast<const ACL_Entity*>(
               &_ACL_Entity_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(ACL_Entity* other);
  friend void swap(ACL_Entity& a, ACL_Entity& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ACL_Entity* New() const PROTOBUF_FINAL { return New(NULL); }

  ACL_Entity* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ACL_Entity& from);
  void MergeFrom(const ACL_Entity& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ACL_Entity* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef ACL_Entity_Type Type;
  static const Type SOME =
    ACL_Entity_Type_SOME;
  static const Type ANY =
    ACL_Entity_Type_ANY;
  static const Type NONE =
    ACL_Entity_Type_NONE;
  static inline bool Type_IsValid(int value) {
    return ACL_Entity_Type_IsValid(value);
  }
  static const Type Type_MIN =
    ACL_Entity_Type_Type_MIN;
  static const Type Type_MAX =
    ACL_Entity_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    ACL_Entity_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return ACL_Entity_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return ACL_Entity_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return ACL_Entity_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated string values = 2;
  int values_size() const;
  void clear_values();
  static const int kValuesFieldNumber = 2;
  const ::std::string& values(int index) const;
  ::std::string* mutable_values(int index);
  void set_values(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_values(int index, ::std::string&& value);
  #endif
  void set_values(int index, const char* value);
  void set_values(int index, const char* value, size_t size);
  ::std::string* add_values();
  void add_values(const ::std::string& value);
  #if LANG_CXX11
  void add_values(::std::string&& value);
  #endif
  void add_values(const char* value);
  void add_values(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& values() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_values();

  // optional .mesos.ACL.Entity.Type type = 1 [default = SOME];
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::mesos::ACL_Entity_Type type() const;
  void set_type(::mesos::ACL_Entity_Type value);

  // @@protoc_insertion_point(class_scope:mesos.ACL.Entity)
 private:
  void set_has_type();
  void clear_has_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> values_;
  int type_;
  friend struct ::protobuf_mesos_2fauthorizer_2facls_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fauthorizer_2facls_2eproto::InitDefaultsACL_EntityImpl();
};
// -------------------------------------------------------------------

class ACL_RegisterFramework : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.ACL.RegisterFramework) */ {
 public:
  ACL_RegisterFramework();
  virtual ~ACL_RegisterFramework();

  ACL_RegisterFramework(const ACL_RegisterFramework& from);

  inline ACL_RegisterFramework& operator=(const ACL_RegisterFramework& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ACL_RegisterFramework(ACL_RegisterFramework&& from) noexcept
    : ACL_RegisterFramework() {
    *this = ::std::move(from);
  }

  inline ACL_RegisterFramework& operator=(ACL_RegisterFramework&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACL_RegisterFramework& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ACL_RegisterFramework* internal_default_instance() {
    return reinterpret_cast<const ACL_RegisterFramework*>(
               &_ACL_RegisterFramework_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(ACL_RegisterFramework* other);
  friend void swap(ACL_RegisterFramework& a, ACL_RegisterFramework& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ACL_RegisterFramework* New() const PROTOBUF_FINAL { return New(NULL); }

  ACL_RegisterFramework* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ACL_RegisterFramework& from);
  void MergeFrom(const ACL_RegisterFramework& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ACL_RegisterFramework* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.ACL.Entity principals = 1;
  bool has_principals() const;
  void clear_principals();
  static const int kPrincipalsFieldNumber = 1;
  const ::mesos::ACL_Entity& principals() const;
  ::mesos::ACL_Entity* release_principals();
  ::mesos::ACL_Entity* mutable_principals();
  void set_allocated_principals(::mesos::ACL_Entity* principals);

  // required .mesos.ACL.Entity roles = 2;
  bool has_roles() const;
  void clear_roles();
  static const int kRolesFieldNumber = 2;
  const ::mesos::ACL_Entity& roles() const;
  ::mesos::ACL_Entity* release_roles();
  ::mesos::ACL_Entity* mutable_roles();
  void set_allocated_roles(::mesos::ACL_Entity* roles);

  // @@protoc_insertion_point(class_scope:mesos.ACL.RegisterFramework)
 private:
  void set_has_principals();
  void clear_has_principals();
  void set_has_roles();
  void clear_has_roles();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::ACL_Entity* principals_;
  ::mesos::ACL_Entity* roles_;
  friend struct ::protobuf_mesos_2fauthorizer_2facls_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fauthorizer_2facls_2eproto::InitDefaultsACL_RegisterFrameworkImpl();
};
// -------------------------------------------------------------------

class ACL_RunTask : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.ACL.RunTask) */ {
 public:
  ACL_RunTask();
  virtual ~ACL_RunTask();

  ACL_RunTask(const ACL_RunTask& from);

  inline ACL_RunTask& operator=(const ACL_RunTask& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ACL_RunTask(ACL_RunTask&& from) noexcept
    : ACL_RunTask() {
    *this = ::std::move(from);
  }

  inline ACL_RunTask& operator=(ACL_RunTask&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACL_RunTask& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ACL_RunTask* internal_default_instance() {
    return reinterpret_cast<const ACL_RunTask*>(
               &_ACL_RunTask_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(ACL_RunTask* other);
  friend void swap(ACL_RunTask& a, ACL_RunTask& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ACL_RunTask* New() const PROTOBUF_FINAL { return New(NULL); }

  ACL_RunTask* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ACL_RunTask& from);
  void MergeFrom(const ACL_RunTask& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ACL_RunTask* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.ACL.Entity principals = 1;
  bool has_principals() const;
  void clear_principals();
  static const int kPrincipalsFieldNumber = 1;
  const ::mesos::ACL_Entity& principals() const;
  ::mesos::ACL_Entity* release_principals();
  ::mesos::ACL_Entity* mutable_principals();
  void set_allocated_principals(::mesos::ACL_Entity* principals);

  // required .mesos.ACL.Entity users = 2;
  bool has_users() const;
  void clear_users();
  static const int kUsersFieldNumber = 2;
  const ::mesos::ACL_Entity& users() const;
  ::mesos::ACL_Entity* release_users();
  ::mesos::ACL_Entity* mutable_users();
  void set_allocated_users(::mesos::ACL_Entity* users);

  // @@protoc_insertion_point(class_scope:mesos.ACL.RunTask)
 private:
  void set_has_principals();
  void clear_has_principals();
  void set_has_users();
  void clear_has_users();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::ACL_Entity* principals_;
  ::mesos::ACL_Entity* users_;
  friend struct ::protobuf_mesos_2fauthorizer_2facls_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fauthorizer_2facls_2eproto::InitDefaultsACL_RunTaskImpl();
};
// -------------------------------------------------------------------

class ACL_TeardownFramework : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.ACL.TeardownFramework) */ {
 public:
  ACL_TeardownFramework();
  virtual ~ACL_TeardownFramework();

  ACL_TeardownFramework(const ACL_TeardownFramework& from);

  inline ACL_TeardownFramework& operator=(const ACL_TeardownFramework& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ACL_TeardownFramework(ACL_TeardownFramework&& from) noexcept
    : ACL_TeardownFramework() {
    *this = ::std::move(from);
  }

  inline ACL_TeardownFramework& operator=(ACL_TeardownFramework&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACL_TeardownFramework& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ACL_TeardownFramework* internal_default_instance() {
    return reinterpret_cast<const ACL_TeardownFramework*>(
               &_ACL_TeardownFramework_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(ACL_TeardownFramework* other);
  friend void swap(ACL_TeardownFramework& a, ACL_TeardownFramework& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ACL_TeardownFramework* New() const PROTOBUF_FINAL { return New(NULL); }

  ACL_TeardownFramework* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ACL_TeardownFramework& from);
  void MergeFrom(const ACL_TeardownFramework& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ACL_TeardownFramework* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.ACL.Entity principals = 1;
  bool has_principals() const;
  void clear_principals();
  static const int kPrincipalsFieldNumber = 1;
  const ::mesos::ACL_Entity& principals() const;
  ::mesos::ACL_Entity* release_principals();
  ::mesos::ACL_Entity* mutable_principals();
  void set_allocated_principals(::mesos::ACL_Entity* principals);

  // required .mesos.ACL.Entity framework_principals = 2;
  bool has_framework_principals() const;
  void clear_framework_principals();
  static const int kFrameworkPrincipalsFieldNumber = 2;
  const ::mesos::ACL_Entity& framework_principals() const;
  ::mesos::ACL_Entity* release_framework_principals();
  ::mesos::ACL_Entity* mutable_framework_principals();
  void set_allocated_framework_principals(::mesos::ACL_Entity* framework_principals);

  // @@protoc_insertion_point(class_scope:mesos.ACL.TeardownFramework)
 private:
  void set_has_principals();
  void clear_has_principals();
  void set_has_framework_principals();
  void clear_has_framework_principals();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::ACL_Entity* principals_;
  ::mesos::ACL_Entity* framework_principals_;
  friend struct ::protobuf_mesos_2fauthorizer_2facls_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fauthorizer_2facls_2eproto::InitDefaultsACL_TeardownFrameworkImpl();
};
// -------------------------------------------------------------------

class ACL_ReserveResources : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.ACL.ReserveResources) */ {
 public:
  ACL_ReserveResources();
  virtual ~ACL_ReserveResources();

  ACL_ReserveResources(const ACL_ReserveResources& from);

  inline ACL_ReserveResources& operator=(const ACL_ReserveResources& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ACL_ReserveResources(ACL_ReserveResources&& from) noexcept
    : ACL_ReserveResources() {
    *this = ::std::move(from);
  }

  inline ACL_ReserveResources& operator=(ACL_ReserveResources&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACL_ReserveResources& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ACL_ReserveResources* internal_default_instance() {
    return reinterpret_cast<const ACL_ReserveResources*>(
               &_ACL_ReserveResources_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(ACL_ReserveResources* other);
  friend void swap(ACL_ReserveResources& a, ACL_ReserveResources& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ACL_ReserveResources* New() const PROTOBUF_FINAL { return New(NULL); }

  ACL_ReserveResources* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ACL_ReserveResources& from);
  void MergeFrom(const ACL_ReserveResources& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ACL_ReserveResources* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.ACL.Entity principals = 1;
  bool has_principals() const;
  void clear_principals();
  static const int kPrincipalsFieldNumber = 1;
  const ::mesos::ACL_Entity& principals() const;
  ::mesos::ACL_Entity* release_principals();
  ::mesos::ACL_Entity* mutable_principals();
  void set_allocated_principals(::mesos::ACL_Entity* principals);

  // required .mesos.ACL.Entity roles = 2;
  bool has_roles() const;
  void clear_roles();
  static const int kRolesFieldNumber = 2;
  const ::mesos::ACL_Entity& roles() const;
  ::mesos::ACL_Entity* release_roles();
  ::mesos::ACL_Entity* mutable_roles();
  void set_allocated_roles(::mesos::ACL_Entity* roles);

  // @@protoc_insertion_point(class_scope:mesos.ACL.ReserveResources)
 private:
  void set_has_principals();
  void clear_has_principals();
  void set_has_roles();
  void clear_has_roles();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::ACL_Entity* principals_;
  ::mesos::ACL_Entity* roles_;
  friend struct ::protobuf_mesos_2fauthorizer_2facls_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fauthorizer_2facls_2eproto::InitDefaultsACL_ReserveResourcesImpl();
};
// -------------------------------------------------------------------

class ACL_UnreserveResources : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.ACL.UnreserveResources) */ {
 public:
  ACL_UnreserveResources();
  virtual ~ACL_UnreserveResources();

  ACL_UnreserveResources(const ACL_UnreserveResources& from);

  inline ACL_UnreserveResources& operator=(const ACL_UnreserveResources& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ACL_UnreserveResources(ACL_UnreserveResources&& from) noexcept
    : ACL_UnreserveResources() {
    *this = ::std::move(from);
  }

  inline ACL_UnreserveResources& operator=(ACL_UnreserveResources&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACL_UnreserveResources& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ACL_UnreserveResources* internal_default_instance() {
    return reinterpret_cast<const ACL_UnreserveResources*>(
               &_ACL_UnreserveResources_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(ACL_UnreserveResources* other);
  friend void swap(ACL_UnreserveResources& a, ACL_UnreserveResources& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ACL_UnreserveResources* New() const PROTOBUF_FINAL { return New(NULL); }

  ACL_UnreserveResources* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ACL_UnreserveResources& from);
  void MergeFrom(const ACL_UnreserveResources& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ACL_UnreserveResources* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.ACL.Entity principals = 1;
  bool has_principals() const;
  void clear_principals();
  static const int kPrincipalsFieldNumber = 1;
  const ::mesos::ACL_Entity& principals() const;
  ::mesos::ACL_Entity* release_principals();
  ::mesos::ACL_Entity* mutable_principals();
  void set_allocated_principals(::mesos::ACL_Entity* principals);

  // required .mesos.ACL.Entity reserver_principals = 2;
  bool has_reserver_principals() const;
  void clear_reserver_principals();
  static const int kReserverPrincipalsFieldNumber = 2;
  const ::mesos::ACL_Entity& reserver_principals() const;
  ::mesos::ACL_Entity* release_reserver_principals();
  ::mesos::ACL_Entity* mutable_reserver_principals();
  void set_allocated_reserver_principals(::mesos::ACL_Entity* reserver_principals);

  // @@protoc_insertion_point(class_scope:mesos.ACL.UnreserveResources)
 private:
  void set_has_principals();
  void clear_has_principals();
  void set_has_reserver_principals();
  void clear_has_reserver_principals();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::ACL_Entity* principals_;
  ::mesos::ACL_Entity* reserver_principals_;
  friend struct ::protobuf_mesos_2fauthorizer_2facls_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fauthorizer_2facls_2eproto::InitDefaultsACL_UnreserveResourcesImpl();
};
// -------------------------------------------------------------------

class ACL_CreateVolume : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.ACL.CreateVolume) */ {
 public:
  ACL_CreateVolume();
  virtual ~ACL_CreateVolume();

  ACL_CreateVolume(const ACL_CreateVolume& from);

  inline ACL_CreateVolume& operator=(const ACL_CreateVolume& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ACL_CreateVolume(ACL_CreateVolume&& from) noexcept
    : ACL_CreateVolume() {
    *this = ::std::move(from);
  }

  inline ACL_CreateVolume& operator=(ACL_CreateVolume&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACL_CreateVolume& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ACL_CreateVolume* internal_default_instance() {
    return reinterpret_cast<const ACL_CreateVolume*>(
               &_ACL_CreateVolume_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(ACL_CreateVolume* other);
  friend void swap(ACL_CreateVolume& a, ACL_CreateVolume& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ACL_CreateVolume* New() const PROTOBUF_FINAL { return New(NULL); }

  ACL_CreateVolume* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ACL_CreateVolume& from);
  void MergeFrom(const ACL_CreateVolume& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ACL_CreateVolume* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.ACL.Entity principals = 1;
  bool has_principals() const;
  void clear_principals();
  static const int kPrincipalsFieldNumber = 1;
  const ::mesos::ACL_Entity& principals() const;
  ::mesos::ACL_Entity* release_principals();
  ::mesos::ACL_Entity* mutable_principals();
  void set_allocated_principals(::mesos::ACL_Entity* principals);

  // required .mesos.ACL.Entity roles = 2;
  bool has_roles() const;
  void clear_roles();
  static const int kRolesFieldNumber = 2;
  const ::mesos::ACL_Entity& roles() const;
  ::mesos::ACL_Entity* release_roles();
  ::mesos::ACL_Entity* mutable_roles();
  void set_allocated_roles(::mesos::ACL_Entity* roles);

  // @@protoc_insertion_point(class_scope:mesos.ACL.CreateVolume)
 private:
  void set_has_principals();
  void clear_has_principals();
  void set_has_roles();
  void clear_has_roles();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::ACL_Entity* principals_;
  ::mesos::ACL_Entity* roles_;
  friend struct ::protobuf_mesos_2fauthorizer_2facls_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fauthorizer_2facls_2eproto::InitDefaultsACL_CreateVolumeImpl();
};
// -------------------------------------------------------------------

class ACL_DestroyVolume : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.ACL.DestroyVolume) */ {
 public:
  ACL_DestroyVolume();
  virtual ~ACL_DestroyVolume();

  ACL_DestroyVolume(const ACL_DestroyVolume& from);

  inline ACL_DestroyVolume& operator=(const ACL_DestroyVolume& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ACL_DestroyVolume(ACL_DestroyVolume&& from) noexcept
    : ACL_DestroyVolume() {
    *this = ::std::move(from);
  }

  inline ACL_DestroyVolume& operator=(ACL_DestroyVolume&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACL_DestroyVolume& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ACL_DestroyVolume* internal_default_instance() {
    return reinterpret_cast<const ACL_DestroyVolume*>(
               &_ACL_DestroyVolume_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(ACL_DestroyVolume* other);
  friend void swap(ACL_DestroyVolume& a, ACL_DestroyVolume& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ACL_DestroyVolume* New() const PROTOBUF_FINAL { return New(NULL); }

  ACL_DestroyVolume* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ACL_DestroyVolume& from);
  void MergeFrom(const ACL_DestroyVolume& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ACL_DestroyVolume* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.ACL.Entity principals = 1;
  bool has_principals() const;
  void clear_principals();
  static const int kPrincipalsFieldNumber = 1;
  const ::mesos::ACL_Entity& principals() const;
  ::mesos::ACL_Entity* release_principals();
  ::mesos::ACL_Entity* mutable_principals();
  void set_allocated_principals(::mesos::ACL_Entity* principals);

  // required .mesos.ACL.Entity creator_principals = 2;
  bool has_creator_principals() const;
  void clear_creator_principals();
  static const int kCreatorPrincipalsFieldNumber = 2;
  const ::mesos::ACL_Entity& creator_principals() const;
  ::mesos::ACL_Entity* release_creator_principals();
  ::mesos::ACL_Entity* mutable_creator_principals();
  void set_allocated_creator_principals(::mesos::ACL_Entity* creator_principals);

  // @@protoc_insertion_point(class_scope:mesos.ACL.DestroyVolume)
 private:
  void set_has_principals();
  void clear_has_principals();
  void set_has_creator_principals();
  void clear_has_creator_principals();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::ACL_Entity* principals_;
  ::mesos::ACL_Entity* creator_principals_;
  friend struct ::protobuf_mesos_2fauthorizer_2facls_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fauthorizer_2facls_2eproto::InitDefaultsACL_DestroyVolumeImpl();
};
// -------------------------------------------------------------------

class ACL_ResizeVolume : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.ACL.ResizeVolume) */ {
 public:
  ACL_ResizeVolume();
  virtual ~ACL_ResizeVolume();

  ACL_ResizeVolume(const ACL_ResizeVolume& from);

  inline ACL_ResizeVolume& operator=(const ACL_ResizeVolume& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ACL_ResizeVolume(ACL_ResizeVolume&& from) noexcept
    : ACL_ResizeVolume() {
    *this = ::std::move(from);
  }

  inline ACL_ResizeVolume& operator=(ACL_ResizeVolume&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACL_ResizeVolume& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ACL_ResizeVolume* internal_default_instance() {
    return reinterpret_cast<const ACL_ResizeVolume*>(
               &_ACL_ResizeVolume_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(ACL_ResizeVolume* other);
  friend void swap(ACL_ResizeVolume& a, ACL_ResizeVolume& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ACL_ResizeVolume* New() const PROTOBUF_FINAL { return New(NULL); }

  ACL_ResizeVolume* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ACL_ResizeVolume& from);
  void MergeFrom(const ACL_ResizeVolume& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ACL_ResizeVolume* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.ACL.Entity principals = 1;
  bool has_principals() const;
  void clear_principals();
  static const int kPrincipalsFieldNumber = 1;
  const ::mesos::ACL_Entity& principals() const;
  ::mesos::ACL_Entity* release_principals();
  ::mesos::ACL_Entity* mutable_principals();
  void set_allocated_principals(::mesos::ACL_Entity* principals);

  // required .mesos.ACL.Entity roles = 2;
  bool has_roles() const;
  void clear_roles();
  static const int kRolesFieldNumber = 2;
  const ::mesos::ACL_Entity& roles() const;
  ::mesos::ACL_Entity* release_roles();
  ::mesos::ACL_Entity* mutable_roles();
  void set_allocated_roles(::mesos::ACL_Entity* roles);

  // @@protoc_insertion_point(class_scope:mesos.ACL.ResizeVolume)
 private:
  void set_has_principals();
  void clear_has_principals();
  void set_has_roles();
  void clear_has_roles();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::ACL_Entity* principals_;
  ::mesos::ACL_Entity* roles_;
  friend struct ::protobuf_mesos_2fauthorizer_2facls_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fauthorizer_2facls_2eproto::InitDefaultsACL_ResizeVolumeImpl();
};
// -------------------------------------------------------------------

class ACL_GetQuota : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.ACL.GetQuota) */ {
 public:
  ACL_GetQuota();
  virtual ~ACL_GetQuota();

  ACL_GetQuota(const ACL_GetQuota& from);

  inline ACL_GetQuota& operator=(const ACL_GetQuota& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ACL_GetQuota(ACL_GetQuota&& from) noexcept
    : ACL_GetQuota() {
    *this = ::std::move(from);
  }

  inline ACL_GetQuota& operator=(ACL_GetQuota&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACL_GetQuota& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ACL_GetQuota* internal_default_instance() {
    return reinterpret_cast<const ACL_GetQuota*>(
               &_ACL_GetQuota_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(ACL_GetQuota* other);
  friend void swap(ACL_GetQuota& a, ACL_GetQuota& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ACL_GetQuota* New() const PROTOBUF_FINAL { return New(NULL); }

  ACL_GetQuota* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ACL_GetQuota& from);
  void MergeFrom(const ACL_GetQuota& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ACL_GetQuota* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.ACL.Entity principals = 1;
  bool has_principals() const;
  void clear_principals();
  static const int kPrincipalsFieldNumber = 1;
  const ::mesos::ACL_Entity& principals() const;
  ::mesos::ACL_Entity* release_principals();
  ::mesos::ACL_Entity* mutable_principals();
  void set_allocated_principals(::mesos::ACL_Entity* principals);

  // required .mesos.ACL.Entity roles = 2;
  bool has_roles() const;
  void clear_roles();
  static const int kRolesFieldNumber = 2;
  const ::mesos::ACL_Entity& roles() const;
  ::mesos::ACL_Entity* release_roles();
  ::mesos::ACL_Entity* mutable_roles();
  void set_allocated_roles(::mesos::ACL_Entity* roles);

  // @@protoc_insertion_point(class_scope:mesos.ACL.GetQuota)
 private:
  void set_has_principals();
  void clear_has_principals();
  void set_has_roles();
  void clear_has_roles();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::ACL_Entity* principals_;
  ::mesos::ACL_Entity* roles_;
  friend struct ::protobuf_mesos_2fauthorizer_2facls_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fauthorizer_2facls_2eproto::InitDefaultsACL_GetQuotaImpl();
};
// -------------------------------------------------------------------

class ACL_UpdateQuota : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.ACL.UpdateQuota) */ {
 public:
  ACL_UpdateQuota();
  virtual ~ACL_UpdateQuota();

  ACL_UpdateQuota(const ACL_UpdateQuota& from);

  inline ACL_UpdateQuota& operator=(const ACL_UpdateQuota& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ACL_UpdateQuota(ACL_UpdateQuota&& from) noexcept
    : ACL_UpdateQuota() {
    *this = ::std::move(from);
  }

  inline ACL_UpdateQuota& operator=(ACL_UpdateQuota&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACL_UpdateQuota& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ACL_UpdateQuota* internal_default_instance() {
    return reinterpret_cast<const ACL_UpdateQuota*>(
               &_ACL_UpdateQuota_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(ACL_UpdateQuota* other);
  friend void swap(ACL_UpdateQuota& a, ACL_UpdateQuota& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ACL_UpdateQuota* New() const PROTOBUF_FINAL { return New(NULL); }

  ACL_UpdateQuota* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ACL_UpdateQuota& from);
  void MergeFrom(const ACL_UpdateQuota& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ACL_UpdateQuota* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.ACL.Entity principals = 1;
  bool has_principals() const;
  void clear_principals();
  static const int kPrincipalsFieldNumber = 1;
  const ::mesos::ACL_Entity& principals() const;
  ::mesos::ACL_Entity* release_principals();
  ::mesos::ACL_Entity* mutable_principals();
  void set_allocated_principals(::mesos::ACL_Entity* principals);

  // required .mesos.ACL.Entity roles = 2;
  bool has_roles() const;
  void clear_roles();
  static const int kRolesFieldNumber = 2;
  const ::mesos::ACL_Entity& roles() const;
  ::mesos::ACL_Entity* release_roles();
  ::mesos::ACL_Entity* mutable_roles();
  void set_allocated_roles(::mesos::ACL_Entity* roles);

  // @@protoc_insertion_point(class_scope:mesos.ACL.UpdateQuota)
 private:
  void set_has_principals();
  void clear_has_principals();
  void set_has_roles();
  void clear_has_roles();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::ACL_Entity* principals_;
  ::mesos::ACL_Entity* roles_;
  friend struct ::protobuf_mesos_2fauthorizer_2facls_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fauthorizer_2facls_2eproto::InitDefaultsACL_UpdateQuotaImpl();
};
// -------------------------------------------------------------------

class ACL_ViewRole : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.ACL.ViewRole) */ {
 public:
  ACL_ViewRole();
  virtual ~ACL_ViewRole();

  ACL_ViewRole(const ACL_ViewRole& from);

  inline ACL_ViewRole& operator=(const ACL_ViewRole& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ACL_ViewRole(ACL_ViewRole&& from) noexcept
    : ACL_ViewRole() {
    *this = ::std::move(from);
  }

  inline ACL_ViewRole& operator=(ACL_ViewRole&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACL_ViewRole& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ACL_ViewRole* internal_default_instance() {
    return reinterpret_cast<const ACL_ViewRole*>(
               &_ACL_ViewRole_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(ACL_ViewRole* other);
  friend void swap(ACL_ViewRole& a, ACL_ViewRole& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ACL_ViewRole* New() const PROTOBUF_FINAL { return New(NULL); }

  ACL_ViewRole* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ACL_ViewRole& from);
  void MergeFrom(const ACL_ViewRole& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ACL_ViewRole* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.ACL.Entity principals = 1;
  bool has_principals() const;
  void clear_principals();
  static const int kPrincipalsFieldNumber = 1;
  const ::mesos::ACL_Entity& principals() const;
  ::mesos::ACL_Entity* release_principals();
  ::mesos::ACL_Entity* mutable_principals();
  void set_allocated_principals(::mesos::ACL_Entity* principals);

  // required .mesos.ACL.Entity roles = 2;
  bool has_roles() const;
  void clear_roles();
  static const int kRolesFieldNumber = 2;
  const ::mesos::ACL_Entity& roles() const;
  ::mesos::ACL_Entity* release_roles();
  ::mesos::ACL_Entity* mutable_roles();
  void set_allocated_roles(::mesos::ACL_Entity* roles);

  // @@protoc_insertion_point(class_scope:mesos.ACL.ViewRole)
 private:
  void set_has_principals();
  void clear_has_principals();
  void set_has_roles();
  void clear_has_roles();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::ACL_Entity* principals_;
  ::mesos::ACL_Entity* roles_;
  friend struct ::protobuf_mesos_2fauthorizer_2facls_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fauthorizer_2facls_2eproto::InitDefaultsACL_ViewRoleImpl();
};
// -------------------------------------------------------------------

class ACL_UpdateWeight : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.ACL.UpdateWeight) */ {
 public:
  ACL_UpdateWeight();
  virtual ~ACL_UpdateWeight();

  ACL_UpdateWeight(const ACL_UpdateWeight& from);

  inline ACL_UpdateWeight& operator=(const ACL_UpdateWeight& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ACL_UpdateWeight(ACL_UpdateWeight&& from) noexcept
    : ACL_UpdateWeight() {
    *this = ::std::move(from);
  }

  inline ACL_UpdateWeight& operator=(ACL_UpdateWeight&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACL_UpdateWeight& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ACL_UpdateWeight* internal_default_instance() {
    return reinterpret_cast<const ACL_UpdateWeight*>(
               &_ACL_UpdateWeight_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(ACL_UpdateWeight* other);
  friend void swap(ACL_UpdateWeight& a, ACL_UpdateWeight& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ACL_UpdateWeight* New() const PROTOBUF_FINAL { return New(NULL); }

  ACL_UpdateWeight* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ACL_UpdateWeight& from);
  void MergeFrom(const ACL_UpdateWeight& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ACL_UpdateWeight* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.ACL.Entity principals = 1;
  bool has_principals() const;
  void clear_principals();
  static const int kPrincipalsFieldNumber = 1;
  const ::mesos::ACL_Entity& principals() const;
  ::mesos::ACL_Entity* release_principals();
  ::mesos::ACL_Entity* mutable_principals();
  void set_allocated_principals(::mesos::ACL_Entity* principals);

  // required .mesos.ACL.Entity roles = 2;
  bool has_roles() const;
  void clear_roles();
  static const int kRolesFieldNumber = 2;
  const ::mesos::ACL_Entity& roles() const;
  ::mesos::ACL_Entity* release_roles();
  ::mesos::ACL_Entity* mutable_roles();
  void set_allocated_roles(::mesos::ACL_Entity* roles);

  // @@protoc_insertion_point(class_scope:mesos.ACL.UpdateWeight)
 private:
  void set_has_principals();
  void clear_has_principals();
  void set_has_roles();
  void clear_has_roles();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::ACL_Entity* principals_;
  ::mesos::ACL_Entity* roles_;
  friend struct ::protobuf_mesos_2fauthorizer_2facls_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fauthorizer_2facls_2eproto::InitDefaultsACL_UpdateWeightImpl();
};
// -------------------------------------------------------------------

class ACL_GetEndpoint : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.ACL.GetEndpoint) */ {
 public:
  ACL_GetEndpoint();
  virtual ~ACL_GetEndpoint();

  ACL_GetEndpoint(const ACL_GetEndpoint& from);

  inline ACL_GetEndpoint& operator=(const ACL_GetEndpoint& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ACL_GetEndpoint(ACL_GetEndpoint&& from) noexcept
    : ACL_GetEndpoint() {
    *this = ::std::move(from);
  }

  inline ACL_GetEndpoint& operator=(ACL_GetEndpoint&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACL_GetEndpoint& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ACL_GetEndpoint* internal_default_instance() {
    return reinterpret_cast<const ACL_GetEndpoint*>(
               &_ACL_GetEndpoint_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(ACL_GetEndpoint* other);
  friend void swap(ACL_GetEndpoint& a, ACL_GetEndpoint& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ACL_GetEndpoint* New() const PROTOBUF_FINAL { return New(NULL); }

  ACL_GetEndpoint* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ACL_GetEndpoint& from);
  void MergeFrom(const ACL_GetEndpoint& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ACL_GetEndpoint* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.ACL.Entity principals = 1;
  bool has_principals() const;
  void clear_principals();
  static const int kPrincipalsFieldNumber = 1;
  const ::mesos::ACL_Entity& principals() const;
  ::mesos::ACL_Entity* release_principals();
  ::mesos::ACL_Entity* mutable_principals();
  void set_allocated_principals(::mesos::ACL_Entity* principals);

  // required .mesos.ACL.Entity paths = 2;
  bool has_paths() const;
  void clear_paths();
  static const int kPathsFieldNumber = 2;
  const ::mesos::ACL_Entity& paths() const;
  ::mesos::ACL_Entity* release_paths();
  ::mesos::ACL_Entity* mutable_paths();
  void set_allocated_paths(::mesos::ACL_Entity* paths);

  // @@protoc_insertion_point(class_scope:mesos.ACL.GetEndpoint)
 private:
  void set_has_principals();
  void clear_has_principals();
  void set_has_paths();
  void clear_has_paths();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::ACL_Entity* principals_;
  ::mesos::ACL_Entity* paths_;
  friend struct ::protobuf_mesos_2fauthorizer_2facls_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fauthorizer_2facls_2eproto::InitDefaultsACL_GetEndpointImpl();
};
// -------------------------------------------------------------------

class ACL_ViewFramework : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.ACL.ViewFramework) */ {
 public:
  ACL_ViewFramework();
  virtual ~ACL_ViewFramework();

  ACL_ViewFramework(const ACL_ViewFramework& from);

  inline ACL_ViewFramework& operator=(const ACL_ViewFramework& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ACL_ViewFramework(ACL_ViewFramework&& from) noexcept
    : ACL_ViewFramework() {
    *this = ::std::move(from);
  }

  inline ACL_ViewFramework& operator=(ACL_ViewFramework&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACL_ViewFramework& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ACL_ViewFramework* internal_default_instance() {
    return reinterpret_cast<const ACL_ViewFramework*>(
               &_ACL_ViewFramework_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    14;

  void Swap(ACL_ViewFramework* other);
  friend void swap(ACL_ViewFramework& a, ACL_ViewFramework& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ACL_ViewFramework* New() const PROTOBUF_FINAL { return New(NULL); }

  ACL_ViewFramework* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ACL_ViewFramework& from);
  void MergeFrom(const ACL_ViewFramework& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ACL_ViewFramework* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.ACL.Entity principals = 1;
  bool has_principals() const;
  void clear_principals();
  static const int kPrincipalsFieldNumber = 1;
  const ::mesos::ACL_Entity& principals() const;
  ::mesos::ACL_Entity* release_principals();
  ::mesos::ACL_Entity* mutable_principals();
  void set_allocated_principals(::mesos::ACL_Entity* principals);

  // required .mesos.ACL.Entity users = 2;
  bool has_users() const;
  void clear_users();
  static const int kUsersFieldNumber = 2;
  const ::mesos::ACL_Entity& users() const;
  ::mesos::ACL_Entity* release_users();
  ::mesos::ACL_Entity* mutable_users();
  void set_allocated_users(::mesos::ACL_Entity* users);

  // @@protoc_insertion_point(class_scope:mesos.ACL.ViewFramework)
 private:
  void set_has_principals();
  void clear_has_principals();
  void set_has_users();
  void clear_has_users();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::ACL_Entity* principals_;
  ::mesos::ACL_Entity* users_;
  friend struct ::protobuf_mesos_2fauthorizer_2facls_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fauthorizer_2facls_2eproto::InitDefaultsACL_ViewFrameworkImpl();
};
// -------------------------------------------------------------------

class ACL_ViewTask : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.ACL.ViewTask) */ {
 public:
  ACL_ViewTask();
  virtual ~ACL_ViewTask();

  ACL_ViewTask(const ACL_ViewTask& from);

  inline ACL_ViewTask& operator=(const ACL_ViewTask& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ACL_ViewTask(ACL_ViewTask&& from) noexcept
    : ACL_ViewTask() {
    *this = ::std::move(from);
  }

  inline ACL_ViewTask& operator=(ACL_ViewTask&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACL_ViewTask& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ACL_ViewTask* internal_default_instance() {
    return reinterpret_cast<const ACL_ViewTask*>(
               &_ACL_ViewTask_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    15;

  void Swap(ACL_ViewTask* other);
  friend void swap(ACL_ViewTask& a, ACL_ViewTask& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ACL_ViewTask* New() const PROTOBUF_FINAL { return New(NULL); }

  ACL_ViewTask* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ACL_ViewTask& from);
  void MergeFrom(const ACL_ViewTask& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ACL_ViewTask* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.ACL.Entity principals = 1;
  bool has_principals() const;
  void clear_principals();
  static const int kPrincipalsFieldNumber = 1;
  const ::mesos::ACL_Entity& principals() const;
  ::mesos::ACL_Entity* release_principals();
  ::mesos::ACL_Entity* mutable_principals();
  void set_allocated_principals(::mesos::ACL_Entity* principals);

  // required .mesos.ACL.Entity users = 2;
  bool has_users() const;
  void clear_users();
  static const int kUsersFieldNumber = 2;
  const ::mesos::ACL_Entity& users() const;
  ::mesos::ACL_Entity* release_users();
  ::mesos::ACL_Entity* mutable_users();
  void set_allocated_users(::mesos::ACL_Entity* users);

  // @@protoc_insertion_point(class_scope:mesos.ACL.ViewTask)
 private:
  void set_has_principals();
  void clear_has_principals();
  void set_has_users();
  void clear_has_users();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::ACL_Entity* principals_;
  ::mesos::ACL_Entity* users_;
  friend struct ::protobuf_mesos_2fauthorizer_2facls_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fauthorizer_2facls_2eproto::InitDefaultsACL_ViewTaskImpl();
};
// -------------------------------------------------------------------

class ACL_ViewExecutor : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.ACL.ViewExecutor) */ {
 public:
  ACL_ViewExecutor();
  virtual ~ACL_ViewExecutor();

  ACL_ViewExecutor(const ACL_ViewExecutor& from);

  inline ACL_ViewExecutor& operator=(const ACL_ViewExecutor& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ACL_ViewExecutor(ACL_ViewExecutor&& from) noexcept
    : ACL_ViewExecutor() {
    *this = ::std::move(from);
  }

  inline ACL_ViewExecutor& operator=(ACL_ViewExecutor&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACL_ViewExecutor& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ACL_ViewExecutor* internal_default_instance() {
    return reinterpret_cast<const ACL_ViewExecutor*>(
               &_ACL_ViewExecutor_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    16;

  void Swap(ACL_ViewExecutor* other);
  friend void swap(ACL_ViewExecutor& a, ACL_ViewExecutor& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ACL_ViewExecutor* New() const PROTOBUF_FINAL { return New(NULL); }

  ACL_ViewExecutor* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ACL_ViewExecutor& from);
  void MergeFrom(const ACL_ViewExecutor& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ACL_ViewExecutor* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.ACL.Entity principals = 1;
  bool has_principals() const;
  void clear_principals();
  static const int kPrincipalsFieldNumber = 1;
  const ::mesos::ACL_Entity& principals() const;
  ::mesos::ACL_Entity* release_principals();
  ::mesos::ACL_Entity* mutable_principals();
  void set_allocated_principals(::mesos::ACL_Entity* principals);

  // required .mesos.ACL.Entity users = 2;
  bool has_users() const;
  void clear_users();
  static const int kUsersFieldNumber = 2;
  const ::mesos::ACL_Entity& users() const;
  ::mesos::ACL_Entity* release_users();
  ::mesos::ACL_Entity* mutable_users();
  void set_allocated_users(::mesos::ACL_Entity* users);

  // @@protoc_insertion_point(class_scope:mesos.ACL.ViewExecutor)
 private:
  void set_has_principals();
  void clear_has_principals();
  void set_has_users();
  void clear_has_users();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::ACL_Entity* principals_;
  ::mesos::ACL_Entity* users_;
  friend struct ::protobuf_mesos_2fauthorizer_2facls_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fauthorizer_2facls_2eproto::InitDefaultsACL_ViewExecutorImpl();
};
// -------------------------------------------------------------------

class ACL_AccessSandbox : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.ACL.AccessSandbox) */ {
 public:
  ACL_AccessSandbox();
  virtual ~ACL_AccessSandbox();

  ACL_AccessSandbox(const ACL_AccessSandbox& from);

  inline ACL_AccessSandbox& operator=(const ACL_AccessSandbox& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ACL_AccessSandbox(ACL_AccessSandbox&& from) noexcept
    : ACL_AccessSandbox() {
    *this = ::std::move(from);
  }

  inline ACL_AccessSandbox& operator=(ACL_AccessSandbox&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACL_AccessSandbox& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ACL_AccessSandbox* internal_default_instance() {
    return reinterpret_cast<const ACL_AccessSandbox*>(
               &_ACL_AccessSandbox_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    17;

  void Swap(ACL_AccessSandbox* other);
  friend void swap(ACL_AccessSandbox& a, ACL_AccessSandbox& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ACL_AccessSandbox* New() const PROTOBUF_FINAL { return New(NULL); }

  ACL_AccessSandbox* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ACL_AccessSandbox& from);
  void MergeFrom(const ACL_AccessSandbox& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ACL_AccessSandbox* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.ACL.Entity principals = 1;
  bool has_principals() const;
  void clear_principals();
  static const int kPrincipalsFieldNumber = 1;
  const ::mesos::ACL_Entity& principals() const;
  ::mesos::ACL_Entity* release_principals();
  ::mesos::ACL_Entity* mutable_principals();
  void set_allocated_principals(::mesos::ACL_Entity* principals);

  // required .mesos.ACL.Entity users = 2;
  bool has_users() const;
  void clear_users();
  static const int kUsersFieldNumber = 2;
  const ::mesos::ACL_Entity& users() const;
  ::mesos::ACL_Entity* release_users();
  ::mesos::ACL_Entity* mutable_users();
  void set_allocated_users(::mesos::ACL_Entity* users);

  // @@protoc_insertion_point(class_scope:mesos.ACL.AccessSandbox)
 private:
  void set_has_principals();
  void clear_has_principals();
  void set_has_users();
  void clear_has_users();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::ACL_Entity* principals_;
  ::mesos::ACL_Entity* users_;
  friend struct ::protobuf_mesos_2fauthorizer_2facls_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fauthorizer_2facls_2eproto::InitDefaultsACL_AccessSandboxImpl();
};
// -------------------------------------------------------------------

class ACL_AccessMesosLog : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.ACL.AccessMesosLog) */ {
 public:
  ACL_AccessMesosLog();
  virtual ~ACL_AccessMesosLog();

  ACL_AccessMesosLog(const ACL_AccessMesosLog& from);

  inline ACL_AccessMesosLog& operator=(const ACL_AccessMesosLog& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ACL_AccessMesosLog(ACL_AccessMesosLog&& from) noexcept
    : ACL_AccessMesosLog() {
    *this = ::std::move(from);
  }

  inline ACL_AccessMesosLog& operator=(ACL_AccessMesosLog&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACL_AccessMesosLog& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ACL_AccessMesosLog* internal_default_instance() {
    return reinterpret_cast<const ACL_AccessMesosLog*>(
               &_ACL_AccessMesosLog_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    18;

  void Swap(ACL_AccessMesosLog* other);
  friend void swap(ACL_AccessMesosLog& a, ACL_AccessMesosLog& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ACL_AccessMesosLog* New() const PROTOBUF_FINAL { return New(NULL); }

  ACL_AccessMesosLog* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ACL_AccessMesosLog& from);
  void MergeFrom(const ACL_AccessMesosLog& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ACL_AccessMesosLog* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.ACL.Entity principals = 1;
  bool has_principals() const;
  void clear_principals();
  static const int kPrincipalsFieldNumber = 1;
  const ::mesos::ACL_Entity& principals() const;
  ::mesos::ACL_Entity* release_principals();
  ::mesos::ACL_Entity* mutable_principals();
  void set_allocated_principals(::mesos::ACL_Entity* principals);

  // required .mesos.ACL.Entity logs = 2;
  bool has_logs() const;
  void clear_logs();
  static const int kLogsFieldNumber = 2;
  const ::mesos::ACL_Entity& logs() const;
  ::mesos::ACL_Entity* release_logs();
  ::mesos::ACL_Entity* mutable_logs();
  void set_allocated_logs(::mesos::ACL_Entity* logs);

  // @@protoc_insertion_point(class_scope:mesos.ACL.AccessMesosLog)
 private:
  void set_has_principals();
  void clear_has_principals();
  void set_has_logs();
  void clear_has_logs();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::ACL_Entity* principals_;
  ::mesos::ACL_Entity* logs_;
  friend struct ::protobuf_mesos_2fauthorizer_2facls_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fauthorizer_2facls_2eproto::InitDefaultsACL_AccessMesosLogImpl();
};
// -------------------------------------------------------------------

class ACL_ViewFlags : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.ACL.ViewFlags) */ {
 public:
  ACL_ViewFlags();
  virtual ~ACL_ViewFlags();

  ACL_ViewFlags(const ACL_ViewFlags& from);

  inline ACL_ViewFlags& operator=(const ACL_ViewFlags& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ACL_ViewFlags(ACL_ViewFlags&& from) noexcept
    : ACL_ViewFlags() {
    *this = ::std::move(from);
  }

  inline ACL_ViewFlags& operator=(ACL_ViewFlags&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACL_ViewFlags& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ACL_ViewFlags* internal_default_instance() {
    return reinterpret_cast<const ACL_ViewFlags*>(
               &_ACL_ViewFlags_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    19;

  void Swap(ACL_ViewFlags* other);
  friend void swap(ACL_ViewFlags& a, ACL_ViewFlags& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ACL_ViewFlags* New() const PROTOBUF_FINAL { return New(NULL); }

  ACL_ViewFlags* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ACL_ViewFlags& from);
  void MergeFrom(const ACL_ViewFlags& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ACL_ViewFlags* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.ACL.Entity principals = 1;
  bool has_principals() const;
  void clear_principals();
  static const int kPrincipalsFieldNumber = 1;
  const ::mesos::ACL_Entity& principals() const;
  ::mesos::ACL_Entity* release_principals();
  ::mesos::ACL_Entity* mutable_principals();
  void set_allocated_principals(::mesos::ACL_Entity* principals);

  // required .mesos.ACL.Entity flags = 2;
  bool has_flags() const;
  void clear_flags();
  static const int kFlagsFieldNumber = 2;
  const ::mesos::ACL_Entity& flags() const;
  ::mesos::ACL_Entity* release_flags();
  ::mesos::ACL_Entity* mutable_flags();
  void set_allocated_flags(::mesos::ACL_Entity* flags);

  // @@protoc_insertion_point(class_scope:mesos.ACL.ViewFlags)
 private:
  void set_has_principals();
  void clear_has_principals();
  void set_has_flags();
  void clear_has_flags();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::ACL_Entity* principals_;
  ::mesos::ACL_Entity* flags_;
  friend struct ::protobuf_mesos_2fauthorizer_2facls_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fauthorizer_2facls_2eproto::InitDefaultsACL_ViewFlagsImpl();
};
// -------------------------------------------------------------------

class ACL_LaunchNestedContainerAsUser : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.ACL.LaunchNestedContainerAsUser) */ {
 public:
  ACL_LaunchNestedContainerAsUser();
  virtual ~ACL_LaunchNestedContainerAsUser();

  ACL_LaunchNestedContainerAsUser(const ACL_LaunchNestedContainerAsUser& from);

  inline ACL_LaunchNestedContainerAsUser& operator=(const ACL_LaunchNestedContainerAsUser& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ACL_LaunchNestedContainerAsUser(ACL_LaunchNestedContainerAsUser&& from) noexcept
    : ACL_LaunchNestedContainerAsUser() {
    *this = ::std::move(from);
  }

  inline ACL_LaunchNestedContainerAsUser& operator=(ACL_LaunchNestedContainerAsUser&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACL_LaunchNestedContainerAsUser& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ACL_LaunchNestedContainerAsUser* internal_default_instance() {
    return reinterpret_cast<const ACL_LaunchNestedContainerAsUser*>(
               &_ACL_LaunchNestedContainerAsUser_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    20;

  void Swap(ACL_LaunchNestedContainerAsUser* other);
  friend void swap(ACL_LaunchNestedContainerAsUser& a, ACL_LaunchNestedContainerAsUser& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ACL_LaunchNestedContainerAsUser* New() const PROTOBUF_FINAL { return New(NULL); }

  ACL_LaunchNestedContainerAsUser* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ACL_LaunchNestedContainerAsUser& from);
  void MergeFrom(const ACL_LaunchNestedContainerAsUser& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ACL_LaunchNestedContainerAsUser* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.ACL.Entity principals = 1;
  bool has_principals() const;
  void clear_principals();
  static const int kPrincipalsFieldNumber = 1;
  const ::mesos::ACL_Entity& principals() const;
  ::mesos::ACL_Entity* release_principals();
  ::mesos::ACL_Entity* mutable_principals();
  void set_allocated_principals(::mesos::ACL_Entity* principals);

  // required .mesos.ACL.Entity users = 2;
  bool has_users() const;
  void clear_users();
  static const int kUsersFieldNumber = 2;
  const ::mesos::ACL_Entity& users() const;
  ::mesos::ACL_Entity* release_users();
  ::mesos::ACL_Entity* mutable_users();
  void set_allocated_users(::mesos::ACL_Entity* users);

  // @@protoc_insertion_point(class_scope:mesos.ACL.LaunchNestedContainerAsUser)
 private:
  void set_has_principals();
  void clear_has_principals();
  void set_has_users();
  void clear_has_users();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::ACL_Entity* principals_;
  ::mesos::ACL_Entity* users_;
  friend struct ::protobuf_mesos_2fauthorizer_2facls_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fauthorizer_2facls_2eproto::InitDefaultsACL_LaunchNestedContainerAsUserImpl();
};
// -------------------------------------------------------------------

class ACL_LaunchNestedContainerUnderParentWithUser : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.ACL.LaunchNestedContainerUnderParentWithUser) */ {
 public:
  ACL_LaunchNestedContainerUnderParentWithUser();
  virtual ~ACL_LaunchNestedContainerUnderParentWithUser();

  ACL_LaunchNestedContainerUnderParentWithUser(const ACL_LaunchNestedContainerUnderParentWithUser& from);

  inline ACL_LaunchNestedContainerUnderParentWithUser& operator=(const ACL_LaunchNestedContainerUnderParentWithUser& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ACL_LaunchNestedContainerUnderParentWithUser(ACL_LaunchNestedContainerUnderParentWithUser&& from) noexcept
    : ACL_LaunchNestedContainerUnderParentWithUser() {
    *this = ::std::move(from);
  }

  inline ACL_LaunchNestedContainerUnderParentWithUser& operator=(ACL_LaunchNestedContainerUnderParentWithUser&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACL_LaunchNestedContainerUnderParentWithUser& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ACL_LaunchNestedContainerUnderParentWithUser* internal_default_instance() {
    return reinterpret_cast<const ACL_LaunchNestedContainerUnderParentWithUser*>(
               &_ACL_LaunchNestedContainerUnderParentWithUser_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    21;

  void Swap(ACL_LaunchNestedContainerUnderParentWithUser* other);
  friend void swap(ACL_LaunchNestedContainerUnderParentWithUser& a, ACL_LaunchNestedContainerUnderParentWithUser& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ACL_LaunchNestedContainerUnderParentWithUser* New() const PROTOBUF_FINAL { return New(NULL); }

  ACL_LaunchNestedContainerUnderParentWithUser* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ACL_LaunchNestedContainerUnderParentWithUser& from);
  void MergeFrom(const ACL_LaunchNestedContainerUnderParentWithUser& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ACL_LaunchNestedContainerUnderParentWithUser* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.ACL.Entity principals = 1;
  bool has_principals() const;
  void clear_principals();
  static const int kPrincipalsFieldNumber = 1;
  const ::mesos::ACL_Entity& principals() const;
  ::mesos::ACL_Entity* release_principals();
  ::mesos::ACL_Entity* mutable_principals();
  void set_allocated_principals(::mesos::ACL_Entity* principals);

  // required .mesos.ACL.Entity users = 2;
  bool has_users() const;
  void clear_users();
  static const int kUsersFieldNumber = 2;
  const ::mesos::ACL_Entity& users() const;
  ::mesos::ACL_Entity* release_users();
  ::mesos::ACL_Entity* mutable_users();
  void set_allocated_users(::mesos::ACL_Entity* users);

  // @@protoc_insertion_point(class_scope:mesos.ACL.LaunchNestedContainerUnderParentWithUser)
 private:
  void set_has_principals();
  void clear_has_principals();
  void set_has_users();
  void clear_has_users();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::ACL_Entity* principals_;
  ::mesos::ACL_Entity* users_;
  friend struct ::protobuf_mesos_2fauthorizer_2facls_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fauthorizer_2facls_2eproto::InitDefaultsACL_LaunchNestedContainerUnderParentWithUserImpl();
};
// -------------------------------------------------------------------

class ACL_LaunchNestedContainerSessionAsUser : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.ACL.LaunchNestedContainerSessionAsUser) */ {
 public:
  ACL_LaunchNestedContainerSessionAsUser();
  virtual ~ACL_LaunchNestedContainerSessionAsUser();

  ACL_LaunchNestedContainerSessionAsUser(const ACL_LaunchNestedContainerSessionAsUser& from);

  inline ACL_LaunchNestedContainerSessionAsUser& operator=(const ACL_LaunchNestedContainerSessionAsUser& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ACL_LaunchNestedContainerSessionAsUser(ACL_LaunchNestedContainerSessionAsUser&& from) noexcept
    : ACL_LaunchNestedContainerSessionAsUser() {
    *this = ::std::move(from);
  }

  inline ACL_LaunchNestedContainerSessionAsUser& operator=(ACL_LaunchNestedContainerSessionAsUser&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACL_LaunchNestedContainerSessionAsUser& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ACL_LaunchNestedContainerSessionAsUser* internal_default_instance() {
    return reinterpret_cast<const ACL_LaunchNestedContainerSessionAsUser*>(
               &_ACL_LaunchNestedContainerSessionAsUser_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    22;

  void Swap(ACL_LaunchNestedContainerSessionAsUser* other);
  friend void swap(ACL_LaunchNestedContainerSessionAsUser& a, ACL_LaunchNestedContainerSessionAsUser& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ACL_LaunchNestedContainerSessionAsUser* New() const PROTOBUF_FINAL { return New(NULL); }

  ACL_LaunchNestedContainerSessionAsUser* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ACL_LaunchNestedContainerSessionAsUser& from);
  void MergeFrom(const ACL_LaunchNestedContainerSessionAsUser& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ACL_LaunchNestedContainerSessionAsUser* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.ACL.Entity principals = 1;
  bool has_principals() const;
  void clear_principals();
  static const int kPrincipalsFieldNumber = 1;
  const ::mesos::ACL_Entity& principals() const;
  ::mesos::ACL_Entity* release_principals();
  ::mesos::ACL_Entity* mutable_principals();
  void set_allocated_principals(::mesos::ACL_Entity* principals);

  // required .mesos.ACL.Entity users = 2;
  bool has_users() const;
  void clear_users();
  static const int kUsersFieldNumber = 2;
  const ::mesos::ACL_Entity& users() const;
  ::mesos::ACL_Entity* release_users();
  ::mesos::ACL_Entity* mutable_users();
  void set_allocated_users(::mesos::ACL_Entity* users);

  // @@protoc_insertion_point(class_scope:mesos.ACL.LaunchNestedContainerSessionAsUser)
 private:
  void set_has_principals();
  void clear_has_principals();
  void set_has_users();
  void clear_has_users();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::ACL_Entity* principals_;
  ::mesos::ACL_Entity* users_;
  friend struct ::protobuf_mesos_2fauthorizer_2facls_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fauthorizer_2facls_2eproto::InitDefaultsACL_LaunchNestedContainerSessionAsUserImpl();
};
// -------------------------------------------------------------------

class ACL_LaunchNestedContainerSessionUnderParentWithUser : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.ACL.LaunchNestedContainerSessionUnderParentWithUser) */ {
 public:
  ACL_LaunchNestedContainerSessionUnderParentWithUser();
  virtual ~ACL_LaunchNestedContainerSessionUnderParentWithUser();

  ACL_LaunchNestedContainerSessionUnderParentWithUser(const ACL_LaunchNestedContainerSessionUnderParentWithUser& from);

  inline ACL_LaunchNestedContainerSessionUnderParentWithUser& operator=(const ACL_LaunchNestedContainerSessionUnderParentWithUser& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ACL_LaunchNestedContainerSessionUnderParentWithUser(ACL_LaunchNestedContainerSessionUnderParentWithUser&& from) noexcept
    : ACL_LaunchNestedContainerSessionUnderParentWithUser() {
    *this = ::std::move(from);
  }

  inline ACL_LaunchNestedContainerSessionUnderParentWithUser& operator=(ACL_LaunchNestedContainerSessionUnderParentWithUser&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACL_LaunchNestedContainerSessionUnderParentWithUser& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ACL_LaunchNestedContainerSessionUnderParentWithUser* internal_default_instance() {
    return reinterpret_cast<const ACL_LaunchNestedContainerSessionUnderParentWithUser*>(
               &_ACL_LaunchNestedContainerSessionUnderParentWithUser_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    23;

  void Swap(ACL_LaunchNestedContainerSessionUnderParentWithUser* other);
  friend void swap(ACL_LaunchNestedContainerSessionUnderParentWithUser& a, ACL_LaunchNestedContainerSessionUnderParentWithUser& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ACL_LaunchNestedContainerSessionUnderParentWithUser* New() const PROTOBUF_FINAL { return New(NULL); }

  ACL_LaunchNestedContainerSessionUnderParentWithUser* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ACL_LaunchNestedContainerSessionUnderParentWithUser& from);
  void MergeFrom(const ACL_LaunchNestedContainerSessionUnderParentWithUser& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ACL_LaunchNestedContainerSessionUnderParentWithUser* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.ACL.Entity principals = 1;
  bool has_principals() const;
  void clear_principals();
  static const int kPrincipalsFieldNumber = 1;
  const ::mesos::ACL_Entity& principals() const;
  ::mesos::ACL_Entity* release_principals();
  ::mesos::ACL_Entity* mutable_principals();
  void set_allocated_principals(::mesos::ACL_Entity* principals);

  // required .mesos.ACL.Entity users = 2;
  bool has_users() const;
  void clear_users();
  static const int kUsersFieldNumber = 2;
  const ::mesos::ACL_Entity& users() const;
  ::mesos::ACL_Entity* release_users();
  ::mesos::ACL_Entity* mutable_users();
  void set_allocated_users(::mesos::ACL_Entity* users);

  // @@protoc_insertion_point(class_scope:mesos.ACL.LaunchNestedContainerSessionUnderParentWithUser)
 private:
  void set_has_principals();
  void clear_has_principals();
  void set_has_users();
  void clear_has_users();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::ACL_Entity* principals_;
  ::mesos::ACL_Entity* users_;
  friend struct ::protobuf_mesos_2fauthorizer_2facls_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fauthorizer_2facls_2eproto::InitDefaultsACL_LaunchNestedContainerSessionUnderParentWithUserImpl();
};
// -------------------------------------------------------------------

class ACL_AttachContainerInput : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.ACL.AttachContainerInput) */ {
 public:
  ACL_AttachContainerInput();
  virtual ~ACL_AttachContainerInput();

  ACL_AttachContainerInput(const ACL_AttachContainerInput& from);

  inline ACL_AttachContainerInput& operator=(const ACL_AttachContainerInput& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ACL_AttachContainerInput(ACL_AttachContainerInput&& from) noexcept
    : ACL_AttachContainerInput() {
    *this = ::std::move(from);
  }

  inline ACL_AttachContainerInput& operator=(ACL_AttachContainerInput&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACL_AttachContainerInput& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ACL_AttachContainerInput* internal_default_instance() {
    return reinterpret_cast<const ACL_AttachContainerInput*>(
               &_ACL_AttachContainerInput_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    24;

  void Swap(ACL_AttachContainerInput* other);
  friend void swap(ACL_AttachContainerInput& a, ACL_AttachContainerInput& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ACL_AttachContainerInput* New() const PROTOBUF_FINAL { return New(NULL); }

  ACL_AttachContainerInput* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ACL_AttachContainerInput& from);
  void MergeFrom(const ACL_AttachContainerInput& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ACL_AttachContainerInput* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.ACL.Entity principals = 1;
  bool has_principals() const;
  void clear_principals();
  static const int kPrincipalsFieldNumber = 1;
  const ::mesos::ACL_Entity& principals() const;
  ::mesos::ACL_Entity* release_principals();
  ::mesos::ACL_Entity* mutable_principals();
  void set_allocated_principals(::mesos::ACL_Entity* principals);

  // required .mesos.ACL.Entity users = 2;
  bool has_users() const;
  void clear_users();
  static const int kUsersFieldNumber = 2;
  const ::mesos::ACL_Entity& users() const;
  ::mesos::ACL_Entity* release_users();
  ::mesos::ACL_Entity* mutable_users();
  void set_allocated_users(::mesos::ACL_Entity* users);

  // @@protoc_insertion_point(class_scope:mesos.ACL.AttachContainerInput)
 private:
  void set_has_principals();
  void clear_has_principals();
  void set_has_users();
  void clear_has_users();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::ACL_Entity* principals_;
  ::mesos::ACL_Entity* users_;
  friend struct ::protobuf_mesos_2fauthorizer_2facls_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fauthorizer_2facls_2eproto::InitDefaultsACL_AttachContainerInputImpl();
};
// -------------------------------------------------------------------

class ACL_AttachContainerOutput : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.ACL.AttachContainerOutput) */ {
 public:
  ACL_AttachContainerOutput();
  virtual ~ACL_AttachContainerOutput();

  ACL_AttachContainerOutput(const ACL_AttachContainerOutput& from);

  inline ACL_AttachContainerOutput& operator=(const ACL_AttachContainerOutput& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ACL_AttachContainerOutput(ACL_AttachContainerOutput&& from) noexcept
    : ACL_AttachContainerOutput() {
    *this = ::std::move(from);
  }

  inline ACL_AttachContainerOutput& operator=(ACL_AttachContainerOutput&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACL_AttachContainerOutput& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ACL_AttachContainerOutput* internal_default_instance() {
    return reinterpret_cast<const ACL_AttachContainerOutput*>(
               &_ACL_AttachContainerOutput_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    25;

  void Swap(ACL_AttachContainerOutput* other);
  friend void swap(ACL_AttachContainerOutput& a, ACL_AttachContainerOutput& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ACL_AttachContainerOutput* New() const PROTOBUF_FINAL { return New(NULL); }

  ACL_AttachContainerOutput* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ACL_AttachContainerOutput& from);
  void MergeFrom(const ACL_AttachContainerOutput& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ACL_AttachContainerOutput* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.ACL.Entity principals = 1;
  bool has_principals() const;
  void clear_principals();
  static const int kPrincipalsFieldNumber = 1;
  const ::mesos::ACL_Entity& principals() const;
  ::mesos::ACL_Entity* release_principals();
  ::mesos::ACL_Entity* mutable_principals();
  void set_allocated_principals(::mesos::ACL_Entity* principals);

  // required .mesos.ACL.Entity users = 2;
  bool has_users() const;
  void clear_users();
  static const int kUsersFieldNumber = 2;
  const ::mesos::ACL_Entity& users() const;
  ::mesos::ACL_Entity* release_users();
  ::mesos::ACL_Entity* mutable_users();
  void set_allocated_users(::mesos::ACL_Entity* users);

  // @@protoc_insertion_point(class_scope:mesos.ACL.AttachContainerOutput)
 private:
  void set_has_principals();
  void clear_has_principals();
  void set_has_users();
  void clear_has_users();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::ACL_Entity* principals_;
  ::mesos::ACL_Entity* users_;
  friend struct ::protobuf_mesos_2fauthorizer_2facls_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fauthorizer_2facls_2eproto::InitDefaultsACL_AttachContainerOutputImpl();
};
// -------------------------------------------------------------------

class ACL_KillNestedContainer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.ACL.KillNestedContainer) */ {
 public:
  ACL_KillNestedContainer();
  virtual ~ACL_KillNestedContainer();

  ACL_KillNestedContainer(const ACL_KillNestedContainer& from);

  inline ACL_KillNestedContainer& operator=(const ACL_KillNestedContainer& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ACL_KillNestedContainer(ACL_KillNestedContainer&& from) noexcept
    : ACL_KillNestedContainer() {
    *this = ::std::move(from);
  }

  inline ACL_KillNestedContainer& operator=(ACL_KillNestedContainer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACL_KillNestedContainer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ACL_KillNestedContainer* internal_default_instance() {
    return reinterpret_cast<const ACL_KillNestedContainer*>(
               &_ACL_KillNestedContainer_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    26;

  void Swap(ACL_KillNestedContainer* other);
  friend void swap(ACL_KillNestedContainer& a, ACL_KillNestedContainer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ACL_KillNestedContainer* New() const PROTOBUF_FINAL { return New(NULL); }

  ACL_KillNestedContainer* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ACL_KillNestedContainer& from);
  void MergeFrom(const ACL_KillNestedContainer& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ACL_KillNestedContainer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.ACL.Entity principals = 1;
  bool has_principals() const;
  void clear_principals();
  static const int kPrincipalsFieldNumber = 1;
  const ::mesos::ACL_Entity& principals() const;
  ::mesos::ACL_Entity* release_principals();
  ::mesos::ACL_Entity* mutable_principals();
  void set_allocated_principals(::mesos::ACL_Entity* principals);

  // required .mesos.ACL.Entity users = 2;
  bool has_users() const;
  void clear_users();
  static const int kUsersFieldNumber = 2;
  const ::mesos::ACL_Entity& users() const;
  ::mesos::ACL_Entity* release_users();
  ::mesos::ACL_Entity* mutable_users();
  void set_allocated_users(::mesos::ACL_Entity* users);

  // @@protoc_insertion_point(class_scope:mesos.ACL.KillNestedContainer)
 private:
  void set_has_principals();
  void clear_has_principals();
  void set_has_users();
  void clear_has_users();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::ACL_Entity* principals_;
  ::mesos::ACL_Entity* users_;
  friend struct ::protobuf_mesos_2fauthorizer_2facls_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fauthorizer_2facls_2eproto::InitDefaultsACL_KillNestedContainerImpl();
};
// -------------------------------------------------------------------

class ACL_WaitNestedContainer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.ACL.WaitNestedContainer) */ {
 public:
  ACL_WaitNestedContainer();
  virtual ~ACL_WaitNestedContainer();

  ACL_WaitNestedContainer(const ACL_WaitNestedContainer& from);

  inline ACL_WaitNestedContainer& operator=(const ACL_WaitNestedContainer& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ACL_WaitNestedContainer(ACL_WaitNestedContainer&& from) noexcept
    : ACL_WaitNestedContainer() {
    *this = ::std::move(from);
  }

  inline ACL_WaitNestedContainer& operator=(ACL_WaitNestedContainer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACL_WaitNestedContainer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ACL_WaitNestedContainer* internal_default_instance() {
    return reinterpret_cast<const ACL_WaitNestedContainer*>(
               &_ACL_WaitNestedContainer_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    27;

  void Swap(ACL_WaitNestedContainer* other);
  friend void swap(ACL_WaitNestedContainer& a, ACL_WaitNestedContainer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ACL_WaitNestedContainer* New() const PROTOBUF_FINAL { return New(NULL); }

  ACL_WaitNestedContainer* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ACL_WaitNestedContainer& from);
  void MergeFrom(const ACL_WaitNestedContainer& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ACL_WaitNestedContainer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.ACL.Entity principals = 1;
  bool has_principals() const;
  void clear_principals();
  static const int kPrincipalsFieldNumber = 1;
  const ::mesos::ACL_Entity& principals() const;
  ::mesos::ACL_Entity* release_principals();
  ::mesos::ACL_Entity* mutable_principals();
  void set_allocated_principals(::mesos::ACL_Entity* principals);

  // required .mesos.ACL.Entity users = 2;
  bool has_users() const;
  void clear_users();
  static const int kUsersFieldNumber = 2;
  const ::mesos::ACL_Entity& users() const;
  ::mesos::ACL_Entity* release_users();
  ::mesos::ACL_Entity* mutable_users();
  void set_allocated_users(::mesos::ACL_Entity* users);

  // @@protoc_insertion_point(class_scope:mesos.ACL.WaitNestedContainer)
 private:
  void set_has_principals();
  void clear_has_principals();
  void set_has_users();
  void clear_has_users();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::ACL_Entity* principals_;
  ::mesos::ACL_Entity* users_;
  friend struct ::protobuf_mesos_2fauthorizer_2facls_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fauthorizer_2facls_2eproto::InitDefaultsACL_WaitNestedContainerImpl();
};
// -------------------------------------------------------------------

class ACL_ViewContainer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.ACL.ViewContainer) */ {
 public:
  ACL_ViewContainer();
  virtual ~ACL_ViewContainer();

  ACL_ViewContainer(const ACL_ViewContainer& from);

  inline ACL_ViewContainer& operator=(const ACL_ViewContainer& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ACL_ViewContainer(ACL_ViewContainer&& from) noexcept
    : ACL_ViewContainer() {
    *this = ::std::move(from);
  }

  inline ACL_ViewContainer& operator=(ACL_ViewContainer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACL_ViewContainer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ACL_ViewContainer* internal_default_instance() {
    return reinterpret_cast<const ACL_ViewContainer*>(
               &_ACL_ViewContainer_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    28;

  void Swap(ACL_ViewContainer* other);
  friend void swap(ACL_ViewContainer& a, ACL_ViewContainer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ACL_ViewContainer* New() const PROTOBUF_FINAL { return New(NULL); }

  ACL_ViewContainer* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ACL_ViewContainer& from);
  void MergeFrom(const ACL_ViewContainer& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ACL_ViewContainer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.ACL.Entity principals = 1;
  bool has_principals() const;
  void clear_principals();
  static const int kPrincipalsFieldNumber = 1;
  const ::mesos::ACL_Entity& principals() const;
  ::mesos::ACL_Entity* release_principals();
  ::mesos::ACL_Entity* mutable_principals();
  void set_allocated_principals(::mesos::ACL_Entity* principals);

  // required .mesos.ACL.Entity users = 2;
  bool has_users() const;
  void clear_users();
  static const int kUsersFieldNumber = 2;
  const ::mesos::ACL_Entity& users() const;
  ::mesos::ACL_Entity* release_users();
  ::mesos::ACL_Entity* mutable_users();
  void set_allocated_users(::mesos::ACL_Entity* users);

  // @@protoc_insertion_point(class_scope:mesos.ACL.ViewContainer)
 private:
  void set_has_principals();
  void clear_has_principals();
  void set_has_users();
  void clear_has_users();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::ACL_Entity* principals_;
  ::mesos::ACL_Entity* users_;
  friend struct ::protobuf_mesos_2fauthorizer_2facls_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fauthorizer_2facls_2eproto::InitDefaultsACL_ViewContainerImpl();
};
// -------------------------------------------------------------------

class ACL_RemoveNestedContainer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.ACL.RemoveNestedContainer) */ {
 public:
  ACL_RemoveNestedContainer();
  virtual ~ACL_RemoveNestedContainer();

  ACL_RemoveNestedContainer(const ACL_RemoveNestedContainer& from);

  inline ACL_RemoveNestedContainer& operator=(const ACL_RemoveNestedContainer& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ACL_RemoveNestedContainer(ACL_RemoveNestedContainer&& from) noexcept
    : ACL_RemoveNestedContainer() {
    *this = ::std::move(from);
  }

  inline ACL_RemoveNestedContainer& operator=(ACL_RemoveNestedContainer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACL_RemoveNestedContainer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ACL_RemoveNestedContainer* internal_default_instance() {
    return reinterpret_cast<const ACL_RemoveNestedContainer*>(
               &_ACL_RemoveNestedContainer_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    29;

  void Swap(ACL_RemoveNestedContainer* other);
  friend void swap(ACL_RemoveNestedContainer& a, ACL_RemoveNestedContainer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ACL_RemoveNestedContainer* New() const PROTOBUF_FINAL { return New(NULL); }

  ACL_RemoveNestedContainer* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ACL_RemoveNestedContainer& from);
  void MergeFrom(const ACL_RemoveNestedContainer& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ACL_RemoveNestedContainer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.ACL.Entity principals = 1;
  bool has_principals() const;
  void clear_principals();
  static const int kPrincipalsFieldNumber = 1;
  const ::mesos::ACL_Entity& principals() const;
  ::mesos::ACL_Entity* release_principals();
  ::mesos::ACL_Entity* mutable_principals();
  void set_allocated_principals(::mesos::ACL_Entity* principals);

  // required .mesos.ACL.Entity users = 2;
  bool has_users() const;
  void clear_users();
  static const int kUsersFieldNumber = 2;
  const ::mesos::ACL_Entity& users() const;
  ::mesos::ACL_Entity* release_users();
  ::mesos::ACL_Entity* mutable_users();
  void set_allocated_users(::mesos::ACL_Entity* users);

  // @@protoc_insertion_point(class_scope:mesos.ACL.RemoveNestedContainer)
 private:
  void set_has_principals();
  void clear_has_principals();
  void set_has_users();
  void clear_has_users();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::ACL_Entity* principals_;
  ::mesos::ACL_Entity* users_;
  friend struct ::protobuf_mesos_2fauthorizer_2facls_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fauthorizer_2facls_2eproto::InitDefaultsACL_RemoveNestedContainerImpl();
};
// -------------------------------------------------------------------

class ACL_SetLogLevel : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.ACL.SetLogLevel) */ {
 public:
  ACL_SetLogLevel();
  virtual ~ACL_SetLogLevel();

  ACL_SetLogLevel(const ACL_SetLogLevel& from);

  inline ACL_SetLogLevel& operator=(const ACL_SetLogLevel& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ACL_SetLogLevel(ACL_SetLogLevel&& from) noexcept
    : ACL_SetLogLevel() {
    *this = ::std::move(from);
  }

  inline ACL_SetLogLevel& operator=(ACL_SetLogLevel&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACL_SetLogLevel& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ACL_SetLogLevel* internal_default_instance() {
    return reinterpret_cast<const ACL_SetLogLevel*>(
               &_ACL_SetLogLevel_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    30;

  void Swap(ACL_SetLogLevel* other);
  friend void swap(ACL_SetLogLevel& a, ACL_SetLogLevel& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ACL_SetLogLevel* New() const PROTOBUF_FINAL { return New(NULL); }

  ACL_SetLogLevel* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ACL_SetLogLevel& from);
  void MergeFrom(const ACL_SetLogLevel& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ACL_SetLogLevel* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.ACL.Entity principals = 1;
  bool has_principals() const;
  void clear_principals();
  static const int kPrincipalsFieldNumber = 1;
  const ::mesos::ACL_Entity& principals() const;
  ::mesos::ACL_Entity* release_principals();
  ::mesos::ACL_Entity* mutable_principals();
  void set_allocated_principals(::mesos::ACL_Entity* principals);

  // required .mesos.ACL.Entity level = 2;
  bool has_level() const;
  void clear_level();
  static const int kLevelFieldNumber = 2;
  const ::mesos::ACL_Entity& level() const;
  ::mesos::ACL_Entity* release_level();
  ::mesos::ACL_Entity* mutable_level();
  void set_allocated_level(::mesos::ACL_Entity* level);

  // @@protoc_insertion_point(class_scope:mesos.ACL.SetLogLevel)
 private:
  void set_has_principals();
  void clear_has_principals();
  void set_has_level();
  void clear_has_level();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::ACL_Entity* principals_;
  ::mesos::ACL_Entity* level_;
  friend struct ::protobuf_mesos_2fauthorizer_2facls_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fauthorizer_2facls_2eproto::InitDefaultsACL_SetLogLevelImpl();
};
// -------------------------------------------------------------------

class ACL_RegisterAgent : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.ACL.RegisterAgent) */ {
 public:
  ACL_RegisterAgent();
  virtual ~ACL_RegisterAgent();

  ACL_RegisterAgent(const ACL_RegisterAgent& from);

  inline ACL_RegisterAgent& operator=(const ACL_RegisterAgent& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ACL_RegisterAgent(ACL_RegisterAgent&& from) noexcept
    : ACL_RegisterAgent() {
    *this = ::std::move(from);
  }

  inline ACL_RegisterAgent& operator=(ACL_RegisterAgent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACL_RegisterAgent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ACL_RegisterAgent* internal_default_instance() {
    return reinterpret_cast<const ACL_RegisterAgent*>(
               &_ACL_RegisterAgent_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    31;

  void Swap(ACL_RegisterAgent* other);
  friend void swap(ACL_RegisterAgent& a, ACL_RegisterAgent& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ACL_RegisterAgent* New() const PROTOBUF_FINAL { return New(NULL); }

  ACL_RegisterAgent* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ACL_RegisterAgent& from);
  void MergeFrom(const ACL_RegisterAgent& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ACL_RegisterAgent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.ACL.Entity principals = 1;
  bool has_principals() const;
  void clear_principals();
  static const int kPrincipalsFieldNumber = 1;
  const ::mesos::ACL_Entity& principals() const;
  ::mesos::ACL_Entity* release_principals();
  ::mesos::ACL_Entity* mutable_principals();
  void set_allocated_principals(::mesos::ACL_Entity* principals);

  // required .mesos.ACL.Entity agents = 2;
  bool has_agents() const;
  void clear_agents();
  static const int kAgentsFieldNumber = 2;
  const ::mesos::ACL_Entity& agents() const;
  ::mesos::ACL_Entity* release_agents();
  ::mesos::ACL_Entity* mutable_agents();
  void set_allocated_agents(::mesos::ACL_Entity* agents);

  // @@protoc_insertion_point(class_scope:mesos.ACL.RegisterAgent)
 private:
  void set_has_principals();
  void clear_has_principals();
  void set_has_agents();
  void clear_has_agents();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::ACL_Entity* principals_;
  ::mesos::ACL_Entity* agents_;
  friend struct ::protobuf_mesos_2fauthorizer_2facls_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fauthorizer_2facls_2eproto::InitDefaultsACL_RegisterAgentImpl();
};
// -------------------------------------------------------------------

class ACL_UpdateMaintenanceSchedule : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.ACL.UpdateMaintenanceSchedule) */ {
 public:
  ACL_UpdateMaintenanceSchedule();
  virtual ~ACL_UpdateMaintenanceSchedule();

  ACL_UpdateMaintenanceSchedule(const ACL_UpdateMaintenanceSchedule& from);

  inline ACL_UpdateMaintenanceSchedule& operator=(const ACL_UpdateMaintenanceSchedule& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ACL_UpdateMaintenanceSchedule(ACL_UpdateMaintenanceSchedule&& from) noexcept
    : ACL_UpdateMaintenanceSchedule() {
    *this = ::std::move(from);
  }

  inline ACL_UpdateMaintenanceSchedule& operator=(ACL_UpdateMaintenanceSchedule&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACL_UpdateMaintenanceSchedule& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ACL_UpdateMaintenanceSchedule* internal_default_instance() {
    return reinterpret_cast<const ACL_UpdateMaintenanceSchedule*>(
               &_ACL_UpdateMaintenanceSchedule_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    32;

  void Swap(ACL_UpdateMaintenanceSchedule* other);
  friend void swap(ACL_UpdateMaintenanceSchedule& a, ACL_UpdateMaintenanceSchedule& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ACL_UpdateMaintenanceSchedule* New() const PROTOBUF_FINAL { return New(NULL); }

  ACL_UpdateMaintenanceSchedule* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ACL_UpdateMaintenanceSchedule& from);
  void MergeFrom(const ACL_UpdateMaintenanceSchedule& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ACL_UpdateMaintenanceSchedule* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.ACL.Entity principals = 1;
  bool has_principals() const;
  void clear_principals();
  static const int kPrincipalsFieldNumber = 1;
  const ::mesos::ACL_Entity& principals() const;
  ::mesos::ACL_Entity* release_principals();
  ::mesos::ACL_Entity* mutable_principals();
  void set_allocated_principals(::mesos::ACL_Entity* principals);

  // required .mesos.ACL.Entity machines = 2;
  bool has_machines() const;
  void clear_machines();
  static const int kMachinesFieldNumber = 2;
  const ::mesos::ACL_Entity& machines() const;
  ::mesos::ACL_Entity* release_machines();
  ::mesos::ACL_Entity* mutable_machines();
  void set_allocated_machines(::mesos::ACL_Entity* machines);

  // @@protoc_insertion_point(class_scope:mesos.ACL.UpdateMaintenanceSchedule)
 private:
  void set_has_principals();
  void clear_has_principals();
  void set_has_machines();
  void clear_has_machines();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::ACL_Entity* principals_;
  ::mesos::ACL_Entity* machines_;
  friend struct ::protobuf_mesos_2fauthorizer_2facls_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fauthorizer_2facls_2eproto::InitDefaultsACL_UpdateMaintenanceScheduleImpl();
};
// -------------------------------------------------------------------

class ACL_GetMaintenanceSchedule : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.ACL.GetMaintenanceSchedule) */ {
 public:
  ACL_GetMaintenanceSchedule();
  virtual ~ACL_GetMaintenanceSchedule();

  ACL_GetMaintenanceSchedule(const ACL_GetMaintenanceSchedule& from);

  inline ACL_GetMaintenanceSchedule& operator=(const ACL_GetMaintenanceSchedule& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ACL_GetMaintenanceSchedule(ACL_GetMaintenanceSchedule&& from) noexcept
    : ACL_GetMaintenanceSchedule() {
    *this = ::std::move(from);
  }

  inline ACL_GetMaintenanceSchedule& operator=(ACL_GetMaintenanceSchedule&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACL_GetMaintenanceSchedule& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ACL_GetMaintenanceSchedule* internal_default_instance() {
    return reinterpret_cast<const ACL_GetMaintenanceSchedule*>(
               &_ACL_GetMaintenanceSchedule_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    33;

  void Swap(ACL_GetMaintenanceSchedule* other);
  friend void swap(ACL_GetMaintenanceSchedule& a, ACL_GetMaintenanceSchedule& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ACL_GetMaintenanceSchedule* New() const PROTOBUF_FINAL { return New(NULL); }

  ACL_GetMaintenanceSchedule* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ACL_GetMaintenanceSchedule& from);
  void MergeFrom(const ACL_GetMaintenanceSchedule& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ACL_GetMaintenanceSchedule* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.ACL.Entity principals = 1;
  bool has_principals() const;
  void clear_principals();
  static const int kPrincipalsFieldNumber = 1;
  const ::mesos::ACL_Entity& principals() const;
  ::mesos::ACL_Entity* release_principals();
  ::mesos::ACL_Entity* mutable_principals();
  void set_allocated_principals(::mesos::ACL_Entity* principals);

  // required .mesos.ACL.Entity machines = 2;
  bool has_machines() const;
  void clear_machines();
  static const int kMachinesFieldNumber = 2;
  const ::mesos::ACL_Entity& machines() const;
  ::mesos::ACL_Entity* release_machines();
  ::mesos::ACL_Entity* mutable_machines();
  void set_allocated_machines(::mesos::ACL_Entity* machines);

  // @@protoc_insertion_point(class_scope:mesos.ACL.GetMaintenanceSchedule)
 private:
  void set_has_principals();
  void clear_has_principals();
  void set_has_machines();
  void clear_has_machines();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::ACL_Entity* principals_;
  ::mesos::ACL_Entity* machines_;
  friend struct ::protobuf_mesos_2fauthorizer_2facls_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fauthorizer_2facls_2eproto::InitDefaultsACL_GetMaintenanceScheduleImpl();
};
// -------------------------------------------------------------------

class ACL_StartMaintenance : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.ACL.StartMaintenance) */ {
 public:
  ACL_StartMaintenance();
  virtual ~ACL_StartMaintenance();

  ACL_StartMaintenance(const ACL_StartMaintenance& from);

  inline ACL_StartMaintenance& operator=(const ACL_StartMaintenance& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ACL_StartMaintenance(ACL_StartMaintenance&& from) noexcept
    : ACL_StartMaintenance() {
    *this = ::std::move(from);
  }

  inline ACL_StartMaintenance& operator=(ACL_StartMaintenance&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACL_StartMaintenance& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ACL_StartMaintenance* internal_default_instance() {
    return reinterpret_cast<const ACL_StartMaintenance*>(
               &_ACL_StartMaintenance_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    34;

  void Swap(ACL_StartMaintenance* other);
  friend void swap(ACL_StartMaintenance& a, ACL_StartMaintenance& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ACL_StartMaintenance* New() const PROTOBUF_FINAL { return New(NULL); }

  ACL_StartMaintenance* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ACL_StartMaintenance& from);
  void MergeFrom(const ACL_StartMaintenance& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ACL_StartMaintenance* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.ACL.Entity principals = 1;
  bool has_principals() const;
  void clear_principals();
  static const int kPrincipalsFieldNumber = 1;
  const ::mesos::ACL_Entity& principals() const;
  ::mesos::ACL_Entity* release_principals();
  ::mesos::ACL_Entity* mutable_principals();
  void set_allocated_principals(::mesos::ACL_Entity* principals);

  // required .mesos.ACL.Entity machines = 2;
  bool has_machines() const;
  void clear_machines();
  static const int kMachinesFieldNumber = 2;
  const ::mesos::ACL_Entity& machines() const;
  ::mesos::ACL_Entity* release_machines();
  ::mesos::ACL_Entity* mutable_machines();
  void set_allocated_machines(::mesos::ACL_Entity* machines);

  // @@protoc_insertion_point(class_scope:mesos.ACL.StartMaintenance)
 private:
  void set_has_principals();
  void clear_has_principals();
  void set_has_machines();
  void clear_has_machines();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::ACL_Entity* principals_;
  ::mesos::ACL_Entity* machines_;
  friend struct ::protobuf_mesos_2fauthorizer_2facls_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fauthorizer_2facls_2eproto::InitDefaultsACL_StartMaintenanceImpl();
};
// -------------------------------------------------------------------

class ACL_StopMaintenance : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.ACL.StopMaintenance) */ {
 public:
  ACL_StopMaintenance();
  virtual ~ACL_StopMaintenance();

  ACL_StopMaintenance(const ACL_StopMaintenance& from);

  inline ACL_StopMaintenance& operator=(const ACL_StopMaintenance& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ACL_StopMaintenance(ACL_StopMaintenance&& from) noexcept
    : ACL_StopMaintenance() {
    *this = ::std::move(from);
  }

  inline ACL_StopMaintenance& operator=(ACL_StopMaintenance&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACL_StopMaintenance& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ACL_StopMaintenance* internal_default_instance() {
    return reinterpret_cast<const ACL_StopMaintenance*>(
               &_ACL_StopMaintenance_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    35;

  void Swap(ACL_StopMaintenance* other);
  friend void swap(ACL_StopMaintenance& a, ACL_StopMaintenance& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ACL_StopMaintenance* New() const PROTOBUF_FINAL { return New(NULL); }

  ACL_StopMaintenance* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ACL_StopMaintenance& from);
  void MergeFrom(const ACL_StopMaintenance& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ACL_StopMaintenance* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.ACL.Entity principals = 1;
  bool has_principals() const;
  void clear_principals();
  static const int kPrincipalsFieldNumber = 1;
  const ::mesos::ACL_Entity& principals() const;
  ::mesos::ACL_Entity* release_principals();
  ::mesos::ACL_Entity* mutable_principals();
  void set_allocated_principals(::mesos::ACL_Entity* principals);

  // required .mesos.ACL.Entity machines = 2;
  bool has_machines() const;
  void clear_machines();
  static const int kMachinesFieldNumber = 2;
  const ::mesos::ACL_Entity& machines() const;
  ::mesos::ACL_Entity* release_machines();
  ::mesos::ACL_Entity* mutable_machines();
  void set_allocated_machines(::mesos::ACL_Entity* machines);

  // @@protoc_insertion_point(class_scope:mesos.ACL.StopMaintenance)
 private:
  void set_has_principals();
  void clear_has_principals();
  void set_has_machines();
  void clear_has_machines();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::ACL_Entity* principals_;
  ::mesos::ACL_Entity* machines_;
  friend struct ::protobuf_mesos_2fauthorizer_2facls_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fauthorizer_2facls_2eproto::InitDefaultsACL_StopMaintenanceImpl();
};
// -------------------------------------------------------------------

class ACL_GetMaintenanceStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.ACL.GetMaintenanceStatus) */ {
 public:
  ACL_GetMaintenanceStatus();
  virtual ~ACL_GetMaintenanceStatus();

  ACL_GetMaintenanceStatus(const ACL_GetMaintenanceStatus& from);

  inline ACL_GetMaintenanceStatus& operator=(const ACL_GetMaintenanceStatus& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ACL_GetMaintenanceStatus(ACL_GetMaintenanceStatus&& from) noexcept
    : ACL_GetMaintenanceStatus() {
    *this = ::std::move(from);
  }

  inline ACL_GetMaintenanceStatus& operator=(ACL_GetMaintenanceStatus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACL_GetMaintenanceStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ACL_GetMaintenanceStatus* internal_default_instance() {
    return reinterpret_cast<const ACL_GetMaintenanceStatus*>(
               &_ACL_GetMaintenanceStatus_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    36;

  void Swap(ACL_GetMaintenanceStatus* other);
  friend void swap(ACL_GetMaintenanceStatus& a, ACL_GetMaintenanceStatus& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ACL_GetMaintenanceStatus* New() const PROTOBUF_FINAL { return New(NULL); }

  ACL_GetMaintenanceStatus* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ACL_GetMaintenanceStatus& from);
  void MergeFrom(const ACL_GetMaintenanceStatus& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ACL_GetMaintenanceStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.ACL.Entity principals = 1;
  bool has_principals() const;
  void clear_principals();
  static const int kPrincipalsFieldNumber = 1;
  const ::mesos::ACL_Entity& principals() const;
  ::mesos::ACL_Entity* release_principals();
  ::mesos::ACL_Entity* mutable_principals();
  void set_allocated_principals(::mesos::ACL_Entity* principals);

  // required .mesos.ACL.Entity machines = 2;
  bool has_machines() const;
  void clear_machines();
  static const int kMachinesFieldNumber = 2;
  const ::mesos::ACL_Entity& machines() const;
  ::mesos::ACL_Entity* release_machines();
  ::mesos::ACL_Entity* mutable_machines();
  void set_allocated_machines(::mesos::ACL_Entity* machines);

  // @@protoc_insertion_point(class_scope:mesos.ACL.GetMaintenanceStatus)
 private:
  void set_has_principals();
  void clear_has_principals();
  void set_has_machines();
  void clear_has_machines();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::ACL_Entity* principals_;
  ::mesos::ACL_Entity* machines_;
  friend struct ::protobuf_mesos_2fauthorizer_2facls_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fauthorizer_2facls_2eproto::InitDefaultsACL_GetMaintenanceStatusImpl();
};
// -------------------------------------------------------------------

class ACL_MarkAgentGone : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.ACL.MarkAgentGone) */ {
 public:
  ACL_MarkAgentGone();
  virtual ~ACL_MarkAgentGone();

  ACL_MarkAgentGone(const ACL_MarkAgentGone& from);

  inline ACL_MarkAgentGone& operator=(const ACL_MarkAgentGone& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ACL_MarkAgentGone(ACL_MarkAgentGone&& from) noexcept
    : ACL_MarkAgentGone() {
    *this = ::std::move(from);
  }

  inline ACL_MarkAgentGone& operator=(ACL_MarkAgentGone&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACL_MarkAgentGone& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ACL_MarkAgentGone* internal_default_instance() {
    return reinterpret_cast<const ACL_MarkAgentGone*>(
               &_ACL_MarkAgentGone_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    37;

  void Swap(ACL_MarkAgentGone* other);
  friend void swap(ACL_MarkAgentGone& a, ACL_MarkAgentGone& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ACL_MarkAgentGone* New() const PROTOBUF_FINAL { return New(NULL); }

  ACL_MarkAgentGone* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ACL_MarkAgentGone& from);
  void MergeFrom(const ACL_MarkAgentGone& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ACL_MarkAgentGone* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.ACL.Entity principals = 1;
  bool has_principals() const;
  void clear_principals();
  static const int kPrincipalsFieldNumber = 1;
  const ::mesos::ACL_Entity& principals() const;
  ::mesos::ACL_Entity* release_principals();
  ::mesos::ACL_Entity* mutable_principals();
  void set_allocated_principals(::mesos::ACL_Entity* principals);

  // required .mesos.ACL.Entity agents = 2;
  bool has_agents() const;
  void clear_agents();
  static const int kAgentsFieldNumber = 2;
  const ::mesos::ACL_Entity& agents() const;
  ::mesos::ACL_Entity* release_agents();
  ::mesos::ACL_Entity* mutable_agents();
  void set_allocated_agents(::mesos::ACL_Entity* agents);

  // @@protoc_insertion_point(class_scope:mesos.ACL.MarkAgentGone)
 private:
  void set_has_principals();
  void clear_has_principals();
  void set_has_agents();
  void clear_has_agents();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::ACL_Entity* principals_;
  ::mesos::ACL_Entity* agents_;
  friend struct ::protobuf_mesos_2fauthorizer_2facls_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fauthorizer_2facls_2eproto::InitDefaultsACL_MarkAgentGoneImpl();
};
// -------------------------------------------------------------------

class ACL_LaunchStandaloneContainer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.ACL.LaunchStandaloneContainer) */ {
 public:
  ACL_LaunchStandaloneContainer();
  virtual ~ACL_LaunchStandaloneContainer();

  ACL_LaunchStandaloneContainer(const ACL_LaunchStandaloneContainer& from);

  inline ACL_LaunchStandaloneContainer& operator=(const ACL_LaunchStandaloneContainer& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ACL_LaunchStandaloneContainer(ACL_LaunchStandaloneContainer&& from) noexcept
    : ACL_LaunchStandaloneContainer() {
    *this = ::std::move(from);
  }

  inline ACL_LaunchStandaloneContainer& operator=(ACL_LaunchStandaloneContainer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACL_LaunchStandaloneContainer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ACL_LaunchStandaloneContainer* internal_default_instance() {
    return reinterpret_cast<const ACL_LaunchStandaloneContainer*>(
               &_ACL_LaunchStandaloneContainer_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    38;

  void Swap(ACL_LaunchStandaloneContainer* other);
  friend void swap(ACL_LaunchStandaloneContainer& a, ACL_LaunchStandaloneContainer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ACL_LaunchStandaloneContainer* New() const PROTOBUF_FINAL { return New(NULL); }

  ACL_LaunchStandaloneContainer* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ACL_LaunchStandaloneContainer& from);
  void MergeFrom(const ACL_LaunchStandaloneContainer& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ACL_LaunchStandaloneContainer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.ACL.Entity principals = 1;
  bool has_principals() const;
  void clear_principals();
  static const int kPrincipalsFieldNumber = 1;
  const ::mesos::ACL_Entity& principals() const;
  ::mesos::ACL_Entity* release_principals();
  ::mesos::ACL_Entity* mutable_principals();
  void set_allocated_principals(::mesos::ACL_Entity* principals);

  // required .mesos.ACL.Entity users = 2;
  bool has_users() const;
  void clear_users();
  static const int kUsersFieldNumber = 2;
  const ::mesos::ACL_Entity& users() const;
  ::mesos::ACL_Entity* release_users();
  ::mesos::ACL_Entity* mutable_users();
  void set_allocated_users(::mesos::ACL_Entity* users);

  // @@protoc_insertion_point(class_scope:mesos.ACL.LaunchStandaloneContainer)
 private:
  void set_has_principals();
  void clear_has_principals();
  void set_has_users();
  void clear_has_users();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::ACL_Entity* principals_;
  ::mesos::ACL_Entity* users_;
  friend struct ::protobuf_mesos_2fauthorizer_2facls_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fauthorizer_2facls_2eproto::InitDefaultsACL_LaunchStandaloneContainerImpl();
};
// -------------------------------------------------------------------

class ACL_KillStandaloneContainer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.ACL.KillStandaloneContainer) */ {
 public:
  ACL_KillStandaloneContainer();
  virtual ~ACL_KillStandaloneContainer();

  ACL_KillStandaloneContainer(const ACL_KillStandaloneContainer& from);

  inline ACL_KillStandaloneContainer& operator=(const ACL_KillStandaloneContainer& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ACL_KillStandaloneContainer(ACL_KillStandaloneContainer&& from) noexcept
    : ACL_KillStandaloneContainer() {
    *this = ::std::move(from);
  }

  inline ACL_KillStandaloneContainer& operator=(ACL_KillStandaloneContainer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACL_KillStandaloneContainer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ACL_KillStandaloneContainer* internal_default_instance() {
    return reinterpret_cast<const ACL_KillStandaloneContainer*>(
               &_ACL_KillStandaloneContainer_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    39;

  void Swap(ACL_KillStandaloneContainer* other);
  friend void swap(ACL_KillStandaloneContainer& a, ACL_KillStandaloneContainer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ACL_KillStandaloneContainer* New() const PROTOBUF_FINAL { return New(NULL); }

  ACL_KillStandaloneContainer* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ACL_KillStandaloneContainer& from);
  void MergeFrom(const ACL_KillStandaloneContainer& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ACL_KillStandaloneContainer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.ACL.Entity principals = 1;
  bool has_principals() const;
  void clear_principals();
  static const int kPrincipalsFieldNumber = 1;
  const ::mesos::ACL_Entity& principals() const;
  ::mesos::ACL_Entity* release_principals();
  ::mesos::ACL_Entity* mutable_principals();
  void set_allocated_principals(::mesos::ACL_Entity* principals);

  // required .mesos.ACL.Entity users = 2;
  bool has_users() const;
  void clear_users();
  static const int kUsersFieldNumber = 2;
  const ::mesos::ACL_Entity& users() const;
  ::mesos::ACL_Entity* release_users();
  ::mesos::ACL_Entity* mutable_users();
  void set_allocated_users(::mesos::ACL_Entity* users);

  // @@protoc_insertion_point(class_scope:mesos.ACL.KillStandaloneContainer)
 private:
  void set_has_principals();
  void clear_has_principals();
  void set_has_users();
  void clear_has_users();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::ACL_Entity* principals_;
  ::mesos::ACL_Entity* users_;
  friend struct ::protobuf_mesos_2fauthorizer_2facls_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fauthorizer_2facls_2eproto::InitDefaultsACL_KillStandaloneContainerImpl();
};
// -------------------------------------------------------------------

class ACL_WaitStandaloneContainer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.ACL.WaitStandaloneContainer) */ {
 public:
  ACL_WaitStandaloneContainer();
  virtual ~ACL_WaitStandaloneContainer();

  ACL_WaitStandaloneContainer(const ACL_WaitStandaloneContainer& from);

  inline ACL_WaitStandaloneContainer& operator=(const ACL_WaitStandaloneContainer& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ACL_WaitStandaloneContainer(ACL_WaitStandaloneContainer&& from) noexcept
    : ACL_WaitStandaloneContainer() {
    *this = ::std::move(from);
  }

  inline ACL_WaitStandaloneContainer& operator=(ACL_WaitStandaloneContainer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACL_WaitStandaloneContainer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ACL_WaitStandaloneContainer* internal_default_instance() {
    return reinterpret_cast<const ACL_WaitStandaloneContainer*>(
               &_ACL_WaitStandaloneContainer_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    40;

  void Swap(ACL_WaitStandaloneContainer* other);
  friend void swap(ACL_WaitStandaloneContainer& a, ACL_WaitStandaloneContainer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ACL_WaitStandaloneContainer* New() const PROTOBUF_FINAL { return New(NULL); }

  ACL_WaitStandaloneContainer* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ACL_WaitStandaloneContainer& from);
  void MergeFrom(const ACL_WaitStandaloneContainer& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ACL_WaitStandaloneContainer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.ACL.Entity principals = 1;
  bool has_principals() const;
  void clear_principals();
  static const int kPrincipalsFieldNumber = 1;
  const ::mesos::ACL_Entity& principals() const;
  ::mesos::ACL_Entity* release_principals();
  ::mesos::ACL_Entity* mutable_principals();
  void set_allocated_principals(::mesos::ACL_Entity* principals);

  // required .mesos.ACL.Entity users = 2;
  bool has_users() const;
  void clear_users();
  static const int kUsersFieldNumber = 2;
  const ::mesos::ACL_Entity& users() const;
  ::mesos::ACL_Entity* release_users();
  ::mesos::ACL_Entity* mutable_users();
  void set_allocated_users(::mesos::ACL_Entity* users);

  // @@protoc_insertion_point(class_scope:mesos.ACL.WaitStandaloneContainer)
 private:
  void set_has_principals();
  void clear_has_principals();
  void set_has_users();
  void clear_has_users();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::ACL_Entity* principals_;
  ::mesos::ACL_Entity* users_;
  friend struct ::protobuf_mesos_2fauthorizer_2facls_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fauthorizer_2facls_2eproto::InitDefaultsACL_WaitStandaloneContainerImpl();
};
// -------------------------------------------------------------------

class ACL_RemoveStandaloneContainer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.ACL.RemoveStandaloneContainer) */ {
 public:
  ACL_RemoveStandaloneContainer();
  virtual ~ACL_RemoveStandaloneContainer();

  ACL_RemoveStandaloneContainer(const ACL_RemoveStandaloneContainer& from);

  inline ACL_RemoveStandaloneContainer& operator=(const ACL_RemoveStandaloneContainer& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ACL_RemoveStandaloneContainer(ACL_RemoveStandaloneContainer&& from) noexcept
    : ACL_RemoveStandaloneContainer() {
    *this = ::std::move(from);
  }

  inline ACL_RemoveStandaloneContainer& operator=(ACL_RemoveStandaloneContainer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACL_RemoveStandaloneContainer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ACL_RemoveStandaloneContainer* internal_default_instance() {
    return reinterpret_cast<const ACL_RemoveStandaloneContainer*>(
               &_ACL_RemoveStandaloneContainer_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    41;

  void Swap(ACL_RemoveStandaloneContainer* other);
  friend void swap(ACL_RemoveStandaloneContainer& a, ACL_RemoveStandaloneContainer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ACL_RemoveStandaloneContainer* New() const PROTOBUF_FINAL { return New(NULL); }

  ACL_RemoveStandaloneContainer* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ACL_RemoveStandaloneContainer& from);
  void MergeFrom(const ACL_RemoveStandaloneContainer& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ACL_RemoveStandaloneContainer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.ACL.Entity principals = 1;
  bool has_principals() const;
  void clear_principals();
  static const int kPrincipalsFieldNumber = 1;
  const ::mesos::ACL_Entity& principals() const;
  ::mesos::ACL_Entity* release_principals();
  ::mesos::ACL_Entity* mutable_principals();
  void set_allocated_principals(::mesos::ACL_Entity* principals);

  // required .mesos.ACL.Entity users = 2;
  bool has_users() const;
  void clear_users();
  static const int kUsersFieldNumber = 2;
  const ::mesos::ACL_Entity& users() const;
  ::mesos::ACL_Entity* release_users();
  ::mesos::ACL_Entity* mutable_users();
  void set_allocated_users(::mesos::ACL_Entity* users);

  // @@protoc_insertion_point(class_scope:mesos.ACL.RemoveStandaloneContainer)
 private:
  void set_has_principals();
  void clear_has_principals();
  void set_has_users();
  void clear_has_users();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::ACL_Entity* principals_;
  ::mesos::ACL_Entity* users_;
  friend struct ::protobuf_mesos_2fauthorizer_2facls_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fauthorizer_2facls_2eproto::InitDefaultsACL_RemoveStandaloneContainerImpl();
};
// -------------------------------------------------------------------

class ACL_ViewStandaloneContainer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.ACL.ViewStandaloneContainer) */ {
 public:
  ACL_ViewStandaloneContainer();
  virtual ~ACL_ViewStandaloneContainer();

  ACL_ViewStandaloneContainer(const ACL_ViewStandaloneContainer& from);

  inline ACL_ViewStandaloneContainer& operator=(const ACL_ViewStandaloneContainer& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ACL_ViewStandaloneContainer(ACL_ViewStandaloneContainer&& from) noexcept
    : ACL_ViewStandaloneContainer() {
    *this = ::std::move(from);
  }

  inline ACL_ViewStandaloneContainer& operator=(ACL_ViewStandaloneContainer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACL_ViewStandaloneContainer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ACL_ViewStandaloneContainer* internal_default_instance() {
    return reinterpret_cast<const ACL_ViewStandaloneContainer*>(
               &_ACL_ViewStandaloneContainer_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    42;

  void Swap(ACL_ViewStandaloneContainer* other);
  friend void swap(ACL_ViewStandaloneContainer& a, ACL_ViewStandaloneContainer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ACL_ViewStandaloneContainer* New() const PROTOBUF_FINAL { return New(NULL); }

  ACL_ViewStandaloneContainer* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ACL_ViewStandaloneContainer& from);
  void MergeFrom(const ACL_ViewStandaloneContainer& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ACL_ViewStandaloneContainer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.ACL.Entity principals = 1;
  bool has_principals() const;
  void clear_principals();
  static const int kPrincipalsFieldNumber = 1;
  const ::mesos::ACL_Entity& principals() const;
  ::mesos::ACL_Entity* release_principals();
  ::mesos::ACL_Entity* mutable_principals();
  void set_allocated_principals(::mesos::ACL_Entity* principals);

  // required .mesos.ACL.Entity users = 2;
  bool has_users() const;
  void clear_users();
  static const int kUsersFieldNumber = 2;
  const ::mesos::ACL_Entity& users() const;
  ::mesos::ACL_Entity* release_users();
  ::mesos::ACL_Entity* mutable_users();
  void set_allocated_users(::mesos::ACL_Entity* users);

  // @@protoc_insertion_point(class_scope:mesos.ACL.ViewStandaloneContainer)
 private:
  void set_has_principals();
  void clear_has_principals();
  void set_has_users();
  void clear_has_users();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::ACL_Entity* principals_;
  ::mesos::ACL_Entity* users_;
  friend struct ::protobuf_mesos_2fauthorizer_2facls_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fauthorizer_2facls_2eproto::InitDefaultsACL_ViewStandaloneContainerImpl();
};
// -------------------------------------------------------------------

class ACL_ModifyResourceProviderConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.ACL.ModifyResourceProviderConfig) */ {
 public:
  ACL_ModifyResourceProviderConfig();
  virtual ~ACL_ModifyResourceProviderConfig();

  ACL_ModifyResourceProviderConfig(const ACL_ModifyResourceProviderConfig& from);

  inline ACL_ModifyResourceProviderConfig& operator=(const ACL_ModifyResourceProviderConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ACL_ModifyResourceProviderConfig(ACL_ModifyResourceProviderConfig&& from) noexcept
    : ACL_ModifyResourceProviderConfig() {
    *this = ::std::move(from);
  }

  inline ACL_ModifyResourceProviderConfig& operator=(ACL_ModifyResourceProviderConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACL_ModifyResourceProviderConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ACL_ModifyResourceProviderConfig* internal_default_instance() {
    return reinterpret_cast<const ACL_ModifyResourceProviderConfig*>(
               &_ACL_ModifyResourceProviderConfig_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    43;

  void Swap(ACL_ModifyResourceProviderConfig* other);
  friend void swap(ACL_ModifyResourceProviderConfig& a, ACL_ModifyResourceProviderConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ACL_ModifyResourceProviderConfig* New() const PROTOBUF_FINAL { return New(NULL); }

  ACL_ModifyResourceProviderConfig* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ACL_ModifyResourceProviderConfig& from);
  void MergeFrom(const ACL_ModifyResourceProviderConfig& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ACL_ModifyResourceProviderConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.ACL.Entity principals = 1;
  bool has_principals() const;
  void clear_principals();
  static const int kPrincipalsFieldNumber = 1;
  const ::mesos::ACL_Entity& principals() const;
  ::mesos::ACL_Entity* release_principals();
  ::mesos::ACL_Entity* mutable_principals();
  void set_allocated_principals(::mesos::ACL_Entity* principals);

  // required .mesos.ACL.Entity resource_providers = 2;
  bool has_resource_providers() const;
  void clear_resource_providers();
  static const int kResourceProvidersFieldNumber = 2;
  const ::mesos::ACL_Entity& resource_providers() const;
  ::mesos::ACL_Entity* release_resource_providers();
  ::mesos::ACL_Entity* mutable_resource_providers();
  void set_allocated_resource_providers(::mesos::ACL_Entity* resource_providers);

  // @@protoc_insertion_point(class_scope:mesos.ACL.ModifyResourceProviderConfig)
 private:
  void set_has_principals();
  void clear_has_principals();
  void set_has_resource_providers();
  void clear_has_resource_providers();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::ACL_Entity* principals_;
  ::mesos::ACL_Entity* resource_providers_;
  friend struct ::protobuf_mesos_2fauthorizer_2facls_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fauthorizer_2facls_2eproto::InitDefaultsACL_ModifyResourceProviderConfigImpl();
};
// -------------------------------------------------------------------

class ACL_PruneImages : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.ACL.PruneImages) */ {
 public:
  ACL_PruneImages();
  virtual ~ACL_PruneImages();

  ACL_PruneImages(const ACL_PruneImages& from);

  inline ACL_PruneImages& operator=(const ACL_PruneImages& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ACL_PruneImages(ACL_PruneImages&& from) noexcept
    : ACL_PruneImages() {
    *this = ::std::move(from);
  }

  inline ACL_PruneImages& operator=(ACL_PruneImages&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACL_PruneImages& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ACL_PruneImages* internal_default_instance() {
    return reinterpret_cast<const ACL_PruneImages*>(
               &_ACL_PruneImages_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    44;

  void Swap(ACL_PruneImages* other);
  friend void swap(ACL_PruneImages& a, ACL_PruneImages& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ACL_PruneImages* New() const PROTOBUF_FINAL { return New(NULL); }

  ACL_PruneImages* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ACL_PruneImages& from);
  void MergeFrom(const ACL_PruneImages& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ACL_PruneImages* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.ACL.Entity principals = 1;
  bool has_principals() const;
  void clear_principals();
  static const int kPrincipalsFieldNumber = 1;
  const ::mesos::ACL_Entity& principals() const;
  ::mesos::ACL_Entity* release_principals();
  ::mesos::ACL_Entity* mutable_principals();
  void set_allocated_principals(::mesos::ACL_Entity* principals);

  // required .mesos.ACL.Entity images = 2;
  bool has_images() const;
  void clear_images();
  static const int kImagesFieldNumber = 2;
  const ::mesos::ACL_Entity& images() const;
  ::mesos::ACL_Entity* release_images();
  ::mesos::ACL_Entity* mutable_images();
  void set_allocated_images(::mesos::ACL_Entity* images);

  // @@protoc_insertion_point(class_scope:mesos.ACL.PruneImages)
 private:
  void set_has_principals();
  void clear_has_principals();
  void set_has_images();
  void clear_has_images();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::ACL_Entity* principals_;
  ::mesos::ACL_Entity* images_;
  friend struct ::protobuf_mesos_2fauthorizer_2facls_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fauthorizer_2facls_2eproto::InitDefaultsACL_PruneImagesImpl();
};
// -------------------------------------------------------------------

class ACL : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.ACL) */ {
 public:
  ACL();
  virtual ~ACL();

  ACL(const ACL& from);

  inline ACL& operator=(const ACL& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ACL(ACL&& from) noexcept
    : ACL() {
    *this = ::std::move(from);
  }

  inline ACL& operator=(ACL&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACL& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ACL* internal_default_instance() {
    return reinterpret_cast<const ACL*>(
               &_ACL_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    45;

  void Swap(ACL* other);
  friend void swap(ACL& a, ACL& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ACL* New() const PROTOBUF_FINAL { return New(NULL); }

  ACL* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ACL& from);
  void MergeFrom(const ACL& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ACL* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef ACL_Entity Entity;
  typedef ACL_RegisterFramework RegisterFramework;
  typedef ACL_RunTask RunTask;
  typedef ACL_TeardownFramework TeardownFramework;
  typedef ACL_ReserveResources ReserveResources;
  typedef ACL_UnreserveResources UnreserveResources;
  typedef ACL_CreateVolume CreateVolume;
  typedef ACL_DestroyVolume DestroyVolume;
  typedef ACL_ResizeVolume ResizeVolume;
  typedef ACL_GetQuota GetQuota;
  typedef ACL_UpdateQuota UpdateQuota;
  typedef ACL_ViewRole ViewRole;
  typedef ACL_UpdateWeight UpdateWeight;
  typedef ACL_GetEndpoint GetEndpoint;
  typedef ACL_ViewFramework ViewFramework;
  typedef ACL_ViewTask ViewTask;
  typedef ACL_ViewExecutor ViewExecutor;
  typedef ACL_AccessSandbox AccessSandbox;
  typedef ACL_AccessMesosLog AccessMesosLog;
  typedef ACL_ViewFlags ViewFlags;
  typedef ACL_LaunchNestedContainerAsUser LaunchNestedContainerAsUser;
  typedef ACL_LaunchNestedContainerUnderParentWithUser LaunchNestedContainerUnderParentWithUser;
  typedef ACL_LaunchNestedContainerSessionAsUser LaunchNestedContainerSessionAsUser;
  typedef ACL_LaunchNestedContainerSessionUnderParentWithUser LaunchNestedContainerSessionUnderParentWithUser;
  typedef ACL_AttachContainerInput AttachContainerInput;
  typedef ACL_AttachContainerOutput AttachContainerOutput;
  typedef ACL_KillNestedContainer KillNestedContainer;
  typedef ACL_WaitNestedContainer WaitNestedContainer;
  typedef ACL_ViewContainer ViewContainer;
  typedef ACL_RemoveNestedContainer RemoveNestedContainer;
  typedef ACL_SetLogLevel SetLogLevel;
  typedef ACL_RegisterAgent RegisterAgent;
  typedef ACL_UpdateMaintenanceSchedule UpdateMaintenanceSchedule;
  typedef ACL_GetMaintenanceSchedule GetMaintenanceSchedule;
  typedef ACL_StartMaintenance StartMaintenance;
  typedef ACL_StopMaintenance StopMaintenance;
  typedef ACL_GetMaintenanceStatus GetMaintenanceStatus;
  typedef ACL_MarkAgentGone MarkAgentGone;
  typedef ACL_LaunchStandaloneContainer LaunchStandaloneContainer;
  typedef ACL_KillStandaloneContainer KillStandaloneContainer;
  typedef ACL_WaitStandaloneContainer WaitStandaloneContainer;
  typedef ACL_RemoveStandaloneContainer RemoveStandaloneContainer;
  typedef ACL_ViewStandaloneContainer ViewStandaloneContainer;
  typedef ACL_ModifyResourceProviderConfig ModifyResourceProviderConfig;
  typedef ACL_PruneImages PruneImages;

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:mesos.ACL)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  friend struct ::protobuf_mesos_2fauthorizer_2facls_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fauthorizer_2facls_2eproto::InitDefaultsACLImpl();
};
// -------------------------------------------------------------------

class ACLs : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.ACLs) */ {
 public:
  ACLs();
  virtual ~ACLs();

  ACLs(const ACLs& from);

  inline ACLs& operator=(const ACLs& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ACLs(ACLs&& from) noexcept
    : ACLs() {
    *this = ::std::move(from);
  }

  inline ACLs& operator=(ACLs&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACLs& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ACLs* internal_default_instance() {
    return reinterpret_cast<const ACLs*>(
               &_ACLs_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    46;

  void Swap(ACLs* other);
  friend void swap(ACLs& a, ACLs& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ACLs* New() const PROTOBUF_FINAL { return New(NULL); }

  ACLs* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ACLs& from);
  void MergeFrom(const ACLs& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ACLs* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.ACL.RegisterFramework register_frameworks = 2;
  int register_frameworks_size() const;
  void clear_register_frameworks();
  static const int kRegisterFrameworksFieldNumber = 2;
  const ::mesos::ACL_RegisterFramework& register_frameworks(int index) const;
  ::mesos::ACL_RegisterFramework* mutable_register_frameworks(int index);
  ::mesos::ACL_RegisterFramework* add_register_frameworks();
  ::google::protobuf::RepeatedPtrField< ::mesos::ACL_RegisterFramework >*
      mutable_register_frameworks();
  const ::google::protobuf::RepeatedPtrField< ::mesos::ACL_RegisterFramework >&
      register_frameworks() const;

  // repeated .mesos.ACL.RunTask run_tasks = 3;
  int run_tasks_size() const;
  void clear_run_tasks();
  static const int kRunTasksFieldNumber = 3;
  const ::mesos::ACL_RunTask& run_tasks(int index) const;
  ::mesos::ACL_RunTask* mutable_run_tasks(int index);
  ::mesos::ACL_RunTask* add_run_tasks();
  ::google::protobuf::RepeatedPtrField< ::mesos::ACL_RunTask >*
      mutable_run_tasks();
  const ::google::protobuf::RepeatedPtrField< ::mesos::ACL_RunTask >&
      run_tasks() const;

  // repeated .mesos.ACL.ReserveResources reserve_resources = 5;
  int reserve_resources_size() const;
  void clear_reserve_resources();
  static const int kReserveResourcesFieldNumber = 5;
  const ::mesos::ACL_ReserveResources& reserve_resources(int index) const;
  ::mesos::ACL_ReserveResources* mutable_reserve_resources(int index);
  ::mesos::ACL_ReserveResources* add_reserve_resources();
  ::google::protobuf::RepeatedPtrField< ::mesos::ACL_ReserveResources >*
      mutable_reserve_resources();
  const ::google::protobuf::RepeatedPtrField< ::mesos::ACL_ReserveResources >&
      reserve_resources() const;

  // repeated .mesos.ACL.UnreserveResources unreserve_resources = 6;
  int unreserve_resources_size() const;
  void clear_unreserve_resources();
  static const int kUnreserveResourcesFieldNumber = 6;
  const ::mesos::ACL_UnreserveResources& unreserve_resources(int index) const;
  ::mesos::ACL_UnreserveResources* mutable_unreserve_resources(int index);
  ::mesos::ACL_UnreserveResources* add_unreserve_resources();
  ::google::protobuf::RepeatedPtrField< ::mesos::ACL_UnreserveResources >*
      mutable_unreserve_resources();
  const ::google::protobuf::RepeatedPtrField< ::mesos::ACL_UnreserveResources >&
      unreserve_resources() const;

  // repeated .mesos.ACL.CreateVolume create_volumes = 7;
  int create_volumes_size() const;
  void clear_create_volumes();
  static const int kCreateVolumesFieldNumber = 7;
  const ::mesos::ACL_CreateVolume& create_volumes(int index) const;
  ::mesos::ACL_CreateVolume* mutable_create_volumes(int index);
  ::mesos::ACL_CreateVolume* add_create_volumes();
  ::google::protobuf::RepeatedPtrField< ::mesos::ACL_CreateVolume >*
      mutable_create_volumes();
  const ::google::protobuf::RepeatedPtrField< ::mesos::ACL_CreateVolume >&
      create_volumes() const;

  // repeated .mesos.ACL.DestroyVolume destroy_volumes = 8;
  int destroy_volumes_size() const;
  void clear_destroy_volumes();
  static const int kDestroyVolumesFieldNumber = 8;
  const ::mesos::ACL_DestroyVolume& destroy_volumes(int index) const;
  ::mesos::ACL_DestroyVolume* mutable_destroy_volumes(int index);
  ::mesos::ACL_DestroyVolume* add_destroy_volumes();
  ::google::protobuf::RepeatedPtrField< ::mesos::ACL_DestroyVolume >*
      mutable_destroy_volumes();
  const ::google::protobuf::RepeatedPtrField< ::mesos::ACL_DestroyVolume >&
      destroy_volumes() const;

  // repeated .mesos.ACL.TeardownFramework teardown_frameworks = 11;
  int teardown_frameworks_size() const;
  void clear_teardown_frameworks();
  static const int kTeardownFrameworksFieldNumber = 11;
  const ::mesos::ACL_TeardownFramework& teardown_frameworks(int index) const;
  ::mesos::ACL_TeardownFramework* mutable_teardown_frameworks(int index);
  ::mesos::ACL_TeardownFramework* add_teardown_frameworks();
  ::google::protobuf::RepeatedPtrField< ::mesos::ACL_TeardownFramework >*
      mutable_teardown_frameworks();
  const ::google::protobuf::RepeatedPtrField< ::mesos::ACL_TeardownFramework >&
      teardown_frameworks() const;

  // repeated .mesos.ACL.UpdateWeight update_weights = 12;
  int update_weights_size() const;
  void clear_update_weights();
  static const int kUpdateWeightsFieldNumber = 12;
  const ::mesos::ACL_UpdateWeight& update_weights(int index) const;
  ::mesos::ACL_UpdateWeight* mutable_update_weights(int index);
  ::mesos::ACL_UpdateWeight* add_update_weights();
  ::google::protobuf::RepeatedPtrField< ::mesos::ACL_UpdateWeight >*
      mutable_update_weights();
  const ::google::protobuf::RepeatedPtrField< ::mesos::ACL_UpdateWeight >&
      update_weights() const;

  // repeated .mesos.ACL.GetEndpoint get_endpoints = 13;
  int get_endpoints_size() const;
  void clear_get_endpoints();
  static const int kGetEndpointsFieldNumber = 13;
  const ::mesos::ACL_GetEndpoint& get_endpoints(int index) const;
  ::mesos::ACL_GetEndpoint* mutable_get_endpoints(int index);
  ::mesos::ACL_GetEndpoint* add_get_endpoints();
  ::google::protobuf::RepeatedPtrField< ::mesos::ACL_GetEndpoint >*
      mutable_get_endpoints();
  const ::google::protobuf::RepeatedPtrField< ::mesos::ACL_GetEndpoint >&
      get_endpoints() const;

  // repeated .mesos.ACL.GetQuota get_quotas = 14;
  int get_quotas_size() const;
  void clear_get_quotas();
  static const int kGetQuotasFieldNumber = 14;
  const ::mesos::ACL_GetQuota& get_quotas(int index) const;
  ::mesos::ACL_GetQuota* mutable_get_quotas(int index);
  ::mesos::ACL_GetQuota* add_get_quotas();
  ::google::protobuf::RepeatedPtrField< ::mesos::ACL_GetQuota >*
      mutable_get_quotas();
  const ::google::protobuf::RepeatedPtrField< ::mesos::ACL_GetQuota >&
      get_quotas() const;

  // repeated .mesos.ACL.UpdateQuota update_quotas = 15;
  int update_quotas_size() const;
  void clear_update_quotas();
  static const int kUpdateQuotasFieldNumber = 15;
  const ::mesos::ACL_UpdateQuota& update_quotas(int index) const;
  ::mesos::ACL_UpdateQuota* mutable_update_quotas(int index);
  ::mesos::ACL_UpdateQuota* add_update_quotas();
  ::google::protobuf::RepeatedPtrField< ::mesos::ACL_UpdateQuota >*
      mutable_update_quotas();
  const ::google::protobuf::RepeatedPtrField< ::mesos::ACL_UpdateQuota >&
      update_quotas() const;

  // repeated .mesos.ACL.ViewFramework view_frameworks = 16;
  int view_frameworks_size() const;
  void clear_view_frameworks();
  static const int kViewFrameworksFieldNumber = 16;
  const ::mesos::ACL_ViewFramework& view_frameworks(int index) const;
  ::mesos::ACL_ViewFramework* mutable_view_frameworks(int index);
  ::mesos::ACL_ViewFramework* add_view_frameworks();
  ::google::protobuf::RepeatedPtrField< ::mesos::ACL_ViewFramework >*
      mutable_view_frameworks();
  const ::google::protobuf::RepeatedPtrField< ::mesos::ACL_ViewFramework >&
      view_frameworks() const;

  // repeated .mesos.ACL.ViewTask view_tasks = 17;
  int view_tasks_size() const;
  void clear_view_tasks();
  static const int kViewTasksFieldNumber = 17;
  const ::mesos::ACL_ViewTask& view_tasks(int index) const;
  ::mesos::ACL_ViewTask* mutable_view_tasks(int index);
  ::mesos::ACL_ViewTask* add_view_tasks();
  ::google::protobuf::RepeatedPtrField< ::mesos::ACL_ViewTask >*
      mutable_view_tasks();
  const ::google::protobuf::RepeatedPtrField< ::mesos::ACL_ViewTask >&
      view_tasks() const;

  // repeated .mesos.ACL.ViewExecutor view_executors = 18;
  int view_executors_size() const;
  void clear_view_executors();
  static const int kViewExecutorsFieldNumber = 18;
  const ::mesos::ACL_ViewExecutor& view_executors(int index) const;
  ::mesos::ACL_ViewExecutor* mutable_view_executors(int index);
  ::mesos::ACL_ViewExecutor* add_view_executors();
  ::google::protobuf::RepeatedPtrField< ::mesos::ACL_ViewExecutor >*
      mutable_view_executors();
  const ::google::protobuf::RepeatedPtrField< ::mesos::ACL_ViewExecutor >&
      view_executors() const;

  // repeated .mesos.ACL.AccessSandbox access_sandboxes = 19;
  int access_sandboxes_size() const;
  void clear_access_sandboxes();
  static const int kAccessSandboxesFieldNumber = 19;
  const ::mesos::ACL_AccessSandbox& access_sandboxes(int index) const;
  ::mesos::ACL_AccessSandbox* mutable_access_sandboxes(int index);
  ::mesos::ACL_AccessSandbox* add_access_sandboxes();
  ::google::protobuf::RepeatedPtrField< ::mesos::ACL_AccessSandbox >*
      mutable_access_sandboxes();
  const ::google::protobuf::RepeatedPtrField< ::mesos::ACL_AccessSandbox >&
      access_sandboxes() const;

  // repeated .mesos.ACL.AccessMesosLog access_mesos_logs = 20;
  int access_mesos_logs_size() const;
  void clear_access_mesos_logs();
  static const int kAccessMesosLogsFieldNumber = 20;
  const ::mesos::ACL_AccessMesosLog& access_mesos_logs(int index) const;
  ::mesos::ACL_AccessMesosLog* mutable_access_mesos_logs(int index);
  ::mesos::ACL_AccessMesosLog* add_access_mesos_logs();
  ::google::protobuf::RepeatedPtrField< ::mesos::ACL_AccessMesosLog >*
      mutable_access_mesos_logs();
  const ::google::protobuf::RepeatedPtrField< ::mesos::ACL_AccessMesosLog >&
      access_mesos_logs() const;

  // repeated .mesos.ACL.ViewRole view_roles = 21;
  int view_roles_size() const;
  void clear_view_roles();
  static const int kViewRolesFieldNumber = 21;
  const ::mesos::ACL_ViewRole& view_roles(int index) const;
  ::mesos::ACL_ViewRole* mutable_view_roles(int index);
  ::mesos::ACL_ViewRole* add_view_roles();
  ::google::protobuf::RepeatedPtrField< ::mesos::ACL_ViewRole >*
      mutable_view_roles();
  const ::google::protobuf::RepeatedPtrField< ::mesos::ACL_ViewRole >&
      view_roles() const;

  // repeated .mesos.ACL.ViewFlags view_flags = 22;
  int view_flags_size() const;
  void clear_view_flags();
  static const int kViewFlagsFieldNumber = 22;
  const ::mesos::ACL_ViewFlags& view_flags(int index) const;
  ::mesos::ACL_ViewFlags* mutable_view_flags(int index);
  ::mesos::ACL_ViewFlags* add_view_flags();
  ::google::protobuf::RepeatedPtrField< ::mesos::ACL_ViewFlags >*
      mutable_view_flags();
  const ::google::protobuf::RepeatedPtrField< ::mesos::ACL_ViewFlags >&
      view_flags() const;

  // repeated .mesos.ACL.LaunchNestedContainerAsUser launch_nested_containers_as_user = 23;
  int launch_nested_containers_as_user_size() const;
  void clear_launch_nested_containers_as_user();
  static const int kLaunchNestedContainersAsUserFieldNumber = 23;
  const ::mesos::ACL_LaunchNestedContainerAsUser& launch_nested_containers_as_user(int index) const;
  ::mesos::ACL_LaunchNestedContainerAsUser* mutable_launch_nested_containers_as_user(int index);
  ::mesos::ACL_LaunchNestedContainerAsUser* add_launch_nested_containers_as_user();
  ::google::protobuf::RepeatedPtrField< ::mesos::ACL_LaunchNestedContainerAsUser >*
      mutable_launch_nested_containers_as_user();
  const ::google::protobuf::RepeatedPtrField< ::mesos::ACL_LaunchNestedContainerAsUser >&
      launch_nested_containers_as_user() const;

  // repeated .mesos.ACL.LaunchNestedContainerUnderParentWithUser launch_nested_containers_under_parent_with_user = 24;
  int launch_nested_containers_under_parent_with_user_size() const;
  void clear_launch_nested_containers_under_parent_with_user();
  static const int kLaunchNestedContainersUnderParentWithUserFieldNumber = 24;
  const ::mesos::ACL_LaunchNestedContainerUnderParentWithUser& launch_nested_containers_under_parent_with_user(int index) const;
  ::mesos::ACL_LaunchNestedContainerUnderParentWithUser* mutable_launch_nested_containers_under_parent_with_user(int index);
  ::mesos::ACL_LaunchNestedContainerUnderParentWithUser* add_launch_nested_containers_under_parent_with_user();
  ::google::protobuf::RepeatedPtrField< ::mesos::ACL_LaunchNestedContainerUnderParentWithUser >*
      mutable_launch_nested_containers_under_parent_with_user();
  const ::google::protobuf::RepeatedPtrField< ::mesos::ACL_LaunchNestedContainerUnderParentWithUser >&
      launch_nested_containers_under_parent_with_user() const;

  // repeated .mesos.ACL.KillNestedContainer kill_nested_containers = 25;
  int kill_nested_containers_size() const;
  void clear_kill_nested_containers();
  static const int kKillNestedContainersFieldNumber = 25;
  const ::mesos::ACL_KillNestedContainer& kill_nested_containers(int index) const;
  ::mesos::ACL_KillNestedContainer* mutable_kill_nested_containers(int index);
  ::mesos::ACL_KillNestedContainer* add_kill_nested_containers();
  ::google::protobuf::RepeatedPtrField< ::mesos::ACL_KillNestedContainer >*
      mutable_kill_nested_containers();
  const ::google::protobuf::RepeatedPtrField< ::mesos::ACL_KillNestedContainer >&
      kill_nested_containers() const;

  // repeated .mesos.ACL.WaitNestedContainer wait_nested_containers = 26;
  int wait_nested_containers_size() const;
  void clear_wait_nested_containers();
  static const int kWaitNestedContainersFieldNumber = 26;
  const ::mesos::ACL_WaitNestedContainer& wait_nested_containers(int index) const;
  ::mesos::ACL_WaitNestedContainer* mutable_wait_nested_containers(int index);
  ::mesos::ACL_WaitNestedContainer* add_wait_nested_containers();
  ::google::protobuf::RepeatedPtrField< ::mesos::ACL_WaitNestedContainer >*
      mutable_wait_nested_containers();
  const ::google::protobuf::RepeatedPtrField< ::mesos::ACL_WaitNestedContainer >&
      wait_nested_containers() const;

  // repeated .mesos.ACL.LaunchNestedContainerSessionAsUser launch_nested_container_sessions_as_user = 27;
  int launch_nested_container_sessions_as_user_size() const;
  void clear_launch_nested_container_sessions_as_user();
  static const int kLaunchNestedContainerSessionsAsUserFieldNumber = 27;
  const ::mesos::ACL_LaunchNestedContainerSessionAsUser& launch_nested_container_sessions_as_user(int index) const;
  ::mesos::ACL_LaunchNestedContainerSessionAsUser* mutable_launch_nested_container_sessions_as_user(int index);
  ::mesos::ACL_LaunchNestedContainerSessionAsUser* add_launch_nested_container_sessions_as_user();
  ::google::protobuf::RepeatedPtrField< ::mesos::ACL_LaunchNestedContainerSessionAsUser >*
      mutable_launch_nested_container_sessions_as_user();
  const ::google::protobuf::RepeatedPtrField< ::mesos::ACL_LaunchNestedContainerSessionAsUser >&
      launch_nested_container_sessions_as_user() const;

  // repeated .mesos.ACL.LaunchNestedContainerSessionUnderParentWithUser launch_nested_container_sessions_under_parent_with_user = 28;
  int launch_nested_container_sessions_under_parent_with_user_size() const;
  void clear_launch_nested_container_sessions_under_parent_with_user();
  static const int kLaunchNestedContainerSessionsUnderParentWithUserFieldNumber = 28;
  const ::mesos::ACL_LaunchNestedContainerSessionUnderParentWithUser& launch_nested_container_sessions_under_parent_with_user(int index) const;
  ::mesos::ACL_LaunchNestedContainerSessionUnderParentWithUser* mutable_launch_nested_container_sessions_under_parent_with_user(int index);
  ::mesos::ACL_LaunchNestedContainerSessionUnderParentWithUser* add_launch_nested_container_sessions_under_parent_with_user();
  ::google::protobuf::RepeatedPtrField< ::mesos::ACL_LaunchNestedContainerSessionUnderParentWithUser >*
      mutable_launch_nested_container_sessions_under_parent_with_user();
  const ::google::protobuf::RepeatedPtrField< ::mesos::ACL_LaunchNestedContainerSessionUnderParentWithUser >&
      launch_nested_container_sessions_under_parent_with_user() const;

  // repeated .mesos.ACL.AttachContainerInput attach_containers_input = 29;
  int attach_containers_input_size() const;
  void clear_attach_containers_input();
  static const int kAttachContainersInputFieldNumber = 29;
  const ::mesos::ACL_AttachContainerInput& attach_containers_input(int index) const;
  ::mesos::ACL_AttachContainerInput* mutable_attach_containers_input(int index);
  ::mesos::ACL_AttachContainerInput* add_attach_containers_input();
  ::google::protobuf::RepeatedPtrField< ::mesos::ACL_AttachContainerInput >*
      mutable_attach_containers_input();
  const ::google::protobuf::RepeatedPtrField< ::mesos::ACL_AttachContainerInput >&
      attach_containers_input() const;

  // repeated .mesos.ACL.AttachContainerOutput attach_containers_output = 30;
  int attach_containers_output_size() const;
  void clear_attach_containers_output();
  static const int kAttachContainersOutputFieldNumber = 30;
  const ::mesos::ACL_AttachContainerOutput& attach_containers_output(int index) const;
  ::mesos::ACL_AttachContainerOutput* mutable_attach_containers_output(int index);
  ::mesos::ACL_AttachContainerOutput* add_attach_containers_output();
  ::google::protobuf::RepeatedPtrField< ::mesos::ACL_AttachContainerOutput >*
      mutable_attach_containers_output();
  const ::google::protobuf::RepeatedPtrField< ::mesos::ACL_AttachContainerOutput >&
      attach_containers_output() const;

  // repeated .mesos.ACL.ViewContainer view_containers = 31;
  int view_containers_size() const;
  void clear_view_containers();
  static const int kViewContainersFieldNumber = 31;
  const ::mesos::ACL_ViewContainer& view_containers(int index) const;
  ::mesos::ACL_ViewContainer* mutable_view_containers(int index);
  ::mesos::ACL_ViewContainer* add_view_containers();
  ::google::protobuf::RepeatedPtrField< ::mesos::ACL_ViewContainer >*
      mutable_view_containers();
  const ::google::protobuf::RepeatedPtrField< ::mesos::ACL_ViewContainer >&
      view_containers() const;

  // repeated .mesos.ACL.SetLogLevel set_log_level = 32;
  int set_log_level_size() const;
  void clear_set_log_level();
  static const int kSetLogLevelFieldNumber = 32;
  const ::mesos::ACL_SetLogLevel& set_log_level(int index) const;
  ::mesos::ACL_SetLogLevel* mutable_set_log_level(int index);
  ::mesos::ACL_SetLogLevel* add_set_log_level();
  ::google::protobuf::RepeatedPtrField< ::mesos::ACL_SetLogLevel >*
      mutable_set_log_level();
  const ::google::protobuf::RepeatedPtrField< ::mesos::ACL_SetLogLevel >&
      set_log_level() const;

  // repeated .mesos.ACL.RemoveNestedContainer remove_nested_containers = 33;
  int remove_nested_containers_size() const;
  void clear_remove_nested_containers();
  static const int kRemoveNestedContainersFieldNumber = 33;
  const ::mesos::ACL_RemoveNestedContainer& remove_nested_containers(int index) const;
  ::mesos::ACL_RemoveNestedContainer* mutable_remove_nested_containers(int index);
  ::mesos::ACL_RemoveNestedContainer* add_remove_nested_containers();
  ::google::protobuf::RepeatedPtrField< ::mesos::ACL_RemoveNestedContainer >*
      mutable_remove_nested_containers();
  const ::google::protobuf::RepeatedPtrField< ::mesos::ACL_RemoveNestedContainer >&
      remove_nested_containers() const;

  // repeated .mesos.ACL.RegisterAgent register_agents = 34;
  int register_agents_size() const;
  void clear_register_agents();
  static const int kRegisterAgentsFieldNumber = 34;
  const ::mesos::ACL_RegisterAgent& register_agents(int index) const;
  ::mesos::ACL_RegisterAgent* mutable_register_agents(int index);
  ::mesos::ACL_RegisterAgent* add_register_agents();
  ::google::protobuf::RepeatedPtrField< ::mesos::ACL_RegisterAgent >*
      mutable_register_agents();
  const ::google::protobuf::RepeatedPtrField< ::mesos::ACL_RegisterAgent >&
      register_agents() const;

  // repeated .mesos.ACL.UpdateMaintenanceSchedule update_maintenance_schedules = 35;
  int update_maintenance_schedules_size() const;
  void clear_update_maintenance_schedules();
  static const int kUpdateMaintenanceSchedulesFieldNumber = 35;
  const ::mesos::ACL_UpdateMaintenanceSchedule& update_maintenance_schedules(int index) const;
  ::mesos::ACL_UpdateMaintenanceSchedule* mutable_update_maintenance_schedules(int index);
  ::mesos::ACL_UpdateMaintenanceSchedule* add_update_maintenance_schedules();
  ::google::protobuf::RepeatedPtrField< ::mesos::ACL_UpdateMaintenanceSchedule >*
      mutable_update_maintenance_schedules();
  const ::google::protobuf::RepeatedPtrField< ::mesos::ACL_UpdateMaintenanceSchedule >&
      update_maintenance_schedules() const;

  // repeated .mesos.ACL.GetMaintenanceSchedule get_maintenance_schedules = 36;
  int get_maintenance_schedules_size() const;
  void clear_get_maintenance_schedules();
  static const int kGetMaintenanceSchedulesFieldNumber = 36;
  const ::mesos::ACL_GetMaintenanceSchedule& get_maintenance_schedules(int index) const;
  ::mesos::ACL_GetMaintenanceSchedule* mutable_get_maintenance_schedules(int index);
  ::mesos::ACL_GetMaintenanceSchedule* add_get_maintenance_schedules();
  ::google::protobuf::RepeatedPtrField< ::mesos::ACL_GetMaintenanceSchedule >*
      mutable_get_maintenance_schedules();
  const ::google::protobuf::RepeatedPtrField< ::mesos::ACL_GetMaintenanceSchedule >&
      get_maintenance_schedules() const;

  // repeated .mesos.ACL.StartMaintenance start_maintenances = 37;
  int start_maintenances_size() const;
  void clear_start_maintenances();
  static const int kStartMaintenancesFieldNumber = 37;
  const ::mesos::ACL_StartMaintenance& start_maintenances(int index) const;
  ::mesos::ACL_StartMaintenance* mutable_start_maintenances(int index);
  ::mesos::ACL_StartMaintenance* add_start_maintenances();
  ::google::protobuf::RepeatedPtrField< ::mesos::ACL_StartMaintenance >*
      mutable_start_maintenances();
  const ::google::protobuf::RepeatedPtrField< ::mesos::ACL_StartMaintenance >&
      start_maintenances() const;

  // repeated .mesos.ACL.StopMaintenance stop_maintenances = 38;
  int stop_maintenances_size() const;
  void clear_stop_maintenances();
  static const int kStopMaintenancesFieldNumber = 38;
  const ::mesos::ACL_StopMaintenance& stop_maintenances(int index) const;
  ::mesos::ACL_StopMaintenance* mutable_stop_maintenances(int index);
  ::mesos::ACL_StopMaintenance* add_stop_maintenances();
  ::google::protobuf::RepeatedPtrField< ::mesos::ACL_StopMaintenance >*
      mutable_stop_maintenances();
  const ::google::protobuf::RepeatedPtrField< ::mesos::ACL_StopMaintenance >&
      stop_maintenances() const;

  // repeated .mesos.ACL.GetMaintenanceStatus get_maintenance_statuses = 39;
  int get_maintenance_statuses_size() const;
  void clear_get_maintenance_statuses();
  static const int kGetMaintenanceStatusesFieldNumber = 39;
  const ::mesos::ACL_GetMaintenanceStatus& get_maintenance_statuses(int index) const;
  ::mesos::ACL_GetMaintenanceStatus* mutable_get_maintenance_statuses(int index);
  ::mesos::ACL_GetMaintenanceStatus* add_get_maintenance_statuses();
  ::google::protobuf::RepeatedPtrField< ::mesos::ACL_GetMaintenanceStatus >*
      mutable_get_maintenance_statuses();
  const ::google::protobuf::RepeatedPtrField< ::mesos::ACL_GetMaintenanceStatus >&
      get_maintenance_statuses() const;

  // repeated .mesos.ACL.MarkAgentGone mark_agents_gone = 40;
  int mark_agents_gone_size() const;
  void clear_mark_agents_gone();
  static const int kMarkAgentsGoneFieldNumber = 40;
  const ::mesos::ACL_MarkAgentGone& mark_agents_gone(int index) const;
  ::mesos::ACL_MarkAgentGone* mutable_mark_agents_gone(int index);
  ::mesos::ACL_MarkAgentGone* add_mark_agents_gone();
  ::google::protobuf::RepeatedPtrField< ::mesos::ACL_MarkAgentGone >*
      mutable_mark_agents_gone();
  const ::google::protobuf::RepeatedPtrField< ::mesos::ACL_MarkAgentGone >&
      mark_agents_gone() const;

  // repeated .mesos.ACL.LaunchStandaloneContainer launch_standalone_containers = 41;
  int launch_standalone_containers_size() const;
  void clear_launch_standalone_containers();
  static const int kLaunchStandaloneContainersFieldNumber = 41;
  const ::mesos::ACL_LaunchStandaloneContainer& launch_standalone_containers(int index) const;
  ::mesos::ACL_LaunchStandaloneContainer* mutable_launch_standalone_containers(int index);
  ::mesos::ACL_LaunchStandaloneContainer* add_launch_standalone_containers();
  ::google::protobuf::RepeatedPtrField< ::mesos::ACL_LaunchStandaloneContainer >*
      mutable_launch_standalone_containers();
  const ::google::protobuf::RepeatedPtrField< ::mesos::ACL_LaunchStandaloneContainer >&
      launch_standalone_containers() const;

  // repeated .mesos.ACL.KillStandaloneContainer kill_standalone_containers = 42;
  int kill_standalone_containers_size() const;
  void clear_kill_standalone_containers();
  static const int kKillStandaloneContainersFieldNumber = 42;
  const ::mesos::ACL_KillStandaloneContainer& kill_standalone_containers(int index) const;
  ::mesos::ACL_KillStandaloneContainer* mutable_kill_standalone_containers(int index);
  ::mesos::ACL_KillStandaloneContainer* add_kill_standalone_containers();
  ::google::protobuf::RepeatedPtrField< ::mesos::ACL_KillStandaloneContainer >*
      mutable_kill_standalone_containers();
  const ::google::protobuf::RepeatedPtrField< ::mesos::ACL_KillStandaloneContainer >&
      kill_standalone_containers() const;

  // repeated .mesos.ACL.WaitStandaloneContainer wait_standalone_containers = 43;
  int wait_standalone_containers_size() const;
  void clear_wait_standalone_containers();
  static const int kWaitStandaloneContainersFieldNumber = 43;
  const ::mesos::ACL_WaitStandaloneContainer& wait_standalone_containers(int index) const;
  ::mesos::ACL_WaitStandaloneContainer* mutable_wait_standalone_containers(int index);
  ::mesos::ACL_WaitStandaloneContainer* add_wait_standalone_containers();
  ::google::protobuf::RepeatedPtrField< ::mesos::ACL_WaitStandaloneContainer >*
      mutable_wait_standalone_containers();
  const ::google::protobuf::RepeatedPtrField< ::mesos::ACL_WaitStandaloneContainer >&
      wait_standalone_containers() const;

  // repeated .mesos.ACL.RemoveStandaloneContainer remove_standalone_containers = 44;
  int remove_standalone_containers_size() const;
  void clear_remove_standalone_containers();
  static const int kRemoveStandaloneContainersFieldNumber = 44;
  const ::mesos::ACL_RemoveStandaloneContainer& remove_standalone_containers(int index) const;
  ::mesos::ACL_RemoveStandaloneContainer* mutable_remove_standalone_containers(int index);
  ::mesos::ACL_RemoveStandaloneContainer* add_remove_standalone_containers();
  ::google::protobuf::RepeatedPtrField< ::mesos::ACL_RemoveStandaloneContainer >*
      mutable_remove_standalone_containers();
  const ::google::protobuf::RepeatedPtrField< ::mesos::ACL_RemoveStandaloneContainer >&
      remove_standalone_containers() const;

  // repeated .mesos.ACL.ModifyResourceProviderConfig modify_resource_provider_configs = 45;
  int modify_resource_provider_configs_size() const;
  void clear_modify_resource_provider_configs();
  static const int kModifyResourceProviderConfigsFieldNumber = 45;
  const ::mesos::ACL_ModifyResourceProviderConfig& modify_resource_provider_configs(int index) const;
  ::mesos::ACL_ModifyResourceProviderConfig* mutable_modify_resource_provider_configs(int index);
  ::mesos::ACL_ModifyResourceProviderConfig* add_modify_resource_provider_configs();
  ::google::protobuf::RepeatedPtrField< ::mesos::ACL_ModifyResourceProviderConfig >*
      mutable_modify_resource_provider_configs();
  const ::google::protobuf::RepeatedPtrField< ::mesos::ACL_ModifyResourceProviderConfig >&
      modify_resource_provider_configs() const;

  // repeated .mesos.ACL.ViewStandaloneContainer view_standalone_containers = 46;
  int view_standalone_containers_size() const;
  void clear_view_standalone_containers();
  static const int kViewStandaloneContainersFieldNumber = 46;
  const ::mesos::ACL_ViewStandaloneContainer& view_standalone_containers(int index) const;
  ::mesos::ACL_ViewStandaloneContainer* mutable_view_standalone_containers(int index);
  ::mesos::ACL_ViewStandaloneContainer* add_view_standalone_containers();
  ::google::protobuf::RepeatedPtrField< ::mesos::ACL_ViewStandaloneContainer >*
      mutable_view_standalone_containers();
  const ::google::protobuf::RepeatedPtrField< ::mesos::ACL_ViewStandaloneContainer >&
      view_standalone_containers() const;

  // repeated .mesos.ACL.PruneImages prune_images = 47;
  int prune_images_size() const;
  void clear_prune_images();
  static const int kPruneImagesFieldNumber = 47;
  const ::mesos::ACL_PruneImages& prune_images(int index) const;
  ::mesos::ACL_PruneImages* mutable_prune_images(int index);
  ::mesos::ACL_PruneImages* add_prune_images();
  ::google::protobuf::RepeatedPtrField< ::mesos::ACL_PruneImages >*
      mutable_prune_images();
  const ::google::protobuf::RepeatedPtrField< ::mesos::ACL_PruneImages >&
      prune_images() const;

  // repeated .mesos.ACL.ResizeVolume resize_volumes = 48;
  int resize_volumes_size() const;
  void clear_resize_volumes();
  static const int kResizeVolumesFieldNumber = 48;
  const ::mesos::ACL_ResizeVolume& resize_volumes(int index) const;
  ::mesos::ACL_ResizeVolume* mutable_resize_volumes(int index);
  ::mesos::ACL_ResizeVolume* add_resize_volumes();
  ::google::protobuf::RepeatedPtrField< ::mesos::ACL_ResizeVolume >*
      mutable_resize_volumes();
  const ::google::protobuf::RepeatedPtrField< ::mesos::ACL_ResizeVolume >&
      resize_volumes() const;

  // optional bool permissive = 1 [default = true];
  bool has_permissive() const;
  void clear_permissive();
  static const int kPermissiveFieldNumber = 1;
  bool permissive() const;
  void set_permissive(bool value);

  // @@protoc_insertion_point(class_scope:mesos.ACLs)
 private:
  void set_has_permissive();
  void clear_has_permissive();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::ACL_RegisterFramework > register_frameworks_;
  ::google::protobuf::RepeatedPtrField< ::mesos::ACL_RunTask > run_tasks_;
  ::google::protobuf::RepeatedPtrField< ::mesos::ACL_ReserveResources > reserve_resources_;
  ::google::protobuf::RepeatedPtrField< ::mesos::ACL_UnreserveResources > unreserve_resources_;
  ::google::protobuf::RepeatedPtrField< ::mesos::ACL_CreateVolume > create_volumes_;
  ::google::protobuf::RepeatedPtrField< ::mesos::ACL_DestroyVolume > destroy_volumes_;
  ::google::protobuf::RepeatedPtrField< ::mesos::ACL_TeardownFramework > teardown_frameworks_;
  ::google::protobuf::RepeatedPtrField< ::mesos::ACL_UpdateWeight > update_weights_;
  ::google::protobuf::RepeatedPtrField< ::mesos::ACL_GetEndpoint > get_endpoints_;
  ::google::protobuf::RepeatedPtrField< ::mesos::ACL_GetQuota > get_quotas_;
  ::google::protobuf::RepeatedPtrField< ::mesos::ACL_UpdateQuota > update_quotas_;
  ::google::protobuf::RepeatedPtrField< ::mesos::ACL_ViewFramework > view_frameworks_;
  ::google::protobuf::RepeatedPtrField< ::mesos::ACL_ViewTask > view_tasks_;
  ::google::protobuf::RepeatedPtrField< ::mesos::ACL_ViewExecutor > view_executors_;
  ::google::protobuf::RepeatedPtrField< ::mesos::ACL_AccessSandbox > access_sandboxes_;
  ::google::protobuf::RepeatedPtrField< ::mesos::ACL_AccessMesosLog > access_mesos_logs_;
  ::google::protobuf::RepeatedPtrField< ::mesos::ACL_ViewRole > view_roles_;
  ::google::protobuf::RepeatedPtrField< ::mesos::ACL_ViewFlags > view_flags_;
  ::google::protobuf::RepeatedPtrField< ::mesos::ACL_LaunchNestedContainerAsUser > launch_nested_containers_as_user_;
  ::google::protobuf::RepeatedPtrField< ::mesos::ACL_LaunchNestedContainerUnderParentWithUser > launch_nested_containers_under_parent_with_user_;
  ::google::protobuf::RepeatedPtrField< ::mesos::ACL_KillNestedContainer > kill_nested_containers_;
  ::google::protobuf::RepeatedPtrField< ::mesos::ACL_WaitNestedContainer > wait_nested_containers_;
  ::google::protobuf::RepeatedPtrField< ::mesos::ACL_LaunchNestedContainerSessionAsUser > launch_nested_container_sessions_as_user_;
  ::google::protobuf::RepeatedPtrField< ::mesos::ACL_LaunchNestedContainerSessionUnderParentWithUser > launch_nested_container_sessions_under_parent_with_user_;
  ::google::protobuf::RepeatedPtrField< ::mesos::ACL_AttachContainerInput > attach_containers_input_;
  ::google::protobuf::RepeatedPtrField< ::mesos::ACL_AttachContainerOutput > attach_containers_output_;
  ::google::protobuf::RepeatedPtrField< ::mesos::ACL_ViewContainer > view_containers_;
  ::google::protobuf::RepeatedPtrField< ::mesos::ACL_SetLogLevel > set_log_level_;
  ::google::protobuf::RepeatedPtrField< ::mesos::ACL_RemoveNestedContainer > remove_nested_containers_;
  ::google::protobuf::RepeatedPtrField< ::mesos::ACL_RegisterAgent > register_agents_;
  ::google::protobuf::RepeatedPtrField< ::mesos::ACL_UpdateMaintenanceSchedule > update_maintenance_schedules_;
  ::google::protobuf::RepeatedPtrField< ::mesos::ACL_GetMaintenanceSchedule > get_maintenance_schedules_;
  ::google::protobuf::RepeatedPtrField< ::mesos::ACL_StartMaintenance > start_maintenances_;
  ::google::protobuf::RepeatedPtrField< ::mesos::ACL_StopMaintenance > stop_maintenances_;
  ::google::protobuf::RepeatedPtrField< ::mesos::ACL_GetMaintenanceStatus > get_maintenance_statuses_;
  ::google::protobuf::RepeatedPtrField< ::mesos::ACL_MarkAgentGone > mark_agents_gone_;
  ::google::protobuf::RepeatedPtrField< ::mesos::ACL_LaunchStandaloneContainer > launch_standalone_containers_;
  ::google::protobuf::RepeatedPtrField< ::mesos::ACL_KillStandaloneContainer > kill_standalone_containers_;
  ::google::protobuf::RepeatedPtrField< ::mesos::ACL_WaitStandaloneContainer > wait_standalone_containers_;
  ::google::protobuf::RepeatedPtrField< ::mesos::ACL_RemoveStandaloneContainer > remove_standalone_containers_;
  ::google::protobuf::RepeatedPtrField< ::mesos::ACL_ModifyResourceProviderConfig > modify_resource_provider_configs_;
  ::google::protobuf::RepeatedPtrField< ::mesos::ACL_ViewStandaloneContainer > view_standalone_containers_;
  ::google::protobuf::RepeatedPtrField< ::mesos::ACL_PruneImages > prune_images_;
  ::google::protobuf::RepeatedPtrField< ::mesos::ACL_ResizeVolume > resize_volumes_;
  bool permissive_;
  friend struct ::protobuf_mesos_2fauthorizer_2facls_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fauthorizer_2facls_2eproto::InitDefaultsACLsImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ACL_Entity

// optional .mesos.ACL.Entity.Type type = 1 [default = SOME];
inline bool ACL_Entity::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACL_Entity::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACL_Entity::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACL_Entity::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::mesos::ACL_Entity_Type ACL_Entity::type() const {
  // @@protoc_insertion_point(field_get:mesos.ACL.Entity.type)
  return static_cast< ::mesos::ACL_Entity_Type >(type_);
}
inline void ACL_Entity::set_type(::mesos::ACL_Entity_Type value) {
  assert(::mesos::ACL_Entity_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:mesos.ACL.Entity.type)
}

// repeated string values = 2;
inline int ACL_Entity::values_size() const {
  return values_.size();
}
inline void ACL_Entity::clear_values() {
  values_.Clear();
}
inline const ::std::string& ACL_Entity::values(int index) const {
  // @@protoc_insertion_point(field_get:mesos.ACL.Entity.values)
  return values_.Get(index);
}
inline ::std::string* ACL_Entity::mutable_values(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.ACL.Entity.values)
  return values_.Mutable(index);
}
inline void ACL_Entity::set_values(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:mesos.ACL.Entity.values)
  values_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void ACL_Entity::set_values(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:mesos.ACL.Entity.values)
  values_.Mutable(index)->assign(std::move(value));
}
#endif
inline void ACL_Entity::set_values(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  values_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.ACL.Entity.values)
}
inline void ACL_Entity::set_values(int index, const char* value, size_t size) {
  values_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.ACL.Entity.values)
}
inline ::std::string* ACL_Entity::add_values() {
  // @@protoc_insertion_point(field_add_mutable:mesos.ACL.Entity.values)
  return values_.Add();
}
inline void ACL_Entity::add_values(const ::std::string& value) {
  values_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:mesos.ACL.Entity.values)
}
#if LANG_CXX11
inline void ACL_Entity::add_values(::std::string&& value) {
  values_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:mesos.ACL.Entity.values)
}
#endif
inline void ACL_Entity::add_values(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  values_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:mesos.ACL.Entity.values)
}
inline void ACL_Entity::add_values(const char* value, size_t size) {
  values_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:mesos.ACL.Entity.values)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ACL_Entity::values() const {
  // @@protoc_insertion_point(field_list:mesos.ACL.Entity.values)
  return values_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ACL_Entity::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:mesos.ACL.Entity.values)
  return &values_;
}

// -------------------------------------------------------------------

// ACL_RegisterFramework

// required .mesos.ACL.Entity principals = 1;
inline bool ACL_RegisterFramework::has_principals() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACL_RegisterFramework::set_has_principals() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACL_RegisterFramework::clear_has_principals() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACL_RegisterFramework::clear_principals() {
  if (principals_ != NULL) principals_->Clear();
  clear_has_principals();
}
inline const ::mesos::ACL_Entity& ACL_RegisterFramework::principals() const {
  const ::mesos::ACL_Entity* p = principals_;
  // @@protoc_insertion_point(field_get:mesos.ACL.RegisterFramework.principals)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ACL_Entity*>(
      &::mesos::_ACL_Entity_default_instance_);
}
inline ::mesos::ACL_Entity* ACL_RegisterFramework::release_principals() {
  // @@protoc_insertion_point(field_release:mesos.ACL.RegisterFramework.principals)
  clear_has_principals();
  ::mesos::ACL_Entity* temp = principals_;
  principals_ = NULL;
  return temp;
}
inline ::mesos::ACL_Entity* ACL_RegisterFramework::mutable_principals() {
  set_has_principals();
  if (principals_ == NULL) {
    principals_ = new ::mesos::ACL_Entity;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ACL.RegisterFramework.principals)
  return principals_;
}
inline void ACL_RegisterFramework::set_allocated_principals(::mesos::ACL_Entity* principals) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete principals_;
  }
  if (principals) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      principals = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, principals, submessage_arena);
    }
    set_has_principals();
  } else {
    clear_has_principals();
  }
  principals_ = principals;
  // @@protoc_insertion_point(field_set_allocated:mesos.ACL.RegisterFramework.principals)
}

// required .mesos.ACL.Entity roles = 2;
inline bool ACL_RegisterFramework::has_roles() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACL_RegisterFramework::set_has_roles() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ACL_RegisterFramework::clear_has_roles() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ACL_RegisterFramework::clear_roles() {
  if (roles_ != NULL) roles_->Clear();
  clear_has_roles();
}
inline const ::mesos::ACL_Entity& ACL_RegisterFramework::roles() const {
  const ::mesos::ACL_Entity* p = roles_;
  // @@protoc_insertion_point(field_get:mesos.ACL.RegisterFramework.roles)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ACL_Entity*>(
      &::mesos::_ACL_Entity_default_instance_);
}
inline ::mesos::ACL_Entity* ACL_RegisterFramework::release_roles() {
  // @@protoc_insertion_point(field_release:mesos.ACL.RegisterFramework.roles)
  clear_has_roles();
  ::mesos::ACL_Entity* temp = roles_;
  roles_ = NULL;
  return temp;
}
inline ::mesos::ACL_Entity* ACL_RegisterFramework::mutable_roles() {
  set_has_roles();
  if (roles_ == NULL) {
    roles_ = new ::mesos::ACL_Entity;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ACL.RegisterFramework.roles)
  return roles_;
}
inline void ACL_RegisterFramework::set_allocated_roles(::mesos::ACL_Entity* roles) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete roles_;
  }
  if (roles) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      roles = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, roles, submessage_arena);
    }
    set_has_roles();
  } else {
    clear_has_roles();
  }
  roles_ = roles;
  // @@protoc_insertion_point(field_set_allocated:mesos.ACL.RegisterFramework.roles)
}

// -------------------------------------------------------------------

// ACL_RunTask

// required .mesos.ACL.Entity principals = 1;
inline bool ACL_RunTask::has_principals() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACL_RunTask::set_has_principals() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACL_RunTask::clear_has_principals() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACL_RunTask::clear_principals() {
  if (principals_ != NULL) principals_->Clear();
  clear_has_principals();
}
inline const ::mesos::ACL_Entity& ACL_RunTask::principals() const {
  const ::mesos::ACL_Entity* p = principals_;
  // @@protoc_insertion_point(field_get:mesos.ACL.RunTask.principals)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ACL_Entity*>(
      &::mesos::_ACL_Entity_default_instance_);
}
inline ::mesos::ACL_Entity* ACL_RunTask::release_principals() {
  // @@protoc_insertion_point(field_release:mesos.ACL.RunTask.principals)
  clear_has_principals();
  ::mesos::ACL_Entity* temp = principals_;
  principals_ = NULL;
  return temp;
}
inline ::mesos::ACL_Entity* ACL_RunTask::mutable_principals() {
  set_has_principals();
  if (principals_ == NULL) {
    principals_ = new ::mesos::ACL_Entity;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ACL.RunTask.principals)
  return principals_;
}
inline void ACL_RunTask::set_allocated_principals(::mesos::ACL_Entity* principals) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete principals_;
  }
  if (principals) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      principals = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, principals, submessage_arena);
    }
    set_has_principals();
  } else {
    clear_has_principals();
  }
  principals_ = principals;
  // @@protoc_insertion_point(field_set_allocated:mesos.ACL.RunTask.principals)
}

// required .mesos.ACL.Entity users = 2;
inline bool ACL_RunTask::has_users() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACL_RunTask::set_has_users() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ACL_RunTask::clear_has_users() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ACL_RunTask::clear_users() {
  if (users_ != NULL) users_->Clear();
  clear_has_users();
}
inline const ::mesos::ACL_Entity& ACL_RunTask::users() const {
  const ::mesos::ACL_Entity* p = users_;
  // @@protoc_insertion_point(field_get:mesos.ACL.RunTask.users)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ACL_Entity*>(
      &::mesos::_ACL_Entity_default_instance_);
}
inline ::mesos::ACL_Entity* ACL_RunTask::release_users() {
  // @@protoc_insertion_point(field_release:mesos.ACL.RunTask.users)
  clear_has_users();
  ::mesos::ACL_Entity* temp = users_;
  users_ = NULL;
  return temp;
}
inline ::mesos::ACL_Entity* ACL_RunTask::mutable_users() {
  set_has_users();
  if (users_ == NULL) {
    users_ = new ::mesos::ACL_Entity;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ACL.RunTask.users)
  return users_;
}
inline void ACL_RunTask::set_allocated_users(::mesos::ACL_Entity* users) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete users_;
  }
  if (users) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      users = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, users, submessage_arena);
    }
    set_has_users();
  } else {
    clear_has_users();
  }
  users_ = users;
  // @@protoc_insertion_point(field_set_allocated:mesos.ACL.RunTask.users)
}

// -------------------------------------------------------------------

// ACL_TeardownFramework

// required .mesos.ACL.Entity principals = 1;
inline bool ACL_TeardownFramework::has_principals() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACL_TeardownFramework::set_has_principals() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACL_TeardownFramework::clear_has_principals() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACL_TeardownFramework::clear_principals() {
  if (principals_ != NULL) principals_->Clear();
  clear_has_principals();
}
inline const ::mesos::ACL_Entity& ACL_TeardownFramework::principals() const {
  const ::mesos::ACL_Entity* p = principals_;
  // @@protoc_insertion_point(field_get:mesos.ACL.TeardownFramework.principals)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ACL_Entity*>(
      &::mesos::_ACL_Entity_default_instance_);
}
inline ::mesos::ACL_Entity* ACL_TeardownFramework::release_principals() {
  // @@protoc_insertion_point(field_release:mesos.ACL.TeardownFramework.principals)
  clear_has_principals();
  ::mesos::ACL_Entity* temp = principals_;
  principals_ = NULL;
  return temp;
}
inline ::mesos::ACL_Entity* ACL_TeardownFramework::mutable_principals() {
  set_has_principals();
  if (principals_ == NULL) {
    principals_ = new ::mesos::ACL_Entity;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ACL.TeardownFramework.principals)
  return principals_;
}
inline void ACL_TeardownFramework::set_allocated_principals(::mesos::ACL_Entity* principals) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete principals_;
  }
  if (principals) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      principals = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, principals, submessage_arena);
    }
    set_has_principals();
  } else {
    clear_has_principals();
  }
  principals_ = principals;
  // @@protoc_insertion_point(field_set_allocated:mesos.ACL.TeardownFramework.principals)
}

// required .mesos.ACL.Entity framework_principals = 2;
inline bool ACL_TeardownFramework::has_framework_principals() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACL_TeardownFramework::set_has_framework_principals() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ACL_TeardownFramework::clear_has_framework_principals() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ACL_TeardownFramework::clear_framework_principals() {
  if (framework_principals_ != NULL) framework_principals_->Clear();
  clear_has_framework_principals();
}
inline const ::mesos::ACL_Entity& ACL_TeardownFramework::framework_principals() const {
  const ::mesos::ACL_Entity* p = framework_principals_;
  // @@protoc_insertion_point(field_get:mesos.ACL.TeardownFramework.framework_principals)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ACL_Entity*>(
      &::mesos::_ACL_Entity_default_instance_);
}
inline ::mesos::ACL_Entity* ACL_TeardownFramework::release_framework_principals() {
  // @@protoc_insertion_point(field_release:mesos.ACL.TeardownFramework.framework_principals)
  clear_has_framework_principals();
  ::mesos::ACL_Entity* temp = framework_principals_;
  framework_principals_ = NULL;
  return temp;
}
inline ::mesos::ACL_Entity* ACL_TeardownFramework::mutable_framework_principals() {
  set_has_framework_principals();
  if (framework_principals_ == NULL) {
    framework_principals_ = new ::mesos::ACL_Entity;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ACL.TeardownFramework.framework_principals)
  return framework_principals_;
}
inline void ACL_TeardownFramework::set_allocated_framework_principals(::mesos::ACL_Entity* framework_principals) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete framework_principals_;
  }
  if (framework_principals) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      framework_principals = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, framework_principals, submessage_arena);
    }
    set_has_framework_principals();
  } else {
    clear_has_framework_principals();
  }
  framework_principals_ = framework_principals;
  // @@protoc_insertion_point(field_set_allocated:mesos.ACL.TeardownFramework.framework_principals)
}

// -------------------------------------------------------------------

// ACL_ReserveResources

// required .mesos.ACL.Entity principals = 1;
inline bool ACL_ReserveResources::has_principals() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACL_ReserveResources::set_has_principals() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACL_ReserveResources::clear_has_principals() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACL_ReserveResources::clear_principals() {
  if (principals_ != NULL) principals_->Clear();
  clear_has_principals();
}
inline const ::mesos::ACL_Entity& ACL_ReserveResources::principals() const {
  const ::mesos::ACL_Entity* p = principals_;
  // @@protoc_insertion_point(field_get:mesos.ACL.ReserveResources.principals)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ACL_Entity*>(
      &::mesos::_ACL_Entity_default_instance_);
}
inline ::mesos::ACL_Entity* ACL_ReserveResources::release_principals() {
  // @@protoc_insertion_point(field_release:mesos.ACL.ReserveResources.principals)
  clear_has_principals();
  ::mesos::ACL_Entity* temp = principals_;
  principals_ = NULL;
  return temp;
}
inline ::mesos::ACL_Entity* ACL_ReserveResources::mutable_principals() {
  set_has_principals();
  if (principals_ == NULL) {
    principals_ = new ::mesos::ACL_Entity;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ACL.ReserveResources.principals)
  return principals_;
}
inline void ACL_ReserveResources::set_allocated_principals(::mesos::ACL_Entity* principals) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete principals_;
  }
  if (principals) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      principals = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, principals, submessage_arena);
    }
    set_has_principals();
  } else {
    clear_has_principals();
  }
  principals_ = principals;
  // @@protoc_insertion_point(field_set_allocated:mesos.ACL.ReserveResources.principals)
}

// required .mesos.ACL.Entity roles = 2;
inline bool ACL_ReserveResources::has_roles() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACL_ReserveResources::set_has_roles() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ACL_ReserveResources::clear_has_roles() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ACL_ReserveResources::clear_roles() {
  if (roles_ != NULL) roles_->Clear();
  clear_has_roles();
}
inline const ::mesos::ACL_Entity& ACL_ReserveResources::roles() const {
  const ::mesos::ACL_Entity* p = roles_;
  // @@protoc_insertion_point(field_get:mesos.ACL.ReserveResources.roles)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ACL_Entity*>(
      &::mesos::_ACL_Entity_default_instance_);
}
inline ::mesos::ACL_Entity* ACL_ReserveResources::release_roles() {
  // @@protoc_insertion_point(field_release:mesos.ACL.ReserveResources.roles)
  clear_has_roles();
  ::mesos::ACL_Entity* temp = roles_;
  roles_ = NULL;
  return temp;
}
inline ::mesos::ACL_Entity* ACL_ReserveResources::mutable_roles() {
  set_has_roles();
  if (roles_ == NULL) {
    roles_ = new ::mesos::ACL_Entity;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ACL.ReserveResources.roles)
  return roles_;
}
inline void ACL_ReserveResources::set_allocated_roles(::mesos::ACL_Entity* roles) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete roles_;
  }
  if (roles) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      roles = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, roles, submessage_arena);
    }
    set_has_roles();
  } else {
    clear_has_roles();
  }
  roles_ = roles;
  // @@protoc_insertion_point(field_set_allocated:mesos.ACL.ReserveResources.roles)
}

// -------------------------------------------------------------------

// ACL_UnreserveResources

// required .mesos.ACL.Entity principals = 1;
inline bool ACL_UnreserveResources::has_principals() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACL_UnreserveResources::set_has_principals() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACL_UnreserveResources::clear_has_principals() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACL_UnreserveResources::clear_principals() {
  if (principals_ != NULL) principals_->Clear();
  clear_has_principals();
}
inline const ::mesos::ACL_Entity& ACL_UnreserveResources::principals() const {
  const ::mesos::ACL_Entity* p = principals_;
  // @@protoc_insertion_point(field_get:mesos.ACL.UnreserveResources.principals)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ACL_Entity*>(
      &::mesos::_ACL_Entity_default_instance_);
}
inline ::mesos::ACL_Entity* ACL_UnreserveResources::release_principals() {
  // @@protoc_insertion_point(field_release:mesos.ACL.UnreserveResources.principals)
  clear_has_principals();
  ::mesos::ACL_Entity* temp = principals_;
  principals_ = NULL;
  return temp;
}
inline ::mesos::ACL_Entity* ACL_UnreserveResources::mutable_principals() {
  set_has_principals();
  if (principals_ == NULL) {
    principals_ = new ::mesos::ACL_Entity;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ACL.UnreserveResources.principals)
  return principals_;
}
inline void ACL_UnreserveResources::set_allocated_principals(::mesos::ACL_Entity* principals) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete principals_;
  }
  if (principals) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      principals = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, principals, submessage_arena);
    }
    set_has_principals();
  } else {
    clear_has_principals();
  }
  principals_ = principals;
  // @@protoc_insertion_point(field_set_allocated:mesos.ACL.UnreserveResources.principals)
}

// required .mesos.ACL.Entity reserver_principals = 2;
inline bool ACL_UnreserveResources::has_reserver_principals() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACL_UnreserveResources::set_has_reserver_principals() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ACL_UnreserveResources::clear_has_reserver_principals() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ACL_UnreserveResources::clear_reserver_principals() {
  if (reserver_principals_ != NULL) reserver_principals_->Clear();
  clear_has_reserver_principals();
}
inline const ::mesos::ACL_Entity& ACL_UnreserveResources::reserver_principals() const {
  const ::mesos::ACL_Entity* p = reserver_principals_;
  // @@protoc_insertion_point(field_get:mesos.ACL.UnreserveResources.reserver_principals)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ACL_Entity*>(
      &::mesos::_ACL_Entity_default_instance_);
}
inline ::mesos::ACL_Entity* ACL_UnreserveResources::release_reserver_principals() {
  // @@protoc_insertion_point(field_release:mesos.ACL.UnreserveResources.reserver_principals)
  clear_has_reserver_principals();
  ::mesos::ACL_Entity* temp = reserver_principals_;
  reserver_principals_ = NULL;
  return temp;
}
inline ::mesos::ACL_Entity* ACL_UnreserveResources::mutable_reserver_principals() {
  set_has_reserver_principals();
  if (reserver_principals_ == NULL) {
    reserver_principals_ = new ::mesos::ACL_Entity;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ACL.UnreserveResources.reserver_principals)
  return reserver_principals_;
}
inline void ACL_UnreserveResources::set_allocated_reserver_principals(::mesos::ACL_Entity* reserver_principals) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reserver_principals_;
  }
  if (reserver_principals) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      reserver_principals = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, reserver_principals, submessage_arena);
    }
    set_has_reserver_principals();
  } else {
    clear_has_reserver_principals();
  }
  reserver_principals_ = reserver_principals;
  // @@protoc_insertion_point(field_set_allocated:mesos.ACL.UnreserveResources.reserver_principals)
}

// -------------------------------------------------------------------

// ACL_CreateVolume

// required .mesos.ACL.Entity principals = 1;
inline bool ACL_CreateVolume::has_principals() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACL_CreateVolume::set_has_principals() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACL_CreateVolume::clear_has_principals() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACL_CreateVolume::clear_principals() {
  if (principals_ != NULL) principals_->Clear();
  clear_has_principals();
}
inline const ::mesos::ACL_Entity& ACL_CreateVolume::principals() const {
  const ::mesos::ACL_Entity* p = principals_;
  // @@protoc_insertion_point(field_get:mesos.ACL.CreateVolume.principals)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ACL_Entity*>(
      &::mesos::_ACL_Entity_default_instance_);
}
inline ::mesos::ACL_Entity* ACL_CreateVolume::release_principals() {
  // @@protoc_insertion_point(field_release:mesos.ACL.CreateVolume.principals)
  clear_has_principals();
  ::mesos::ACL_Entity* temp = principals_;
  principals_ = NULL;
  return temp;
}
inline ::mesos::ACL_Entity* ACL_CreateVolume::mutable_principals() {
  set_has_principals();
  if (principals_ == NULL) {
    principals_ = new ::mesos::ACL_Entity;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ACL.CreateVolume.principals)
  return principals_;
}
inline void ACL_CreateVolume::set_allocated_principals(::mesos::ACL_Entity* principals) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete principals_;
  }
  if (principals) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      principals = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, principals, submessage_arena);
    }
    set_has_principals();
  } else {
    clear_has_principals();
  }
  principals_ = principals;
  // @@protoc_insertion_point(field_set_allocated:mesos.ACL.CreateVolume.principals)
}

// required .mesos.ACL.Entity roles = 2;
inline bool ACL_CreateVolume::has_roles() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACL_CreateVolume::set_has_roles() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ACL_CreateVolume::clear_has_roles() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ACL_CreateVolume::clear_roles() {
  if (roles_ != NULL) roles_->Clear();
  clear_has_roles();
}
inline const ::mesos::ACL_Entity& ACL_CreateVolume::roles() const {
  const ::mesos::ACL_Entity* p = roles_;
  // @@protoc_insertion_point(field_get:mesos.ACL.CreateVolume.roles)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ACL_Entity*>(
      &::mesos::_ACL_Entity_default_instance_);
}
inline ::mesos::ACL_Entity* ACL_CreateVolume::release_roles() {
  // @@protoc_insertion_point(field_release:mesos.ACL.CreateVolume.roles)
  clear_has_roles();
  ::mesos::ACL_Entity* temp = roles_;
  roles_ = NULL;
  return temp;
}
inline ::mesos::ACL_Entity* ACL_CreateVolume::mutable_roles() {
  set_has_roles();
  if (roles_ == NULL) {
    roles_ = new ::mesos::ACL_Entity;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ACL.CreateVolume.roles)
  return roles_;
}
inline void ACL_CreateVolume::set_allocated_roles(::mesos::ACL_Entity* roles) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete roles_;
  }
  if (roles) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      roles = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, roles, submessage_arena);
    }
    set_has_roles();
  } else {
    clear_has_roles();
  }
  roles_ = roles;
  // @@protoc_insertion_point(field_set_allocated:mesos.ACL.CreateVolume.roles)
}

// -------------------------------------------------------------------

// ACL_DestroyVolume

// required .mesos.ACL.Entity principals = 1;
inline bool ACL_DestroyVolume::has_principals() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACL_DestroyVolume::set_has_principals() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACL_DestroyVolume::clear_has_principals() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACL_DestroyVolume::clear_principals() {
  if (principals_ != NULL) principals_->Clear();
  clear_has_principals();
}
inline const ::mesos::ACL_Entity& ACL_DestroyVolume::principals() const {
  const ::mesos::ACL_Entity* p = principals_;
  // @@protoc_insertion_point(field_get:mesos.ACL.DestroyVolume.principals)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ACL_Entity*>(
      &::mesos::_ACL_Entity_default_instance_);
}
inline ::mesos::ACL_Entity* ACL_DestroyVolume::release_principals() {
  // @@protoc_insertion_point(field_release:mesos.ACL.DestroyVolume.principals)
  clear_has_principals();
  ::mesos::ACL_Entity* temp = principals_;
  principals_ = NULL;
  return temp;
}
inline ::mesos::ACL_Entity* ACL_DestroyVolume::mutable_principals() {
  set_has_principals();
  if (principals_ == NULL) {
    principals_ = new ::mesos::ACL_Entity;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ACL.DestroyVolume.principals)
  return principals_;
}
inline void ACL_DestroyVolume::set_allocated_principals(::mesos::ACL_Entity* principals) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete principals_;
  }
  if (principals) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      principals = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, principals, submessage_arena);
    }
    set_has_principals();
  } else {
    clear_has_principals();
  }
  principals_ = principals;
  // @@protoc_insertion_point(field_set_allocated:mesos.ACL.DestroyVolume.principals)
}

// required .mesos.ACL.Entity creator_principals = 2;
inline bool ACL_DestroyVolume::has_creator_principals() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACL_DestroyVolume::set_has_creator_principals() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ACL_DestroyVolume::clear_has_creator_principals() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ACL_DestroyVolume::clear_creator_principals() {
  if (creator_principals_ != NULL) creator_principals_->Clear();
  clear_has_creator_principals();
}
inline const ::mesos::ACL_Entity& ACL_DestroyVolume::creator_principals() const {
  const ::mesos::ACL_Entity* p = creator_principals_;
  // @@protoc_insertion_point(field_get:mesos.ACL.DestroyVolume.creator_principals)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ACL_Entity*>(
      &::mesos::_ACL_Entity_default_instance_);
}
inline ::mesos::ACL_Entity* ACL_DestroyVolume::release_creator_principals() {
  // @@protoc_insertion_point(field_release:mesos.ACL.DestroyVolume.creator_principals)
  clear_has_creator_principals();
  ::mesos::ACL_Entity* temp = creator_principals_;
  creator_principals_ = NULL;
  return temp;
}
inline ::mesos::ACL_Entity* ACL_DestroyVolume::mutable_creator_principals() {
  set_has_creator_principals();
  if (creator_principals_ == NULL) {
    creator_principals_ = new ::mesos::ACL_Entity;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ACL.DestroyVolume.creator_principals)
  return creator_principals_;
}
inline void ACL_DestroyVolume::set_allocated_creator_principals(::mesos::ACL_Entity* creator_principals) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete creator_principals_;
  }
  if (creator_principals) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      creator_principals = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, creator_principals, submessage_arena);
    }
    set_has_creator_principals();
  } else {
    clear_has_creator_principals();
  }
  creator_principals_ = creator_principals;
  // @@protoc_insertion_point(field_set_allocated:mesos.ACL.DestroyVolume.creator_principals)
}

// -------------------------------------------------------------------

// ACL_ResizeVolume

// required .mesos.ACL.Entity principals = 1;
inline bool ACL_ResizeVolume::has_principals() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACL_ResizeVolume::set_has_principals() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACL_ResizeVolume::clear_has_principals() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACL_ResizeVolume::clear_principals() {
  if (principals_ != NULL) principals_->Clear();
  clear_has_principals();
}
inline const ::mesos::ACL_Entity& ACL_ResizeVolume::principals() const {
  const ::mesos::ACL_Entity* p = principals_;
  // @@protoc_insertion_point(field_get:mesos.ACL.ResizeVolume.principals)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ACL_Entity*>(
      &::mesos::_ACL_Entity_default_instance_);
}
inline ::mesos::ACL_Entity* ACL_ResizeVolume::release_principals() {
  // @@protoc_insertion_point(field_release:mesos.ACL.ResizeVolume.principals)
  clear_has_principals();
  ::mesos::ACL_Entity* temp = principals_;
  principals_ = NULL;
  return temp;
}
inline ::mesos::ACL_Entity* ACL_ResizeVolume::mutable_principals() {
  set_has_principals();
  if (principals_ == NULL) {
    principals_ = new ::mesos::ACL_Entity;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ACL.ResizeVolume.principals)
  return principals_;
}
inline void ACL_ResizeVolume::set_allocated_principals(::mesos::ACL_Entity* principals) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete principals_;
  }
  if (principals) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      principals = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, principals, submessage_arena);
    }
    set_has_principals();
  } else {
    clear_has_principals();
  }
  principals_ = principals;
  // @@protoc_insertion_point(field_set_allocated:mesos.ACL.ResizeVolume.principals)
}

// required .mesos.ACL.Entity roles = 2;
inline bool ACL_ResizeVolume::has_roles() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACL_ResizeVolume::set_has_roles() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ACL_ResizeVolume::clear_has_roles() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ACL_ResizeVolume::clear_roles() {
  if (roles_ != NULL) roles_->Clear();
  clear_has_roles();
}
inline const ::mesos::ACL_Entity& ACL_ResizeVolume::roles() const {
  const ::mesos::ACL_Entity* p = roles_;
  // @@protoc_insertion_point(field_get:mesos.ACL.ResizeVolume.roles)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ACL_Entity*>(
      &::mesos::_ACL_Entity_default_instance_);
}
inline ::mesos::ACL_Entity* ACL_ResizeVolume::release_roles() {
  // @@protoc_insertion_point(field_release:mesos.ACL.ResizeVolume.roles)
  clear_has_roles();
  ::mesos::ACL_Entity* temp = roles_;
  roles_ = NULL;
  return temp;
}
inline ::mesos::ACL_Entity* ACL_ResizeVolume::mutable_roles() {
  set_has_roles();
  if (roles_ == NULL) {
    roles_ = new ::mesos::ACL_Entity;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ACL.ResizeVolume.roles)
  return roles_;
}
inline void ACL_ResizeVolume::set_allocated_roles(::mesos::ACL_Entity* roles) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete roles_;
  }
  if (roles) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      roles = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, roles, submessage_arena);
    }
    set_has_roles();
  } else {
    clear_has_roles();
  }
  roles_ = roles;
  // @@protoc_insertion_point(field_set_allocated:mesos.ACL.ResizeVolume.roles)
}

// -------------------------------------------------------------------

// ACL_GetQuota

// required .mesos.ACL.Entity principals = 1;
inline bool ACL_GetQuota::has_principals() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACL_GetQuota::set_has_principals() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACL_GetQuota::clear_has_principals() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACL_GetQuota::clear_principals() {
  if (principals_ != NULL) principals_->Clear();
  clear_has_principals();
}
inline const ::mesos::ACL_Entity& ACL_GetQuota::principals() const {
  const ::mesos::ACL_Entity* p = principals_;
  // @@protoc_insertion_point(field_get:mesos.ACL.GetQuota.principals)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ACL_Entity*>(
      &::mesos::_ACL_Entity_default_instance_);
}
inline ::mesos::ACL_Entity* ACL_GetQuota::release_principals() {
  // @@protoc_insertion_point(field_release:mesos.ACL.GetQuota.principals)
  clear_has_principals();
  ::mesos::ACL_Entity* temp = principals_;
  principals_ = NULL;
  return temp;
}
inline ::mesos::ACL_Entity* ACL_GetQuota::mutable_principals() {
  set_has_principals();
  if (principals_ == NULL) {
    principals_ = new ::mesos::ACL_Entity;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ACL.GetQuota.principals)
  return principals_;
}
inline void ACL_GetQuota::set_allocated_principals(::mesos::ACL_Entity* principals) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete principals_;
  }
  if (principals) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      principals = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, principals, submessage_arena);
    }
    set_has_principals();
  } else {
    clear_has_principals();
  }
  principals_ = principals;
  // @@protoc_insertion_point(field_set_allocated:mesos.ACL.GetQuota.principals)
}

// required .mesos.ACL.Entity roles = 2;
inline bool ACL_GetQuota::has_roles() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACL_GetQuota::set_has_roles() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ACL_GetQuota::clear_has_roles() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ACL_GetQuota::clear_roles() {
  if (roles_ != NULL) roles_->Clear();
  clear_has_roles();
}
inline const ::mesos::ACL_Entity& ACL_GetQuota::roles() const {
  const ::mesos::ACL_Entity* p = roles_;
  // @@protoc_insertion_point(field_get:mesos.ACL.GetQuota.roles)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ACL_Entity*>(
      &::mesos::_ACL_Entity_default_instance_);
}
inline ::mesos::ACL_Entity* ACL_GetQuota::release_roles() {
  // @@protoc_insertion_point(field_release:mesos.ACL.GetQuota.roles)
  clear_has_roles();
  ::mesos::ACL_Entity* temp = roles_;
  roles_ = NULL;
  return temp;
}
inline ::mesos::ACL_Entity* ACL_GetQuota::mutable_roles() {
  set_has_roles();
  if (roles_ == NULL) {
    roles_ = new ::mesos::ACL_Entity;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ACL.GetQuota.roles)
  return roles_;
}
inline void ACL_GetQuota::set_allocated_roles(::mesos::ACL_Entity* roles) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete roles_;
  }
  if (roles) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      roles = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, roles, submessage_arena);
    }
    set_has_roles();
  } else {
    clear_has_roles();
  }
  roles_ = roles;
  // @@protoc_insertion_point(field_set_allocated:mesos.ACL.GetQuota.roles)
}

// -------------------------------------------------------------------

// ACL_UpdateQuota

// required .mesos.ACL.Entity principals = 1;
inline bool ACL_UpdateQuota::has_principals() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACL_UpdateQuota::set_has_principals() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACL_UpdateQuota::clear_has_principals() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACL_UpdateQuota::clear_principals() {
  if (principals_ != NULL) principals_->Clear();
  clear_has_principals();
}
inline const ::mesos::ACL_Entity& ACL_UpdateQuota::principals() const {
  const ::mesos::ACL_Entity* p = principals_;
  // @@protoc_insertion_point(field_get:mesos.ACL.UpdateQuota.principals)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ACL_Entity*>(
      &::mesos::_ACL_Entity_default_instance_);
}
inline ::mesos::ACL_Entity* ACL_UpdateQuota::release_principals() {
  // @@protoc_insertion_point(field_release:mesos.ACL.UpdateQuota.principals)
  clear_has_principals();
  ::mesos::ACL_Entity* temp = principals_;
  principals_ = NULL;
  return temp;
}
inline ::mesos::ACL_Entity* ACL_UpdateQuota::mutable_principals() {
  set_has_principals();
  if (principals_ == NULL) {
    principals_ = new ::mesos::ACL_Entity;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ACL.UpdateQuota.principals)
  return principals_;
}
inline void ACL_UpdateQuota::set_allocated_principals(::mesos::ACL_Entity* principals) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete principals_;
  }
  if (principals) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      principals = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, principals, submessage_arena);
    }
    set_has_principals();
  } else {
    clear_has_principals();
  }
  principals_ = principals;
  // @@protoc_insertion_point(field_set_allocated:mesos.ACL.UpdateQuota.principals)
}

// required .mesos.ACL.Entity roles = 2;
inline bool ACL_UpdateQuota::has_roles() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACL_UpdateQuota::set_has_roles() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ACL_UpdateQuota::clear_has_roles() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ACL_UpdateQuota::clear_roles() {
  if (roles_ != NULL) roles_->Clear();
  clear_has_roles();
}
inline const ::mesos::ACL_Entity& ACL_UpdateQuota::roles() const {
  const ::mesos::ACL_Entity* p = roles_;
  // @@protoc_insertion_point(field_get:mesos.ACL.UpdateQuota.roles)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ACL_Entity*>(
      &::mesos::_ACL_Entity_default_instance_);
}
inline ::mesos::ACL_Entity* ACL_UpdateQuota::release_roles() {
  // @@protoc_insertion_point(field_release:mesos.ACL.UpdateQuota.roles)
  clear_has_roles();
  ::mesos::ACL_Entity* temp = roles_;
  roles_ = NULL;
  return temp;
}
inline ::mesos::ACL_Entity* ACL_UpdateQuota::mutable_roles() {
  set_has_roles();
  if (roles_ == NULL) {
    roles_ = new ::mesos::ACL_Entity;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ACL.UpdateQuota.roles)
  return roles_;
}
inline void ACL_UpdateQuota::set_allocated_roles(::mesos::ACL_Entity* roles) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete roles_;
  }
  if (roles) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      roles = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, roles, submessage_arena);
    }
    set_has_roles();
  } else {
    clear_has_roles();
  }
  roles_ = roles;
  // @@protoc_insertion_point(field_set_allocated:mesos.ACL.UpdateQuota.roles)
}

// -------------------------------------------------------------------

// ACL_ViewRole

// required .mesos.ACL.Entity principals = 1;
inline bool ACL_ViewRole::has_principals() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACL_ViewRole::set_has_principals() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACL_ViewRole::clear_has_principals() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACL_ViewRole::clear_principals() {
  if (principals_ != NULL) principals_->Clear();
  clear_has_principals();
}
inline const ::mesos::ACL_Entity& ACL_ViewRole::principals() const {
  const ::mesos::ACL_Entity* p = principals_;
  // @@protoc_insertion_point(field_get:mesos.ACL.ViewRole.principals)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ACL_Entity*>(
      &::mesos::_ACL_Entity_default_instance_);
}
inline ::mesos::ACL_Entity* ACL_ViewRole::release_principals() {
  // @@protoc_insertion_point(field_release:mesos.ACL.ViewRole.principals)
  clear_has_principals();
  ::mesos::ACL_Entity* temp = principals_;
  principals_ = NULL;
  return temp;
}
inline ::mesos::ACL_Entity* ACL_ViewRole::mutable_principals() {
  set_has_principals();
  if (principals_ == NULL) {
    principals_ = new ::mesos::ACL_Entity;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ACL.ViewRole.principals)
  return principals_;
}
inline void ACL_ViewRole::set_allocated_principals(::mesos::ACL_Entity* principals) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete principals_;
  }
  if (principals) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      principals = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, principals, submessage_arena);
    }
    set_has_principals();
  } else {
    clear_has_principals();
  }
  principals_ = principals;
  // @@protoc_insertion_point(field_set_allocated:mesos.ACL.ViewRole.principals)
}

// required .mesos.ACL.Entity roles = 2;
inline bool ACL_ViewRole::has_roles() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACL_ViewRole::set_has_roles() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ACL_ViewRole::clear_has_roles() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ACL_ViewRole::clear_roles() {
  if (roles_ != NULL) roles_->Clear();
  clear_has_roles();
}
inline const ::mesos::ACL_Entity& ACL_ViewRole::roles() const {
  const ::mesos::ACL_Entity* p = roles_;
  // @@protoc_insertion_point(field_get:mesos.ACL.ViewRole.roles)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ACL_Entity*>(
      &::mesos::_ACL_Entity_default_instance_);
}
inline ::mesos::ACL_Entity* ACL_ViewRole::release_roles() {
  // @@protoc_insertion_point(field_release:mesos.ACL.ViewRole.roles)
  clear_has_roles();
  ::mesos::ACL_Entity* temp = roles_;
  roles_ = NULL;
  return temp;
}
inline ::mesos::ACL_Entity* ACL_ViewRole::mutable_roles() {
  set_has_roles();
  if (roles_ == NULL) {
    roles_ = new ::mesos::ACL_Entity;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ACL.ViewRole.roles)
  return roles_;
}
inline void ACL_ViewRole::set_allocated_roles(::mesos::ACL_Entity* roles) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete roles_;
  }
  if (roles) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      roles = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, roles, submessage_arena);
    }
    set_has_roles();
  } else {
    clear_has_roles();
  }
  roles_ = roles;
  // @@protoc_insertion_point(field_set_allocated:mesos.ACL.ViewRole.roles)
}

// -------------------------------------------------------------------

// ACL_UpdateWeight

// required .mesos.ACL.Entity principals = 1;
inline bool ACL_UpdateWeight::has_principals() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACL_UpdateWeight::set_has_principals() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACL_UpdateWeight::clear_has_principals() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACL_UpdateWeight::clear_principals() {
  if (principals_ != NULL) principals_->Clear();
  clear_has_principals();
}
inline const ::mesos::ACL_Entity& ACL_UpdateWeight::principals() const {
  const ::mesos::ACL_Entity* p = principals_;
  // @@protoc_insertion_point(field_get:mesos.ACL.UpdateWeight.principals)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ACL_Entity*>(
      &::mesos::_ACL_Entity_default_instance_);
}
inline ::mesos::ACL_Entity* ACL_UpdateWeight::release_principals() {
  // @@protoc_insertion_point(field_release:mesos.ACL.UpdateWeight.principals)
  clear_has_principals();
  ::mesos::ACL_Entity* temp = principals_;
  principals_ = NULL;
  return temp;
}
inline ::mesos::ACL_Entity* ACL_UpdateWeight::mutable_principals() {
  set_has_principals();
  if (principals_ == NULL) {
    principals_ = new ::mesos::ACL_Entity;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ACL.UpdateWeight.principals)
  return principals_;
}
inline void ACL_UpdateWeight::set_allocated_principals(::mesos::ACL_Entity* principals) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete principals_;
  }
  if (principals) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      principals = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, principals, submessage_arena);
    }
    set_has_principals();
  } else {
    clear_has_principals();
  }
  principals_ = principals;
  // @@protoc_insertion_point(field_set_allocated:mesos.ACL.UpdateWeight.principals)
}

// required .mesos.ACL.Entity roles = 2;
inline bool ACL_UpdateWeight::has_roles() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACL_UpdateWeight::set_has_roles() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ACL_UpdateWeight::clear_has_roles() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ACL_UpdateWeight::clear_roles() {
  if (roles_ != NULL) roles_->Clear();
  clear_has_roles();
}
inline const ::mesos::ACL_Entity& ACL_UpdateWeight::roles() const {
  const ::mesos::ACL_Entity* p = roles_;
  // @@protoc_insertion_point(field_get:mesos.ACL.UpdateWeight.roles)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ACL_Entity*>(
      &::mesos::_ACL_Entity_default_instance_);
}
inline ::mesos::ACL_Entity* ACL_UpdateWeight::release_roles() {
  // @@protoc_insertion_point(field_release:mesos.ACL.UpdateWeight.roles)
  clear_has_roles();
  ::mesos::ACL_Entity* temp = roles_;
  roles_ = NULL;
  return temp;
}
inline ::mesos::ACL_Entity* ACL_UpdateWeight::mutable_roles() {
  set_has_roles();
  if (roles_ == NULL) {
    roles_ = new ::mesos::ACL_Entity;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ACL.UpdateWeight.roles)
  return roles_;
}
inline void ACL_UpdateWeight::set_allocated_roles(::mesos::ACL_Entity* roles) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete roles_;
  }
  if (roles) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      roles = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, roles, submessage_arena);
    }
    set_has_roles();
  } else {
    clear_has_roles();
  }
  roles_ = roles;
  // @@protoc_insertion_point(field_set_allocated:mesos.ACL.UpdateWeight.roles)
}

// -------------------------------------------------------------------

// ACL_GetEndpoint

// required .mesos.ACL.Entity principals = 1;
inline bool ACL_GetEndpoint::has_principals() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACL_GetEndpoint::set_has_principals() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACL_GetEndpoint::clear_has_principals() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACL_GetEndpoint::clear_principals() {
  if (principals_ != NULL) principals_->Clear();
  clear_has_principals();
}
inline const ::mesos::ACL_Entity& ACL_GetEndpoint::principals() const {
  const ::mesos::ACL_Entity* p = principals_;
  // @@protoc_insertion_point(field_get:mesos.ACL.GetEndpoint.principals)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ACL_Entity*>(
      &::mesos::_ACL_Entity_default_instance_);
}
inline ::mesos::ACL_Entity* ACL_GetEndpoint::release_principals() {
  // @@protoc_insertion_point(field_release:mesos.ACL.GetEndpoint.principals)
  clear_has_principals();
  ::mesos::ACL_Entity* temp = principals_;
  principals_ = NULL;
  return temp;
}
inline ::mesos::ACL_Entity* ACL_GetEndpoint::mutable_principals() {
  set_has_principals();
  if (principals_ == NULL) {
    principals_ = new ::mesos::ACL_Entity;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ACL.GetEndpoint.principals)
  return principals_;
}
inline void ACL_GetEndpoint::set_allocated_principals(::mesos::ACL_Entity* principals) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete principals_;
  }
  if (principals) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      principals = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, principals, submessage_arena);
    }
    set_has_principals();
  } else {
    clear_has_principals();
  }
  principals_ = principals;
  // @@protoc_insertion_point(field_set_allocated:mesos.ACL.GetEndpoint.principals)
}

// required .mesos.ACL.Entity paths = 2;
inline bool ACL_GetEndpoint::has_paths() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACL_GetEndpoint::set_has_paths() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ACL_GetEndpoint::clear_has_paths() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ACL_GetEndpoint::clear_paths() {
  if (paths_ != NULL) paths_->Clear();
  clear_has_paths();
}
inline const ::mesos::ACL_Entity& ACL_GetEndpoint::paths() const {
  const ::mesos::ACL_Entity* p = paths_;
  // @@protoc_insertion_point(field_get:mesos.ACL.GetEndpoint.paths)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ACL_Entity*>(
      &::mesos::_ACL_Entity_default_instance_);
}
inline ::mesos::ACL_Entity* ACL_GetEndpoint::release_paths() {
  // @@protoc_insertion_point(field_release:mesos.ACL.GetEndpoint.paths)
  clear_has_paths();
  ::mesos::ACL_Entity* temp = paths_;
  paths_ = NULL;
  return temp;
}
inline ::mesos::ACL_Entity* ACL_GetEndpoint::mutable_paths() {
  set_has_paths();
  if (paths_ == NULL) {
    paths_ = new ::mesos::ACL_Entity;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ACL.GetEndpoint.paths)
  return paths_;
}
inline void ACL_GetEndpoint::set_allocated_paths(::mesos::ACL_Entity* paths) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete paths_;
  }
  if (paths) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      paths = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, paths, submessage_arena);
    }
    set_has_paths();
  } else {
    clear_has_paths();
  }
  paths_ = paths;
  // @@protoc_insertion_point(field_set_allocated:mesos.ACL.GetEndpoint.paths)
}

// -------------------------------------------------------------------

// ACL_ViewFramework

// required .mesos.ACL.Entity principals = 1;
inline bool ACL_ViewFramework::has_principals() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACL_ViewFramework::set_has_principals() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACL_ViewFramework::clear_has_principals() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACL_ViewFramework::clear_principals() {
  if (principals_ != NULL) principals_->Clear();
  clear_has_principals();
}
inline const ::mesos::ACL_Entity& ACL_ViewFramework::principals() const {
  const ::mesos::ACL_Entity* p = principals_;
  // @@protoc_insertion_point(field_get:mesos.ACL.ViewFramework.principals)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ACL_Entity*>(
      &::mesos::_ACL_Entity_default_instance_);
}
inline ::mesos::ACL_Entity* ACL_ViewFramework::release_principals() {
  // @@protoc_insertion_point(field_release:mesos.ACL.ViewFramework.principals)
  clear_has_principals();
  ::mesos::ACL_Entity* temp = principals_;
  principals_ = NULL;
  return temp;
}
inline ::mesos::ACL_Entity* ACL_ViewFramework::mutable_principals() {
  set_has_principals();
  if (principals_ == NULL) {
    principals_ = new ::mesos::ACL_Entity;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ACL.ViewFramework.principals)
  return principals_;
}
inline void ACL_ViewFramework::set_allocated_principals(::mesos::ACL_Entity* principals) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete principals_;
  }
  if (principals) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      principals = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, principals, submessage_arena);
    }
    set_has_principals();
  } else {
    clear_has_principals();
  }
  principals_ = principals;
  // @@protoc_insertion_point(field_set_allocated:mesos.ACL.ViewFramework.principals)
}

// required .mesos.ACL.Entity users = 2;
inline bool ACL_ViewFramework::has_users() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACL_ViewFramework::set_has_users() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ACL_ViewFramework::clear_has_users() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ACL_ViewFramework::clear_users() {
  if (users_ != NULL) users_->Clear();
  clear_has_users();
}
inline const ::mesos::ACL_Entity& ACL_ViewFramework::users() const {
  const ::mesos::ACL_Entity* p = users_;
  // @@protoc_insertion_point(field_get:mesos.ACL.ViewFramework.users)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ACL_Entity*>(
      &::mesos::_ACL_Entity_default_instance_);
}
inline ::mesos::ACL_Entity* ACL_ViewFramework::release_users() {
  // @@protoc_insertion_point(field_release:mesos.ACL.ViewFramework.users)
  clear_has_users();
  ::mesos::ACL_Entity* temp = users_;
  users_ = NULL;
  return temp;
}
inline ::mesos::ACL_Entity* ACL_ViewFramework::mutable_users() {
  set_has_users();
  if (users_ == NULL) {
    users_ = new ::mesos::ACL_Entity;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ACL.ViewFramework.users)
  return users_;
}
inline void ACL_ViewFramework::set_allocated_users(::mesos::ACL_Entity* users) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete users_;
  }
  if (users) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      users = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, users, submessage_arena);
    }
    set_has_users();
  } else {
    clear_has_users();
  }
  users_ = users;
  // @@protoc_insertion_point(field_set_allocated:mesos.ACL.ViewFramework.users)
}

// -------------------------------------------------------------------

// ACL_ViewTask

// required .mesos.ACL.Entity principals = 1;
inline bool ACL_ViewTask::has_principals() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACL_ViewTask::set_has_principals() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACL_ViewTask::clear_has_principals() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACL_ViewTask::clear_principals() {
  if (principals_ != NULL) principals_->Clear();
  clear_has_principals();
}
inline const ::mesos::ACL_Entity& ACL_ViewTask::principals() const {
  const ::mesos::ACL_Entity* p = principals_;
  // @@protoc_insertion_point(field_get:mesos.ACL.ViewTask.principals)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ACL_Entity*>(
      &::mesos::_ACL_Entity_default_instance_);
}
inline ::mesos::ACL_Entity* ACL_ViewTask::release_principals() {
  // @@protoc_insertion_point(field_release:mesos.ACL.ViewTask.principals)
  clear_has_principals();
  ::mesos::ACL_Entity* temp = principals_;
  principals_ = NULL;
  return temp;
}
inline ::mesos::ACL_Entity* ACL_ViewTask::mutable_principals() {
  set_has_principals();
  if (principals_ == NULL) {
    principals_ = new ::mesos::ACL_Entity;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ACL.ViewTask.principals)
  return principals_;
}
inline void ACL_ViewTask::set_allocated_principals(::mesos::ACL_Entity* principals) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete principals_;
  }
  if (principals) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      principals = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, principals, submessage_arena);
    }
    set_has_principals();
  } else {
    clear_has_principals();
  }
  principals_ = principals;
  // @@protoc_insertion_point(field_set_allocated:mesos.ACL.ViewTask.principals)
}

// required .mesos.ACL.Entity users = 2;
inline bool ACL_ViewTask::has_users() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACL_ViewTask::set_has_users() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ACL_ViewTask::clear_has_users() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ACL_ViewTask::clear_users() {
  if (users_ != NULL) users_->Clear();
  clear_has_users();
}
inline const ::mesos::ACL_Entity& ACL_ViewTask::users() const {
  const ::mesos::ACL_Entity* p = users_;
  // @@protoc_insertion_point(field_get:mesos.ACL.ViewTask.users)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ACL_Entity*>(
      &::mesos::_ACL_Entity_default_instance_);
}
inline ::mesos::ACL_Entity* ACL_ViewTask::release_users() {
  // @@protoc_insertion_point(field_release:mesos.ACL.ViewTask.users)
  clear_has_users();
  ::mesos::ACL_Entity* temp = users_;
  users_ = NULL;
  return temp;
}
inline ::mesos::ACL_Entity* ACL_ViewTask::mutable_users() {
  set_has_users();
  if (users_ == NULL) {
    users_ = new ::mesos::ACL_Entity;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ACL.ViewTask.users)
  return users_;
}
inline void ACL_ViewTask::set_allocated_users(::mesos::ACL_Entity* users) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete users_;
  }
  if (users) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      users = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, users, submessage_arena);
    }
    set_has_users();
  } else {
    clear_has_users();
  }
  users_ = users;
  // @@protoc_insertion_point(field_set_allocated:mesos.ACL.ViewTask.users)
}

// -------------------------------------------------------------------

// ACL_ViewExecutor

// required .mesos.ACL.Entity principals = 1;
inline bool ACL_ViewExecutor::has_principals() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACL_ViewExecutor::set_has_principals() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACL_ViewExecutor::clear_has_principals() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACL_ViewExecutor::clear_principals() {
  if (principals_ != NULL) principals_->Clear();
  clear_has_principals();
}
inline const ::mesos::ACL_Entity& ACL_ViewExecutor::principals() const {
  const ::mesos::ACL_Entity* p = principals_;
  // @@protoc_insertion_point(field_get:mesos.ACL.ViewExecutor.principals)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ACL_Entity*>(
      &::mesos::_ACL_Entity_default_instance_);
}
inline ::mesos::ACL_Entity* ACL_ViewExecutor::release_principals() {
  // @@protoc_insertion_point(field_release:mesos.ACL.ViewExecutor.principals)
  clear_has_principals();
  ::mesos::ACL_Entity* temp = principals_;
  principals_ = NULL;
  return temp;
}
inline ::mesos::ACL_Entity* ACL_ViewExecutor::mutable_principals() {
  set_has_principals();
  if (principals_ == NULL) {
    principals_ = new ::mesos::ACL_Entity;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ACL.ViewExecutor.principals)
  return principals_;
}
inline void ACL_ViewExecutor::set_allocated_principals(::mesos::ACL_Entity* principals) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete principals_;
  }
  if (principals) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      principals = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, principals, submessage_arena);
    }
    set_has_principals();
  } else {
    clear_has_principals();
  }
  principals_ = principals;
  // @@protoc_insertion_point(field_set_allocated:mesos.ACL.ViewExecutor.principals)
}

// required .mesos.ACL.Entity users = 2;
inline bool ACL_ViewExecutor::has_users() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACL_ViewExecutor::set_has_users() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ACL_ViewExecutor::clear_has_users() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ACL_ViewExecutor::clear_users() {
  if (users_ != NULL) users_->Clear();
  clear_has_users();
}
inline const ::mesos::ACL_Entity& ACL_ViewExecutor::users() const {
  const ::mesos::ACL_Entity* p = users_;
  // @@protoc_insertion_point(field_get:mesos.ACL.ViewExecutor.users)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ACL_Entity*>(
      &::mesos::_ACL_Entity_default_instance_);
}
inline ::mesos::ACL_Entity* ACL_ViewExecutor::release_users() {
  // @@protoc_insertion_point(field_release:mesos.ACL.ViewExecutor.users)
  clear_has_users();
  ::mesos::ACL_Entity* temp = users_;
  users_ = NULL;
  return temp;
}
inline ::mesos::ACL_Entity* ACL_ViewExecutor::mutable_users() {
  set_has_users();
  if (users_ == NULL) {
    users_ = new ::mesos::ACL_Entity;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ACL.ViewExecutor.users)
  return users_;
}
inline void ACL_ViewExecutor::set_allocated_users(::mesos::ACL_Entity* users) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete users_;
  }
  if (users) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      users = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, users, submessage_arena);
    }
    set_has_users();
  } else {
    clear_has_users();
  }
  users_ = users;
  // @@protoc_insertion_point(field_set_allocated:mesos.ACL.ViewExecutor.users)
}

// -------------------------------------------------------------------

// ACL_AccessSandbox

// required .mesos.ACL.Entity principals = 1;
inline bool ACL_AccessSandbox::has_principals() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACL_AccessSandbox::set_has_principals() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACL_AccessSandbox::clear_has_principals() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACL_AccessSandbox::clear_principals() {
  if (principals_ != NULL) principals_->Clear();
  clear_has_principals();
}
inline const ::mesos::ACL_Entity& ACL_AccessSandbox::principals() const {
  const ::mesos::ACL_Entity* p = principals_;
  // @@protoc_insertion_point(field_get:mesos.ACL.AccessSandbox.principals)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ACL_Entity*>(
      &::mesos::_ACL_Entity_default_instance_);
}
inline ::mesos::ACL_Entity* ACL_AccessSandbox::release_principals() {
  // @@protoc_insertion_point(field_release:mesos.ACL.AccessSandbox.principals)
  clear_has_principals();
  ::mesos::ACL_Entity* temp = principals_;
  principals_ = NULL;
  return temp;
}
inline ::mesos::ACL_Entity* ACL_AccessSandbox::mutable_principals() {
  set_has_principals();
  if (principals_ == NULL) {
    principals_ = new ::mesos::ACL_Entity;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ACL.AccessSandbox.principals)
  return principals_;
}
inline void ACL_AccessSandbox::set_allocated_principals(::mesos::ACL_Entity* principals) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete principals_;
  }
  if (principals) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      principals = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, principals, submessage_arena);
    }
    set_has_principals();
  } else {
    clear_has_principals();
  }
  principals_ = principals;
  // @@protoc_insertion_point(field_set_allocated:mesos.ACL.AccessSandbox.principals)
}

// required .mesos.ACL.Entity users = 2;
inline bool ACL_AccessSandbox::has_users() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACL_AccessSandbox::set_has_users() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ACL_AccessSandbox::clear_has_users() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ACL_AccessSandbox::clear_users() {
  if (users_ != NULL) users_->Clear();
  clear_has_users();
}
inline const ::mesos::ACL_Entity& ACL_AccessSandbox::users() const {
  const ::mesos::ACL_Entity* p = users_;
  // @@protoc_insertion_point(field_get:mesos.ACL.AccessSandbox.users)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ACL_Entity*>(
      &::mesos::_ACL_Entity_default_instance_);
}
inline ::mesos::ACL_Entity* ACL_AccessSandbox::release_users() {
  // @@protoc_insertion_point(field_release:mesos.ACL.AccessSandbox.users)
  clear_has_users();
  ::mesos::ACL_Entity* temp = users_;
  users_ = NULL;
  return temp;
}
inline ::mesos::ACL_Entity* ACL_AccessSandbox::mutable_users() {
  set_has_users();
  if (users_ == NULL) {
    users_ = new ::mesos::ACL_Entity;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ACL.AccessSandbox.users)
  return users_;
}
inline void ACL_AccessSandbox::set_allocated_users(::mesos::ACL_Entity* users) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete users_;
  }
  if (users) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      users = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, users, submessage_arena);
    }
    set_has_users();
  } else {
    clear_has_users();
  }
  users_ = users;
  // @@protoc_insertion_point(field_set_allocated:mesos.ACL.AccessSandbox.users)
}

// -------------------------------------------------------------------

// ACL_AccessMesosLog

// required .mesos.ACL.Entity principals = 1;
inline bool ACL_AccessMesosLog::has_principals() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACL_AccessMesosLog::set_has_principals() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACL_AccessMesosLog::clear_has_principals() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACL_AccessMesosLog::clear_principals() {
  if (principals_ != NULL) principals_->Clear();
  clear_has_principals();
}
inline const ::mesos::ACL_Entity& ACL_AccessMesosLog::principals() const {
  const ::mesos::ACL_Entity* p = principals_;
  // @@protoc_insertion_point(field_get:mesos.ACL.AccessMesosLog.principals)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ACL_Entity*>(
      &::mesos::_ACL_Entity_default_instance_);
}
inline ::mesos::ACL_Entity* ACL_AccessMesosLog::release_principals() {
  // @@protoc_insertion_point(field_release:mesos.ACL.AccessMesosLog.principals)
  clear_has_principals();
  ::mesos::ACL_Entity* temp = principals_;
  principals_ = NULL;
  return temp;
}
inline ::mesos::ACL_Entity* ACL_AccessMesosLog::mutable_principals() {
  set_has_principals();
  if (principals_ == NULL) {
    principals_ = new ::mesos::ACL_Entity;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ACL.AccessMesosLog.principals)
  return principals_;
}
inline void ACL_AccessMesosLog::set_allocated_principals(::mesos::ACL_Entity* principals) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete principals_;
  }
  if (principals) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      principals = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, principals, submessage_arena);
    }
    set_has_principals();
  } else {
    clear_has_principals();
  }
  principals_ = principals;
  // @@protoc_insertion_point(field_set_allocated:mesos.ACL.AccessMesosLog.principals)
}

// required .mesos.ACL.Entity logs = 2;
inline bool ACL_AccessMesosLog::has_logs() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACL_AccessMesosLog::set_has_logs() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ACL_AccessMesosLog::clear_has_logs() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ACL_AccessMesosLog::clear_logs() {
  if (logs_ != NULL) logs_->Clear();
  clear_has_logs();
}
inline const ::mesos::ACL_Entity& ACL_AccessMesosLog::logs() const {
  const ::mesos::ACL_Entity* p = logs_;
  // @@protoc_insertion_point(field_get:mesos.ACL.AccessMesosLog.logs)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ACL_Entity*>(
      &::mesos::_ACL_Entity_default_instance_);
}
inline ::mesos::ACL_Entity* ACL_AccessMesosLog::release_logs() {
  // @@protoc_insertion_point(field_release:mesos.ACL.AccessMesosLog.logs)
  clear_has_logs();
  ::mesos::ACL_Entity* temp = logs_;
  logs_ = NULL;
  return temp;
}
inline ::mesos::ACL_Entity* ACL_AccessMesosLog::mutable_logs() {
  set_has_logs();
  if (logs_ == NULL) {
    logs_ = new ::mesos::ACL_Entity;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ACL.AccessMesosLog.logs)
  return logs_;
}
inline void ACL_AccessMesosLog::set_allocated_logs(::mesos::ACL_Entity* logs) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete logs_;
  }
  if (logs) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      logs = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, logs, submessage_arena);
    }
    set_has_logs();
  } else {
    clear_has_logs();
  }
  logs_ = logs;
  // @@protoc_insertion_point(field_set_allocated:mesos.ACL.AccessMesosLog.logs)
}

// -------------------------------------------------------------------

// ACL_ViewFlags

// required .mesos.ACL.Entity principals = 1;
inline bool ACL_ViewFlags::has_principals() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACL_ViewFlags::set_has_principals() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACL_ViewFlags::clear_has_principals() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACL_ViewFlags::clear_principals() {
  if (principals_ != NULL) principals_->Clear();
  clear_has_principals();
}
inline const ::mesos::ACL_Entity& ACL_ViewFlags::principals() const {
  const ::mesos::ACL_Entity* p = principals_;
  // @@protoc_insertion_point(field_get:mesos.ACL.ViewFlags.principals)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ACL_Entity*>(
      &::mesos::_ACL_Entity_default_instance_);
}
inline ::mesos::ACL_Entity* ACL_ViewFlags::release_principals() {
  // @@protoc_insertion_point(field_release:mesos.ACL.ViewFlags.principals)
  clear_has_principals();
  ::mesos::ACL_Entity* temp = principals_;
  principals_ = NULL;
  return temp;
}
inline ::mesos::ACL_Entity* ACL_ViewFlags::mutable_principals() {
  set_has_principals();
  if (principals_ == NULL) {
    principals_ = new ::mesos::ACL_Entity;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ACL.ViewFlags.principals)
  return principals_;
}
inline void ACL_ViewFlags::set_allocated_principals(::mesos::ACL_Entity* principals) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete principals_;
  }
  if (principals) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      principals = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, principals, submessage_arena);
    }
    set_has_principals();
  } else {
    clear_has_principals();
  }
  principals_ = principals;
  // @@protoc_insertion_point(field_set_allocated:mesos.ACL.ViewFlags.principals)
}

// required .mesos.ACL.Entity flags = 2;
inline bool ACL_ViewFlags::has_flags() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACL_ViewFlags::set_has_flags() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ACL_ViewFlags::clear_has_flags() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ACL_ViewFlags::clear_flags() {
  if (flags_ != NULL) flags_->Clear();
  clear_has_flags();
}
inline const ::mesos::ACL_Entity& ACL_ViewFlags::flags() const {
  const ::mesos::ACL_Entity* p = flags_;
  // @@protoc_insertion_point(field_get:mesos.ACL.ViewFlags.flags)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ACL_Entity*>(
      &::mesos::_ACL_Entity_default_instance_);
}
inline ::mesos::ACL_Entity* ACL_ViewFlags::release_flags() {
  // @@protoc_insertion_point(field_release:mesos.ACL.ViewFlags.flags)
  clear_has_flags();
  ::mesos::ACL_Entity* temp = flags_;
  flags_ = NULL;
  return temp;
}
inline ::mesos::ACL_Entity* ACL_ViewFlags::mutable_flags() {
  set_has_flags();
  if (flags_ == NULL) {
    flags_ = new ::mesos::ACL_Entity;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ACL.ViewFlags.flags)
  return flags_;
}
inline void ACL_ViewFlags::set_allocated_flags(::mesos::ACL_Entity* flags) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete flags_;
  }
  if (flags) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      flags = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, flags, submessage_arena);
    }
    set_has_flags();
  } else {
    clear_has_flags();
  }
  flags_ = flags;
  // @@protoc_insertion_point(field_set_allocated:mesos.ACL.ViewFlags.flags)
}

// -------------------------------------------------------------------

// ACL_LaunchNestedContainerAsUser

// required .mesos.ACL.Entity principals = 1;
inline bool ACL_LaunchNestedContainerAsUser::has_principals() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACL_LaunchNestedContainerAsUser::set_has_principals() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACL_LaunchNestedContainerAsUser::clear_has_principals() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACL_LaunchNestedContainerAsUser::clear_principals() {
  if (principals_ != NULL) principals_->Clear();
  clear_has_principals();
}
inline const ::mesos::ACL_Entity& ACL_LaunchNestedContainerAsUser::principals() const {
  const ::mesos::ACL_Entity* p = principals_;
  // @@protoc_insertion_point(field_get:mesos.ACL.LaunchNestedContainerAsUser.principals)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ACL_Entity*>(
      &::mesos::_ACL_Entity_default_instance_);
}
inline ::mesos::ACL_Entity* ACL_LaunchNestedContainerAsUser::release_principals() {
  // @@protoc_insertion_point(field_release:mesos.ACL.LaunchNestedContainerAsUser.principals)
  clear_has_principals();
  ::mesos::ACL_Entity* temp = principals_;
  principals_ = NULL;
  return temp;
}
inline ::mesos::ACL_Entity* ACL_LaunchNestedContainerAsUser::mutable_principals() {
  set_has_principals();
  if (principals_ == NULL) {
    principals_ = new ::mesos::ACL_Entity;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ACL.LaunchNestedContainerAsUser.principals)
  return principals_;
}
inline void ACL_LaunchNestedContainerAsUser::set_allocated_principals(::mesos::ACL_Entity* principals) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete principals_;
  }
  if (principals) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      principals = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, principals, submessage_arena);
    }
    set_has_principals();
  } else {
    clear_has_principals();
  }
  principals_ = principals;
  // @@protoc_insertion_point(field_set_allocated:mesos.ACL.LaunchNestedContainerAsUser.principals)
}

// required .mesos.ACL.Entity users = 2;
inline bool ACL_LaunchNestedContainerAsUser::has_users() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACL_LaunchNestedContainerAsUser::set_has_users() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ACL_LaunchNestedContainerAsUser::clear_has_users() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ACL_LaunchNestedContainerAsUser::clear_users() {
  if (users_ != NULL) users_->Clear();
  clear_has_users();
}
inline const ::mesos::ACL_Entity& ACL_LaunchNestedContainerAsUser::users() const {
  const ::mesos::ACL_Entity* p = users_;
  // @@protoc_insertion_point(field_get:mesos.ACL.LaunchNestedContainerAsUser.users)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ACL_Entity*>(
      &::mesos::_ACL_Entity_default_instance_);
}
inline ::mesos::ACL_Entity* ACL_LaunchNestedContainerAsUser::release_users() {
  // @@protoc_insertion_point(field_release:mesos.ACL.LaunchNestedContainerAsUser.users)
  clear_has_users();
  ::mesos::ACL_Entity* temp = users_;
  users_ = NULL;
  return temp;
}
inline ::mesos::ACL_Entity* ACL_LaunchNestedContainerAsUser::mutable_users() {
  set_has_users();
  if (users_ == NULL) {
    users_ = new ::mesos::ACL_Entity;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ACL.LaunchNestedContainerAsUser.users)
  return users_;
}
inline void ACL_LaunchNestedContainerAsUser::set_allocated_users(::mesos::ACL_Entity* users) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete users_;
  }
  if (users) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      users = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, users, submessage_arena);
    }
    set_has_users();
  } else {
    clear_has_users();
  }
  users_ = users;
  // @@protoc_insertion_point(field_set_allocated:mesos.ACL.LaunchNestedContainerAsUser.users)
}

// -------------------------------------------------------------------

// ACL_LaunchNestedContainerUnderParentWithUser

// required .mesos.ACL.Entity principals = 1;
inline bool ACL_LaunchNestedContainerUnderParentWithUser::has_principals() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACL_LaunchNestedContainerUnderParentWithUser::set_has_principals() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACL_LaunchNestedContainerUnderParentWithUser::clear_has_principals() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACL_LaunchNestedContainerUnderParentWithUser::clear_principals() {
  if (principals_ != NULL) principals_->Clear();
  clear_has_principals();
}
inline const ::mesos::ACL_Entity& ACL_LaunchNestedContainerUnderParentWithUser::principals() const {
  const ::mesos::ACL_Entity* p = principals_;
  // @@protoc_insertion_point(field_get:mesos.ACL.LaunchNestedContainerUnderParentWithUser.principals)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ACL_Entity*>(
      &::mesos::_ACL_Entity_default_instance_);
}
inline ::mesos::ACL_Entity* ACL_LaunchNestedContainerUnderParentWithUser::release_principals() {
  // @@protoc_insertion_point(field_release:mesos.ACL.LaunchNestedContainerUnderParentWithUser.principals)
  clear_has_principals();
  ::mesos::ACL_Entity* temp = principals_;
  principals_ = NULL;
  return temp;
}
inline ::mesos::ACL_Entity* ACL_LaunchNestedContainerUnderParentWithUser::mutable_principals() {
  set_has_principals();
  if (principals_ == NULL) {
    principals_ = new ::mesos::ACL_Entity;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ACL.LaunchNestedContainerUnderParentWithUser.principals)
  return principals_;
}
inline void ACL_LaunchNestedContainerUnderParentWithUser::set_allocated_principals(::mesos::ACL_Entity* principals) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete principals_;
  }
  if (principals) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      principals = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, principals, submessage_arena);
    }
    set_has_principals();
  } else {
    clear_has_principals();
  }
  principals_ = principals;
  // @@protoc_insertion_point(field_set_allocated:mesos.ACL.LaunchNestedContainerUnderParentWithUser.principals)
}

// required .mesos.ACL.Entity users = 2;
inline bool ACL_LaunchNestedContainerUnderParentWithUser::has_users() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACL_LaunchNestedContainerUnderParentWithUser::set_has_users() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ACL_LaunchNestedContainerUnderParentWithUser::clear_has_users() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ACL_LaunchNestedContainerUnderParentWithUser::clear_users() {
  if (users_ != NULL) users_->Clear();
  clear_has_users();
}
inline const ::mesos::ACL_Entity& ACL_LaunchNestedContainerUnderParentWithUser::users() const {
  const ::mesos::ACL_Entity* p = users_;
  // @@protoc_insertion_point(field_get:mesos.ACL.LaunchNestedContainerUnderParentWithUser.users)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ACL_Entity*>(
      &::mesos::_ACL_Entity_default_instance_);
}
inline ::mesos::ACL_Entity* ACL_LaunchNestedContainerUnderParentWithUser::release_users() {
  // @@protoc_insertion_point(field_release:mesos.ACL.LaunchNestedContainerUnderParentWithUser.users)
  clear_has_users();
  ::mesos::ACL_Entity* temp = users_;
  users_ = NULL;
  return temp;
}
inline ::mesos::ACL_Entity* ACL_LaunchNestedContainerUnderParentWithUser::mutable_users() {
  set_has_users();
  if (users_ == NULL) {
    users_ = new ::mesos::ACL_Entity;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ACL.LaunchNestedContainerUnderParentWithUser.users)
  return users_;
}
inline void ACL_LaunchNestedContainerUnderParentWithUser::set_allocated_users(::mesos::ACL_Entity* users) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete users_;
  }
  if (users) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      users = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, users, submessage_arena);
    }
    set_has_users();
  } else {
    clear_has_users();
  }
  users_ = users;
  // @@protoc_insertion_point(field_set_allocated:mesos.ACL.LaunchNestedContainerUnderParentWithUser.users)
}

// -------------------------------------------------------------------

// ACL_LaunchNestedContainerSessionAsUser

// required .mesos.ACL.Entity principals = 1;
inline bool ACL_LaunchNestedContainerSessionAsUser::has_principals() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACL_LaunchNestedContainerSessionAsUser::set_has_principals() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACL_LaunchNestedContainerSessionAsUser::clear_has_principals() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACL_LaunchNestedContainerSessionAsUser::clear_principals() {
  if (principals_ != NULL) principals_->Clear();
  clear_has_principals();
}
inline const ::mesos::ACL_Entity& ACL_LaunchNestedContainerSessionAsUser::principals() const {
  const ::mesos::ACL_Entity* p = principals_;
  // @@protoc_insertion_point(field_get:mesos.ACL.LaunchNestedContainerSessionAsUser.principals)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ACL_Entity*>(
      &::mesos::_ACL_Entity_default_instance_);
}
inline ::mesos::ACL_Entity* ACL_LaunchNestedContainerSessionAsUser::release_principals() {
  // @@protoc_insertion_point(field_release:mesos.ACL.LaunchNestedContainerSessionAsUser.principals)
  clear_has_principals();
  ::mesos::ACL_Entity* temp = principals_;
  principals_ = NULL;
  return temp;
}
inline ::mesos::ACL_Entity* ACL_LaunchNestedContainerSessionAsUser::mutable_principals() {
  set_has_principals();
  if (principals_ == NULL) {
    principals_ = new ::mesos::ACL_Entity;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ACL.LaunchNestedContainerSessionAsUser.principals)
  return principals_;
}
inline void ACL_LaunchNestedContainerSessionAsUser::set_allocated_principals(::mesos::ACL_Entity* principals) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete principals_;
  }
  if (principals) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      principals = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, principals, submessage_arena);
    }
    set_has_principals();
  } else {
    clear_has_principals();
  }
  principals_ = principals;
  // @@protoc_insertion_point(field_set_allocated:mesos.ACL.LaunchNestedContainerSessionAsUser.principals)
}

// required .mesos.ACL.Entity users = 2;
inline bool ACL_LaunchNestedContainerSessionAsUser::has_users() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACL_LaunchNestedContainerSessionAsUser::set_has_users() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ACL_LaunchNestedContainerSessionAsUser::clear_has_users() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ACL_LaunchNestedContainerSessionAsUser::clear_users() {
  if (users_ != NULL) users_->Clear();
  clear_has_users();
}
inline const ::mesos::ACL_Entity& ACL_LaunchNestedContainerSessionAsUser::users() const {
  const ::mesos::ACL_Entity* p = users_;
  // @@protoc_insertion_point(field_get:mesos.ACL.LaunchNestedContainerSessionAsUser.users)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ACL_Entity*>(
      &::mesos::_ACL_Entity_default_instance_);
}
inline ::mesos::ACL_Entity* ACL_LaunchNestedContainerSessionAsUser::release_users() {
  // @@protoc_insertion_point(field_release:mesos.ACL.LaunchNestedContainerSessionAsUser.users)
  clear_has_users();
  ::mesos::ACL_Entity* temp = users_;
  users_ = NULL;
  return temp;
}
inline ::mesos::ACL_Entity* ACL_LaunchNestedContainerSessionAsUser::mutable_users() {
  set_has_users();
  if (users_ == NULL) {
    users_ = new ::mesos::ACL_Entity;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ACL.LaunchNestedContainerSessionAsUser.users)
  return users_;
}
inline void ACL_LaunchNestedContainerSessionAsUser::set_allocated_users(::mesos::ACL_Entity* users) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete users_;
  }
  if (users) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      users = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, users, submessage_arena);
    }
    set_has_users();
  } else {
    clear_has_users();
  }
  users_ = users;
  // @@protoc_insertion_point(field_set_allocated:mesos.ACL.LaunchNestedContainerSessionAsUser.users)
}

// -------------------------------------------------------------------

// ACL_LaunchNestedContainerSessionUnderParentWithUser

// required .mesos.ACL.Entity principals = 1;
inline bool ACL_LaunchNestedContainerSessionUnderParentWithUser::has_principals() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACL_LaunchNestedContainerSessionUnderParentWithUser::set_has_principals() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACL_LaunchNestedContainerSessionUnderParentWithUser::clear_has_principals() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACL_LaunchNestedContainerSessionUnderParentWithUser::clear_principals() {
  if (principals_ != NULL) principals_->Clear();
  clear_has_principals();
}
inline const ::mesos::ACL_Entity& ACL_LaunchNestedContainerSessionUnderParentWithUser::principals() const {
  const ::mesos::ACL_Entity* p = principals_;
  // @@protoc_insertion_point(field_get:mesos.ACL.LaunchNestedContainerSessionUnderParentWithUser.principals)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ACL_Entity*>(
      &::mesos::_ACL_Entity_default_instance_);
}
inline ::mesos::ACL_Entity* ACL_LaunchNestedContainerSessionUnderParentWithUser::release_principals() {
  // @@protoc_insertion_point(field_release:mesos.ACL.LaunchNestedContainerSessionUnderParentWithUser.principals)
  clear_has_principals();
  ::mesos::ACL_Entity* temp = principals_;
  principals_ = NULL;
  return temp;
}
inline ::mesos::ACL_Entity* ACL_LaunchNestedContainerSessionUnderParentWithUser::mutable_principals() {
  set_has_principals();
  if (principals_ == NULL) {
    principals_ = new ::mesos::ACL_Entity;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ACL.LaunchNestedContainerSessionUnderParentWithUser.principals)
  return principals_;
}
inline void ACL_LaunchNestedContainerSessionUnderParentWithUser::set_allocated_principals(::mesos::ACL_Entity* principals) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete principals_;
  }
  if (principals) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      principals = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, principals, submessage_arena);
    }
    set_has_principals();
  } else {
    clear_has_principals();
  }
  principals_ = principals;
  // @@protoc_insertion_point(field_set_allocated:mesos.ACL.LaunchNestedContainerSessionUnderParentWithUser.principals)
}

// required .mesos.ACL.Entity users = 2;
inline bool ACL_LaunchNestedContainerSessionUnderParentWithUser::has_users() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACL_LaunchNestedContainerSessionUnderParentWithUser::set_has_users() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ACL_LaunchNestedContainerSessionUnderParentWithUser::clear_has_users() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ACL_LaunchNestedContainerSessionUnderParentWithUser::clear_users() {
  if (users_ != NULL) users_->Clear();
  clear_has_users();
}
inline const ::mesos::ACL_Entity& ACL_LaunchNestedContainerSessionUnderParentWithUser::users() const {
  const ::mesos::ACL_Entity* p = users_;
  // @@protoc_insertion_point(field_get:mesos.ACL.LaunchNestedContainerSessionUnderParentWithUser.users)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ACL_Entity*>(
      &::mesos::_ACL_Entity_default_instance_);
}
inline ::mesos::ACL_Entity* ACL_LaunchNestedContainerSessionUnderParentWithUser::release_users() {
  // @@protoc_insertion_point(field_release:mesos.ACL.LaunchNestedContainerSessionUnderParentWithUser.users)
  clear_has_users();
  ::mesos::ACL_Entity* temp = users_;
  users_ = NULL;
  return temp;
}
inline ::mesos::ACL_Entity* ACL_LaunchNestedContainerSessionUnderParentWithUser::mutable_users() {
  set_has_users();
  if (users_ == NULL) {
    users_ = new ::mesos::ACL_Entity;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ACL.LaunchNestedContainerSessionUnderParentWithUser.users)
  return users_;
}
inline void ACL_LaunchNestedContainerSessionUnderParentWithUser::set_allocated_users(::mesos::ACL_Entity* users) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete users_;
  }
  if (users) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      users = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, users, submessage_arena);
    }
    set_has_users();
  } else {
    clear_has_users();
  }
  users_ = users;
  // @@protoc_insertion_point(field_set_allocated:mesos.ACL.LaunchNestedContainerSessionUnderParentWithUser.users)
}

// -------------------------------------------------------------------

// ACL_AttachContainerInput

// required .mesos.ACL.Entity principals = 1;
inline bool ACL_AttachContainerInput::has_principals() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACL_AttachContainerInput::set_has_principals() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACL_AttachContainerInput::clear_has_principals() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACL_AttachContainerInput::clear_principals() {
  if (principals_ != NULL) principals_->Clear();
  clear_has_principals();
}
inline const ::mesos::ACL_Entity& ACL_AttachContainerInput::principals() const {
  const ::mesos::ACL_Entity* p = principals_;
  // @@protoc_insertion_point(field_get:mesos.ACL.AttachContainerInput.principals)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ACL_Entity*>(
      &::mesos::_ACL_Entity_default_instance_);
}
inline ::mesos::ACL_Entity* ACL_AttachContainerInput::release_principals() {
  // @@protoc_insertion_point(field_release:mesos.ACL.AttachContainerInput.principals)
  clear_has_principals();
  ::mesos::ACL_Entity* temp = principals_;
  principals_ = NULL;
  return temp;
}
inline ::mesos::ACL_Entity* ACL_AttachContainerInput::mutable_principals() {
  set_has_principals();
  if (principals_ == NULL) {
    principals_ = new ::mesos::ACL_Entity;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ACL.AttachContainerInput.principals)
  return principals_;
}
inline void ACL_AttachContainerInput::set_allocated_principals(::mesos::ACL_Entity* principals) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete principals_;
  }
  if (principals) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      principals = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, principals, submessage_arena);
    }
    set_has_principals();
  } else {
    clear_has_principals();
  }
  principals_ = principals;
  // @@protoc_insertion_point(field_set_allocated:mesos.ACL.AttachContainerInput.principals)
}

// required .mesos.ACL.Entity users = 2;
inline bool ACL_AttachContainerInput::has_users() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACL_AttachContainerInput::set_has_users() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ACL_AttachContainerInput::clear_has_users() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ACL_AttachContainerInput::clear_users() {
  if (users_ != NULL) users_->Clear();
  clear_has_users();
}
inline const ::mesos::ACL_Entity& ACL_AttachContainerInput::users() const {
  const ::mesos::ACL_Entity* p = users_;
  // @@protoc_insertion_point(field_get:mesos.ACL.AttachContainerInput.users)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ACL_Entity*>(
      &::mesos::_ACL_Entity_default_instance_);
}
inline ::mesos::ACL_Entity* ACL_AttachContainerInput::release_users() {
  // @@protoc_insertion_point(field_release:mesos.ACL.AttachContainerInput.users)
  clear_has_users();
  ::mesos::ACL_Entity* temp = users_;
  users_ = NULL;
  return temp;
}
inline ::mesos::ACL_Entity* ACL_AttachContainerInput::mutable_users() {
  set_has_users();
  if (users_ == NULL) {
    users_ = new ::mesos::ACL_Entity;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ACL.AttachContainerInput.users)
  return users_;
}
inline void ACL_AttachContainerInput::set_allocated_users(::mesos::ACL_Entity* users) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete users_;
  }
  if (users) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      users = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, users, submessage_arena);
    }
    set_has_users();
  } else {
    clear_has_users();
  }
  users_ = users;
  // @@protoc_insertion_point(field_set_allocated:mesos.ACL.AttachContainerInput.users)
}

// -------------------------------------------------------------------

// ACL_AttachContainerOutput

// required .mesos.ACL.Entity principals = 1;
inline bool ACL_AttachContainerOutput::has_principals() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACL_AttachContainerOutput::set_has_principals() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACL_AttachContainerOutput::clear_has_principals() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACL_AttachContainerOutput::clear_principals() {
  if (principals_ != NULL) principals_->Clear();
  clear_has_principals();
}
inline const ::mesos::ACL_Entity& ACL_AttachContainerOutput::principals() const {
  const ::mesos::ACL_Entity* p = principals_;
  // @@protoc_insertion_point(field_get:mesos.ACL.AttachContainerOutput.principals)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ACL_Entity*>(
      &::mesos::_ACL_Entity_default_instance_);
}
inline ::mesos::ACL_Entity* ACL_AttachContainerOutput::release_principals() {
  // @@protoc_insertion_point(field_release:mesos.ACL.AttachContainerOutput.principals)
  clear_has_principals();
  ::mesos::ACL_Entity* temp = principals_;
  principals_ = NULL;
  return temp;
}
inline ::mesos::ACL_Entity* ACL_AttachContainerOutput::mutable_principals() {
  set_has_principals();
  if (principals_ == NULL) {
    principals_ = new ::mesos::ACL_Entity;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ACL.AttachContainerOutput.principals)
  return principals_;
}
inline void ACL_AttachContainerOutput::set_allocated_principals(::mesos::ACL_Entity* principals) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete principals_;
  }
  if (principals) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      principals = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, principals, submessage_arena);
    }
    set_has_principals();
  } else {
    clear_has_principals();
  }
  principals_ = principals;
  // @@protoc_insertion_point(field_set_allocated:mesos.ACL.AttachContainerOutput.principals)
}

// required .mesos.ACL.Entity users = 2;
inline bool ACL_AttachContainerOutput::has_users() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACL_AttachContainerOutput::set_has_users() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ACL_AttachContainerOutput::clear_has_users() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ACL_AttachContainerOutput::clear_users() {
  if (users_ != NULL) users_->Clear();
  clear_has_users();
}
inline const ::mesos::ACL_Entity& ACL_AttachContainerOutput::users() const {
  const ::mesos::ACL_Entity* p = users_;
  // @@protoc_insertion_point(field_get:mesos.ACL.AttachContainerOutput.users)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ACL_Entity*>(
      &::mesos::_ACL_Entity_default_instance_);
}
inline ::mesos::ACL_Entity* ACL_AttachContainerOutput::release_users() {
  // @@protoc_insertion_point(field_release:mesos.ACL.AttachContainerOutput.users)
  clear_has_users();
  ::mesos::ACL_Entity* temp = users_;
  users_ = NULL;
  return temp;
}
inline ::mesos::ACL_Entity* ACL_AttachContainerOutput::mutable_users() {
  set_has_users();
  if (users_ == NULL) {
    users_ = new ::mesos::ACL_Entity;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ACL.AttachContainerOutput.users)
  return users_;
}
inline void ACL_AttachContainerOutput::set_allocated_users(::mesos::ACL_Entity* users) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete users_;
  }
  if (users) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      users = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, users, submessage_arena);
    }
    set_has_users();
  } else {
    clear_has_users();
  }
  users_ = users;
  // @@protoc_insertion_point(field_set_allocated:mesos.ACL.AttachContainerOutput.users)
}

// -------------------------------------------------------------------

// ACL_KillNestedContainer

// required .mesos.ACL.Entity principals = 1;
inline bool ACL_KillNestedContainer::has_principals() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACL_KillNestedContainer::set_has_principals() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACL_KillNestedContainer::clear_has_principals() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACL_KillNestedContainer::clear_principals() {
  if (principals_ != NULL) principals_->Clear();
  clear_has_principals();
}
inline const ::mesos::ACL_Entity& ACL_KillNestedContainer::principals() const {
  const ::mesos::ACL_Entity* p = principals_;
  // @@protoc_insertion_point(field_get:mesos.ACL.KillNestedContainer.principals)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ACL_Entity*>(
      &::mesos::_ACL_Entity_default_instance_);
}
inline ::mesos::ACL_Entity* ACL_KillNestedContainer::release_principals() {
  // @@protoc_insertion_point(field_release:mesos.ACL.KillNestedContainer.principals)
  clear_has_principals();
  ::mesos::ACL_Entity* temp = principals_;
  principals_ = NULL;
  return temp;
}
inline ::mesos::ACL_Entity* ACL_KillNestedContainer::mutable_principals() {
  set_has_principals();
  if (principals_ == NULL) {
    principals_ = new ::mesos::ACL_Entity;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ACL.KillNestedContainer.principals)
  return principals_;
}
inline void ACL_KillNestedContainer::set_allocated_principals(::mesos::ACL_Entity* principals) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete principals_;
  }
  if (principals) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      principals = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, principals, submessage_arena);
    }
    set_has_principals();
  } else {
    clear_has_principals();
  }
  principals_ = principals;
  // @@protoc_insertion_point(field_set_allocated:mesos.ACL.KillNestedContainer.principals)
}

// required .mesos.ACL.Entity users = 2;
inline bool ACL_KillNestedContainer::has_users() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACL_KillNestedContainer::set_has_users() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ACL_KillNestedContainer::clear_has_users() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ACL_KillNestedContainer::clear_users() {
  if (users_ != NULL) users_->Clear();
  clear_has_users();
}
inline const ::mesos::ACL_Entity& ACL_KillNestedContainer::users() const {
  const ::mesos::ACL_Entity* p = users_;
  // @@protoc_insertion_point(field_get:mesos.ACL.KillNestedContainer.users)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ACL_Entity*>(
      &::mesos::_ACL_Entity_default_instance_);
}
inline ::mesos::ACL_Entity* ACL_KillNestedContainer::release_users() {
  // @@protoc_insertion_point(field_release:mesos.ACL.KillNestedContainer.users)
  clear_has_users();
  ::mesos::ACL_Entity* temp = users_;
  users_ = NULL;
  return temp;
}
inline ::mesos::ACL_Entity* ACL_KillNestedContainer::mutable_users() {
  set_has_users();
  if (users_ == NULL) {
    users_ = new ::mesos::ACL_Entity;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ACL.KillNestedContainer.users)
  return users_;
}
inline void ACL_KillNestedContainer::set_allocated_users(::mesos::ACL_Entity* users) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete users_;
  }
  if (users) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      users = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, users, submessage_arena);
    }
    set_has_users();
  } else {
    clear_has_users();
  }
  users_ = users;
  // @@protoc_insertion_point(field_set_allocated:mesos.ACL.KillNestedContainer.users)
}

// -------------------------------------------------------------------

// ACL_WaitNestedContainer

// required .mesos.ACL.Entity principals = 1;
inline bool ACL_WaitNestedContainer::has_principals() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACL_WaitNestedContainer::set_has_principals() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACL_WaitNestedContainer::clear_has_principals() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACL_WaitNestedContainer::clear_principals() {
  if (principals_ != NULL) principals_->Clear();
  clear_has_principals();
}
inline const ::mesos::ACL_Entity& ACL_WaitNestedContainer::principals() const {
  const ::mesos::ACL_Entity* p = principals_;
  // @@protoc_insertion_point(field_get:mesos.ACL.WaitNestedContainer.principals)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ACL_Entity*>(
      &::mesos::_ACL_Entity_default_instance_);
}
inline ::mesos::ACL_Entity* ACL_WaitNestedContainer::release_principals() {
  // @@protoc_insertion_point(field_release:mesos.ACL.WaitNestedContainer.principals)
  clear_has_principals();
  ::mesos::ACL_Entity* temp = principals_;
  principals_ = NULL;
  return temp;
}
inline ::mesos::ACL_Entity* ACL_WaitNestedContainer::mutable_principals() {
  set_has_principals();
  if (principals_ == NULL) {
    principals_ = new ::mesos::ACL_Entity;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ACL.WaitNestedContainer.principals)
  return principals_;
}
inline void ACL_WaitNestedContainer::set_allocated_principals(::mesos::ACL_Entity* principals) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete principals_;
  }
  if (principals) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      principals = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, principals, submessage_arena);
    }
    set_has_principals();
  } else {
    clear_has_principals();
  }
  principals_ = principals;
  // @@protoc_insertion_point(field_set_allocated:mesos.ACL.WaitNestedContainer.principals)
}

// required .mesos.ACL.Entity users = 2;
inline bool ACL_WaitNestedContainer::has_users() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACL_WaitNestedContainer::set_has_users() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ACL_WaitNestedContainer::clear_has_users() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ACL_WaitNestedContainer::clear_users() {
  if (users_ != NULL) users_->Clear();
  clear_has_users();
}
inline const ::mesos::ACL_Entity& ACL_WaitNestedContainer::users() const {
  const ::mesos::ACL_Entity* p = users_;
  // @@protoc_insertion_point(field_get:mesos.ACL.WaitNestedContainer.users)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ACL_Entity*>(
      &::mesos::_ACL_Entity_default_instance_);
}
inline ::mesos::ACL_Entity* ACL_WaitNestedContainer::release_users() {
  // @@protoc_insertion_point(field_release:mesos.ACL.WaitNestedContainer.users)
  clear_has_users();
  ::mesos::ACL_Entity* temp = users_;
  users_ = NULL;
  return temp;
}
inline ::mesos::ACL_Entity* ACL_WaitNestedContainer::mutable_users() {
  set_has_users();
  if (users_ == NULL) {
    users_ = new ::mesos::ACL_Entity;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ACL.WaitNestedContainer.users)
  return users_;
}
inline void ACL_WaitNestedContainer::set_allocated_users(::mesos::ACL_Entity* users) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete users_;
  }
  if (users) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      users = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, users, submessage_arena);
    }
    set_has_users();
  } else {
    clear_has_users();
  }
  users_ = users;
  // @@protoc_insertion_point(field_set_allocated:mesos.ACL.WaitNestedContainer.users)
}

// -------------------------------------------------------------------

// ACL_ViewContainer

// required .mesos.ACL.Entity principals = 1;
inline bool ACL_ViewContainer::has_principals() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACL_ViewContainer::set_has_principals() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACL_ViewContainer::clear_has_principals() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACL_ViewContainer::clear_principals() {
  if (principals_ != NULL) principals_->Clear();
  clear_has_principals();
}
inline const ::mesos::ACL_Entity& ACL_ViewContainer::principals() const {
  const ::mesos::ACL_Entity* p = principals_;
  // @@protoc_insertion_point(field_get:mesos.ACL.ViewContainer.principals)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ACL_Entity*>(
      &::mesos::_ACL_Entity_default_instance_);
}
inline ::mesos::ACL_Entity* ACL_ViewContainer::release_principals() {
  // @@protoc_insertion_point(field_release:mesos.ACL.ViewContainer.principals)
  clear_has_principals();
  ::mesos::ACL_Entity* temp = principals_;
  principals_ = NULL;
  return temp;
}
inline ::mesos::ACL_Entity* ACL_ViewContainer::mutable_principals() {
  set_has_principals();
  if (principals_ == NULL) {
    principals_ = new ::mesos::ACL_Entity;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ACL.ViewContainer.principals)
  return principals_;
}
inline void ACL_ViewContainer::set_allocated_principals(::mesos::ACL_Entity* principals) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete principals_;
  }
  if (principals) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      principals = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, principals, submessage_arena);
    }
    set_has_principals();
  } else {
    clear_has_principals();
  }
  principals_ = principals;
  // @@protoc_insertion_point(field_set_allocated:mesos.ACL.ViewContainer.principals)
}

// required .mesos.ACL.Entity users = 2;
inline bool ACL_ViewContainer::has_users() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACL_ViewContainer::set_has_users() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ACL_ViewContainer::clear_has_users() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ACL_ViewContainer::clear_users() {
  if (users_ != NULL) users_->Clear();
  clear_has_users();
}
inline const ::mesos::ACL_Entity& ACL_ViewContainer::users() const {
  const ::mesos::ACL_Entity* p = users_;
  // @@protoc_insertion_point(field_get:mesos.ACL.ViewContainer.users)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ACL_Entity*>(
      &::mesos::_ACL_Entity_default_instance_);
}
inline ::mesos::ACL_Entity* ACL_ViewContainer::release_users() {
  // @@protoc_insertion_point(field_release:mesos.ACL.ViewContainer.users)
  clear_has_users();
  ::mesos::ACL_Entity* temp = users_;
  users_ = NULL;
  return temp;
}
inline ::mesos::ACL_Entity* ACL_ViewContainer::mutable_users() {
  set_has_users();
  if (users_ == NULL) {
    users_ = new ::mesos::ACL_Entity;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ACL.ViewContainer.users)
  return users_;
}
inline void ACL_ViewContainer::set_allocated_users(::mesos::ACL_Entity* users) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete users_;
  }
  if (users) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      users = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, users, submessage_arena);
    }
    set_has_users();
  } else {
    clear_has_users();
  }
  users_ = users;
  // @@protoc_insertion_point(field_set_allocated:mesos.ACL.ViewContainer.users)
}

// -------------------------------------------------------------------

// ACL_RemoveNestedContainer

// required .mesos.ACL.Entity principals = 1;
inline bool ACL_RemoveNestedContainer::has_principals() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACL_RemoveNestedContainer::set_has_principals() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACL_RemoveNestedContainer::clear_has_principals() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACL_RemoveNestedContainer::clear_principals() {
  if (principals_ != NULL) principals_->Clear();
  clear_has_principals();
}
inline const ::mesos::ACL_Entity& ACL_RemoveNestedContainer::principals() const {
  const ::mesos::ACL_Entity* p = principals_;
  // @@protoc_insertion_point(field_get:mesos.ACL.RemoveNestedContainer.principals)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ACL_Entity*>(
      &::mesos::_ACL_Entity_default_instance_);
}
inline ::mesos::ACL_Entity* ACL_RemoveNestedContainer::release_principals() {
  // @@protoc_insertion_point(field_release:mesos.ACL.RemoveNestedContainer.principals)
  clear_has_principals();
  ::mesos::ACL_Entity* temp = principals_;
  principals_ = NULL;
  return temp;
}
inline ::mesos::ACL_Entity* ACL_RemoveNestedContainer::mutable_principals() {
  set_has_principals();
  if (principals_ == NULL) {
    principals_ = new ::mesos::ACL_Entity;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ACL.RemoveNestedContainer.principals)
  return principals_;
}
inline void ACL_RemoveNestedContainer::set_allocated_principals(::mesos::ACL_Entity* principals) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete principals_;
  }
  if (principals) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      principals = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, principals, submessage_arena);
    }
    set_has_principals();
  } else {
    clear_has_principals();
  }
  principals_ = principals;
  // @@protoc_insertion_point(field_set_allocated:mesos.ACL.RemoveNestedContainer.principals)
}

// required .mesos.ACL.Entity users = 2;
inline bool ACL_RemoveNestedContainer::has_users() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACL_RemoveNestedContainer::set_has_users() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ACL_RemoveNestedContainer::clear_has_users() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ACL_RemoveNestedContainer::clear_users() {
  if (users_ != NULL) users_->Clear();
  clear_has_users();
}
inline const ::mesos::ACL_Entity& ACL_RemoveNestedContainer::users() const {
  const ::mesos::ACL_Entity* p = users_;
  // @@protoc_insertion_point(field_get:mesos.ACL.RemoveNestedContainer.users)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ACL_Entity*>(
      &::mesos::_ACL_Entity_default_instance_);
}
inline ::mesos::ACL_Entity* ACL_RemoveNestedContainer::release_users() {
  // @@protoc_insertion_point(field_release:mesos.ACL.RemoveNestedContainer.users)
  clear_has_users();
  ::mesos::ACL_Entity* temp = users_;
  users_ = NULL;
  return temp;
}
inline ::mesos::ACL_Entity* ACL_RemoveNestedContainer::mutable_users() {
  set_has_users();
  if (users_ == NULL) {
    users_ = new ::mesos::ACL_Entity;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ACL.RemoveNestedContainer.users)
  return users_;
}
inline void ACL_RemoveNestedContainer::set_allocated_users(::mesos::ACL_Entity* users) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete users_;
  }
  if (users) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      users = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, users, submessage_arena);
    }
    set_has_users();
  } else {
    clear_has_users();
  }
  users_ = users;
  // @@protoc_insertion_point(field_set_allocated:mesos.ACL.RemoveNestedContainer.users)
}

// -------------------------------------------------------------------

// ACL_SetLogLevel

// required .mesos.ACL.Entity principals = 1;
inline bool ACL_SetLogLevel::has_principals() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACL_SetLogLevel::set_has_principals() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACL_SetLogLevel::clear_has_principals() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACL_SetLogLevel::clear_principals() {
  if (principals_ != NULL) principals_->Clear();
  clear_has_principals();
}
inline const ::mesos::ACL_Entity& ACL_SetLogLevel::principals() const {
  const ::mesos::ACL_Entity* p = principals_;
  // @@protoc_insertion_point(field_get:mesos.ACL.SetLogLevel.principals)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ACL_Entity*>(
      &::mesos::_ACL_Entity_default_instance_);
}
inline ::mesos::ACL_Entity* ACL_SetLogLevel::release_principals() {
  // @@protoc_insertion_point(field_release:mesos.ACL.SetLogLevel.principals)
  clear_has_principals();
  ::mesos::ACL_Entity* temp = principals_;
  principals_ = NULL;
  return temp;
}
inline ::mesos::ACL_Entity* ACL_SetLogLevel::mutable_principals() {
  set_has_principals();
  if (principals_ == NULL) {
    principals_ = new ::mesos::ACL_Entity;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ACL.SetLogLevel.principals)
  return principals_;
}
inline void ACL_SetLogLevel::set_allocated_principals(::mesos::ACL_Entity* principals) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete principals_;
  }
  if (principals) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      principals = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, principals, submessage_arena);
    }
    set_has_principals();
  } else {
    clear_has_principals();
  }
  principals_ = principals;
  // @@protoc_insertion_point(field_set_allocated:mesos.ACL.SetLogLevel.principals)
}

// required .mesos.ACL.Entity level = 2;
inline bool ACL_SetLogLevel::has_level() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACL_SetLogLevel::set_has_level() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ACL_SetLogLevel::clear_has_level() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ACL_SetLogLevel::clear_level() {
  if (level_ != NULL) level_->Clear();
  clear_has_level();
}
inline const ::mesos::ACL_Entity& ACL_SetLogLevel::level() const {
  const ::mesos::ACL_Entity* p = level_;
  // @@protoc_insertion_point(field_get:mesos.ACL.SetLogLevel.level)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ACL_Entity*>(
      &::mesos::_ACL_Entity_default_instance_);
}
inline ::mesos::ACL_Entity* ACL_SetLogLevel::release_level() {
  // @@protoc_insertion_point(field_release:mesos.ACL.SetLogLevel.level)
  clear_has_level();
  ::mesos::ACL_Entity* temp = level_;
  level_ = NULL;
  return temp;
}
inline ::mesos::ACL_Entity* ACL_SetLogLevel::mutable_level() {
  set_has_level();
  if (level_ == NULL) {
    level_ = new ::mesos::ACL_Entity;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ACL.SetLogLevel.level)
  return level_;
}
inline void ACL_SetLogLevel::set_allocated_level(::mesos::ACL_Entity* level) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete level_;
  }
  if (level) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      level = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, level, submessage_arena);
    }
    set_has_level();
  } else {
    clear_has_level();
  }
  level_ = level;
  // @@protoc_insertion_point(field_set_allocated:mesos.ACL.SetLogLevel.level)
}

// -------------------------------------------------------------------

// ACL_RegisterAgent

// required .mesos.ACL.Entity principals = 1;
inline bool ACL_RegisterAgent::has_principals() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACL_RegisterAgent::set_has_principals() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACL_RegisterAgent::clear_has_principals() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACL_RegisterAgent::clear_principals() {
  if (principals_ != NULL) principals_->Clear();
  clear_has_principals();
}
inline const ::mesos::ACL_Entity& ACL_RegisterAgent::principals() const {
  const ::mesos::ACL_Entity* p = principals_;
  // @@protoc_insertion_point(field_get:mesos.ACL.RegisterAgent.principals)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ACL_Entity*>(
      &::mesos::_ACL_Entity_default_instance_);
}
inline ::mesos::ACL_Entity* ACL_RegisterAgent::release_principals() {
  // @@protoc_insertion_point(field_release:mesos.ACL.RegisterAgent.principals)
  clear_has_principals();
  ::mesos::ACL_Entity* temp = principals_;
  principals_ = NULL;
  return temp;
}
inline ::mesos::ACL_Entity* ACL_RegisterAgent::mutable_principals() {
  set_has_principals();
  if (principals_ == NULL) {
    principals_ = new ::mesos::ACL_Entity;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ACL.RegisterAgent.principals)
  return principals_;
}
inline void ACL_RegisterAgent::set_allocated_principals(::mesos::ACL_Entity* principals) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete principals_;
  }
  if (principals) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      principals = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, principals, submessage_arena);
    }
    set_has_principals();
  } else {
    clear_has_principals();
  }
  principals_ = principals;
  // @@protoc_insertion_point(field_set_allocated:mesos.ACL.RegisterAgent.principals)
}

// required .mesos.ACL.Entity agents = 2;
inline bool ACL_RegisterAgent::has_agents() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACL_RegisterAgent::set_has_agents() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ACL_RegisterAgent::clear_has_agents() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ACL_RegisterAgent::clear_agents() {
  if (agents_ != NULL) agents_->Clear();
  clear_has_agents();
}
inline const ::mesos::ACL_Entity& ACL_RegisterAgent::agents() const {
  const ::mesos::ACL_Entity* p = agents_;
  // @@protoc_insertion_point(field_get:mesos.ACL.RegisterAgent.agents)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ACL_Entity*>(
      &::mesos::_ACL_Entity_default_instance_);
}
inline ::mesos::ACL_Entity* ACL_RegisterAgent::release_agents() {
  // @@protoc_insertion_point(field_release:mesos.ACL.RegisterAgent.agents)
  clear_has_agents();
  ::mesos::ACL_Entity* temp = agents_;
  agents_ = NULL;
  return temp;
}
inline ::mesos::ACL_Entity* ACL_RegisterAgent::mutable_agents() {
  set_has_agents();
  if (agents_ == NULL) {
    agents_ = new ::mesos::ACL_Entity;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ACL.RegisterAgent.agents)
  return agents_;
}
inline void ACL_RegisterAgent::set_allocated_agents(::mesos::ACL_Entity* agents) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete agents_;
  }
  if (agents) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      agents = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, agents, submessage_arena);
    }
    set_has_agents();
  } else {
    clear_has_agents();
  }
  agents_ = agents;
  // @@protoc_insertion_point(field_set_allocated:mesos.ACL.RegisterAgent.agents)
}

// -------------------------------------------------------------------

// ACL_UpdateMaintenanceSchedule

// required .mesos.ACL.Entity principals = 1;
inline bool ACL_UpdateMaintenanceSchedule::has_principals() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACL_UpdateMaintenanceSchedule::set_has_principals() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACL_UpdateMaintenanceSchedule::clear_has_principals() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACL_UpdateMaintenanceSchedule::clear_principals() {
  if (principals_ != NULL) principals_->Clear();
  clear_has_principals();
}
inline const ::mesos::ACL_Entity& ACL_UpdateMaintenanceSchedule::principals() const {
  const ::mesos::ACL_Entity* p = principals_;
  // @@protoc_insertion_point(field_get:mesos.ACL.UpdateMaintenanceSchedule.principals)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ACL_Entity*>(
      &::mesos::_ACL_Entity_default_instance_);
}
inline ::mesos::ACL_Entity* ACL_UpdateMaintenanceSchedule::release_principals() {
  // @@protoc_insertion_point(field_release:mesos.ACL.UpdateMaintenanceSchedule.principals)
  clear_has_principals();
  ::mesos::ACL_Entity* temp = principals_;
  principals_ = NULL;
  return temp;
}
inline ::mesos::ACL_Entity* ACL_UpdateMaintenanceSchedule::mutable_principals() {
  set_has_principals();
  if (principals_ == NULL) {
    principals_ = new ::mesos::ACL_Entity;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ACL.UpdateMaintenanceSchedule.principals)
  return principals_;
}
inline void ACL_UpdateMaintenanceSchedule::set_allocated_principals(::mesos::ACL_Entity* principals) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete principals_;
  }
  if (principals) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      principals = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, principals, submessage_arena);
    }
    set_has_principals();
  } else {
    clear_has_principals();
  }
  principals_ = principals;
  // @@protoc_insertion_point(field_set_allocated:mesos.ACL.UpdateMaintenanceSchedule.principals)
}

// required .mesos.ACL.Entity machines = 2;
inline bool ACL_UpdateMaintenanceSchedule::has_machines() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACL_UpdateMaintenanceSchedule::set_has_machines() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ACL_UpdateMaintenanceSchedule::clear_has_machines() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ACL_UpdateMaintenanceSchedule::clear_machines() {
  if (machines_ != NULL) machines_->Clear();
  clear_has_machines();
}
inline const ::mesos::ACL_Entity& ACL_UpdateMaintenanceSchedule::machines() const {
  const ::mesos::ACL_Entity* p = machines_;
  // @@protoc_insertion_point(field_get:mesos.ACL.UpdateMaintenanceSchedule.machines)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ACL_Entity*>(
      &::mesos::_ACL_Entity_default_instance_);
}
inline ::mesos::ACL_Entity* ACL_UpdateMaintenanceSchedule::release_machines() {
  // @@protoc_insertion_point(field_release:mesos.ACL.UpdateMaintenanceSchedule.machines)
  clear_has_machines();
  ::mesos::ACL_Entity* temp = machines_;
  machines_ = NULL;
  return temp;
}
inline ::mesos::ACL_Entity* ACL_UpdateMaintenanceSchedule::mutable_machines() {
  set_has_machines();
  if (machines_ == NULL) {
    machines_ = new ::mesos::ACL_Entity;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ACL.UpdateMaintenanceSchedule.machines)
  return machines_;
}
inline void ACL_UpdateMaintenanceSchedule::set_allocated_machines(::mesos::ACL_Entity* machines) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete machines_;
  }
  if (machines) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      machines = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, machines, submessage_arena);
    }
    set_has_machines();
  } else {
    clear_has_machines();
  }
  machines_ = machines;
  // @@protoc_insertion_point(field_set_allocated:mesos.ACL.UpdateMaintenanceSchedule.machines)
}

// -------------------------------------------------------------------

// ACL_GetMaintenanceSchedule

// required .mesos.ACL.Entity principals = 1;
inline bool ACL_GetMaintenanceSchedule::has_principals() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACL_GetMaintenanceSchedule::set_has_principals() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACL_GetMaintenanceSchedule::clear_has_principals() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACL_GetMaintenanceSchedule::clear_principals() {
  if (principals_ != NULL) principals_->Clear();
  clear_has_principals();
}
inline const ::mesos::ACL_Entity& ACL_GetMaintenanceSchedule::principals() const {
  const ::mesos::ACL_Entity* p = principals_;
  // @@protoc_insertion_point(field_get:mesos.ACL.GetMaintenanceSchedule.principals)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ACL_Entity*>(
      &::mesos::_ACL_Entity_default_instance_);
}
inline ::mesos::ACL_Entity* ACL_GetMaintenanceSchedule::release_principals() {
  // @@protoc_insertion_point(field_release:mesos.ACL.GetMaintenanceSchedule.principals)
  clear_has_principals();
  ::mesos::ACL_Entity* temp = principals_;
  principals_ = NULL;
  return temp;
}
inline ::mesos::ACL_Entity* ACL_GetMaintenanceSchedule::mutable_principals() {
  set_has_principals();
  if (principals_ == NULL) {
    principals_ = new ::mesos::ACL_Entity;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ACL.GetMaintenanceSchedule.principals)
  return principals_;
}
inline void ACL_GetMaintenanceSchedule::set_allocated_principals(::mesos::ACL_Entity* principals) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete principals_;
  }
  if (principals) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      principals = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, principals, submessage_arena);
    }
    set_has_principals();
  } else {
    clear_has_principals();
  }
  principals_ = principals;
  // @@protoc_insertion_point(field_set_allocated:mesos.ACL.GetMaintenanceSchedule.principals)
}

// required .mesos.ACL.Entity machines = 2;
inline bool ACL_GetMaintenanceSchedule::has_machines() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACL_GetMaintenanceSchedule::set_has_machines() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ACL_GetMaintenanceSchedule::clear_has_machines() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ACL_GetMaintenanceSchedule::clear_machines() {
  if (machines_ != NULL) machines_->Clear();
  clear_has_machines();
}
inline const ::mesos::ACL_Entity& ACL_GetMaintenanceSchedule::machines() const {
  const ::mesos::ACL_Entity* p = machines_;
  // @@protoc_insertion_point(field_get:mesos.ACL.GetMaintenanceSchedule.machines)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ACL_Entity*>(
      &::mesos::_ACL_Entity_default_instance_);
}
inline ::mesos::ACL_Entity* ACL_GetMaintenanceSchedule::release_machines() {
  // @@protoc_insertion_point(field_release:mesos.ACL.GetMaintenanceSchedule.machines)
  clear_has_machines();
  ::mesos::ACL_Entity* temp = machines_;
  machines_ = NULL;
  return temp;
}
inline ::mesos::ACL_Entity* ACL_GetMaintenanceSchedule::mutable_machines() {
  set_has_machines();
  if (machines_ == NULL) {
    machines_ = new ::mesos::ACL_Entity;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ACL.GetMaintenanceSchedule.machines)
  return machines_;
}
inline void ACL_GetMaintenanceSchedule::set_allocated_machines(::mesos::ACL_Entity* machines) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete machines_;
  }
  if (machines) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      machines = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, machines, submessage_arena);
    }
    set_has_machines();
  } else {
    clear_has_machines();
  }
  machines_ = machines;
  // @@protoc_insertion_point(field_set_allocated:mesos.ACL.GetMaintenanceSchedule.machines)
}

// -------------------------------------------------------------------

// ACL_StartMaintenance

// required .mesos.ACL.Entity principals = 1;
inline bool ACL_StartMaintenance::has_principals() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACL_StartMaintenance::set_has_principals() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACL_StartMaintenance::clear_has_principals() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACL_StartMaintenance::clear_principals() {
  if (principals_ != NULL) principals_->Clear();
  clear_has_principals();
}
inline const ::mesos::ACL_Entity& ACL_StartMaintenance::principals() const {
  const ::mesos::ACL_Entity* p = principals_;
  // @@protoc_insertion_point(field_get:mesos.ACL.StartMaintenance.principals)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ACL_Entity*>(
      &::mesos::_ACL_Entity_default_instance_);
}
inline ::mesos::ACL_Entity* ACL_StartMaintenance::release_principals() {
  // @@protoc_insertion_point(field_release:mesos.ACL.StartMaintenance.principals)
  clear_has_principals();
  ::mesos::ACL_Entity* temp = principals_;
  principals_ = NULL;
  return temp;
}
inline ::mesos::ACL_Entity* ACL_StartMaintenance::mutable_principals() {
  set_has_principals();
  if (principals_ == NULL) {
    principals_ = new ::mesos::ACL_Entity;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ACL.StartMaintenance.principals)
  return principals_;
}
inline void ACL_StartMaintenance::set_allocated_principals(::mesos::ACL_Entity* principals) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete principals_;
  }
  if (principals) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      principals = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, principals, submessage_arena);
    }
    set_has_principals();
  } else {
    clear_has_principals();
  }
  principals_ = principals;
  // @@protoc_insertion_point(field_set_allocated:mesos.ACL.StartMaintenance.principals)
}

// required .mesos.ACL.Entity machines = 2;
inline bool ACL_StartMaintenance::has_machines() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACL_StartMaintenance::set_has_machines() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ACL_StartMaintenance::clear_has_machines() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ACL_StartMaintenance::clear_machines() {
  if (machines_ != NULL) machines_->Clear();
  clear_has_machines();
}
inline const ::mesos::ACL_Entity& ACL_StartMaintenance::machines() const {
  const ::mesos::ACL_Entity* p = machines_;
  // @@protoc_insertion_point(field_get:mesos.ACL.StartMaintenance.machines)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ACL_Entity*>(
      &::mesos::_ACL_Entity_default_instance_);
}
inline ::mesos::ACL_Entity* ACL_StartMaintenance::release_machines() {
  // @@protoc_insertion_point(field_release:mesos.ACL.StartMaintenance.machines)
  clear_has_machines();
  ::mesos::ACL_Entity* temp = machines_;
  machines_ = NULL;
  return temp;
}
inline ::mesos::ACL_Entity* ACL_StartMaintenance::mutable_machines() {
  set_has_machines();
  if (machines_ == NULL) {
    machines_ = new ::mesos::ACL_Entity;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ACL.StartMaintenance.machines)
  return machines_;
}
inline void ACL_StartMaintenance::set_allocated_machines(::mesos::ACL_Entity* machines) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete machines_;
  }
  if (machines) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      machines = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, machines, submessage_arena);
    }
    set_has_machines();
  } else {
    clear_has_machines();
  }
  machines_ = machines;
  // @@protoc_insertion_point(field_set_allocated:mesos.ACL.StartMaintenance.machines)
}

// -------------------------------------------------------------------

// ACL_StopMaintenance

// required .mesos.ACL.Entity principals = 1;
inline bool ACL_StopMaintenance::has_principals() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACL_StopMaintenance::set_has_principals() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACL_StopMaintenance::clear_has_principals() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACL_StopMaintenance::clear_principals() {
  if (principals_ != NULL) principals_->Clear();
  clear_has_principals();
}
inline const ::mesos::ACL_Entity& ACL_StopMaintenance::principals() const {
  const ::mesos::ACL_Entity* p = principals_;
  // @@protoc_insertion_point(field_get:mesos.ACL.StopMaintenance.principals)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ACL_Entity*>(
      &::mesos::_ACL_Entity_default_instance_);
}
inline ::mesos::ACL_Entity* ACL_StopMaintenance::release_principals() {
  // @@protoc_insertion_point(field_release:mesos.ACL.StopMaintenance.principals)
  clear_has_principals();
  ::mesos::ACL_Entity* temp = principals_;
  principals_ = NULL;
  return temp;
}
inline ::mesos::ACL_Entity* ACL_StopMaintenance::mutable_principals() {
  set_has_principals();
  if (principals_ == NULL) {
    principals_ = new ::mesos::ACL_Entity;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ACL.StopMaintenance.principals)
  return principals_;
}
inline void ACL_StopMaintenance::set_allocated_principals(::mesos::ACL_Entity* principals) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete principals_;
  }
  if (principals) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      principals = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, principals, submessage_arena);
    }
    set_has_principals();
  } else {
    clear_has_principals();
  }
  principals_ = principals;
  // @@protoc_insertion_point(field_set_allocated:mesos.ACL.StopMaintenance.principals)
}

// required .mesos.ACL.Entity machines = 2;
inline bool ACL_StopMaintenance::has_machines() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACL_StopMaintenance::set_has_machines() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ACL_StopMaintenance::clear_has_machines() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ACL_StopMaintenance::clear_machines() {
  if (machines_ != NULL) machines_->Clear();
  clear_has_machines();
}
inline const ::mesos::ACL_Entity& ACL_StopMaintenance::machines() const {
  const ::mesos::ACL_Entity* p = machines_;
  // @@protoc_insertion_point(field_get:mesos.ACL.StopMaintenance.machines)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ACL_Entity*>(
      &::mesos::_ACL_Entity_default_instance_);
}
inline ::mesos::ACL_Entity* ACL_StopMaintenance::release_machines() {
  // @@protoc_insertion_point(field_release:mesos.ACL.StopMaintenance.machines)
  clear_has_machines();
  ::mesos::ACL_Entity* temp = machines_;
  machines_ = NULL;
  return temp;
}
inline ::mesos::ACL_Entity* ACL_StopMaintenance::mutable_machines() {
  set_has_machines();
  if (machines_ == NULL) {
    machines_ = new ::mesos::ACL_Entity;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ACL.StopMaintenance.machines)
  return machines_;
}
inline void ACL_StopMaintenance::set_allocated_machines(::mesos::ACL_Entity* machines) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete machines_;
  }
  if (machines) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      machines = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, machines, submessage_arena);
    }
    set_has_machines();
  } else {
    clear_has_machines();
  }
  machines_ = machines;
  // @@protoc_insertion_point(field_set_allocated:mesos.ACL.StopMaintenance.machines)
}

// -------------------------------------------------------------------

// ACL_GetMaintenanceStatus

// required .mesos.ACL.Entity principals = 1;
inline bool ACL_GetMaintenanceStatus::has_principals() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACL_GetMaintenanceStatus::set_has_principals() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACL_GetMaintenanceStatus::clear_has_principals() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACL_GetMaintenanceStatus::clear_principals() {
  if (principals_ != NULL) principals_->Clear();
  clear_has_principals();
}
inline const ::mesos::ACL_Entity& ACL_GetMaintenanceStatus::principals() const {
  const ::mesos::ACL_Entity* p = principals_;
  // @@protoc_insertion_point(field_get:mesos.ACL.GetMaintenanceStatus.principals)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ACL_Entity*>(
      &::mesos::_ACL_Entity_default_instance_);
}
inline ::mesos::ACL_Entity* ACL_GetMaintenanceStatus::release_principals() {
  // @@protoc_insertion_point(field_release:mesos.ACL.GetMaintenanceStatus.principals)
  clear_has_principals();
  ::mesos::ACL_Entity* temp = principals_;
  principals_ = NULL;
  return temp;
}
inline ::mesos::ACL_Entity* ACL_GetMaintenanceStatus::mutable_principals() {
  set_has_principals();
  if (principals_ == NULL) {
    principals_ = new ::mesos::ACL_Entity;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ACL.GetMaintenanceStatus.principals)
  return principals_;
}
inline void ACL_GetMaintenanceStatus::set_allocated_principals(::mesos::ACL_Entity* principals) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete principals_;
  }
  if (principals) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      principals = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, principals, submessage_arena);
    }
    set_has_principals();
  } else {
    clear_has_principals();
  }
  principals_ = principals;
  // @@protoc_insertion_point(field_set_allocated:mesos.ACL.GetMaintenanceStatus.principals)
}

// required .mesos.ACL.Entity machines = 2;
inline bool ACL_GetMaintenanceStatus::has_machines() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACL_GetMaintenanceStatus::set_has_machines() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ACL_GetMaintenanceStatus::clear_has_machines() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ACL_GetMaintenanceStatus::clear_machines() {
  if (machines_ != NULL) machines_->Clear();
  clear_has_machines();
}
inline const ::mesos::ACL_Entity& ACL_GetMaintenanceStatus::machines() const {
  const ::mesos::ACL_Entity* p = machines_;
  // @@protoc_insertion_point(field_get:mesos.ACL.GetMaintenanceStatus.machines)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ACL_Entity*>(
      &::mesos::_ACL_Entity_default_instance_);
}
inline ::mesos::ACL_Entity* ACL_GetMaintenanceStatus::release_machines() {
  // @@protoc_insertion_point(field_release:mesos.ACL.GetMaintenanceStatus.machines)
  clear_has_machines();
  ::mesos::ACL_Entity* temp = machines_;
  machines_ = NULL;
  return temp;
}
inline ::mesos::ACL_Entity* ACL_GetMaintenanceStatus::mutable_machines() {
  set_has_machines();
  if (machines_ == NULL) {
    machines_ = new ::mesos::ACL_Entity;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ACL.GetMaintenanceStatus.machines)
  return machines_;
}
inline void ACL_GetMaintenanceStatus::set_allocated_machines(::mesos::ACL_Entity* machines) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete machines_;
  }
  if (machines) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      machines = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, machines, submessage_arena);
    }
    set_has_machines();
  } else {
    clear_has_machines();
  }
  machines_ = machines;
  // @@protoc_insertion_point(field_set_allocated:mesos.ACL.GetMaintenanceStatus.machines)
}

// -------------------------------------------------------------------

// ACL_MarkAgentGone

// required .mesos.ACL.Entity principals = 1;
inline bool ACL_MarkAgentGone::has_principals() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACL_MarkAgentGone::set_has_principals() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACL_MarkAgentGone::clear_has_principals() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACL_MarkAgentGone::clear_principals() {
  if (principals_ != NULL) principals_->Clear();
  clear_has_principals();
}
inline const ::mesos::ACL_Entity& ACL_MarkAgentGone::principals() const {
  const ::mesos::ACL_Entity* p = principals_;
  // @@protoc_insertion_point(field_get:mesos.ACL.MarkAgentGone.principals)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ACL_Entity*>(
      &::mesos::_ACL_Entity_default_instance_);
}
inline ::mesos::ACL_Entity* ACL_MarkAgentGone::release_principals() {
  // @@protoc_insertion_point(field_release:mesos.ACL.MarkAgentGone.principals)
  clear_has_principals();
  ::mesos::ACL_Entity* temp = principals_;
  principals_ = NULL;
  return temp;
}
inline ::mesos::ACL_Entity* ACL_MarkAgentGone::mutable_principals() {
  set_has_principals();
  if (principals_ == NULL) {
    principals_ = new ::mesos::ACL_Entity;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ACL.MarkAgentGone.principals)
  return principals_;
}
inline void ACL_MarkAgentGone::set_allocated_principals(::mesos::ACL_Entity* principals) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete principals_;
  }
  if (principals) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      principals = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, principals, submessage_arena);
    }
    set_has_principals();
  } else {
    clear_has_principals();
  }
  principals_ = principals;
  // @@protoc_insertion_point(field_set_allocated:mesos.ACL.MarkAgentGone.principals)
}

// required .mesos.ACL.Entity agents = 2;
inline bool ACL_MarkAgentGone::has_agents() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACL_MarkAgentGone::set_has_agents() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ACL_MarkAgentGone::clear_has_agents() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ACL_MarkAgentGone::clear_agents() {
  if (agents_ != NULL) agents_->Clear();
  clear_has_agents();
}
inline const ::mesos::ACL_Entity& ACL_MarkAgentGone::agents() const {
  const ::mesos::ACL_Entity* p = agents_;
  // @@protoc_insertion_point(field_get:mesos.ACL.MarkAgentGone.agents)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ACL_Entity*>(
      &::mesos::_ACL_Entity_default_instance_);
}
inline ::mesos::ACL_Entity* ACL_MarkAgentGone::release_agents() {
  // @@protoc_insertion_point(field_release:mesos.ACL.MarkAgentGone.agents)
  clear_has_agents();
  ::mesos::ACL_Entity* temp = agents_;
  agents_ = NULL;
  return temp;
}
inline ::mesos::ACL_Entity* ACL_MarkAgentGone::mutable_agents() {
  set_has_agents();
  if (agents_ == NULL) {
    agents_ = new ::mesos::ACL_Entity;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ACL.MarkAgentGone.agents)
  return agents_;
}
inline void ACL_MarkAgentGone::set_allocated_agents(::mesos::ACL_Entity* agents) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete agents_;
  }
  if (agents) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      agents = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, agents, submessage_arena);
    }
    set_has_agents();
  } else {
    clear_has_agents();
  }
  agents_ = agents;
  // @@protoc_insertion_point(field_set_allocated:mesos.ACL.MarkAgentGone.agents)
}

// -------------------------------------------------------------------

// ACL_LaunchStandaloneContainer

// required .mesos.ACL.Entity principals = 1;
inline bool ACL_LaunchStandaloneContainer::has_principals() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACL_LaunchStandaloneContainer::set_has_principals() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACL_LaunchStandaloneContainer::clear_has_principals() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACL_LaunchStandaloneContainer::clear_principals() {
  if (principals_ != NULL) principals_->Clear();
  clear_has_principals();
}
inline const ::mesos::ACL_Entity& ACL_LaunchStandaloneContainer::principals() const {
  const ::mesos::ACL_Entity* p = principals_;
  // @@protoc_insertion_point(field_get:mesos.ACL.LaunchStandaloneContainer.principals)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ACL_Entity*>(
      &::mesos::_ACL_Entity_default_instance_);
}
inline ::mesos::ACL_Entity* ACL_LaunchStandaloneContainer::release_principals() {
  // @@protoc_insertion_point(field_release:mesos.ACL.LaunchStandaloneContainer.principals)
  clear_has_principals();
  ::mesos::ACL_Entity* temp = principals_;
  principals_ = NULL;
  return temp;
}
inline ::mesos::ACL_Entity* ACL_LaunchStandaloneContainer::mutable_principals() {
  set_has_principals();
  if (principals_ == NULL) {
    principals_ = new ::mesos::ACL_Entity;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ACL.LaunchStandaloneContainer.principals)
  return principals_;
}
inline void ACL_LaunchStandaloneContainer::set_allocated_principals(::mesos::ACL_Entity* principals) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete principals_;
  }
  if (principals) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      principals = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, principals, submessage_arena);
    }
    set_has_principals();
  } else {
    clear_has_principals();
  }
  principals_ = principals;
  // @@protoc_insertion_point(field_set_allocated:mesos.ACL.LaunchStandaloneContainer.principals)
}

// required .mesos.ACL.Entity users = 2;
inline bool ACL_LaunchStandaloneContainer::has_users() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACL_LaunchStandaloneContainer::set_has_users() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ACL_LaunchStandaloneContainer::clear_has_users() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ACL_LaunchStandaloneContainer::clear_users() {
  if (users_ != NULL) users_->Clear();
  clear_has_users();
}
inline const ::mesos::ACL_Entity& ACL_LaunchStandaloneContainer::users() const {
  const ::mesos::ACL_Entity* p = users_;
  // @@protoc_insertion_point(field_get:mesos.ACL.LaunchStandaloneContainer.users)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ACL_Entity*>(
      &::mesos::_ACL_Entity_default_instance_);
}
inline ::mesos::ACL_Entity* ACL_LaunchStandaloneContainer::release_users() {
  // @@protoc_insertion_point(field_release:mesos.ACL.LaunchStandaloneContainer.users)
  clear_has_users();
  ::mesos::ACL_Entity* temp = users_;
  users_ = NULL;
  return temp;
}
inline ::mesos::ACL_Entity* ACL_LaunchStandaloneContainer::mutable_users() {
  set_has_users();
  if (users_ == NULL) {
    users_ = new ::mesos::ACL_Entity;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ACL.LaunchStandaloneContainer.users)
  return users_;
}
inline void ACL_LaunchStandaloneContainer::set_allocated_users(::mesos::ACL_Entity* users) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete users_;
  }
  if (users) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      users = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, users, submessage_arena);
    }
    set_has_users();
  } else {
    clear_has_users();
  }
  users_ = users;
  // @@protoc_insertion_point(field_set_allocated:mesos.ACL.LaunchStandaloneContainer.users)
}

// -------------------------------------------------------------------

// ACL_KillStandaloneContainer

// required .mesos.ACL.Entity principals = 1;
inline bool ACL_KillStandaloneContainer::has_principals() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACL_KillStandaloneContainer::set_has_principals() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACL_KillStandaloneContainer::clear_has_principals() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACL_KillStandaloneContainer::clear_principals() {
  if (principals_ != NULL) principals_->Clear();
  clear_has_principals();
}
inline const ::mesos::ACL_Entity& ACL_KillStandaloneContainer::principals() const {
  const ::mesos::ACL_Entity* p = principals_;
  // @@protoc_insertion_point(field_get:mesos.ACL.KillStandaloneContainer.principals)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ACL_Entity*>(
      &::mesos::_ACL_Entity_default_instance_);
}
inline ::mesos::ACL_Entity* ACL_KillStandaloneContainer::release_principals() {
  // @@protoc_insertion_point(field_release:mesos.ACL.KillStandaloneContainer.principals)
  clear_has_principals();
  ::mesos::ACL_Entity* temp = principals_;
  principals_ = NULL;
  return temp;
}
inline ::mesos::ACL_Entity* ACL_KillStandaloneContainer::mutable_principals() {
  set_has_principals();
  if (principals_ == NULL) {
    principals_ = new ::mesos::ACL_Entity;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ACL.KillStandaloneContainer.principals)
  return principals_;
}
inline void ACL_KillStandaloneContainer::set_allocated_principals(::mesos::ACL_Entity* principals) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete principals_;
  }
  if (principals) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      principals = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, principals, submessage_arena);
    }
    set_has_principals();
  } else {
    clear_has_principals();
  }
  principals_ = principals;
  // @@protoc_insertion_point(field_set_allocated:mesos.ACL.KillStandaloneContainer.principals)
}

// required .mesos.ACL.Entity users = 2;
inline bool ACL_KillStandaloneContainer::has_users() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACL_KillStandaloneContainer::set_has_users() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ACL_KillStandaloneContainer::clear_has_users() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ACL_KillStandaloneContainer::clear_users() {
  if (users_ != NULL) users_->Clear();
  clear_has_users();
}
inline const ::mesos::ACL_Entity& ACL_KillStandaloneContainer::users() const {
  const ::mesos::ACL_Entity* p = users_;
  // @@protoc_insertion_point(field_get:mesos.ACL.KillStandaloneContainer.users)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ACL_Entity*>(
      &::mesos::_ACL_Entity_default_instance_);
}
inline ::mesos::ACL_Entity* ACL_KillStandaloneContainer::release_users() {
  // @@protoc_insertion_point(field_release:mesos.ACL.KillStandaloneContainer.users)
  clear_has_users();
  ::mesos::ACL_Entity* temp = users_;
  users_ = NULL;
  return temp;
}
inline ::mesos::ACL_Entity* ACL_KillStandaloneContainer::mutable_users() {
  set_has_users();
  if (users_ == NULL) {
    users_ = new ::mesos::ACL_Entity;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ACL.KillStandaloneContainer.users)
  return users_;
}
inline void ACL_KillStandaloneContainer::set_allocated_users(::mesos::ACL_Entity* users) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete users_;
  }
  if (users) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      users = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, users, submessage_arena);
    }
    set_has_users();
  } else {
    clear_has_users();
  }
  users_ = users;
  // @@protoc_insertion_point(field_set_allocated:mesos.ACL.KillStandaloneContainer.users)
}

// -------------------------------------------------------------------

// ACL_WaitStandaloneContainer

// required .mesos.ACL.Entity principals = 1;
inline bool ACL_WaitStandaloneContainer::has_principals() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACL_WaitStandaloneContainer::set_has_principals() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACL_WaitStandaloneContainer::clear_has_principals() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACL_WaitStandaloneContainer::clear_principals() {
  if (principals_ != NULL) principals_->Clear();
  clear_has_principals();
}
inline const ::mesos::ACL_Entity& ACL_WaitStandaloneContainer::principals() const {
  const ::mesos::ACL_Entity* p = principals_;
  // @@protoc_insertion_point(field_get:mesos.ACL.WaitStandaloneContainer.principals)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ACL_Entity*>(
      &::mesos::_ACL_Entity_default_instance_);
}
inline ::mesos::ACL_Entity* ACL_WaitStandaloneContainer::release_principals() {
  // @@protoc_insertion_point(field_release:mesos.ACL.WaitStandaloneContainer.principals)
  clear_has_principals();
  ::mesos::ACL_Entity* temp = principals_;
  principals_ = NULL;
  return temp;
}
inline ::mesos::ACL_Entity* ACL_WaitStandaloneContainer::mutable_principals() {
  set_has_principals();
  if (principals_ == NULL) {
    principals_ = new ::mesos::ACL_Entity;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ACL.WaitStandaloneContainer.principals)
  return principals_;
}
inline void ACL_WaitStandaloneContainer::set_allocated_principals(::mesos::ACL_Entity* principals) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete principals_;
  }
  if (principals) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      principals = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, principals, submessage_arena);
    }
    set_has_principals();
  } else {
    clear_has_principals();
  }
  principals_ = principals;
  // @@protoc_insertion_point(field_set_allocated:mesos.ACL.WaitStandaloneContainer.principals)
}

// required .mesos.ACL.Entity users = 2;
inline bool ACL_WaitStandaloneContainer::has_users() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACL_WaitStandaloneContainer::set_has_users() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ACL_WaitStandaloneContainer::clear_has_users() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ACL_WaitStandaloneContainer::clear_users() {
  if (users_ != NULL) users_->Clear();
  clear_has_users();
}
inline const ::mesos::ACL_Entity& ACL_WaitStandaloneContainer::users() const {
  const ::mesos::ACL_Entity* p = users_;
  // @@protoc_insertion_point(field_get:mesos.ACL.WaitStandaloneContainer.users)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ACL_Entity*>(
      &::mesos::_ACL_Entity_default_instance_);
}
inline ::mesos::ACL_Entity* ACL_WaitStandaloneContainer::release_users() {
  // @@protoc_insertion_point(field_release:mesos.ACL.WaitStandaloneContainer.users)
  clear_has_users();
  ::mesos::ACL_Entity* temp = users_;
  users_ = NULL;
  return temp;
}
inline ::mesos::ACL_Entity* ACL_WaitStandaloneContainer::mutable_users() {
  set_has_users();
  if (users_ == NULL) {
    users_ = new ::mesos::ACL_Entity;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ACL.WaitStandaloneContainer.users)
  return users_;
}
inline void ACL_WaitStandaloneContainer::set_allocated_users(::mesos::ACL_Entity* users) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete users_;
  }
  if (users) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      users = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, users, submessage_arena);
    }
    set_has_users();
  } else {
    clear_has_users();
  }
  users_ = users;
  // @@protoc_insertion_point(field_set_allocated:mesos.ACL.WaitStandaloneContainer.users)
}

// -------------------------------------------------------------------

// ACL_RemoveStandaloneContainer

// required .mesos.ACL.Entity principals = 1;
inline bool ACL_RemoveStandaloneContainer::has_principals() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACL_RemoveStandaloneContainer::set_has_principals() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACL_RemoveStandaloneContainer::clear_has_principals() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACL_RemoveStandaloneContainer::clear_principals() {
  if (principals_ != NULL) principals_->Clear();
  clear_has_principals();
}
inline const ::mesos::ACL_Entity& ACL_RemoveStandaloneContainer::principals() const {
  const ::mesos::ACL_Entity* p = principals_;
  // @@protoc_insertion_point(field_get:mesos.ACL.RemoveStandaloneContainer.principals)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ACL_Entity*>(
      &::mesos::_ACL_Entity_default_instance_);
}
inline ::mesos::ACL_Entity* ACL_RemoveStandaloneContainer::release_principals() {
  // @@protoc_insertion_point(field_release:mesos.ACL.RemoveStandaloneContainer.principals)
  clear_has_principals();
  ::mesos::ACL_Entity* temp = principals_;
  principals_ = NULL;
  return temp;
}
inline ::mesos::ACL_Entity* ACL_RemoveStandaloneContainer::mutable_principals() {
  set_has_principals();
  if (principals_ == NULL) {
    principals_ = new ::mesos::ACL_Entity;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ACL.RemoveStandaloneContainer.principals)
  return principals_;
}
inline void ACL_RemoveStandaloneContainer::set_allocated_principals(::mesos::ACL_Entity* principals) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete principals_;
  }
  if (principals) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      principals = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, principals, submessage_arena);
    }
    set_has_principals();
  } else {
    clear_has_principals();
  }
  principals_ = principals;
  // @@protoc_insertion_point(field_set_allocated:mesos.ACL.RemoveStandaloneContainer.principals)
}

// required .mesos.ACL.Entity users = 2;
inline bool ACL_RemoveStandaloneContainer::has_users() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACL_RemoveStandaloneContainer::set_has_users() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ACL_RemoveStandaloneContainer::clear_has_users() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ACL_RemoveStandaloneContainer::clear_users() {
  if (users_ != NULL) users_->Clear();
  clear_has_users();
}
inline const ::mesos::ACL_Entity& ACL_RemoveStandaloneContainer::users() const {
  const ::mesos::ACL_Entity* p = users_;
  // @@protoc_insertion_point(field_get:mesos.ACL.RemoveStandaloneContainer.users)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ACL_Entity*>(
      &::mesos::_ACL_Entity_default_instance_);
}
inline ::mesos::ACL_Entity* ACL_RemoveStandaloneContainer::release_users() {
  // @@protoc_insertion_point(field_release:mesos.ACL.RemoveStandaloneContainer.users)
  clear_has_users();
  ::mesos::ACL_Entity* temp = users_;
  users_ = NULL;
  return temp;
}
inline ::mesos::ACL_Entity* ACL_RemoveStandaloneContainer::mutable_users() {
  set_has_users();
  if (users_ == NULL) {
    users_ = new ::mesos::ACL_Entity;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ACL.RemoveStandaloneContainer.users)
  return users_;
}
inline void ACL_RemoveStandaloneContainer::set_allocated_users(::mesos::ACL_Entity* users) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete users_;
  }
  if (users) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      users = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, users, submessage_arena);
    }
    set_has_users();
  } else {
    clear_has_users();
  }
  users_ = users;
  // @@protoc_insertion_point(field_set_allocated:mesos.ACL.RemoveStandaloneContainer.users)
}

// -------------------------------------------------------------------

// ACL_ViewStandaloneContainer

// required .mesos.ACL.Entity principals = 1;
inline bool ACL_ViewStandaloneContainer::has_principals() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACL_ViewStandaloneContainer::set_has_principals() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACL_ViewStandaloneContainer::clear_has_principals() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACL_ViewStandaloneContainer::clear_principals() {
  if (principals_ != NULL) principals_->Clear();
  clear_has_principals();
}
inline const ::mesos::ACL_Entity& ACL_ViewStandaloneContainer::principals() const {
  const ::mesos::ACL_Entity* p = principals_;
  // @@protoc_insertion_point(field_get:mesos.ACL.ViewStandaloneContainer.principals)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ACL_Entity*>(
      &::mesos::_ACL_Entity_default_instance_);
}
inline ::mesos::ACL_Entity* ACL_ViewStandaloneContainer::release_principals() {
  // @@protoc_insertion_point(field_release:mesos.ACL.ViewStandaloneContainer.principals)
  clear_has_principals();
  ::mesos::ACL_Entity* temp = principals_;
  principals_ = NULL;
  return temp;
}
inline ::mesos::ACL_Entity* ACL_ViewStandaloneContainer::mutable_principals() {
  set_has_principals();
  if (principals_ == NULL) {
    principals_ = new ::mesos::ACL_Entity;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ACL.ViewStandaloneContainer.principals)
  return principals_;
}
inline void ACL_ViewStandaloneContainer::set_allocated_principals(::mesos::ACL_Entity* principals) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete principals_;
  }
  if (principals) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      principals = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, principals, submessage_arena);
    }
    set_has_principals();
  } else {
    clear_has_principals();
  }
  principals_ = principals;
  // @@protoc_insertion_point(field_set_allocated:mesos.ACL.ViewStandaloneContainer.principals)
}

// required .mesos.ACL.Entity users = 2;
inline bool ACL_ViewStandaloneContainer::has_users() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACL_ViewStandaloneContainer::set_has_users() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ACL_ViewStandaloneContainer::clear_has_users() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ACL_ViewStandaloneContainer::clear_users() {
  if (users_ != NULL) users_->Clear();
  clear_has_users();
}
inline const ::mesos::ACL_Entity& ACL_ViewStandaloneContainer::users() const {
  const ::mesos::ACL_Entity* p = users_;
  // @@protoc_insertion_point(field_get:mesos.ACL.ViewStandaloneContainer.users)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ACL_Entity*>(
      &::mesos::_ACL_Entity_default_instance_);
}
inline ::mesos::ACL_Entity* ACL_ViewStandaloneContainer::release_users() {
  // @@protoc_insertion_point(field_release:mesos.ACL.ViewStandaloneContainer.users)
  clear_has_users();
  ::mesos::ACL_Entity* temp = users_;
  users_ = NULL;
  return temp;
}
inline ::mesos::ACL_Entity* ACL_ViewStandaloneContainer::mutable_users() {
  set_has_users();
  if (users_ == NULL) {
    users_ = new ::mesos::ACL_Entity;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ACL.ViewStandaloneContainer.users)
  return users_;
}
inline void ACL_ViewStandaloneContainer::set_allocated_users(::mesos::ACL_Entity* users) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete users_;
  }
  if (users) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      users = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, users, submessage_arena);
    }
    set_has_users();
  } else {
    clear_has_users();
  }
  users_ = users;
  // @@protoc_insertion_point(field_set_allocated:mesos.ACL.ViewStandaloneContainer.users)
}

// -------------------------------------------------------------------

// ACL_ModifyResourceProviderConfig

// required .mesos.ACL.Entity principals = 1;
inline bool ACL_ModifyResourceProviderConfig::has_principals() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACL_ModifyResourceProviderConfig::set_has_principals() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACL_ModifyResourceProviderConfig::clear_has_principals() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACL_ModifyResourceProviderConfig::clear_principals() {
  if (principals_ != NULL) principals_->Clear();
  clear_has_principals();
}
inline const ::mesos::ACL_Entity& ACL_ModifyResourceProviderConfig::principals() const {
  const ::mesos::ACL_Entity* p = principals_;
  // @@protoc_insertion_point(field_get:mesos.ACL.ModifyResourceProviderConfig.principals)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ACL_Entity*>(
      &::mesos::_ACL_Entity_default_instance_);
}
inline ::mesos::ACL_Entity* ACL_ModifyResourceProviderConfig::release_principals() {
  // @@protoc_insertion_point(field_release:mesos.ACL.ModifyResourceProviderConfig.principals)
  clear_has_principals();
  ::mesos::ACL_Entity* temp = principals_;
  principals_ = NULL;
  return temp;
}
inline ::mesos::ACL_Entity* ACL_ModifyResourceProviderConfig::mutable_principals() {
  set_has_principals();
  if (principals_ == NULL) {
    principals_ = new ::mesos::ACL_Entity;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ACL.ModifyResourceProviderConfig.principals)
  return principals_;
}
inline void ACL_ModifyResourceProviderConfig::set_allocated_principals(::mesos::ACL_Entity* principals) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete principals_;
  }
  if (principals) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      principals = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, principals, submessage_arena);
    }
    set_has_principals();
  } else {
    clear_has_principals();
  }
  principals_ = principals;
  // @@protoc_insertion_point(field_set_allocated:mesos.ACL.ModifyResourceProviderConfig.principals)
}

// required .mesos.ACL.Entity resource_providers = 2;
inline bool ACL_ModifyResourceProviderConfig::has_resource_providers() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACL_ModifyResourceProviderConfig::set_has_resource_providers() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ACL_ModifyResourceProviderConfig::clear_has_resource_providers() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ACL_ModifyResourceProviderConfig::clear_resource_providers() {
  if (resource_providers_ != NULL) resource_providers_->Clear();
  clear_has_resource_providers();
}
inline const ::mesos::ACL_Entity& ACL_ModifyResourceProviderConfig::resource_providers() const {
  const ::mesos::ACL_Entity* p = resource_providers_;
  // @@protoc_insertion_point(field_get:mesos.ACL.ModifyResourceProviderConfig.resource_providers)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ACL_Entity*>(
      &::mesos::_ACL_Entity_default_instance_);
}
inline ::mesos::ACL_Entity* ACL_ModifyResourceProviderConfig::release_resource_providers() {
  // @@protoc_insertion_point(field_release:mesos.ACL.ModifyResourceProviderConfig.resource_providers)
  clear_has_resource_providers();
  ::mesos::ACL_Entity* temp = resource_providers_;
  resource_providers_ = NULL;
  return temp;
}
inline ::mesos::ACL_Entity* ACL_ModifyResourceProviderConfig::mutable_resource_providers() {
  set_has_resource_providers();
  if (resource_providers_ == NULL) {
    resource_providers_ = new ::mesos::ACL_Entity;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ACL.ModifyResourceProviderConfig.resource_providers)
  return resource_providers_;
}
inline void ACL_ModifyResourceProviderConfig::set_allocated_resource_providers(::mesos::ACL_Entity* resource_providers) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete resource_providers_;
  }
  if (resource_providers) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      resource_providers = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, resource_providers, submessage_arena);
    }
    set_has_resource_providers();
  } else {
    clear_has_resource_providers();
  }
  resource_providers_ = resource_providers;
  // @@protoc_insertion_point(field_set_allocated:mesos.ACL.ModifyResourceProviderConfig.resource_providers)
}

// -------------------------------------------------------------------

// ACL_PruneImages

// required .mesos.ACL.Entity principals = 1;
inline bool ACL_PruneImages::has_principals() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACL_PruneImages::set_has_principals() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACL_PruneImages::clear_has_principals() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACL_PruneImages::clear_principals() {
  if (principals_ != NULL) principals_->Clear();
  clear_has_principals();
}
inline const ::mesos::ACL_Entity& ACL_PruneImages::principals() const {
  const ::mesos::ACL_Entity* p = principals_;
  // @@protoc_insertion_point(field_get:mesos.ACL.PruneImages.principals)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ACL_Entity*>(
      &::mesos::_ACL_Entity_default_instance_);
}
inline ::mesos::ACL_Entity* ACL_PruneImages::release_principals() {
  // @@protoc_insertion_point(field_release:mesos.ACL.PruneImages.principals)
  clear_has_principals();
  ::mesos::ACL_Entity* temp = principals_;
  principals_ = NULL;
  return temp;
}
inline ::mesos::ACL_Entity* ACL_PruneImages::mutable_principals() {
  set_has_principals();
  if (principals_ == NULL) {
    principals_ = new ::mesos::ACL_Entity;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ACL.PruneImages.principals)
  return principals_;
}
inline void ACL_PruneImages::set_allocated_principals(::mesos::ACL_Entity* principals) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete principals_;
  }
  if (principals) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      principals = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, principals, submessage_arena);
    }
    set_has_principals();
  } else {
    clear_has_principals();
  }
  principals_ = principals;
  // @@protoc_insertion_point(field_set_allocated:mesos.ACL.PruneImages.principals)
}

// required .mesos.ACL.Entity images = 2;
inline bool ACL_PruneImages::has_images() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACL_PruneImages::set_has_images() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ACL_PruneImages::clear_has_images() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ACL_PruneImages::clear_images() {
  if (images_ != NULL) images_->Clear();
  clear_has_images();
}
inline const ::mesos::ACL_Entity& ACL_PruneImages::images() const {
  const ::mesos::ACL_Entity* p = images_;
  // @@protoc_insertion_point(field_get:mesos.ACL.PruneImages.images)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ACL_Entity*>(
      &::mesos::_ACL_Entity_default_instance_);
}
inline ::mesos::ACL_Entity* ACL_PruneImages::release_images() {
  // @@protoc_insertion_point(field_release:mesos.ACL.PruneImages.images)
  clear_has_images();
  ::mesos::ACL_Entity* temp = images_;
  images_ = NULL;
  return temp;
}
inline ::mesos::ACL_Entity* ACL_PruneImages::mutable_images() {
  set_has_images();
  if (images_ == NULL) {
    images_ = new ::mesos::ACL_Entity;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ACL.PruneImages.images)
  return images_;
}
inline void ACL_PruneImages::set_allocated_images(::mesos::ACL_Entity* images) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete images_;
  }
  if (images) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      images = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, images, submessage_arena);
    }
    set_has_images();
  } else {
    clear_has_images();
  }
  images_ = images;
  // @@protoc_insertion_point(field_set_allocated:mesos.ACL.PruneImages.images)
}

// -------------------------------------------------------------------

// ACL

// -------------------------------------------------------------------

// ACLs

// optional bool permissive = 1 [default = true];
inline bool ACLs::has_permissive() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACLs::set_has_permissive() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACLs::clear_has_permissive() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACLs::clear_permissive() {
  permissive_ = true;
  clear_has_permissive();
}
inline bool ACLs::permissive() const {
  // @@protoc_insertion_point(field_get:mesos.ACLs.permissive)
  return permissive_;
}
inline void ACLs::set_permissive(bool value) {
  set_has_permissive();
  permissive_ = value;
  // @@protoc_insertion_point(field_set:mesos.ACLs.permissive)
}

// repeated .mesos.ACL.RegisterFramework register_frameworks = 2;
inline int ACLs::register_frameworks_size() const {
  return register_frameworks_.size();
}
inline void ACLs::clear_register_frameworks() {
  register_frameworks_.Clear();
}
inline const ::mesos::ACL_RegisterFramework& ACLs::register_frameworks(int index) const {
  // @@protoc_insertion_point(field_get:mesos.ACLs.register_frameworks)
  return register_frameworks_.Get(index);
}
inline ::mesos::ACL_RegisterFramework* ACLs::mutable_register_frameworks(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.ACLs.register_frameworks)
  return register_frameworks_.Mutable(index);
}
inline ::mesos::ACL_RegisterFramework* ACLs::add_register_frameworks() {
  // @@protoc_insertion_point(field_add:mesos.ACLs.register_frameworks)
  return register_frameworks_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::ACL_RegisterFramework >*
ACLs::mutable_register_frameworks() {
  // @@protoc_insertion_point(field_mutable_list:mesos.ACLs.register_frameworks)
  return &register_frameworks_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::ACL_RegisterFramework >&
ACLs::register_frameworks() const {
  // @@protoc_insertion_point(field_list:mesos.ACLs.register_frameworks)
  return register_frameworks_;
}

// repeated .mesos.ACL.RunTask run_tasks = 3;
inline int ACLs::run_tasks_size() const {
  return run_tasks_.size();
}
inline void ACLs::clear_run_tasks() {
  run_tasks_.Clear();
}
inline const ::mesos::ACL_RunTask& ACLs::run_tasks(int index) const {
  // @@protoc_insertion_point(field_get:mesos.ACLs.run_tasks)
  return run_tasks_.Get(index);
}
inline ::mesos::ACL_RunTask* ACLs::mutable_run_tasks(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.ACLs.run_tasks)
  return run_tasks_.Mutable(index);
}
inline ::mesos::ACL_RunTask* ACLs::add_run_tasks() {
  // @@protoc_insertion_point(field_add:mesos.ACLs.run_tasks)
  return run_tasks_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::ACL_RunTask >*
ACLs::mutable_run_tasks() {
  // @@protoc_insertion_point(field_mutable_list:mesos.ACLs.run_tasks)
  return &run_tasks_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::ACL_RunTask >&
ACLs::run_tasks() const {
  // @@protoc_insertion_point(field_list:mesos.ACLs.run_tasks)
  return run_tasks_;
}

// repeated .mesos.ACL.ReserveResources reserve_resources = 5;
inline int ACLs::reserve_resources_size() const {
  return reserve_resources_.size();
}
inline void ACLs::clear_reserve_resources() {
  reserve_resources_.Clear();
}
inline const ::mesos::ACL_ReserveResources& ACLs::reserve_resources(int index) const {
  // @@protoc_insertion_point(field_get:mesos.ACLs.reserve_resources)
  return reserve_resources_.Get(index);
}
inline ::mesos::ACL_ReserveResources* ACLs::mutable_reserve_resources(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.ACLs.reserve_resources)
  return reserve_resources_.Mutable(index);
}
inline ::mesos::ACL_ReserveResources* ACLs::add_reserve_resources() {
  // @@protoc_insertion_point(field_add:mesos.ACLs.reserve_resources)
  return reserve_resources_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::ACL_ReserveResources >*
ACLs::mutable_reserve_resources() {
  // @@protoc_insertion_point(field_mutable_list:mesos.ACLs.reserve_resources)
  return &reserve_resources_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::ACL_ReserveResources >&
ACLs::reserve_resources() const {
  // @@protoc_insertion_point(field_list:mesos.ACLs.reserve_resources)
  return reserve_resources_;
}

// repeated .mesos.ACL.UnreserveResources unreserve_resources = 6;
inline int ACLs::unreserve_resources_size() const {
  return unreserve_resources_.size();
}
inline void ACLs::clear_unreserve_resources() {
  unreserve_resources_.Clear();
}
inline const ::mesos::ACL_UnreserveResources& ACLs::unreserve_resources(int index) const {
  // @@protoc_insertion_point(field_get:mesos.ACLs.unreserve_resources)
  return unreserve_resources_.Get(index);
}
inline ::mesos::ACL_UnreserveResources* ACLs::mutable_unreserve_resources(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.ACLs.unreserve_resources)
  return unreserve_resources_.Mutable(index);
}
inline ::mesos::ACL_UnreserveResources* ACLs::add_unreserve_resources() {
  // @@protoc_insertion_point(field_add:mesos.ACLs.unreserve_resources)
  return unreserve_resources_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::ACL_UnreserveResources >*
ACLs::mutable_unreserve_resources() {
  // @@protoc_insertion_point(field_mutable_list:mesos.ACLs.unreserve_resources)
  return &unreserve_resources_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::ACL_UnreserveResources >&
ACLs::unreserve_resources() const {
  // @@protoc_insertion_point(field_list:mesos.ACLs.unreserve_resources)
  return unreserve_resources_;
}

// repeated .mesos.ACL.CreateVolume create_volumes = 7;
inline int ACLs::create_volumes_size() const {
  return create_volumes_.size();
}
inline void ACLs::clear_create_volumes() {
  create_volumes_.Clear();
}
inline const ::mesos::ACL_CreateVolume& ACLs::create_volumes(int index) const {
  // @@protoc_insertion_point(field_get:mesos.ACLs.create_volumes)
  return create_volumes_.Get(index);
}
inline ::mesos::ACL_CreateVolume* ACLs::mutable_create_volumes(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.ACLs.create_volumes)
  return create_volumes_.Mutable(index);
}
inline ::mesos::ACL_CreateVolume* ACLs::add_create_volumes() {
  // @@protoc_insertion_point(field_add:mesos.ACLs.create_volumes)
  return create_volumes_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::ACL_CreateVolume >*
ACLs::mutable_create_volumes() {
  // @@protoc_insertion_point(field_mutable_list:mesos.ACLs.create_volumes)
  return &create_volumes_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::ACL_CreateVolume >&
ACLs::create_volumes() const {
  // @@protoc_insertion_point(field_list:mesos.ACLs.create_volumes)
  return create_volumes_;
}

// repeated .mesos.ACL.DestroyVolume destroy_volumes = 8;
inline int ACLs::destroy_volumes_size() const {
  return destroy_volumes_.size();
}
inline void ACLs::clear_destroy_volumes() {
  destroy_volumes_.Clear();
}
inline const ::mesos::ACL_DestroyVolume& ACLs::destroy_volumes(int index) const {
  // @@protoc_insertion_point(field_get:mesos.ACLs.destroy_volumes)
  return destroy_volumes_.Get(index);
}
inline ::mesos::ACL_DestroyVolume* ACLs::mutable_destroy_volumes(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.ACLs.destroy_volumes)
  return destroy_volumes_.Mutable(index);
}
inline ::mesos::ACL_DestroyVolume* ACLs::add_destroy_volumes() {
  // @@protoc_insertion_point(field_add:mesos.ACLs.destroy_volumes)
  return destroy_volumes_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::ACL_DestroyVolume >*
ACLs::mutable_destroy_volumes() {
  // @@protoc_insertion_point(field_mutable_list:mesos.ACLs.destroy_volumes)
  return &destroy_volumes_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::ACL_DestroyVolume >&
ACLs::destroy_volumes() const {
  // @@protoc_insertion_point(field_list:mesos.ACLs.destroy_volumes)
  return destroy_volumes_;
}

// repeated .mesos.ACL.TeardownFramework teardown_frameworks = 11;
inline int ACLs::teardown_frameworks_size() const {
  return teardown_frameworks_.size();
}
inline void ACLs::clear_teardown_frameworks() {
  teardown_frameworks_.Clear();
}
inline const ::mesos::ACL_TeardownFramework& ACLs::teardown_frameworks(int index) const {
  // @@protoc_insertion_point(field_get:mesos.ACLs.teardown_frameworks)
  return teardown_frameworks_.Get(index);
}
inline ::mesos::ACL_TeardownFramework* ACLs::mutable_teardown_frameworks(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.ACLs.teardown_frameworks)
  return teardown_frameworks_.Mutable(index);
}
inline ::mesos::ACL_TeardownFramework* ACLs::add_teardown_frameworks() {
  // @@protoc_insertion_point(field_add:mesos.ACLs.teardown_frameworks)
  return teardown_frameworks_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::ACL_TeardownFramework >*
ACLs::mutable_teardown_frameworks() {
  // @@protoc_insertion_point(field_mutable_list:mesos.ACLs.teardown_frameworks)
  return &teardown_frameworks_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::ACL_TeardownFramework >&
ACLs::teardown_frameworks() const {
  // @@protoc_insertion_point(field_list:mesos.ACLs.teardown_frameworks)
  return teardown_frameworks_;
}

// repeated .mesos.ACL.UpdateWeight update_weights = 12;
inline int ACLs::update_weights_size() const {
  return update_weights_.size();
}
inline void ACLs::clear_update_weights() {
  update_weights_.Clear();
}
inline const ::mesos::ACL_UpdateWeight& ACLs::update_weights(int index) const {
  // @@protoc_insertion_point(field_get:mesos.ACLs.update_weights)
  return update_weights_.Get(index);
}
inline ::mesos::ACL_UpdateWeight* ACLs::mutable_update_weights(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.ACLs.update_weights)
  return update_weights_.Mutable(index);
}
inline ::mesos::ACL_UpdateWeight* ACLs::add_update_weights() {
  // @@protoc_insertion_point(field_add:mesos.ACLs.update_weights)
  return update_weights_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::ACL_UpdateWeight >*
ACLs::mutable_update_weights() {
  // @@protoc_insertion_point(field_mutable_list:mesos.ACLs.update_weights)
  return &update_weights_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::ACL_UpdateWeight >&
ACLs::update_weights() const {
  // @@protoc_insertion_point(field_list:mesos.ACLs.update_weights)
  return update_weights_;
}

// repeated .mesos.ACL.GetEndpoint get_endpoints = 13;
inline int ACLs::get_endpoints_size() const {
  return get_endpoints_.size();
}
inline void ACLs::clear_get_endpoints() {
  get_endpoints_.Clear();
}
inline const ::mesos::ACL_GetEndpoint& ACLs::get_endpoints(int index) const {
  // @@protoc_insertion_point(field_get:mesos.ACLs.get_endpoints)
  return get_endpoints_.Get(index);
}
inline ::mesos::ACL_GetEndpoint* ACLs::mutable_get_endpoints(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.ACLs.get_endpoints)
  return get_endpoints_.Mutable(index);
}
inline ::mesos::ACL_GetEndpoint* ACLs::add_get_endpoints() {
  // @@protoc_insertion_point(field_add:mesos.ACLs.get_endpoints)
  return get_endpoints_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::ACL_GetEndpoint >*
ACLs::mutable_get_endpoints() {
  // @@protoc_insertion_point(field_mutable_list:mesos.ACLs.get_endpoints)
  return &get_endpoints_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::ACL_GetEndpoint >&
ACLs::get_endpoints() const {
  // @@protoc_insertion_point(field_list:mesos.ACLs.get_endpoints)
  return get_endpoints_;
}

// repeated .mesos.ACL.GetQuota get_quotas = 14;
inline int ACLs::get_quotas_size() const {
  return get_quotas_.size();
}
inline void ACLs::clear_get_quotas() {
  get_quotas_.Clear();
}
inline const ::mesos::ACL_GetQuota& ACLs::get_quotas(int index) const {
  // @@protoc_insertion_point(field_get:mesos.ACLs.get_quotas)
  return get_quotas_.Get(index);
}
inline ::mesos::ACL_GetQuota* ACLs::mutable_get_quotas(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.ACLs.get_quotas)
  return get_quotas_.Mutable(index);
}
inline ::mesos::ACL_GetQuota* ACLs::add_get_quotas() {
  // @@protoc_insertion_point(field_add:mesos.ACLs.get_quotas)
  return get_quotas_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::ACL_GetQuota >*
ACLs::mutable_get_quotas() {
  // @@protoc_insertion_point(field_mutable_list:mesos.ACLs.get_quotas)
  return &get_quotas_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::ACL_GetQuota >&
ACLs::get_quotas() const {
  // @@protoc_insertion_point(field_list:mesos.ACLs.get_quotas)
  return get_quotas_;
}

// repeated .mesos.ACL.UpdateQuota update_quotas = 15;
inline int ACLs::update_quotas_size() const {
  return update_quotas_.size();
}
inline void ACLs::clear_update_quotas() {
  update_quotas_.Clear();
}
inline const ::mesos::ACL_UpdateQuota& ACLs::update_quotas(int index) const {
  // @@protoc_insertion_point(field_get:mesos.ACLs.update_quotas)
  return update_quotas_.Get(index);
}
inline ::mesos::ACL_UpdateQuota* ACLs::mutable_update_quotas(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.ACLs.update_quotas)
  return update_quotas_.Mutable(index);
}
inline ::mesos::ACL_UpdateQuota* ACLs::add_update_quotas() {
  // @@protoc_insertion_point(field_add:mesos.ACLs.update_quotas)
  return update_quotas_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::ACL_UpdateQuota >*
ACLs::mutable_update_quotas() {
  // @@protoc_insertion_point(field_mutable_list:mesos.ACLs.update_quotas)
  return &update_quotas_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::ACL_UpdateQuota >&
ACLs::update_quotas() const {
  // @@protoc_insertion_point(field_list:mesos.ACLs.update_quotas)
  return update_quotas_;
}

// repeated .mesos.ACL.ViewFramework view_frameworks = 16;
inline int ACLs::view_frameworks_size() const {
  return view_frameworks_.size();
}
inline void ACLs::clear_view_frameworks() {
  view_frameworks_.Clear();
}
inline const ::mesos::ACL_ViewFramework& ACLs::view_frameworks(int index) const {
  // @@protoc_insertion_point(field_get:mesos.ACLs.view_frameworks)
  return view_frameworks_.Get(index);
}
inline ::mesos::ACL_ViewFramework* ACLs::mutable_view_frameworks(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.ACLs.view_frameworks)
  return view_frameworks_.Mutable(index);
}
inline ::mesos::ACL_ViewFramework* ACLs::add_view_frameworks() {
  // @@protoc_insertion_point(field_add:mesos.ACLs.view_frameworks)
  return view_frameworks_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::ACL_ViewFramework >*
ACLs::mutable_view_frameworks() {
  // @@protoc_insertion_point(field_mutable_list:mesos.ACLs.view_frameworks)
  return &view_frameworks_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::ACL_ViewFramework >&
ACLs::view_frameworks() const {
  // @@protoc_insertion_point(field_list:mesos.ACLs.view_frameworks)
  return view_frameworks_;
}

// repeated .mesos.ACL.ViewTask view_tasks = 17;
inline int ACLs::view_tasks_size() const {
  return view_tasks_.size();
}
inline void ACLs::clear_view_tasks() {
  view_tasks_.Clear();
}
inline const ::mesos::ACL_ViewTask& ACLs::view_tasks(int index) const {
  // @@protoc_insertion_point(field_get:mesos.ACLs.view_tasks)
  return view_tasks_.Get(index);
}
inline ::mesos::ACL_ViewTask* ACLs::mutable_view_tasks(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.ACLs.view_tasks)
  return view_tasks_.Mutable(index);
}
inline ::mesos::ACL_ViewTask* ACLs::add_view_tasks() {
  // @@protoc_insertion_point(field_add:mesos.ACLs.view_tasks)
  return view_tasks_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::ACL_ViewTask >*
ACLs::mutable_view_tasks() {
  // @@protoc_insertion_point(field_mutable_list:mesos.ACLs.view_tasks)
  return &view_tasks_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::ACL_ViewTask >&
ACLs::view_tasks() const {
  // @@protoc_insertion_point(field_list:mesos.ACLs.view_tasks)
  return view_tasks_;
}

// repeated .mesos.ACL.ViewExecutor view_executors = 18;
inline int ACLs::view_executors_size() const {
  return view_executors_.size();
}
inline void ACLs::clear_view_executors() {
  view_executors_.Clear();
}
inline const ::mesos::ACL_ViewExecutor& ACLs::view_executors(int index) const {
  // @@protoc_insertion_point(field_get:mesos.ACLs.view_executors)
  return view_executors_.Get(index);
}
inline ::mesos::ACL_ViewExecutor* ACLs::mutable_view_executors(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.ACLs.view_executors)
  return view_executors_.Mutable(index);
}
inline ::mesos::ACL_ViewExecutor* ACLs::add_view_executors() {
  // @@protoc_insertion_point(field_add:mesos.ACLs.view_executors)
  return view_executors_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::ACL_ViewExecutor >*
ACLs::mutable_view_executors() {
  // @@protoc_insertion_point(field_mutable_list:mesos.ACLs.view_executors)
  return &view_executors_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::ACL_ViewExecutor >&
ACLs::view_executors() const {
  // @@protoc_insertion_point(field_list:mesos.ACLs.view_executors)
  return view_executors_;
}

// repeated .mesos.ACL.AccessSandbox access_sandboxes = 19;
inline int ACLs::access_sandboxes_size() const {
  return access_sandboxes_.size();
}
inline void ACLs::clear_access_sandboxes() {
  access_sandboxes_.Clear();
}
inline const ::mesos::ACL_AccessSandbox& ACLs::access_sandboxes(int index) const {
  // @@protoc_insertion_point(field_get:mesos.ACLs.access_sandboxes)
  return access_sandboxes_.Get(index);
}
inline ::mesos::ACL_AccessSandbox* ACLs::mutable_access_sandboxes(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.ACLs.access_sandboxes)
  return access_sandboxes_.Mutable(index);
}
inline ::mesos::ACL_AccessSandbox* ACLs::add_access_sandboxes() {
  // @@protoc_insertion_point(field_add:mesos.ACLs.access_sandboxes)
  return access_sandboxes_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::ACL_AccessSandbox >*
ACLs::mutable_access_sandboxes() {
  // @@protoc_insertion_point(field_mutable_list:mesos.ACLs.access_sandboxes)
  return &access_sandboxes_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::ACL_AccessSandbox >&
ACLs::access_sandboxes() const {
  // @@protoc_insertion_point(field_list:mesos.ACLs.access_sandboxes)
  return access_sandboxes_;
}

// repeated .mesos.ACL.AccessMesosLog access_mesos_logs = 20;
inline int ACLs::access_mesos_logs_size() const {
  return access_mesos_logs_.size();
}
inline void ACLs::clear_access_mesos_logs() {
  access_mesos_logs_.Clear();
}
inline const ::mesos::ACL_AccessMesosLog& ACLs::access_mesos_logs(int index) const {
  // @@protoc_insertion_point(field_get:mesos.ACLs.access_mesos_logs)
  return access_mesos_logs_.Get(index);
}
inline ::mesos::ACL_AccessMesosLog* ACLs::mutable_access_mesos_logs(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.ACLs.access_mesos_logs)
  return access_mesos_logs_.Mutable(index);
}
inline ::mesos::ACL_AccessMesosLog* ACLs::add_access_mesos_logs() {
  // @@protoc_insertion_point(field_add:mesos.ACLs.access_mesos_logs)
  return access_mesos_logs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::ACL_AccessMesosLog >*
ACLs::mutable_access_mesos_logs() {
  // @@protoc_insertion_point(field_mutable_list:mesos.ACLs.access_mesos_logs)
  return &access_mesos_logs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::ACL_AccessMesosLog >&
ACLs::access_mesos_logs() const {
  // @@protoc_insertion_point(field_list:mesos.ACLs.access_mesos_logs)
  return access_mesos_logs_;
}

// repeated .mesos.ACL.ViewRole view_roles = 21;
inline int ACLs::view_roles_size() const {
  return view_roles_.size();
}
inline void ACLs::clear_view_roles() {
  view_roles_.Clear();
}
inline const ::mesos::ACL_ViewRole& ACLs::view_roles(int index) const {
  // @@protoc_insertion_point(field_get:mesos.ACLs.view_roles)
  return view_roles_.Get(index);
}
inline ::mesos::ACL_ViewRole* ACLs::mutable_view_roles(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.ACLs.view_roles)
  return view_roles_.Mutable(index);
}
inline ::mesos::ACL_ViewRole* ACLs::add_view_roles() {
  // @@protoc_insertion_point(field_add:mesos.ACLs.view_roles)
  return view_roles_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::ACL_ViewRole >*
ACLs::mutable_view_roles() {
  // @@protoc_insertion_point(field_mutable_list:mesos.ACLs.view_roles)
  return &view_roles_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::ACL_ViewRole >&
ACLs::view_roles() const {
  // @@protoc_insertion_point(field_list:mesos.ACLs.view_roles)
  return view_roles_;
}

// repeated .mesos.ACL.ViewFlags view_flags = 22;
inline int ACLs::view_flags_size() const {
  return view_flags_.size();
}
inline void ACLs::clear_view_flags() {
  view_flags_.Clear();
}
inline const ::mesos::ACL_ViewFlags& ACLs::view_flags(int index) const {
  // @@protoc_insertion_point(field_get:mesos.ACLs.view_flags)
  return view_flags_.Get(index);
}
inline ::mesos::ACL_ViewFlags* ACLs::mutable_view_flags(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.ACLs.view_flags)
  return view_flags_.Mutable(index);
}
inline ::mesos::ACL_ViewFlags* ACLs::add_view_flags() {
  // @@protoc_insertion_point(field_add:mesos.ACLs.view_flags)
  return view_flags_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::ACL_ViewFlags >*
ACLs::mutable_view_flags() {
  // @@protoc_insertion_point(field_mutable_list:mesos.ACLs.view_flags)
  return &view_flags_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::ACL_ViewFlags >&
ACLs::view_flags() const {
  // @@protoc_insertion_point(field_list:mesos.ACLs.view_flags)
  return view_flags_;
}

// repeated .mesos.ACL.LaunchNestedContainerAsUser launch_nested_containers_as_user = 23;
inline int ACLs::launch_nested_containers_as_user_size() const {
  return launch_nested_containers_as_user_.size();
}
inline void ACLs::clear_launch_nested_containers_as_user() {
  launch_nested_containers_as_user_.Clear();
}
inline const ::mesos::ACL_LaunchNestedContainerAsUser& ACLs::launch_nested_containers_as_user(int index) const {
  // @@protoc_insertion_point(field_get:mesos.ACLs.launch_nested_containers_as_user)
  return launch_nested_containers_as_user_.Get(index);
}
inline ::mesos::ACL_LaunchNestedContainerAsUser* ACLs::mutable_launch_nested_containers_as_user(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.ACLs.launch_nested_containers_as_user)
  return launch_nested_containers_as_user_.Mutable(index);
}
inline ::mesos::ACL_LaunchNestedContainerAsUser* ACLs::add_launch_nested_containers_as_user() {
  // @@protoc_insertion_point(field_add:mesos.ACLs.launch_nested_containers_as_user)
  return launch_nested_containers_as_user_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::ACL_LaunchNestedContainerAsUser >*
ACLs::mutable_launch_nested_containers_as_user() {
  // @@protoc_insertion_point(field_mutable_list:mesos.ACLs.launch_nested_containers_as_user)
  return &launch_nested_containers_as_user_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::ACL_LaunchNestedContainerAsUser >&
ACLs::launch_nested_containers_as_user() const {
  // @@protoc_insertion_point(field_list:mesos.ACLs.launch_nested_containers_as_user)
  return launch_nested_containers_as_user_;
}

// repeated .mesos.ACL.LaunchNestedContainerUnderParentWithUser launch_nested_containers_under_parent_with_user = 24;
inline int ACLs::launch_nested_containers_under_parent_with_user_size() const {
  return launch_nested_containers_under_parent_with_user_.size();
}
inline void ACLs::clear_launch_nested_containers_under_parent_with_user() {
  launch_nested_containers_under_parent_with_user_.Clear();
}
inline const ::mesos::ACL_LaunchNestedContainerUnderParentWithUser& ACLs::launch_nested_containers_under_parent_with_user(int index) const {
  // @@protoc_insertion_point(field_get:mesos.ACLs.launch_nested_containers_under_parent_with_user)
  return launch_nested_containers_under_parent_with_user_.Get(index);
}
inline ::mesos::ACL_LaunchNestedContainerUnderParentWithUser* ACLs::mutable_launch_nested_containers_under_parent_with_user(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.ACLs.launch_nested_containers_under_parent_with_user)
  return launch_nested_containers_under_parent_with_user_.Mutable(index);
}
inline ::mesos::ACL_LaunchNestedContainerUnderParentWithUser* ACLs::add_launch_nested_containers_under_parent_with_user() {
  // @@protoc_insertion_point(field_add:mesos.ACLs.launch_nested_containers_under_parent_with_user)
  return launch_nested_containers_under_parent_with_user_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::ACL_LaunchNestedContainerUnderParentWithUser >*
ACLs::mutable_launch_nested_containers_under_parent_with_user() {
  // @@protoc_insertion_point(field_mutable_list:mesos.ACLs.launch_nested_containers_under_parent_with_user)
  return &launch_nested_containers_under_parent_with_user_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::ACL_LaunchNestedContainerUnderParentWithUser >&
ACLs::launch_nested_containers_under_parent_with_user() const {
  // @@protoc_insertion_point(field_list:mesos.ACLs.launch_nested_containers_under_parent_with_user)
  return launch_nested_containers_under_parent_with_user_;
}

// repeated .mesos.ACL.KillNestedContainer kill_nested_containers = 25;
inline int ACLs::kill_nested_containers_size() const {
  return kill_nested_containers_.size();
}
inline void ACLs::clear_kill_nested_containers() {
  kill_nested_containers_.Clear();
}
inline const ::mesos::ACL_KillNestedContainer& ACLs::kill_nested_containers(int index) const {
  // @@protoc_insertion_point(field_get:mesos.ACLs.kill_nested_containers)
  return kill_nested_containers_.Get(index);
}
inline ::mesos::ACL_KillNestedContainer* ACLs::mutable_kill_nested_containers(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.ACLs.kill_nested_containers)
  return kill_nested_containers_.Mutable(index);
}
inline ::mesos::ACL_KillNestedContainer* ACLs::add_kill_nested_containers() {
  // @@protoc_insertion_point(field_add:mesos.ACLs.kill_nested_containers)
  return kill_nested_containers_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::ACL_KillNestedContainer >*
ACLs::mutable_kill_nested_containers() {
  // @@protoc_insertion_point(field_mutable_list:mesos.ACLs.kill_nested_containers)
  return &kill_nested_containers_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::ACL_KillNestedContainer >&
ACLs::kill_nested_containers() const {
  // @@protoc_insertion_point(field_list:mesos.ACLs.kill_nested_containers)
  return kill_nested_containers_;
}

// repeated .mesos.ACL.WaitNestedContainer wait_nested_containers = 26;
inline int ACLs::wait_nested_containers_size() const {
  return wait_nested_containers_.size();
}
inline void ACLs::clear_wait_nested_containers() {
  wait_nested_containers_.Clear();
}
inline const ::mesos::ACL_WaitNestedContainer& ACLs::wait_nested_containers(int index) const {
  // @@protoc_insertion_point(field_get:mesos.ACLs.wait_nested_containers)
  return wait_nested_containers_.Get(index);
}
inline ::mesos::ACL_WaitNestedContainer* ACLs::mutable_wait_nested_containers(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.ACLs.wait_nested_containers)
  return wait_nested_containers_.Mutable(index);
}
inline ::mesos::ACL_WaitNestedContainer* ACLs::add_wait_nested_containers() {
  // @@protoc_insertion_point(field_add:mesos.ACLs.wait_nested_containers)
  return wait_nested_containers_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::ACL_WaitNestedContainer >*
ACLs::mutable_wait_nested_containers() {
  // @@protoc_insertion_point(field_mutable_list:mesos.ACLs.wait_nested_containers)
  return &wait_nested_containers_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::ACL_WaitNestedContainer >&
ACLs::wait_nested_containers() const {
  // @@protoc_insertion_point(field_list:mesos.ACLs.wait_nested_containers)
  return wait_nested_containers_;
}

// repeated .mesos.ACL.LaunchNestedContainerSessionAsUser launch_nested_container_sessions_as_user = 27;
inline int ACLs::launch_nested_container_sessions_as_user_size() const {
  return launch_nested_container_sessions_as_user_.size();
}
inline void ACLs::clear_launch_nested_container_sessions_as_user() {
  launch_nested_container_sessions_as_user_.Clear();
}
inline const ::mesos::ACL_LaunchNestedContainerSessionAsUser& ACLs::launch_nested_container_sessions_as_user(int index) const {
  // @@protoc_insertion_point(field_get:mesos.ACLs.launch_nested_container_sessions_as_user)
  return launch_nested_container_sessions_as_user_.Get(index);
}
inline ::mesos::ACL_LaunchNestedContainerSessionAsUser* ACLs::mutable_launch_nested_container_sessions_as_user(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.ACLs.launch_nested_container_sessions_as_user)
  return launch_nested_container_sessions_as_user_.Mutable(index);
}
inline ::mesos::ACL_LaunchNestedContainerSessionAsUser* ACLs::add_launch_nested_container_sessions_as_user() {
  // @@protoc_insertion_point(field_add:mesos.ACLs.launch_nested_container_sessions_as_user)
  return launch_nested_container_sessions_as_user_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::ACL_LaunchNestedContainerSessionAsUser >*
ACLs::mutable_launch_nested_container_sessions_as_user() {
  // @@protoc_insertion_point(field_mutable_list:mesos.ACLs.launch_nested_container_sessions_as_user)
  return &launch_nested_container_sessions_as_user_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::ACL_LaunchNestedContainerSessionAsUser >&
ACLs::launch_nested_container_sessions_as_user() const {
  // @@protoc_insertion_point(field_list:mesos.ACLs.launch_nested_container_sessions_as_user)
  return launch_nested_container_sessions_as_user_;
}

// repeated .mesos.ACL.LaunchNestedContainerSessionUnderParentWithUser launch_nested_container_sessions_under_parent_with_user = 28;
inline int ACLs::launch_nested_container_sessions_under_parent_with_user_size() const {
  return launch_nested_container_sessions_under_parent_with_user_.size();
}
inline void ACLs::clear_launch_nested_container_sessions_under_parent_with_user() {
  launch_nested_container_sessions_under_parent_with_user_.Clear();
}
inline const ::mesos::ACL_LaunchNestedContainerSessionUnderParentWithUser& ACLs::launch_nested_container_sessions_under_parent_with_user(int index) const {
  // @@protoc_insertion_point(field_get:mesos.ACLs.launch_nested_container_sessions_under_parent_with_user)
  return launch_nested_container_sessions_under_parent_with_user_.Get(index);
}
inline ::mesos::ACL_LaunchNestedContainerSessionUnderParentWithUser* ACLs::mutable_launch_nested_container_sessions_under_parent_with_user(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.ACLs.launch_nested_container_sessions_under_parent_with_user)
  return launch_nested_container_sessions_under_parent_with_user_.Mutable(index);
}
inline ::mesos::ACL_LaunchNestedContainerSessionUnderParentWithUser* ACLs::add_launch_nested_container_sessions_under_parent_with_user() {
  // @@protoc_insertion_point(field_add:mesos.ACLs.launch_nested_container_sessions_under_parent_with_user)
  return launch_nested_container_sessions_under_parent_with_user_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::ACL_LaunchNestedContainerSessionUnderParentWithUser >*
ACLs::mutable_launch_nested_container_sessions_under_parent_with_user() {
  // @@protoc_insertion_point(field_mutable_list:mesos.ACLs.launch_nested_container_sessions_under_parent_with_user)
  return &launch_nested_container_sessions_under_parent_with_user_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::ACL_LaunchNestedContainerSessionUnderParentWithUser >&
ACLs::launch_nested_container_sessions_under_parent_with_user() const {
  // @@protoc_insertion_point(field_list:mesos.ACLs.launch_nested_container_sessions_under_parent_with_user)
  return launch_nested_container_sessions_under_parent_with_user_;
}

// repeated .mesos.ACL.AttachContainerInput attach_containers_input = 29;
inline int ACLs::attach_containers_input_size() const {
  return attach_containers_input_.size();
}
inline void ACLs::clear_attach_containers_input() {
  attach_containers_input_.Clear();
}
inline const ::mesos::ACL_AttachContainerInput& ACLs::attach_containers_input(int index) const {
  // @@protoc_insertion_point(field_get:mesos.ACLs.attach_containers_input)
  return attach_containers_input_.Get(index);
}
inline ::mesos::ACL_AttachContainerInput* ACLs::mutable_attach_containers_input(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.ACLs.attach_containers_input)
  return attach_containers_input_.Mutable(index);
}
inline ::mesos::ACL_AttachContainerInput* ACLs::add_attach_containers_input() {
  // @@protoc_insertion_point(field_add:mesos.ACLs.attach_containers_input)
  return attach_containers_input_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::ACL_AttachContainerInput >*
ACLs::mutable_attach_containers_input() {
  // @@protoc_insertion_point(field_mutable_list:mesos.ACLs.attach_containers_input)
  return &attach_containers_input_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::ACL_AttachContainerInput >&
ACLs::attach_containers_input() const {
  // @@protoc_insertion_point(field_list:mesos.ACLs.attach_containers_input)
  return attach_containers_input_;
}

// repeated .mesos.ACL.AttachContainerOutput attach_containers_output = 30;
inline int ACLs::attach_containers_output_size() const {
  return attach_containers_output_.size();
}
inline void ACLs::clear_attach_containers_output() {
  attach_containers_output_.Clear();
}
inline const ::mesos::ACL_AttachContainerOutput& ACLs::attach_containers_output(int index) const {
  // @@protoc_insertion_point(field_get:mesos.ACLs.attach_containers_output)
  return attach_containers_output_.Get(index);
}
inline ::mesos::ACL_AttachContainerOutput* ACLs::mutable_attach_containers_output(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.ACLs.attach_containers_output)
  return attach_containers_output_.Mutable(index);
}
inline ::mesos::ACL_AttachContainerOutput* ACLs::add_attach_containers_output() {
  // @@protoc_insertion_point(field_add:mesos.ACLs.attach_containers_output)
  return attach_containers_output_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::ACL_AttachContainerOutput >*
ACLs::mutable_attach_containers_output() {
  // @@protoc_insertion_point(field_mutable_list:mesos.ACLs.attach_containers_output)
  return &attach_containers_output_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::ACL_AttachContainerOutput >&
ACLs::attach_containers_output() const {
  // @@protoc_insertion_point(field_list:mesos.ACLs.attach_containers_output)
  return attach_containers_output_;
}

// repeated .mesos.ACL.ViewContainer view_containers = 31;
inline int ACLs::view_containers_size() const {
  return view_containers_.size();
}
inline void ACLs::clear_view_containers() {
  view_containers_.Clear();
}
inline const ::mesos::ACL_ViewContainer& ACLs::view_containers(int index) const {
  // @@protoc_insertion_point(field_get:mesos.ACLs.view_containers)
  return view_containers_.Get(index);
}
inline ::mesos::ACL_ViewContainer* ACLs::mutable_view_containers(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.ACLs.view_containers)
  return view_containers_.Mutable(index);
}
inline ::mesos::ACL_ViewContainer* ACLs::add_view_containers() {
  // @@protoc_insertion_point(field_add:mesos.ACLs.view_containers)
  return view_containers_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::ACL_ViewContainer >*
ACLs::mutable_view_containers() {
  // @@protoc_insertion_point(field_mutable_list:mesos.ACLs.view_containers)
  return &view_containers_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::ACL_ViewContainer >&
ACLs::view_containers() const {
  // @@protoc_insertion_point(field_list:mesos.ACLs.view_containers)
  return view_containers_;
}

// repeated .mesos.ACL.SetLogLevel set_log_level = 32;
inline int ACLs::set_log_level_size() const {
  return set_log_level_.size();
}
inline void ACLs::clear_set_log_level() {
  set_log_level_.Clear();
}
inline const ::mesos::ACL_SetLogLevel& ACLs::set_log_level(int index) const {
  // @@protoc_insertion_point(field_get:mesos.ACLs.set_log_level)
  return set_log_level_.Get(index);
}
inline ::mesos::ACL_SetLogLevel* ACLs::mutable_set_log_level(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.ACLs.set_log_level)
  return set_log_level_.Mutable(index);
}
inline ::mesos::ACL_SetLogLevel* ACLs::add_set_log_level() {
  // @@protoc_insertion_point(field_add:mesos.ACLs.set_log_level)
  return set_log_level_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::ACL_SetLogLevel >*
ACLs::mutable_set_log_level() {
  // @@protoc_insertion_point(field_mutable_list:mesos.ACLs.set_log_level)
  return &set_log_level_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::ACL_SetLogLevel >&
ACLs::set_log_level() const {
  // @@protoc_insertion_point(field_list:mesos.ACLs.set_log_level)
  return set_log_level_;
}

// repeated .mesos.ACL.RemoveNestedContainer remove_nested_containers = 33;
inline int ACLs::remove_nested_containers_size() const {
  return remove_nested_containers_.size();
}
inline void ACLs::clear_remove_nested_containers() {
  remove_nested_containers_.Clear();
}
inline const ::mesos::ACL_RemoveNestedContainer& ACLs::remove_nested_containers(int index) const {
  // @@protoc_insertion_point(field_get:mesos.ACLs.remove_nested_containers)
  return remove_nested_containers_.Get(index);
}
inline ::mesos::ACL_RemoveNestedContainer* ACLs::mutable_remove_nested_containers(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.ACLs.remove_nested_containers)
  return remove_nested_containers_.Mutable(index);
}
inline ::mesos::ACL_RemoveNestedContainer* ACLs::add_remove_nested_containers() {
  // @@protoc_insertion_point(field_add:mesos.ACLs.remove_nested_containers)
  return remove_nested_containers_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::ACL_RemoveNestedContainer >*
ACLs::mutable_remove_nested_containers() {
  // @@protoc_insertion_point(field_mutable_list:mesos.ACLs.remove_nested_containers)
  return &remove_nested_containers_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::ACL_RemoveNestedContainer >&
ACLs::remove_nested_containers() const {
  // @@protoc_insertion_point(field_list:mesos.ACLs.remove_nested_containers)
  return remove_nested_containers_;
}

// repeated .mesos.ACL.RegisterAgent register_agents = 34;
inline int ACLs::register_agents_size() const {
  return register_agents_.size();
}
inline void ACLs::clear_register_agents() {
  register_agents_.Clear();
}
inline const ::mesos::ACL_RegisterAgent& ACLs::register_agents(int index) const {
  // @@protoc_insertion_point(field_get:mesos.ACLs.register_agents)
  return register_agents_.Get(index);
}
inline ::mesos::ACL_RegisterAgent* ACLs::mutable_register_agents(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.ACLs.register_agents)
  return register_agents_.Mutable(index);
}
inline ::mesos::ACL_RegisterAgent* ACLs::add_register_agents() {
  // @@protoc_insertion_point(field_add:mesos.ACLs.register_agents)
  return register_agents_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::ACL_RegisterAgent >*
ACLs::mutable_register_agents() {
  // @@protoc_insertion_point(field_mutable_list:mesos.ACLs.register_agents)
  return &register_agents_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::ACL_RegisterAgent >&
ACLs::register_agents() const {
  // @@protoc_insertion_point(field_list:mesos.ACLs.register_agents)
  return register_agents_;
}

// repeated .mesos.ACL.UpdateMaintenanceSchedule update_maintenance_schedules = 35;
inline int ACLs::update_maintenance_schedules_size() const {
  return update_maintenance_schedules_.size();
}
inline void ACLs::clear_update_maintenance_schedules() {
  update_maintenance_schedules_.Clear();
}
inline const ::mesos::ACL_UpdateMaintenanceSchedule& ACLs::update_maintenance_schedules(int index) const {
  // @@protoc_insertion_point(field_get:mesos.ACLs.update_maintenance_schedules)
  return update_maintenance_schedules_.Get(index);
}
inline ::mesos::ACL_UpdateMaintenanceSchedule* ACLs::mutable_update_maintenance_schedules(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.ACLs.update_maintenance_schedules)
  return update_maintenance_schedules_.Mutable(index);
}
inline ::mesos::ACL_UpdateMaintenanceSchedule* ACLs::add_update_maintenance_schedules() {
  // @@protoc_insertion_point(field_add:mesos.ACLs.update_maintenance_schedules)
  return update_maintenance_schedules_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::ACL_UpdateMaintenanceSchedule >*
ACLs::mutable_update_maintenance_schedules() {
  // @@protoc_insertion_point(field_mutable_list:mesos.ACLs.update_maintenance_schedules)
  return &update_maintenance_schedules_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::ACL_UpdateMaintenanceSchedule >&
ACLs::update_maintenance_schedules() const {
  // @@protoc_insertion_point(field_list:mesos.ACLs.update_maintenance_schedules)
  return update_maintenance_schedules_;
}

// repeated .mesos.ACL.GetMaintenanceSchedule get_maintenance_schedules = 36;
inline int ACLs::get_maintenance_schedules_size() const {
  return get_maintenance_schedules_.size();
}
inline void ACLs::clear_get_maintenance_schedules() {
  get_maintenance_schedules_.Clear();
}
inline const ::mesos::ACL_GetMaintenanceSchedule& ACLs::get_maintenance_schedules(int index) const {
  // @@protoc_insertion_point(field_get:mesos.ACLs.get_maintenance_schedules)
  return get_maintenance_schedules_.Get(index);
}
inline ::mesos::ACL_GetMaintenanceSchedule* ACLs::mutable_get_maintenance_schedules(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.ACLs.get_maintenance_schedules)
  return get_maintenance_schedules_.Mutable(index);
}
inline ::mesos::ACL_GetMaintenanceSchedule* ACLs::add_get_maintenance_schedules() {
  // @@protoc_insertion_point(field_add:mesos.ACLs.get_maintenance_schedules)
  return get_maintenance_schedules_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::ACL_GetMaintenanceSchedule >*
ACLs::mutable_get_maintenance_schedules() {
  // @@protoc_insertion_point(field_mutable_list:mesos.ACLs.get_maintenance_schedules)
  return &get_maintenance_schedules_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::ACL_GetMaintenanceSchedule >&
ACLs::get_maintenance_schedules() const {
  // @@protoc_insertion_point(field_list:mesos.ACLs.get_maintenance_schedules)
  return get_maintenance_schedules_;
}

// repeated .mesos.ACL.StartMaintenance start_maintenances = 37;
inline int ACLs::start_maintenances_size() const {
  return start_maintenances_.size();
}
inline void ACLs::clear_start_maintenances() {
  start_maintenances_.Clear();
}
inline const ::mesos::ACL_StartMaintenance& ACLs::start_maintenances(int index) const {
  // @@protoc_insertion_point(field_get:mesos.ACLs.start_maintenances)
  return start_maintenances_.Get(index);
}
inline ::mesos::ACL_StartMaintenance* ACLs::mutable_start_maintenances(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.ACLs.start_maintenances)
  return start_maintenances_.Mutable(index);
}
inline ::mesos::ACL_StartMaintenance* ACLs::add_start_maintenances() {
  // @@protoc_insertion_point(field_add:mesos.ACLs.start_maintenances)
  return start_maintenances_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::ACL_StartMaintenance >*
ACLs::mutable_start_maintenances() {
  // @@protoc_insertion_point(field_mutable_list:mesos.ACLs.start_maintenances)
  return &start_maintenances_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::ACL_StartMaintenance >&
ACLs::start_maintenances() const {
  // @@protoc_insertion_point(field_list:mesos.ACLs.start_maintenances)
  return start_maintenances_;
}

// repeated .mesos.ACL.StopMaintenance stop_maintenances = 38;
inline int ACLs::stop_maintenances_size() const {
  return stop_maintenances_.size();
}
inline void ACLs::clear_stop_maintenances() {
  stop_maintenances_.Clear();
}
inline const ::mesos::ACL_StopMaintenance& ACLs::stop_maintenances(int index) const {
  // @@protoc_insertion_point(field_get:mesos.ACLs.stop_maintenances)
  return stop_maintenances_.Get(index);
}
inline ::mesos::ACL_StopMaintenance* ACLs::mutable_stop_maintenances(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.ACLs.stop_maintenances)
  return stop_maintenances_.Mutable(index);
}
inline ::mesos::ACL_StopMaintenance* ACLs::add_stop_maintenances() {
  // @@protoc_insertion_point(field_add:mesos.ACLs.stop_maintenances)
  return stop_maintenances_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::ACL_StopMaintenance >*
ACLs::mutable_stop_maintenances() {
  // @@protoc_insertion_point(field_mutable_list:mesos.ACLs.stop_maintenances)
  return &stop_maintenances_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::ACL_StopMaintenance >&
ACLs::stop_maintenances() const {
  // @@protoc_insertion_point(field_list:mesos.ACLs.stop_maintenances)
  return stop_maintenances_;
}

// repeated .mesos.ACL.GetMaintenanceStatus get_maintenance_statuses = 39;
inline int ACLs::get_maintenance_statuses_size() const {
  return get_maintenance_statuses_.size();
}
inline void ACLs::clear_get_maintenance_statuses() {
  get_maintenance_statuses_.Clear();
}
inline const ::mesos::ACL_GetMaintenanceStatus& ACLs::get_maintenance_statuses(int index) const {
  // @@protoc_insertion_point(field_get:mesos.ACLs.get_maintenance_statuses)
  return get_maintenance_statuses_.Get(index);
}
inline ::mesos::ACL_GetMaintenanceStatus* ACLs::mutable_get_maintenance_statuses(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.ACLs.get_maintenance_statuses)
  return get_maintenance_statuses_.Mutable(index);
}
inline ::mesos::ACL_GetMaintenanceStatus* ACLs::add_get_maintenance_statuses() {
  // @@protoc_insertion_point(field_add:mesos.ACLs.get_maintenance_statuses)
  return get_maintenance_statuses_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::ACL_GetMaintenanceStatus >*
ACLs::mutable_get_maintenance_statuses() {
  // @@protoc_insertion_point(field_mutable_list:mesos.ACLs.get_maintenance_statuses)
  return &get_maintenance_statuses_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::ACL_GetMaintenanceStatus >&
ACLs::get_maintenance_statuses() const {
  // @@protoc_insertion_point(field_list:mesos.ACLs.get_maintenance_statuses)
  return get_maintenance_statuses_;
}

// repeated .mesos.ACL.MarkAgentGone mark_agents_gone = 40;
inline int ACLs::mark_agents_gone_size() const {
  return mark_agents_gone_.size();
}
inline void ACLs::clear_mark_agents_gone() {
  mark_agents_gone_.Clear();
}
inline const ::mesos::ACL_MarkAgentGone& ACLs::mark_agents_gone(int index) const {
  // @@protoc_insertion_point(field_get:mesos.ACLs.mark_agents_gone)
  return mark_agents_gone_.Get(index);
}
inline ::mesos::ACL_MarkAgentGone* ACLs::mutable_mark_agents_gone(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.ACLs.mark_agents_gone)
  return mark_agents_gone_.Mutable(index);
}
inline ::mesos::ACL_MarkAgentGone* ACLs::add_mark_agents_gone() {
  // @@protoc_insertion_point(field_add:mesos.ACLs.mark_agents_gone)
  return mark_agents_gone_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::ACL_MarkAgentGone >*
ACLs::mutable_mark_agents_gone() {
  // @@protoc_insertion_point(field_mutable_list:mesos.ACLs.mark_agents_gone)
  return &mark_agents_gone_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::ACL_MarkAgentGone >&
ACLs::mark_agents_gone() const {
  // @@protoc_insertion_point(field_list:mesos.ACLs.mark_agents_gone)
  return mark_agents_gone_;
}

// repeated .mesos.ACL.LaunchStandaloneContainer launch_standalone_containers = 41;
inline int ACLs::launch_standalone_containers_size() const {
  return launch_standalone_containers_.size();
}
inline void ACLs::clear_launch_standalone_containers() {
  launch_standalone_containers_.Clear();
}
inline const ::mesos::ACL_LaunchStandaloneContainer& ACLs::launch_standalone_containers(int index) const {
  // @@protoc_insertion_point(field_get:mesos.ACLs.launch_standalone_containers)
  return launch_standalone_containers_.Get(index);
}
inline ::mesos::ACL_LaunchStandaloneContainer* ACLs::mutable_launch_standalone_containers(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.ACLs.launch_standalone_containers)
  return launch_standalone_containers_.Mutable(index);
}
inline ::mesos::ACL_LaunchStandaloneContainer* ACLs::add_launch_standalone_containers() {
  // @@protoc_insertion_point(field_add:mesos.ACLs.launch_standalone_containers)
  return launch_standalone_containers_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::ACL_LaunchStandaloneContainer >*
ACLs::mutable_launch_standalone_containers() {
  // @@protoc_insertion_point(field_mutable_list:mesos.ACLs.launch_standalone_containers)
  return &launch_standalone_containers_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::ACL_LaunchStandaloneContainer >&
ACLs::launch_standalone_containers() const {
  // @@protoc_insertion_point(field_list:mesos.ACLs.launch_standalone_containers)
  return launch_standalone_containers_;
}

// repeated .mesos.ACL.KillStandaloneContainer kill_standalone_containers = 42;
inline int ACLs::kill_standalone_containers_size() const {
  return kill_standalone_containers_.size();
}
inline void ACLs::clear_kill_standalone_containers() {
  kill_standalone_containers_.Clear();
}
inline const ::mesos::ACL_KillStandaloneContainer& ACLs::kill_standalone_containers(int index) const {
  // @@protoc_insertion_point(field_get:mesos.ACLs.kill_standalone_containers)
  return kill_standalone_containers_.Get(index);
}
inline ::mesos::ACL_KillStandaloneContainer* ACLs::mutable_kill_standalone_containers(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.ACLs.kill_standalone_containers)
  return kill_standalone_containers_.Mutable(index);
}
inline ::mesos::ACL_KillStandaloneContainer* ACLs::add_kill_standalone_containers() {
  // @@protoc_insertion_point(field_add:mesos.ACLs.kill_standalone_containers)
  return kill_standalone_containers_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::ACL_KillStandaloneContainer >*
ACLs::mutable_kill_standalone_containers() {
  // @@protoc_insertion_point(field_mutable_list:mesos.ACLs.kill_standalone_containers)
  return &kill_standalone_containers_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::ACL_KillStandaloneContainer >&
ACLs::kill_standalone_containers() const {
  // @@protoc_insertion_point(field_list:mesos.ACLs.kill_standalone_containers)
  return kill_standalone_containers_;
}

// repeated .mesos.ACL.WaitStandaloneContainer wait_standalone_containers = 43;
inline int ACLs::wait_standalone_containers_size() const {
  return wait_standalone_containers_.size();
}
inline void ACLs::clear_wait_standalone_containers() {
  wait_standalone_containers_.Clear();
}
inline const ::mesos::ACL_WaitStandaloneContainer& ACLs::wait_standalone_containers(int index) const {
  // @@protoc_insertion_point(field_get:mesos.ACLs.wait_standalone_containers)
  return wait_standalone_containers_.Get(index);
}
inline ::mesos::ACL_WaitStandaloneContainer* ACLs::mutable_wait_standalone_containers(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.ACLs.wait_standalone_containers)
  return wait_standalone_containers_.Mutable(index);
}
inline ::mesos::ACL_WaitStandaloneContainer* ACLs::add_wait_standalone_containers() {
  // @@protoc_insertion_point(field_add:mesos.ACLs.wait_standalone_containers)
  return wait_standalone_containers_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::ACL_WaitStandaloneContainer >*
ACLs::mutable_wait_standalone_containers() {
  // @@protoc_insertion_point(field_mutable_list:mesos.ACLs.wait_standalone_containers)
  return &wait_standalone_containers_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::ACL_WaitStandaloneContainer >&
ACLs::wait_standalone_containers() const {
  // @@protoc_insertion_point(field_list:mesos.ACLs.wait_standalone_containers)
  return wait_standalone_containers_;
}

// repeated .mesos.ACL.RemoveStandaloneContainer remove_standalone_containers = 44;
inline int ACLs::remove_standalone_containers_size() const {
  return remove_standalone_containers_.size();
}
inline void ACLs::clear_remove_standalone_containers() {
  remove_standalone_containers_.Clear();
}
inline const ::mesos::ACL_RemoveStandaloneContainer& ACLs::remove_standalone_containers(int index) const {
  // @@protoc_insertion_point(field_get:mesos.ACLs.remove_standalone_containers)
  return remove_standalone_containers_.Get(index);
}
inline ::mesos::ACL_RemoveStandaloneContainer* ACLs::mutable_remove_standalone_containers(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.ACLs.remove_standalone_containers)
  return remove_standalone_containers_.Mutable(index);
}
inline ::mesos::ACL_RemoveStandaloneContainer* ACLs::add_remove_standalone_containers() {
  // @@protoc_insertion_point(field_add:mesos.ACLs.remove_standalone_containers)
  return remove_standalone_containers_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::ACL_RemoveStandaloneContainer >*
ACLs::mutable_remove_standalone_containers() {
  // @@protoc_insertion_point(field_mutable_list:mesos.ACLs.remove_standalone_containers)
  return &remove_standalone_containers_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::ACL_RemoveStandaloneContainer >&
ACLs::remove_standalone_containers() const {
  // @@protoc_insertion_point(field_list:mesos.ACLs.remove_standalone_containers)
  return remove_standalone_containers_;
}

// repeated .mesos.ACL.ViewStandaloneContainer view_standalone_containers = 46;
inline int ACLs::view_standalone_containers_size() const {
  return view_standalone_containers_.size();
}
inline void ACLs::clear_view_standalone_containers() {
  view_standalone_containers_.Clear();
}
inline const ::mesos::ACL_ViewStandaloneContainer& ACLs::view_standalone_containers(int index) const {
  // @@protoc_insertion_point(field_get:mesos.ACLs.view_standalone_containers)
  return view_standalone_containers_.Get(index);
}
inline ::mesos::ACL_ViewStandaloneContainer* ACLs::mutable_view_standalone_containers(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.ACLs.view_standalone_containers)
  return view_standalone_containers_.Mutable(index);
}
inline ::mesos::ACL_ViewStandaloneContainer* ACLs::add_view_standalone_containers() {
  // @@protoc_insertion_point(field_add:mesos.ACLs.view_standalone_containers)
  return view_standalone_containers_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::ACL_ViewStandaloneContainer >*
ACLs::mutable_view_standalone_containers() {
  // @@protoc_insertion_point(field_mutable_list:mesos.ACLs.view_standalone_containers)
  return &view_standalone_containers_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::ACL_ViewStandaloneContainer >&
ACLs::view_standalone_containers() const {
  // @@protoc_insertion_point(field_list:mesos.ACLs.view_standalone_containers)
  return view_standalone_containers_;
}

// repeated .mesos.ACL.ModifyResourceProviderConfig modify_resource_provider_configs = 45;
inline int ACLs::modify_resource_provider_configs_size() const {
  return modify_resource_provider_configs_.size();
}
inline void ACLs::clear_modify_resource_provider_configs() {
  modify_resource_provider_configs_.Clear();
}
inline const ::mesos::ACL_ModifyResourceProviderConfig& ACLs::modify_resource_provider_configs(int index) const {
  // @@protoc_insertion_point(field_get:mesos.ACLs.modify_resource_provider_configs)
  return modify_resource_provider_configs_.Get(index);
}
inline ::mesos::ACL_ModifyResourceProviderConfig* ACLs::mutable_modify_resource_provider_configs(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.ACLs.modify_resource_provider_configs)
  return modify_resource_provider_configs_.Mutable(index);
}
inline ::mesos::ACL_ModifyResourceProviderConfig* ACLs::add_modify_resource_provider_configs() {
  // @@protoc_insertion_point(field_add:mesos.ACLs.modify_resource_provider_configs)
  return modify_resource_provider_configs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::ACL_ModifyResourceProviderConfig >*
ACLs::mutable_modify_resource_provider_configs() {
  // @@protoc_insertion_point(field_mutable_list:mesos.ACLs.modify_resource_provider_configs)
  return &modify_resource_provider_configs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::ACL_ModifyResourceProviderConfig >&
ACLs::modify_resource_provider_configs() const {
  // @@protoc_insertion_point(field_list:mesos.ACLs.modify_resource_provider_configs)
  return modify_resource_provider_configs_;
}

// repeated .mesos.ACL.PruneImages prune_images = 47;
inline int ACLs::prune_images_size() const {
  return prune_images_.size();
}
inline void ACLs::clear_prune_images() {
  prune_images_.Clear();
}
inline const ::mesos::ACL_PruneImages& ACLs::prune_images(int index) const {
  // @@protoc_insertion_point(field_get:mesos.ACLs.prune_images)
  return prune_images_.Get(index);
}
inline ::mesos::ACL_PruneImages* ACLs::mutable_prune_images(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.ACLs.prune_images)
  return prune_images_.Mutable(index);
}
inline ::mesos::ACL_PruneImages* ACLs::add_prune_images() {
  // @@protoc_insertion_point(field_add:mesos.ACLs.prune_images)
  return prune_images_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::ACL_PruneImages >*
ACLs::mutable_prune_images() {
  // @@protoc_insertion_point(field_mutable_list:mesos.ACLs.prune_images)
  return &prune_images_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::ACL_PruneImages >&
ACLs::prune_images() const {
  // @@protoc_insertion_point(field_list:mesos.ACLs.prune_images)
  return prune_images_;
}

// repeated .mesos.ACL.ResizeVolume resize_volumes = 48;
inline int ACLs::resize_volumes_size() const {
  return resize_volumes_.size();
}
inline void ACLs::clear_resize_volumes() {
  resize_volumes_.Clear();
}
inline const ::mesos::ACL_ResizeVolume& ACLs::resize_volumes(int index) const {
  // @@protoc_insertion_point(field_get:mesos.ACLs.resize_volumes)
  return resize_volumes_.Get(index);
}
inline ::mesos::ACL_ResizeVolume* ACLs::mutable_resize_volumes(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.ACLs.resize_volumes)
  return resize_volumes_.Mutable(index);
}
inline ::mesos::ACL_ResizeVolume* ACLs::add_resize_volumes() {
  // @@protoc_insertion_point(field_add:mesos.ACLs.resize_volumes)
  return resize_volumes_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::ACL_ResizeVolume >*
ACLs::mutable_resize_volumes() {
  // @@protoc_insertion_point(field_mutable_list:mesos.ACLs.resize_volumes)
  return &resize_volumes_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::ACL_ResizeVolume >&
ACLs::resize_volumes() const {
  // @@protoc_insertion_point(field_list:mesos.ACLs.resize_volumes)
  return resize_volumes_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace mesos

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::mesos::ACL_Entity_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mesos::ACL_Entity_Type>() {
  return ::mesos::ACL_Entity_Type_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_mesos_2fauthorizer_2facls_2eproto__INCLUDED
