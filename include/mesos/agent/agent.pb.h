// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mesos/agent/agent.proto

#ifndef PROTOBUF_mesos_2fagent_2fagent_2eproto__INCLUDED
#define PROTOBUF_mesos_2fagent_2fagent_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "mesos/mesos.pb.h"
// @@protoc_insertion_point(includes)

namespace protobuf_mesos_2fagent_2fagent_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[47];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsCall_GetMetricsImpl();
void InitDefaultsCall_GetMetrics();
void InitDefaultsCall_SetLoggingLevelImpl();
void InitDefaultsCall_SetLoggingLevel();
void InitDefaultsCall_ListFilesImpl();
void InitDefaultsCall_ListFiles();
void InitDefaultsCall_ReadFileImpl();
void InitDefaultsCall_ReadFile();
void InitDefaultsCall_GetContainersImpl();
void InitDefaultsCall_GetContainers();
void InitDefaultsCall_LaunchNestedContainerImpl();
void InitDefaultsCall_LaunchNestedContainer();
void InitDefaultsCall_WaitNestedContainerImpl();
void InitDefaultsCall_WaitNestedContainer();
void InitDefaultsCall_KillNestedContainerImpl();
void InitDefaultsCall_KillNestedContainer();
void InitDefaultsCall_RemoveNestedContainerImpl();
void InitDefaultsCall_RemoveNestedContainer();
void InitDefaultsCall_LaunchNestedContainerSessionImpl();
void InitDefaultsCall_LaunchNestedContainerSession();
void InitDefaultsCall_AttachContainerInputImpl();
void InitDefaultsCall_AttachContainerInput();
void InitDefaultsCall_AttachContainerOutputImpl();
void InitDefaultsCall_AttachContainerOutput();
void InitDefaultsCall_LaunchContainerImpl();
void InitDefaultsCall_LaunchContainer();
void InitDefaultsCall_WaitContainerImpl();
void InitDefaultsCall_WaitContainer();
void InitDefaultsCall_KillContainerImpl();
void InitDefaultsCall_KillContainer();
void InitDefaultsCall_RemoveContainerImpl();
void InitDefaultsCall_RemoveContainer();
void InitDefaultsCall_AddResourceProviderConfigImpl();
void InitDefaultsCall_AddResourceProviderConfig();
void InitDefaultsCall_UpdateResourceProviderConfigImpl();
void InitDefaultsCall_UpdateResourceProviderConfig();
void InitDefaultsCall_RemoveResourceProviderConfigImpl();
void InitDefaultsCall_RemoveResourceProviderConfig();
void InitDefaultsCall_PruneImagesImpl();
void InitDefaultsCall_PruneImages();
void InitDefaultsCallImpl();
void InitDefaultsCall();
void InitDefaultsResponse_GetHealthImpl();
void InitDefaultsResponse_GetHealth();
void InitDefaultsResponse_GetFlagsImpl();
void InitDefaultsResponse_GetFlags();
void InitDefaultsResponse_GetVersionImpl();
void InitDefaultsResponse_GetVersion();
void InitDefaultsResponse_GetMetricsImpl();
void InitDefaultsResponse_GetMetrics();
void InitDefaultsResponse_GetLoggingLevelImpl();
void InitDefaultsResponse_GetLoggingLevel();
void InitDefaultsResponse_ListFilesImpl();
void InitDefaultsResponse_ListFiles();
void InitDefaultsResponse_ReadFileImpl();
void InitDefaultsResponse_ReadFile();
void InitDefaultsResponse_GetStateImpl();
void InitDefaultsResponse_GetState();
void InitDefaultsResponse_GetContainers_ContainerImpl();
void InitDefaultsResponse_GetContainers_Container();
void InitDefaultsResponse_GetContainersImpl();
void InitDefaultsResponse_GetContainers();
void InitDefaultsResponse_GetFrameworks_FrameworkImpl();
void InitDefaultsResponse_GetFrameworks_Framework();
void InitDefaultsResponse_GetFrameworksImpl();
void InitDefaultsResponse_GetFrameworks();
void InitDefaultsResponse_GetExecutors_ExecutorImpl();
void InitDefaultsResponse_GetExecutors_Executor();
void InitDefaultsResponse_GetExecutorsImpl();
void InitDefaultsResponse_GetExecutors();
void InitDefaultsResponse_GetOperationsImpl();
void InitDefaultsResponse_GetOperations();
void InitDefaultsResponse_GetTasksImpl();
void InitDefaultsResponse_GetTasks();
void InitDefaultsResponse_GetAgentImpl();
void InitDefaultsResponse_GetAgent();
void InitDefaultsResponse_GetResourceProviders_ResourceProviderImpl();
void InitDefaultsResponse_GetResourceProviders_ResourceProvider();
void InitDefaultsResponse_GetResourceProvidersImpl();
void InitDefaultsResponse_GetResourceProviders();
void InitDefaultsResponse_WaitNestedContainerImpl();
void InitDefaultsResponse_WaitNestedContainer();
void InitDefaultsResponse_WaitContainerImpl();
void InitDefaultsResponse_WaitContainer();
void InitDefaultsResponseImpl();
void InitDefaultsResponse();
void InitDefaultsProcessIO_DataImpl();
void InitDefaultsProcessIO_Data();
void InitDefaultsProcessIO_Control_HeartbeatImpl();
void InitDefaultsProcessIO_Control_Heartbeat();
void InitDefaultsProcessIO_ControlImpl();
void InitDefaultsProcessIO_Control();
void InitDefaultsProcessIOImpl();
void InitDefaultsProcessIO();
inline void InitDefaults() {
  InitDefaultsCall_GetMetrics();
  InitDefaultsCall_SetLoggingLevel();
  InitDefaultsCall_ListFiles();
  InitDefaultsCall_ReadFile();
  InitDefaultsCall_GetContainers();
  InitDefaultsCall_LaunchNestedContainer();
  InitDefaultsCall_WaitNestedContainer();
  InitDefaultsCall_KillNestedContainer();
  InitDefaultsCall_RemoveNestedContainer();
  InitDefaultsCall_LaunchNestedContainerSession();
  InitDefaultsCall_AttachContainerInput();
  InitDefaultsCall_AttachContainerOutput();
  InitDefaultsCall_LaunchContainer();
  InitDefaultsCall_WaitContainer();
  InitDefaultsCall_KillContainer();
  InitDefaultsCall_RemoveContainer();
  InitDefaultsCall_AddResourceProviderConfig();
  InitDefaultsCall_UpdateResourceProviderConfig();
  InitDefaultsCall_RemoveResourceProviderConfig();
  InitDefaultsCall_PruneImages();
  InitDefaultsCall();
  InitDefaultsResponse_GetHealth();
  InitDefaultsResponse_GetFlags();
  InitDefaultsResponse_GetVersion();
  InitDefaultsResponse_GetMetrics();
  InitDefaultsResponse_GetLoggingLevel();
  InitDefaultsResponse_ListFiles();
  InitDefaultsResponse_ReadFile();
  InitDefaultsResponse_GetState();
  InitDefaultsResponse_GetContainers_Container();
  InitDefaultsResponse_GetContainers();
  InitDefaultsResponse_GetFrameworks_Framework();
  InitDefaultsResponse_GetFrameworks();
  InitDefaultsResponse_GetExecutors_Executor();
  InitDefaultsResponse_GetExecutors();
  InitDefaultsResponse_GetOperations();
  InitDefaultsResponse_GetTasks();
  InitDefaultsResponse_GetAgent();
  InitDefaultsResponse_GetResourceProviders_ResourceProvider();
  InitDefaultsResponse_GetResourceProviders();
  InitDefaultsResponse_WaitNestedContainer();
  InitDefaultsResponse_WaitContainer();
  InitDefaultsResponse();
  InitDefaultsProcessIO_Data();
  InitDefaultsProcessIO_Control_Heartbeat();
  InitDefaultsProcessIO_Control();
  InitDefaultsProcessIO();
}
}  // namespace protobuf_mesos_2fagent_2fagent_2eproto
namespace mesos {
namespace agent {
class Call;
class CallDefaultTypeInternal;
extern CallDefaultTypeInternal _Call_default_instance_;
class Call_AddResourceProviderConfig;
class Call_AddResourceProviderConfigDefaultTypeInternal;
extern Call_AddResourceProviderConfigDefaultTypeInternal _Call_AddResourceProviderConfig_default_instance_;
class Call_AttachContainerInput;
class Call_AttachContainerInputDefaultTypeInternal;
extern Call_AttachContainerInputDefaultTypeInternal _Call_AttachContainerInput_default_instance_;
class Call_AttachContainerOutput;
class Call_AttachContainerOutputDefaultTypeInternal;
extern Call_AttachContainerOutputDefaultTypeInternal _Call_AttachContainerOutput_default_instance_;
class Call_GetContainers;
class Call_GetContainersDefaultTypeInternal;
extern Call_GetContainersDefaultTypeInternal _Call_GetContainers_default_instance_;
class Call_GetMetrics;
class Call_GetMetricsDefaultTypeInternal;
extern Call_GetMetricsDefaultTypeInternal _Call_GetMetrics_default_instance_;
class Call_KillContainer;
class Call_KillContainerDefaultTypeInternal;
extern Call_KillContainerDefaultTypeInternal _Call_KillContainer_default_instance_;
class Call_KillNestedContainer;
class Call_KillNestedContainerDefaultTypeInternal;
extern Call_KillNestedContainerDefaultTypeInternal _Call_KillNestedContainer_default_instance_;
class Call_LaunchContainer;
class Call_LaunchContainerDefaultTypeInternal;
extern Call_LaunchContainerDefaultTypeInternal _Call_LaunchContainer_default_instance_;
class Call_LaunchNestedContainer;
class Call_LaunchNestedContainerDefaultTypeInternal;
extern Call_LaunchNestedContainerDefaultTypeInternal _Call_LaunchNestedContainer_default_instance_;
class Call_LaunchNestedContainerSession;
class Call_LaunchNestedContainerSessionDefaultTypeInternal;
extern Call_LaunchNestedContainerSessionDefaultTypeInternal _Call_LaunchNestedContainerSession_default_instance_;
class Call_ListFiles;
class Call_ListFilesDefaultTypeInternal;
extern Call_ListFilesDefaultTypeInternal _Call_ListFiles_default_instance_;
class Call_PruneImages;
class Call_PruneImagesDefaultTypeInternal;
extern Call_PruneImagesDefaultTypeInternal _Call_PruneImages_default_instance_;
class Call_ReadFile;
class Call_ReadFileDefaultTypeInternal;
extern Call_ReadFileDefaultTypeInternal _Call_ReadFile_default_instance_;
class Call_RemoveContainer;
class Call_RemoveContainerDefaultTypeInternal;
extern Call_RemoveContainerDefaultTypeInternal _Call_RemoveContainer_default_instance_;
class Call_RemoveNestedContainer;
class Call_RemoveNestedContainerDefaultTypeInternal;
extern Call_RemoveNestedContainerDefaultTypeInternal _Call_RemoveNestedContainer_default_instance_;
class Call_RemoveResourceProviderConfig;
class Call_RemoveResourceProviderConfigDefaultTypeInternal;
extern Call_RemoveResourceProviderConfigDefaultTypeInternal _Call_RemoveResourceProviderConfig_default_instance_;
class Call_SetLoggingLevel;
class Call_SetLoggingLevelDefaultTypeInternal;
extern Call_SetLoggingLevelDefaultTypeInternal _Call_SetLoggingLevel_default_instance_;
class Call_UpdateResourceProviderConfig;
class Call_UpdateResourceProviderConfigDefaultTypeInternal;
extern Call_UpdateResourceProviderConfigDefaultTypeInternal _Call_UpdateResourceProviderConfig_default_instance_;
class Call_WaitContainer;
class Call_WaitContainerDefaultTypeInternal;
extern Call_WaitContainerDefaultTypeInternal _Call_WaitContainer_default_instance_;
class Call_WaitNestedContainer;
class Call_WaitNestedContainerDefaultTypeInternal;
extern Call_WaitNestedContainerDefaultTypeInternal _Call_WaitNestedContainer_default_instance_;
class ProcessIO;
class ProcessIODefaultTypeInternal;
extern ProcessIODefaultTypeInternal _ProcessIO_default_instance_;
class ProcessIO_Control;
class ProcessIO_ControlDefaultTypeInternal;
extern ProcessIO_ControlDefaultTypeInternal _ProcessIO_Control_default_instance_;
class ProcessIO_Control_Heartbeat;
class ProcessIO_Control_HeartbeatDefaultTypeInternal;
extern ProcessIO_Control_HeartbeatDefaultTypeInternal _ProcessIO_Control_Heartbeat_default_instance_;
class ProcessIO_Data;
class ProcessIO_DataDefaultTypeInternal;
extern ProcessIO_DataDefaultTypeInternal _ProcessIO_Data_default_instance_;
class Response;
class ResponseDefaultTypeInternal;
extern ResponseDefaultTypeInternal _Response_default_instance_;
class Response_GetAgent;
class Response_GetAgentDefaultTypeInternal;
extern Response_GetAgentDefaultTypeInternal _Response_GetAgent_default_instance_;
class Response_GetContainers;
class Response_GetContainersDefaultTypeInternal;
extern Response_GetContainersDefaultTypeInternal _Response_GetContainers_default_instance_;
class Response_GetContainers_Container;
class Response_GetContainers_ContainerDefaultTypeInternal;
extern Response_GetContainers_ContainerDefaultTypeInternal _Response_GetContainers_Container_default_instance_;
class Response_GetExecutors;
class Response_GetExecutorsDefaultTypeInternal;
extern Response_GetExecutorsDefaultTypeInternal _Response_GetExecutors_default_instance_;
class Response_GetExecutors_Executor;
class Response_GetExecutors_ExecutorDefaultTypeInternal;
extern Response_GetExecutors_ExecutorDefaultTypeInternal _Response_GetExecutors_Executor_default_instance_;
class Response_GetFlags;
class Response_GetFlagsDefaultTypeInternal;
extern Response_GetFlagsDefaultTypeInternal _Response_GetFlags_default_instance_;
class Response_GetFrameworks;
class Response_GetFrameworksDefaultTypeInternal;
extern Response_GetFrameworksDefaultTypeInternal _Response_GetFrameworks_default_instance_;
class Response_GetFrameworks_Framework;
class Response_GetFrameworks_FrameworkDefaultTypeInternal;
extern Response_GetFrameworks_FrameworkDefaultTypeInternal _Response_GetFrameworks_Framework_default_instance_;
class Response_GetHealth;
class Response_GetHealthDefaultTypeInternal;
extern Response_GetHealthDefaultTypeInternal _Response_GetHealth_default_instance_;
class Response_GetLoggingLevel;
class Response_GetLoggingLevelDefaultTypeInternal;
extern Response_GetLoggingLevelDefaultTypeInternal _Response_GetLoggingLevel_default_instance_;
class Response_GetMetrics;
class Response_GetMetricsDefaultTypeInternal;
extern Response_GetMetricsDefaultTypeInternal _Response_GetMetrics_default_instance_;
class Response_GetOperations;
class Response_GetOperationsDefaultTypeInternal;
extern Response_GetOperationsDefaultTypeInternal _Response_GetOperations_default_instance_;
class Response_GetResourceProviders;
class Response_GetResourceProvidersDefaultTypeInternal;
extern Response_GetResourceProvidersDefaultTypeInternal _Response_GetResourceProviders_default_instance_;
class Response_GetResourceProviders_ResourceProvider;
class Response_GetResourceProviders_ResourceProviderDefaultTypeInternal;
extern Response_GetResourceProviders_ResourceProviderDefaultTypeInternal _Response_GetResourceProviders_ResourceProvider_default_instance_;
class Response_GetState;
class Response_GetStateDefaultTypeInternal;
extern Response_GetStateDefaultTypeInternal _Response_GetState_default_instance_;
class Response_GetTasks;
class Response_GetTasksDefaultTypeInternal;
extern Response_GetTasksDefaultTypeInternal _Response_GetTasks_default_instance_;
class Response_GetVersion;
class Response_GetVersionDefaultTypeInternal;
extern Response_GetVersionDefaultTypeInternal _Response_GetVersion_default_instance_;
class Response_ListFiles;
class Response_ListFilesDefaultTypeInternal;
extern Response_ListFilesDefaultTypeInternal _Response_ListFiles_default_instance_;
class Response_ReadFile;
class Response_ReadFileDefaultTypeInternal;
extern Response_ReadFileDefaultTypeInternal _Response_ReadFile_default_instance_;
class Response_WaitContainer;
class Response_WaitContainerDefaultTypeInternal;
extern Response_WaitContainerDefaultTypeInternal _Response_WaitContainer_default_instance_;
class Response_WaitNestedContainer;
class Response_WaitNestedContainerDefaultTypeInternal;
extern Response_WaitNestedContainerDefaultTypeInternal _Response_WaitNestedContainer_default_instance_;
}  // namespace agent
}  // namespace mesos
namespace mesos {
namespace agent {

enum Call_AttachContainerInput_Type {
  Call_AttachContainerInput_Type_UNKNOWN = 0,
  Call_AttachContainerInput_Type_CONTAINER_ID = 1,
  Call_AttachContainerInput_Type_PROCESS_IO = 2
};
bool Call_AttachContainerInput_Type_IsValid(int value);
const Call_AttachContainerInput_Type Call_AttachContainerInput_Type_Type_MIN = Call_AttachContainerInput_Type_UNKNOWN;
const Call_AttachContainerInput_Type Call_AttachContainerInput_Type_Type_MAX = Call_AttachContainerInput_Type_PROCESS_IO;
const int Call_AttachContainerInput_Type_Type_ARRAYSIZE = Call_AttachContainerInput_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Call_AttachContainerInput_Type_descriptor();
inline const ::std::string& Call_AttachContainerInput_Type_Name(Call_AttachContainerInput_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Call_AttachContainerInput_Type_descriptor(), value);
}
inline bool Call_AttachContainerInput_Type_Parse(
    const ::std::string& name, Call_AttachContainerInput_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Call_AttachContainerInput_Type>(
    Call_AttachContainerInput_Type_descriptor(), name, value);
}
enum Call_Type {
  Call_Type_UNKNOWN = 0,
  Call_Type_GET_HEALTH = 1,
  Call_Type_GET_FLAGS = 2,
  Call_Type_GET_VERSION = 3,
  Call_Type_GET_METRICS = 4,
  Call_Type_GET_LOGGING_LEVEL = 5,
  Call_Type_SET_LOGGING_LEVEL = 6,
  Call_Type_LIST_FILES = 7,
  Call_Type_READ_FILE = 8,
  Call_Type_GET_STATE = 9,
  Call_Type_GET_CONTAINERS = 10,
  Call_Type_GET_FRAMEWORKS = 11,
  Call_Type_GET_EXECUTORS = 12,
  Call_Type_GET_OPERATIONS = 31,
  Call_Type_GET_TASKS = 13,
  Call_Type_GET_AGENT = 20,
  Call_Type_GET_RESOURCE_PROVIDERS = 26,
  Call_Type_LAUNCH_NESTED_CONTAINER PROTOBUF_DEPRECATED = 14,
  Call_Type_WAIT_NESTED_CONTAINER PROTOBUF_DEPRECATED = 15,
  Call_Type_KILL_NESTED_CONTAINER PROTOBUF_DEPRECATED = 16,
  Call_Type_REMOVE_NESTED_CONTAINER PROTOBUF_DEPRECATED = 21,
  Call_Type_LAUNCH_NESTED_CONTAINER_SESSION = 17,
  Call_Type_ATTACH_CONTAINER_INPUT = 18,
  Call_Type_ATTACH_CONTAINER_OUTPUT = 19,
  Call_Type_LAUNCH_CONTAINER = 22,
  Call_Type_WAIT_CONTAINER = 23,
  Call_Type_KILL_CONTAINER = 24,
  Call_Type_REMOVE_CONTAINER = 25,
  Call_Type_ADD_RESOURCE_PROVIDER_CONFIG = 27,
  Call_Type_UPDATE_RESOURCE_PROVIDER_CONFIG = 28,
  Call_Type_REMOVE_RESOURCE_PROVIDER_CONFIG = 29,
  Call_Type_PRUNE_IMAGES = 30
};
bool Call_Type_IsValid(int value);
const Call_Type Call_Type_Type_MIN = Call_Type_UNKNOWN;
const Call_Type Call_Type_Type_MAX = Call_Type_GET_OPERATIONS;
const int Call_Type_Type_ARRAYSIZE = Call_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Call_Type_descriptor();
inline const ::std::string& Call_Type_Name(Call_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Call_Type_descriptor(), value);
}
inline bool Call_Type_Parse(
    const ::std::string& name, Call_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Call_Type>(
    Call_Type_descriptor(), name, value);
}
enum Response_Type {
  Response_Type_UNKNOWN = 0,
  Response_Type_GET_HEALTH = 1,
  Response_Type_GET_FLAGS = 2,
  Response_Type_GET_VERSION = 3,
  Response_Type_GET_METRICS = 4,
  Response_Type_GET_LOGGING_LEVEL = 5,
  Response_Type_LIST_FILES = 6,
  Response_Type_READ_FILE = 7,
  Response_Type_GET_STATE = 8,
  Response_Type_GET_CONTAINERS = 9,
  Response_Type_GET_FRAMEWORKS = 10,
  Response_Type_GET_EXECUTORS = 11,
  Response_Type_GET_OPERATIONS = 17,
  Response_Type_GET_TASKS = 12,
  Response_Type_GET_AGENT = 14,
  Response_Type_GET_RESOURCE_PROVIDERS = 16,
  Response_Type_WAIT_NESTED_CONTAINER PROTOBUF_DEPRECATED = 13,
  Response_Type_WAIT_CONTAINER = 15
};
bool Response_Type_IsValid(int value);
const Response_Type Response_Type_Type_MIN = Response_Type_UNKNOWN;
const Response_Type Response_Type_Type_MAX = Response_Type_GET_OPERATIONS;
const int Response_Type_Type_ARRAYSIZE = Response_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Response_Type_descriptor();
inline const ::std::string& Response_Type_Name(Response_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Response_Type_descriptor(), value);
}
inline bool Response_Type_Parse(
    const ::std::string& name, Response_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Response_Type>(
    Response_Type_descriptor(), name, value);
}
enum ProcessIO_Data_Type {
  ProcessIO_Data_Type_UNKNOWN = 0,
  ProcessIO_Data_Type_STDIN = 1,
  ProcessIO_Data_Type_STDOUT = 2,
  ProcessIO_Data_Type_STDERR = 3
};
bool ProcessIO_Data_Type_IsValid(int value);
const ProcessIO_Data_Type ProcessIO_Data_Type_Type_MIN = ProcessIO_Data_Type_UNKNOWN;
const ProcessIO_Data_Type ProcessIO_Data_Type_Type_MAX = ProcessIO_Data_Type_STDERR;
const int ProcessIO_Data_Type_Type_ARRAYSIZE = ProcessIO_Data_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* ProcessIO_Data_Type_descriptor();
inline const ::std::string& ProcessIO_Data_Type_Name(ProcessIO_Data_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    ProcessIO_Data_Type_descriptor(), value);
}
inline bool ProcessIO_Data_Type_Parse(
    const ::std::string& name, ProcessIO_Data_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ProcessIO_Data_Type>(
    ProcessIO_Data_Type_descriptor(), name, value);
}
enum ProcessIO_Control_Type {
  ProcessIO_Control_Type_UNKNOWN = 0,
  ProcessIO_Control_Type_TTY_INFO = 1,
  ProcessIO_Control_Type_HEARTBEAT = 2
};
bool ProcessIO_Control_Type_IsValid(int value);
const ProcessIO_Control_Type ProcessIO_Control_Type_Type_MIN = ProcessIO_Control_Type_UNKNOWN;
const ProcessIO_Control_Type ProcessIO_Control_Type_Type_MAX = ProcessIO_Control_Type_HEARTBEAT;
const int ProcessIO_Control_Type_Type_ARRAYSIZE = ProcessIO_Control_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* ProcessIO_Control_Type_descriptor();
inline const ::std::string& ProcessIO_Control_Type_Name(ProcessIO_Control_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    ProcessIO_Control_Type_descriptor(), value);
}
inline bool ProcessIO_Control_Type_Parse(
    const ::std::string& name, ProcessIO_Control_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ProcessIO_Control_Type>(
    ProcessIO_Control_Type_descriptor(), name, value);
}
enum ProcessIO_Type {
  ProcessIO_Type_UNKNOWN = 0,
  ProcessIO_Type_DATA = 1,
  ProcessIO_Type_CONTROL = 2
};
bool ProcessIO_Type_IsValid(int value);
const ProcessIO_Type ProcessIO_Type_Type_MIN = ProcessIO_Type_UNKNOWN;
const ProcessIO_Type ProcessIO_Type_Type_MAX = ProcessIO_Type_CONTROL;
const int ProcessIO_Type_Type_ARRAYSIZE = ProcessIO_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* ProcessIO_Type_descriptor();
inline const ::std::string& ProcessIO_Type_Name(ProcessIO_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    ProcessIO_Type_descriptor(), value);
}
inline bool ProcessIO_Type_Parse(
    const ::std::string& name, ProcessIO_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ProcessIO_Type>(
    ProcessIO_Type_descriptor(), name, value);
}
// ===================================================================

class Call_GetMetrics : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.agent.Call.GetMetrics) */ {
 public:
  Call_GetMetrics();
  virtual ~Call_GetMetrics();

  Call_GetMetrics(const Call_GetMetrics& from);

  inline Call_GetMetrics& operator=(const Call_GetMetrics& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Call_GetMetrics(Call_GetMetrics&& from) noexcept
    : Call_GetMetrics() {
    *this = ::std::move(from);
  }

  inline Call_GetMetrics& operator=(Call_GetMetrics&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Call_GetMetrics& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Call_GetMetrics* internal_default_instance() {
    return reinterpret_cast<const Call_GetMetrics*>(
               &_Call_GetMetrics_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(Call_GetMetrics* other);
  friend void swap(Call_GetMetrics& a, Call_GetMetrics& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Call_GetMetrics* New() const PROTOBUF_FINAL { return New(NULL); }

  Call_GetMetrics* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Call_GetMetrics& from);
  void MergeFrom(const Call_GetMetrics& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Call_GetMetrics* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mesos.DurationInfo timeout = 1;
  bool has_timeout() const;
  void clear_timeout();
  static const int kTimeoutFieldNumber = 1;
  const ::mesos::DurationInfo& timeout() const;
  ::mesos::DurationInfo* release_timeout();
  ::mesos::DurationInfo* mutable_timeout();
  void set_allocated_timeout(::mesos::DurationInfo* timeout);

  // @@protoc_insertion_point(class_scope:mesos.agent.Call.GetMetrics)
 private:
  void set_has_timeout();
  void clear_has_timeout();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::DurationInfo* timeout_;
  friend struct ::protobuf_mesos_2fagent_2fagent_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fagent_2fagent_2eproto::InitDefaultsCall_GetMetricsImpl();
};
// -------------------------------------------------------------------

class Call_SetLoggingLevel : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.agent.Call.SetLoggingLevel) */ {
 public:
  Call_SetLoggingLevel();
  virtual ~Call_SetLoggingLevel();

  Call_SetLoggingLevel(const Call_SetLoggingLevel& from);

  inline Call_SetLoggingLevel& operator=(const Call_SetLoggingLevel& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Call_SetLoggingLevel(Call_SetLoggingLevel&& from) noexcept
    : Call_SetLoggingLevel() {
    *this = ::std::move(from);
  }

  inline Call_SetLoggingLevel& operator=(Call_SetLoggingLevel&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Call_SetLoggingLevel& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Call_SetLoggingLevel* internal_default_instance() {
    return reinterpret_cast<const Call_SetLoggingLevel*>(
               &_Call_SetLoggingLevel_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(Call_SetLoggingLevel* other);
  friend void swap(Call_SetLoggingLevel& a, Call_SetLoggingLevel& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Call_SetLoggingLevel* New() const PROTOBUF_FINAL { return New(NULL); }

  Call_SetLoggingLevel* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Call_SetLoggingLevel& from);
  void MergeFrom(const Call_SetLoggingLevel& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Call_SetLoggingLevel* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.DurationInfo duration = 2;
  bool has_duration() const;
  void clear_duration();
  static const int kDurationFieldNumber = 2;
  const ::mesos::DurationInfo& duration() const;
  ::mesos::DurationInfo* release_duration();
  ::mesos::DurationInfo* mutable_duration();
  void set_allocated_duration(::mesos::DurationInfo* duration);

  // required uint32 level = 1;
  bool has_level() const;
  void clear_level();
  static const int kLevelFieldNumber = 1;
  ::google::protobuf::uint32 level() const;
  void set_level(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mesos.agent.Call.SetLoggingLevel)
 private:
  void set_has_level();
  void clear_has_level();
  void set_has_duration();
  void clear_has_duration();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::DurationInfo* duration_;
  ::google::protobuf::uint32 level_;
  friend struct ::protobuf_mesos_2fagent_2fagent_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fagent_2fagent_2eproto::InitDefaultsCall_SetLoggingLevelImpl();
};
// -------------------------------------------------------------------

class Call_ListFiles : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.agent.Call.ListFiles) */ {
 public:
  Call_ListFiles();
  virtual ~Call_ListFiles();

  Call_ListFiles(const Call_ListFiles& from);

  inline Call_ListFiles& operator=(const Call_ListFiles& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Call_ListFiles(Call_ListFiles&& from) noexcept
    : Call_ListFiles() {
    *this = ::std::move(from);
  }

  inline Call_ListFiles& operator=(Call_ListFiles&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Call_ListFiles& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Call_ListFiles* internal_default_instance() {
    return reinterpret_cast<const Call_ListFiles*>(
               &_Call_ListFiles_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(Call_ListFiles* other);
  friend void swap(Call_ListFiles& a, Call_ListFiles& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Call_ListFiles* New() const PROTOBUF_FINAL { return New(NULL); }

  Call_ListFiles* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Call_ListFiles& from);
  void MergeFrom(const Call_ListFiles& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Call_ListFiles* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string path = 1;
  bool has_path() const;
  void clear_path();
  static const int kPathFieldNumber = 1;
  const ::std::string& path() const;
  void set_path(const ::std::string& value);
  #if LANG_CXX11
  void set_path(::std::string&& value);
  #endif
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  ::std::string* mutable_path();
  ::std::string* release_path();
  void set_allocated_path(::std::string* path);

  // @@protoc_insertion_point(class_scope:mesos.agent.Call.ListFiles)
 private:
  void set_has_path();
  void clear_has_path();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr path_;
  friend struct ::protobuf_mesos_2fagent_2fagent_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fagent_2fagent_2eproto::InitDefaultsCall_ListFilesImpl();
};
// -------------------------------------------------------------------

class Call_ReadFile : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.agent.Call.ReadFile) */ {
 public:
  Call_ReadFile();
  virtual ~Call_ReadFile();

  Call_ReadFile(const Call_ReadFile& from);

  inline Call_ReadFile& operator=(const Call_ReadFile& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Call_ReadFile(Call_ReadFile&& from) noexcept
    : Call_ReadFile() {
    *this = ::std::move(from);
  }

  inline Call_ReadFile& operator=(Call_ReadFile&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Call_ReadFile& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Call_ReadFile* internal_default_instance() {
    return reinterpret_cast<const Call_ReadFile*>(
               &_Call_ReadFile_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(Call_ReadFile* other);
  friend void swap(Call_ReadFile& a, Call_ReadFile& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Call_ReadFile* New() const PROTOBUF_FINAL { return New(NULL); }

  Call_ReadFile* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Call_ReadFile& from);
  void MergeFrom(const Call_ReadFile& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Call_ReadFile* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string path = 1;
  bool has_path() const;
  void clear_path();
  static const int kPathFieldNumber = 1;
  const ::std::string& path() const;
  void set_path(const ::std::string& value);
  #if LANG_CXX11
  void set_path(::std::string&& value);
  #endif
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  ::std::string* mutable_path();
  ::std::string* release_path();
  void set_allocated_path(::std::string* path);

  // required uint64 offset = 2;
  bool has_offset() const;
  void clear_offset();
  static const int kOffsetFieldNumber = 2;
  ::google::protobuf::uint64 offset() const;
  void set_offset(::google::protobuf::uint64 value);

  // optional uint64 length = 3;
  bool has_length() const;
  void clear_length();
  static const int kLengthFieldNumber = 3;
  ::google::protobuf::uint64 length() const;
  void set_length(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:mesos.agent.Call.ReadFile)
 private:
  void set_has_path();
  void clear_has_path();
  void set_has_offset();
  void clear_has_offset();
  void set_has_length();
  void clear_has_length();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr path_;
  ::google::protobuf::uint64 offset_;
  ::google::protobuf::uint64 length_;
  friend struct ::protobuf_mesos_2fagent_2fagent_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fagent_2fagent_2eproto::InitDefaultsCall_ReadFileImpl();
};
// -------------------------------------------------------------------

class Call_GetContainers : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.agent.Call.GetContainers) */ {
 public:
  Call_GetContainers();
  virtual ~Call_GetContainers();

  Call_GetContainers(const Call_GetContainers& from);

  inline Call_GetContainers& operator=(const Call_GetContainers& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Call_GetContainers(Call_GetContainers&& from) noexcept
    : Call_GetContainers() {
    *this = ::std::move(from);
  }

  inline Call_GetContainers& operator=(Call_GetContainers&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Call_GetContainers& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Call_GetContainers* internal_default_instance() {
    return reinterpret_cast<const Call_GetContainers*>(
               &_Call_GetContainers_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(Call_GetContainers* other);
  friend void swap(Call_GetContainers& a, Call_GetContainers& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Call_GetContainers* New() const PROTOBUF_FINAL { return New(NULL); }

  Call_GetContainers* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Call_GetContainers& from);
  void MergeFrom(const Call_GetContainers& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Call_GetContainers* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool show_nested = 1;
  bool has_show_nested() const;
  void clear_show_nested();
  static const int kShowNestedFieldNumber = 1;
  bool show_nested() const;
  void set_show_nested(bool value);

  // optional bool show_standalone = 2;
  bool has_show_standalone() const;
  void clear_show_standalone();
  static const int kShowStandaloneFieldNumber = 2;
  bool show_standalone() const;
  void set_show_standalone(bool value);

  // @@protoc_insertion_point(class_scope:mesos.agent.Call.GetContainers)
 private:
  void set_has_show_nested();
  void clear_has_show_nested();
  void set_has_show_standalone();
  void clear_has_show_standalone();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  bool show_nested_;
  bool show_standalone_;
  friend struct ::protobuf_mesos_2fagent_2fagent_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fagent_2fagent_2eproto::InitDefaultsCall_GetContainersImpl();
};
// -------------------------------------------------------------------

class Call_LaunchNestedContainer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.agent.Call.LaunchNestedContainer) */ {
 public:
  Call_LaunchNestedContainer();
  virtual ~Call_LaunchNestedContainer();

  Call_LaunchNestedContainer(const Call_LaunchNestedContainer& from);

  inline Call_LaunchNestedContainer& operator=(const Call_LaunchNestedContainer& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Call_LaunchNestedContainer(Call_LaunchNestedContainer&& from) noexcept
    : Call_LaunchNestedContainer() {
    *this = ::std::move(from);
  }

  inline Call_LaunchNestedContainer& operator=(Call_LaunchNestedContainer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Call_LaunchNestedContainer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Call_LaunchNestedContainer* internal_default_instance() {
    return reinterpret_cast<const Call_LaunchNestedContainer*>(
               &_Call_LaunchNestedContainer_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(Call_LaunchNestedContainer* other);
  friend void swap(Call_LaunchNestedContainer& a, Call_LaunchNestedContainer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Call_LaunchNestedContainer* New() const PROTOBUF_FINAL { return New(NULL); }

  Call_LaunchNestedContainer* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Call_LaunchNestedContainer& from);
  void MergeFrom(const Call_LaunchNestedContainer& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Call_LaunchNestedContainer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.ContainerID container_id = 1;
  bool has_container_id() const;
  void clear_container_id();
  static const int kContainerIdFieldNumber = 1;
  const ::mesos::ContainerID& container_id() const;
  ::mesos::ContainerID* release_container_id();
  ::mesos::ContainerID* mutable_container_id();
  void set_allocated_container_id(::mesos::ContainerID* container_id);

  // optional .mesos.CommandInfo command = 2;
  bool has_command() const;
  void clear_command();
  static const int kCommandFieldNumber = 2;
  const ::mesos::CommandInfo& command() const;
  ::mesos::CommandInfo* release_command();
  ::mesos::CommandInfo* mutable_command();
  void set_allocated_command(::mesos::CommandInfo* command);

  // optional .mesos.ContainerInfo container = 3;
  bool has_container() const;
  void clear_container();
  static const int kContainerFieldNumber = 3;
  const ::mesos::ContainerInfo& container() const;
  ::mesos::ContainerInfo* release_container();
  ::mesos::ContainerInfo* mutable_container();
  void set_allocated_container(::mesos::ContainerInfo* container);

  // @@protoc_insertion_point(class_scope:mesos.agent.Call.LaunchNestedContainer)
 private:
  void set_has_container_id();
  void clear_has_container_id();
  void set_has_command();
  void clear_has_command();
  void set_has_container();
  void clear_has_container();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::ContainerID* container_id_;
  ::mesos::CommandInfo* command_;
  ::mesos::ContainerInfo* container_;
  friend struct ::protobuf_mesos_2fagent_2fagent_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fagent_2fagent_2eproto::InitDefaultsCall_LaunchNestedContainerImpl();
};
// -------------------------------------------------------------------

class Call_WaitNestedContainer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.agent.Call.WaitNestedContainer) */ {
 public:
  Call_WaitNestedContainer();
  virtual ~Call_WaitNestedContainer();

  Call_WaitNestedContainer(const Call_WaitNestedContainer& from);

  inline Call_WaitNestedContainer& operator=(const Call_WaitNestedContainer& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Call_WaitNestedContainer(Call_WaitNestedContainer&& from) noexcept
    : Call_WaitNestedContainer() {
    *this = ::std::move(from);
  }

  inline Call_WaitNestedContainer& operator=(Call_WaitNestedContainer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Call_WaitNestedContainer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Call_WaitNestedContainer* internal_default_instance() {
    return reinterpret_cast<const Call_WaitNestedContainer*>(
               &_Call_WaitNestedContainer_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(Call_WaitNestedContainer* other);
  friend void swap(Call_WaitNestedContainer& a, Call_WaitNestedContainer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Call_WaitNestedContainer* New() const PROTOBUF_FINAL { return New(NULL); }

  Call_WaitNestedContainer* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Call_WaitNestedContainer& from);
  void MergeFrom(const Call_WaitNestedContainer& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Call_WaitNestedContainer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.ContainerID container_id = 1;
  bool has_container_id() const;
  void clear_container_id();
  static const int kContainerIdFieldNumber = 1;
  const ::mesos::ContainerID& container_id() const;
  ::mesos::ContainerID* release_container_id();
  ::mesos::ContainerID* mutable_container_id();
  void set_allocated_container_id(::mesos::ContainerID* container_id);

  // @@protoc_insertion_point(class_scope:mesos.agent.Call.WaitNestedContainer)
 private:
  void set_has_container_id();
  void clear_has_container_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::ContainerID* container_id_;
  friend struct ::protobuf_mesos_2fagent_2fagent_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fagent_2fagent_2eproto::InitDefaultsCall_WaitNestedContainerImpl();
};
// -------------------------------------------------------------------

class Call_KillNestedContainer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.agent.Call.KillNestedContainer) */ {
 public:
  Call_KillNestedContainer();
  virtual ~Call_KillNestedContainer();

  Call_KillNestedContainer(const Call_KillNestedContainer& from);

  inline Call_KillNestedContainer& operator=(const Call_KillNestedContainer& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Call_KillNestedContainer(Call_KillNestedContainer&& from) noexcept
    : Call_KillNestedContainer() {
    *this = ::std::move(from);
  }

  inline Call_KillNestedContainer& operator=(Call_KillNestedContainer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Call_KillNestedContainer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Call_KillNestedContainer* internal_default_instance() {
    return reinterpret_cast<const Call_KillNestedContainer*>(
               &_Call_KillNestedContainer_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(Call_KillNestedContainer* other);
  friend void swap(Call_KillNestedContainer& a, Call_KillNestedContainer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Call_KillNestedContainer* New() const PROTOBUF_FINAL { return New(NULL); }

  Call_KillNestedContainer* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Call_KillNestedContainer& from);
  void MergeFrom(const Call_KillNestedContainer& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Call_KillNestedContainer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.ContainerID container_id = 1;
  bool has_container_id() const;
  void clear_container_id();
  static const int kContainerIdFieldNumber = 1;
  const ::mesos::ContainerID& container_id() const;
  ::mesos::ContainerID* release_container_id();
  ::mesos::ContainerID* mutable_container_id();
  void set_allocated_container_id(::mesos::ContainerID* container_id);

  // optional int32 signal = 2;
  bool has_signal() const;
  void clear_signal();
  static const int kSignalFieldNumber = 2;
  ::google::protobuf::int32 signal() const;
  void set_signal(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:mesos.agent.Call.KillNestedContainer)
 private:
  void set_has_container_id();
  void clear_has_container_id();
  void set_has_signal();
  void clear_has_signal();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::ContainerID* container_id_;
  ::google::protobuf::int32 signal_;
  friend struct ::protobuf_mesos_2fagent_2fagent_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fagent_2fagent_2eproto::InitDefaultsCall_KillNestedContainerImpl();
};
// -------------------------------------------------------------------

class Call_RemoveNestedContainer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.agent.Call.RemoveNestedContainer) */ {
 public:
  Call_RemoveNestedContainer();
  virtual ~Call_RemoveNestedContainer();

  Call_RemoveNestedContainer(const Call_RemoveNestedContainer& from);

  inline Call_RemoveNestedContainer& operator=(const Call_RemoveNestedContainer& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Call_RemoveNestedContainer(Call_RemoveNestedContainer&& from) noexcept
    : Call_RemoveNestedContainer() {
    *this = ::std::move(from);
  }

  inline Call_RemoveNestedContainer& operator=(Call_RemoveNestedContainer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Call_RemoveNestedContainer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Call_RemoveNestedContainer* internal_default_instance() {
    return reinterpret_cast<const Call_RemoveNestedContainer*>(
               &_Call_RemoveNestedContainer_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(Call_RemoveNestedContainer* other);
  friend void swap(Call_RemoveNestedContainer& a, Call_RemoveNestedContainer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Call_RemoveNestedContainer* New() const PROTOBUF_FINAL { return New(NULL); }

  Call_RemoveNestedContainer* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Call_RemoveNestedContainer& from);
  void MergeFrom(const Call_RemoveNestedContainer& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Call_RemoveNestedContainer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.ContainerID container_id = 1;
  bool has_container_id() const;
  void clear_container_id();
  static const int kContainerIdFieldNumber = 1;
  const ::mesos::ContainerID& container_id() const;
  ::mesos::ContainerID* release_container_id();
  ::mesos::ContainerID* mutable_container_id();
  void set_allocated_container_id(::mesos::ContainerID* container_id);

  // @@protoc_insertion_point(class_scope:mesos.agent.Call.RemoveNestedContainer)
 private:
  void set_has_container_id();
  void clear_has_container_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::ContainerID* container_id_;
  friend struct ::protobuf_mesos_2fagent_2fagent_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fagent_2fagent_2eproto::InitDefaultsCall_RemoveNestedContainerImpl();
};
// -------------------------------------------------------------------

class Call_LaunchNestedContainerSession : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.agent.Call.LaunchNestedContainerSession) */ {
 public:
  Call_LaunchNestedContainerSession();
  virtual ~Call_LaunchNestedContainerSession();

  Call_LaunchNestedContainerSession(const Call_LaunchNestedContainerSession& from);

  inline Call_LaunchNestedContainerSession& operator=(const Call_LaunchNestedContainerSession& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Call_LaunchNestedContainerSession(Call_LaunchNestedContainerSession&& from) noexcept
    : Call_LaunchNestedContainerSession() {
    *this = ::std::move(from);
  }

  inline Call_LaunchNestedContainerSession& operator=(Call_LaunchNestedContainerSession&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Call_LaunchNestedContainerSession& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Call_LaunchNestedContainerSession* internal_default_instance() {
    return reinterpret_cast<const Call_LaunchNestedContainerSession*>(
               &_Call_LaunchNestedContainerSession_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(Call_LaunchNestedContainerSession* other);
  friend void swap(Call_LaunchNestedContainerSession& a, Call_LaunchNestedContainerSession& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Call_LaunchNestedContainerSession* New() const PROTOBUF_FINAL { return New(NULL); }

  Call_LaunchNestedContainerSession* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Call_LaunchNestedContainerSession& from);
  void MergeFrom(const Call_LaunchNestedContainerSession& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Call_LaunchNestedContainerSession* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.ContainerID container_id = 1;
  bool has_container_id() const;
  void clear_container_id();
  static const int kContainerIdFieldNumber = 1;
  const ::mesos::ContainerID& container_id() const;
  ::mesos::ContainerID* release_container_id();
  ::mesos::ContainerID* mutable_container_id();
  void set_allocated_container_id(::mesos::ContainerID* container_id);

  // optional .mesos.CommandInfo command = 2;
  bool has_command() const;
  void clear_command();
  static const int kCommandFieldNumber = 2;
  const ::mesos::CommandInfo& command() const;
  ::mesos::CommandInfo* release_command();
  ::mesos::CommandInfo* mutable_command();
  void set_allocated_command(::mesos::CommandInfo* command);

  // optional .mesos.ContainerInfo container = 3;
  bool has_container() const;
  void clear_container();
  static const int kContainerFieldNumber = 3;
  const ::mesos::ContainerInfo& container() const;
  ::mesos::ContainerInfo* release_container();
  ::mesos::ContainerInfo* mutable_container();
  void set_allocated_container(::mesos::ContainerInfo* container);

  // @@protoc_insertion_point(class_scope:mesos.agent.Call.LaunchNestedContainerSession)
 private:
  void set_has_container_id();
  void clear_has_container_id();
  void set_has_command();
  void clear_has_command();
  void set_has_container();
  void clear_has_container();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::ContainerID* container_id_;
  ::mesos::CommandInfo* command_;
  ::mesos::ContainerInfo* container_;
  friend struct ::protobuf_mesos_2fagent_2fagent_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fagent_2fagent_2eproto::InitDefaultsCall_LaunchNestedContainerSessionImpl();
};
// -------------------------------------------------------------------

class Call_AttachContainerInput : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.agent.Call.AttachContainerInput) */ {
 public:
  Call_AttachContainerInput();
  virtual ~Call_AttachContainerInput();

  Call_AttachContainerInput(const Call_AttachContainerInput& from);

  inline Call_AttachContainerInput& operator=(const Call_AttachContainerInput& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Call_AttachContainerInput(Call_AttachContainerInput&& from) noexcept
    : Call_AttachContainerInput() {
    *this = ::std::move(from);
  }

  inline Call_AttachContainerInput& operator=(Call_AttachContainerInput&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Call_AttachContainerInput& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Call_AttachContainerInput* internal_default_instance() {
    return reinterpret_cast<const Call_AttachContainerInput*>(
               &_Call_AttachContainerInput_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(Call_AttachContainerInput* other);
  friend void swap(Call_AttachContainerInput& a, Call_AttachContainerInput& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Call_AttachContainerInput* New() const PROTOBUF_FINAL { return New(NULL); }

  Call_AttachContainerInput* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Call_AttachContainerInput& from);
  void MergeFrom(const Call_AttachContainerInput& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Call_AttachContainerInput* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Call_AttachContainerInput_Type Type;
  static const Type UNKNOWN =
    Call_AttachContainerInput_Type_UNKNOWN;
  static const Type CONTAINER_ID =
    Call_AttachContainerInput_Type_CONTAINER_ID;
  static const Type PROCESS_IO =
    Call_AttachContainerInput_Type_PROCESS_IO;
  static inline bool Type_IsValid(int value) {
    return Call_AttachContainerInput_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Call_AttachContainerInput_Type_Type_MIN;
  static const Type Type_MAX =
    Call_AttachContainerInput_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Call_AttachContainerInput_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Call_AttachContainerInput_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Call_AttachContainerInput_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Call_AttachContainerInput_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .mesos.ContainerID container_id = 2;
  bool has_container_id() const;
  void clear_container_id();
  static const int kContainerIdFieldNumber = 2;
  const ::mesos::ContainerID& container_id() const;
  ::mesos::ContainerID* release_container_id();
  ::mesos::ContainerID* mutable_container_id();
  void set_allocated_container_id(::mesos::ContainerID* container_id);

  // optional .mesos.agent.ProcessIO process_io = 3;
  bool has_process_io() const;
  void clear_process_io();
  static const int kProcessIoFieldNumber = 3;
  const ::mesos::agent::ProcessIO& process_io() const;
  ::mesos::agent::ProcessIO* release_process_io();
  ::mesos::agent::ProcessIO* mutable_process_io();
  void set_allocated_process_io(::mesos::agent::ProcessIO* process_io);

  // optional .mesos.agent.Call.AttachContainerInput.Type type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::mesos::agent::Call_AttachContainerInput_Type type() const;
  void set_type(::mesos::agent::Call_AttachContainerInput_Type value);

  // @@protoc_insertion_point(class_scope:mesos.agent.Call.AttachContainerInput)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_container_id();
  void clear_has_container_id();
  void set_has_process_io();
  void clear_has_process_io();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::ContainerID* container_id_;
  ::mesos::agent::ProcessIO* process_io_;
  int type_;
  friend struct ::protobuf_mesos_2fagent_2fagent_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fagent_2fagent_2eproto::InitDefaultsCall_AttachContainerInputImpl();
};
// -------------------------------------------------------------------

class Call_AttachContainerOutput : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.agent.Call.AttachContainerOutput) */ {
 public:
  Call_AttachContainerOutput();
  virtual ~Call_AttachContainerOutput();

  Call_AttachContainerOutput(const Call_AttachContainerOutput& from);

  inline Call_AttachContainerOutput& operator=(const Call_AttachContainerOutput& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Call_AttachContainerOutput(Call_AttachContainerOutput&& from) noexcept
    : Call_AttachContainerOutput() {
    *this = ::std::move(from);
  }

  inline Call_AttachContainerOutput& operator=(Call_AttachContainerOutput&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Call_AttachContainerOutput& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Call_AttachContainerOutput* internal_default_instance() {
    return reinterpret_cast<const Call_AttachContainerOutput*>(
               &_Call_AttachContainerOutput_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(Call_AttachContainerOutput* other);
  friend void swap(Call_AttachContainerOutput& a, Call_AttachContainerOutput& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Call_AttachContainerOutput* New() const PROTOBUF_FINAL { return New(NULL); }

  Call_AttachContainerOutput* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Call_AttachContainerOutput& from);
  void MergeFrom(const Call_AttachContainerOutput& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Call_AttachContainerOutput* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.ContainerID container_id = 1;
  bool has_container_id() const;
  void clear_container_id();
  static const int kContainerIdFieldNumber = 1;
  const ::mesos::ContainerID& container_id() const;
  ::mesos::ContainerID* release_container_id();
  ::mesos::ContainerID* mutable_container_id();
  void set_allocated_container_id(::mesos::ContainerID* container_id);

  // @@protoc_insertion_point(class_scope:mesos.agent.Call.AttachContainerOutput)
 private:
  void set_has_container_id();
  void clear_has_container_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::ContainerID* container_id_;
  friend struct ::protobuf_mesos_2fagent_2fagent_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fagent_2fagent_2eproto::InitDefaultsCall_AttachContainerOutputImpl();
};
// -------------------------------------------------------------------

class Call_LaunchContainer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.agent.Call.LaunchContainer) */ {
 public:
  Call_LaunchContainer();
  virtual ~Call_LaunchContainer();

  Call_LaunchContainer(const Call_LaunchContainer& from);

  inline Call_LaunchContainer& operator=(const Call_LaunchContainer& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Call_LaunchContainer(Call_LaunchContainer&& from) noexcept
    : Call_LaunchContainer() {
    *this = ::std::move(from);
  }

  inline Call_LaunchContainer& operator=(Call_LaunchContainer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Call_LaunchContainer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Call_LaunchContainer* internal_default_instance() {
    return reinterpret_cast<const Call_LaunchContainer*>(
               &_Call_LaunchContainer_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(Call_LaunchContainer* other);
  friend void swap(Call_LaunchContainer& a, Call_LaunchContainer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Call_LaunchContainer* New() const PROTOBUF_FINAL { return New(NULL); }

  Call_LaunchContainer* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Call_LaunchContainer& from);
  void MergeFrom(const Call_LaunchContainer& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Call_LaunchContainer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.Resource resources = 3;
  int resources_size() const;
  void clear_resources();
  static const int kResourcesFieldNumber = 3;
  const ::mesos::Resource& resources(int index) const;
  ::mesos::Resource* mutable_resources(int index);
  ::mesos::Resource* add_resources();
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
      mutable_resources();
  const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
      resources() const;

  // required .mesos.ContainerID container_id = 1;
  bool has_container_id() const;
  void clear_container_id();
  static const int kContainerIdFieldNumber = 1;
  const ::mesos::ContainerID& container_id() const;
  ::mesos::ContainerID* release_container_id();
  ::mesos::ContainerID* mutable_container_id();
  void set_allocated_container_id(::mesos::ContainerID* container_id);

  // optional .mesos.CommandInfo command = 2;
  bool has_command() const;
  void clear_command();
  static const int kCommandFieldNumber = 2;
  const ::mesos::CommandInfo& command() const;
  ::mesos::CommandInfo* release_command();
  ::mesos::CommandInfo* mutable_command();
  void set_allocated_command(::mesos::CommandInfo* command);

  // optional .mesos.ContainerInfo container = 4;
  bool has_container() const;
  void clear_container();
  static const int kContainerFieldNumber = 4;
  const ::mesos::ContainerInfo& container() const;
  ::mesos::ContainerInfo* release_container();
  ::mesos::ContainerInfo* mutable_container();
  void set_allocated_container(::mesos::ContainerInfo* container);

  // @@protoc_insertion_point(class_scope:mesos.agent.Call.LaunchContainer)
 private:
  void set_has_container_id();
  void clear_has_container_id();
  void set_has_command();
  void clear_has_command();
  void set_has_container();
  void clear_has_container();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource > resources_;
  ::mesos::ContainerID* container_id_;
  ::mesos::CommandInfo* command_;
  ::mesos::ContainerInfo* container_;
  friend struct ::protobuf_mesos_2fagent_2fagent_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fagent_2fagent_2eproto::InitDefaultsCall_LaunchContainerImpl();
};
// -------------------------------------------------------------------

class Call_WaitContainer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.agent.Call.WaitContainer) */ {
 public:
  Call_WaitContainer();
  virtual ~Call_WaitContainer();

  Call_WaitContainer(const Call_WaitContainer& from);

  inline Call_WaitContainer& operator=(const Call_WaitContainer& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Call_WaitContainer(Call_WaitContainer&& from) noexcept
    : Call_WaitContainer() {
    *this = ::std::move(from);
  }

  inline Call_WaitContainer& operator=(Call_WaitContainer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Call_WaitContainer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Call_WaitContainer* internal_default_instance() {
    return reinterpret_cast<const Call_WaitContainer*>(
               &_Call_WaitContainer_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(Call_WaitContainer* other);
  friend void swap(Call_WaitContainer& a, Call_WaitContainer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Call_WaitContainer* New() const PROTOBUF_FINAL { return New(NULL); }

  Call_WaitContainer* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Call_WaitContainer& from);
  void MergeFrom(const Call_WaitContainer& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Call_WaitContainer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.ContainerID container_id = 1;
  bool has_container_id() const;
  void clear_container_id();
  static const int kContainerIdFieldNumber = 1;
  const ::mesos::ContainerID& container_id() const;
  ::mesos::ContainerID* release_container_id();
  ::mesos::ContainerID* mutable_container_id();
  void set_allocated_container_id(::mesos::ContainerID* container_id);

  // @@protoc_insertion_point(class_scope:mesos.agent.Call.WaitContainer)
 private:
  void set_has_container_id();
  void clear_has_container_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::ContainerID* container_id_;
  friend struct ::protobuf_mesos_2fagent_2fagent_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fagent_2fagent_2eproto::InitDefaultsCall_WaitContainerImpl();
};
// -------------------------------------------------------------------

class Call_KillContainer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.agent.Call.KillContainer) */ {
 public:
  Call_KillContainer();
  virtual ~Call_KillContainer();

  Call_KillContainer(const Call_KillContainer& from);

  inline Call_KillContainer& operator=(const Call_KillContainer& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Call_KillContainer(Call_KillContainer&& from) noexcept
    : Call_KillContainer() {
    *this = ::std::move(from);
  }

  inline Call_KillContainer& operator=(Call_KillContainer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Call_KillContainer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Call_KillContainer* internal_default_instance() {
    return reinterpret_cast<const Call_KillContainer*>(
               &_Call_KillContainer_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    14;

  void Swap(Call_KillContainer* other);
  friend void swap(Call_KillContainer& a, Call_KillContainer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Call_KillContainer* New() const PROTOBUF_FINAL { return New(NULL); }

  Call_KillContainer* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Call_KillContainer& from);
  void MergeFrom(const Call_KillContainer& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Call_KillContainer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.ContainerID container_id = 1;
  bool has_container_id() const;
  void clear_container_id();
  static const int kContainerIdFieldNumber = 1;
  const ::mesos::ContainerID& container_id() const;
  ::mesos::ContainerID* release_container_id();
  ::mesos::ContainerID* mutable_container_id();
  void set_allocated_container_id(::mesos::ContainerID* container_id);

  // optional int32 signal = 2;
  bool has_signal() const;
  void clear_signal();
  static const int kSignalFieldNumber = 2;
  ::google::protobuf::int32 signal() const;
  void set_signal(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:mesos.agent.Call.KillContainer)
 private:
  void set_has_container_id();
  void clear_has_container_id();
  void set_has_signal();
  void clear_has_signal();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::ContainerID* container_id_;
  ::google::protobuf::int32 signal_;
  friend struct ::protobuf_mesos_2fagent_2fagent_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fagent_2fagent_2eproto::InitDefaultsCall_KillContainerImpl();
};
// -------------------------------------------------------------------

class Call_RemoveContainer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.agent.Call.RemoveContainer) */ {
 public:
  Call_RemoveContainer();
  virtual ~Call_RemoveContainer();

  Call_RemoveContainer(const Call_RemoveContainer& from);

  inline Call_RemoveContainer& operator=(const Call_RemoveContainer& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Call_RemoveContainer(Call_RemoveContainer&& from) noexcept
    : Call_RemoveContainer() {
    *this = ::std::move(from);
  }

  inline Call_RemoveContainer& operator=(Call_RemoveContainer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Call_RemoveContainer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Call_RemoveContainer* internal_default_instance() {
    return reinterpret_cast<const Call_RemoveContainer*>(
               &_Call_RemoveContainer_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    15;

  void Swap(Call_RemoveContainer* other);
  friend void swap(Call_RemoveContainer& a, Call_RemoveContainer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Call_RemoveContainer* New() const PROTOBUF_FINAL { return New(NULL); }

  Call_RemoveContainer* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Call_RemoveContainer& from);
  void MergeFrom(const Call_RemoveContainer& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Call_RemoveContainer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.ContainerID container_id = 1;
  bool has_container_id() const;
  void clear_container_id();
  static const int kContainerIdFieldNumber = 1;
  const ::mesos::ContainerID& container_id() const;
  ::mesos::ContainerID* release_container_id();
  ::mesos::ContainerID* mutable_container_id();
  void set_allocated_container_id(::mesos::ContainerID* container_id);

  // @@protoc_insertion_point(class_scope:mesos.agent.Call.RemoveContainer)
 private:
  void set_has_container_id();
  void clear_has_container_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::ContainerID* container_id_;
  friend struct ::protobuf_mesos_2fagent_2fagent_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fagent_2fagent_2eproto::InitDefaultsCall_RemoveContainerImpl();
};
// -------------------------------------------------------------------

class Call_AddResourceProviderConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.agent.Call.AddResourceProviderConfig) */ {
 public:
  Call_AddResourceProviderConfig();
  virtual ~Call_AddResourceProviderConfig();

  Call_AddResourceProviderConfig(const Call_AddResourceProviderConfig& from);

  inline Call_AddResourceProviderConfig& operator=(const Call_AddResourceProviderConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Call_AddResourceProviderConfig(Call_AddResourceProviderConfig&& from) noexcept
    : Call_AddResourceProviderConfig() {
    *this = ::std::move(from);
  }

  inline Call_AddResourceProviderConfig& operator=(Call_AddResourceProviderConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Call_AddResourceProviderConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Call_AddResourceProviderConfig* internal_default_instance() {
    return reinterpret_cast<const Call_AddResourceProviderConfig*>(
               &_Call_AddResourceProviderConfig_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    16;

  void Swap(Call_AddResourceProviderConfig* other);
  friend void swap(Call_AddResourceProviderConfig& a, Call_AddResourceProviderConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Call_AddResourceProviderConfig* New() const PROTOBUF_FINAL { return New(NULL); }

  Call_AddResourceProviderConfig* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Call_AddResourceProviderConfig& from);
  void MergeFrom(const Call_AddResourceProviderConfig& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Call_AddResourceProviderConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.ResourceProviderInfo info = 1;
  bool has_info() const;
  void clear_info();
  static const int kInfoFieldNumber = 1;
  const ::mesos::ResourceProviderInfo& info() const;
  ::mesos::ResourceProviderInfo* release_info();
  ::mesos::ResourceProviderInfo* mutable_info();
  void set_allocated_info(::mesos::ResourceProviderInfo* info);

  // @@protoc_insertion_point(class_scope:mesos.agent.Call.AddResourceProviderConfig)
 private:
  void set_has_info();
  void clear_has_info();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::ResourceProviderInfo* info_;
  friend struct ::protobuf_mesos_2fagent_2fagent_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fagent_2fagent_2eproto::InitDefaultsCall_AddResourceProviderConfigImpl();
};
// -------------------------------------------------------------------

class Call_UpdateResourceProviderConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.agent.Call.UpdateResourceProviderConfig) */ {
 public:
  Call_UpdateResourceProviderConfig();
  virtual ~Call_UpdateResourceProviderConfig();

  Call_UpdateResourceProviderConfig(const Call_UpdateResourceProviderConfig& from);

  inline Call_UpdateResourceProviderConfig& operator=(const Call_UpdateResourceProviderConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Call_UpdateResourceProviderConfig(Call_UpdateResourceProviderConfig&& from) noexcept
    : Call_UpdateResourceProviderConfig() {
    *this = ::std::move(from);
  }

  inline Call_UpdateResourceProviderConfig& operator=(Call_UpdateResourceProviderConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Call_UpdateResourceProviderConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Call_UpdateResourceProviderConfig* internal_default_instance() {
    return reinterpret_cast<const Call_UpdateResourceProviderConfig*>(
               &_Call_UpdateResourceProviderConfig_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    17;

  void Swap(Call_UpdateResourceProviderConfig* other);
  friend void swap(Call_UpdateResourceProviderConfig& a, Call_UpdateResourceProviderConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Call_UpdateResourceProviderConfig* New() const PROTOBUF_FINAL { return New(NULL); }

  Call_UpdateResourceProviderConfig* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Call_UpdateResourceProviderConfig& from);
  void MergeFrom(const Call_UpdateResourceProviderConfig& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Call_UpdateResourceProviderConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.ResourceProviderInfo info = 1;
  bool has_info() const;
  void clear_info();
  static const int kInfoFieldNumber = 1;
  const ::mesos::ResourceProviderInfo& info() const;
  ::mesos::ResourceProviderInfo* release_info();
  ::mesos::ResourceProviderInfo* mutable_info();
  void set_allocated_info(::mesos::ResourceProviderInfo* info);

  // @@protoc_insertion_point(class_scope:mesos.agent.Call.UpdateResourceProviderConfig)
 private:
  void set_has_info();
  void clear_has_info();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::ResourceProviderInfo* info_;
  friend struct ::protobuf_mesos_2fagent_2fagent_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fagent_2fagent_2eproto::InitDefaultsCall_UpdateResourceProviderConfigImpl();
};
// -------------------------------------------------------------------

class Call_RemoveResourceProviderConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.agent.Call.RemoveResourceProviderConfig) */ {
 public:
  Call_RemoveResourceProviderConfig();
  virtual ~Call_RemoveResourceProviderConfig();

  Call_RemoveResourceProviderConfig(const Call_RemoveResourceProviderConfig& from);

  inline Call_RemoveResourceProviderConfig& operator=(const Call_RemoveResourceProviderConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Call_RemoveResourceProviderConfig(Call_RemoveResourceProviderConfig&& from) noexcept
    : Call_RemoveResourceProviderConfig() {
    *this = ::std::move(from);
  }

  inline Call_RemoveResourceProviderConfig& operator=(Call_RemoveResourceProviderConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Call_RemoveResourceProviderConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Call_RemoveResourceProviderConfig* internal_default_instance() {
    return reinterpret_cast<const Call_RemoveResourceProviderConfig*>(
               &_Call_RemoveResourceProviderConfig_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    18;

  void Swap(Call_RemoveResourceProviderConfig* other);
  friend void swap(Call_RemoveResourceProviderConfig& a, Call_RemoveResourceProviderConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Call_RemoveResourceProviderConfig* New() const PROTOBUF_FINAL { return New(NULL); }

  Call_RemoveResourceProviderConfig* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Call_RemoveResourceProviderConfig& from);
  void MergeFrom(const Call_RemoveResourceProviderConfig& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Call_RemoveResourceProviderConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // required string name = 2;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:mesos.agent.Call.RemoveResourceProviderConfig)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_name();
  void clear_has_name();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  friend struct ::protobuf_mesos_2fagent_2fagent_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fagent_2fagent_2eproto::InitDefaultsCall_RemoveResourceProviderConfigImpl();
};
// -------------------------------------------------------------------

class Call_PruneImages : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.agent.Call.PruneImages) */ {
 public:
  Call_PruneImages();
  virtual ~Call_PruneImages();

  Call_PruneImages(const Call_PruneImages& from);

  inline Call_PruneImages& operator=(const Call_PruneImages& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Call_PruneImages(Call_PruneImages&& from) noexcept
    : Call_PruneImages() {
    *this = ::std::move(from);
  }

  inline Call_PruneImages& operator=(Call_PruneImages&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Call_PruneImages& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Call_PruneImages* internal_default_instance() {
    return reinterpret_cast<const Call_PruneImages*>(
               &_Call_PruneImages_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    19;

  void Swap(Call_PruneImages* other);
  friend void swap(Call_PruneImages& a, Call_PruneImages& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Call_PruneImages* New() const PROTOBUF_FINAL { return New(NULL); }

  Call_PruneImages* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Call_PruneImages& from);
  void MergeFrom(const Call_PruneImages& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Call_PruneImages* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.Image excluded_images = 1;
  int excluded_images_size() const;
  void clear_excluded_images();
  static const int kExcludedImagesFieldNumber = 1;
  const ::mesos::Image& excluded_images(int index) const;
  ::mesos::Image* mutable_excluded_images(int index);
  ::mesos::Image* add_excluded_images();
  ::google::protobuf::RepeatedPtrField< ::mesos::Image >*
      mutable_excluded_images();
  const ::google::protobuf::RepeatedPtrField< ::mesos::Image >&
      excluded_images() const;

  // @@protoc_insertion_point(class_scope:mesos.agent.Call.PruneImages)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Image > excluded_images_;
  friend struct ::protobuf_mesos_2fagent_2fagent_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fagent_2fagent_2eproto::InitDefaultsCall_PruneImagesImpl();
};
// -------------------------------------------------------------------

class Call : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.agent.Call) */ {
 public:
  Call();
  virtual ~Call();

  Call(const Call& from);

  inline Call& operator=(const Call& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Call(Call&& from) noexcept
    : Call() {
    *this = ::std::move(from);
  }

  inline Call& operator=(Call&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Call& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Call* internal_default_instance() {
    return reinterpret_cast<const Call*>(
               &_Call_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    20;

  void Swap(Call* other);
  friend void swap(Call& a, Call& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Call* New() const PROTOBUF_FINAL { return New(NULL); }

  Call* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Call& from);
  void MergeFrom(const Call& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Call* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Call_GetMetrics GetMetrics;
  typedef Call_SetLoggingLevel SetLoggingLevel;
  typedef Call_ListFiles ListFiles;
  typedef Call_ReadFile ReadFile;
  typedef Call_GetContainers GetContainers;
  typedef Call_LaunchNestedContainer LaunchNestedContainer;
  typedef Call_WaitNestedContainer WaitNestedContainer;
  typedef Call_KillNestedContainer KillNestedContainer;
  typedef Call_RemoveNestedContainer RemoveNestedContainer;
  typedef Call_LaunchNestedContainerSession LaunchNestedContainerSession;
  typedef Call_AttachContainerInput AttachContainerInput;
  typedef Call_AttachContainerOutput AttachContainerOutput;
  typedef Call_LaunchContainer LaunchContainer;
  typedef Call_WaitContainer WaitContainer;
  typedef Call_KillContainer KillContainer;
  typedef Call_RemoveContainer RemoveContainer;
  typedef Call_AddResourceProviderConfig AddResourceProviderConfig;
  typedef Call_UpdateResourceProviderConfig UpdateResourceProviderConfig;
  typedef Call_RemoveResourceProviderConfig RemoveResourceProviderConfig;
  typedef Call_PruneImages PruneImages;

  typedef Call_Type Type;
  static const Type UNKNOWN =
    Call_Type_UNKNOWN;
  static const Type GET_HEALTH =
    Call_Type_GET_HEALTH;
  static const Type GET_FLAGS =
    Call_Type_GET_FLAGS;
  static const Type GET_VERSION =
    Call_Type_GET_VERSION;
  static const Type GET_METRICS =
    Call_Type_GET_METRICS;
  static const Type GET_LOGGING_LEVEL =
    Call_Type_GET_LOGGING_LEVEL;
  static const Type SET_LOGGING_LEVEL =
    Call_Type_SET_LOGGING_LEVEL;
  static const Type LIST_FILES =
    Call_Type_LIST_FILES;
  static const Type READ_FILE =
    Call_Type_READ_FILE;
  static const Type GET_STATE =
    Call_Type_GET_STATE;
  static const Type GET_CONTAINERS =
    Call_Type_GET_CONTAINERS;
  static const Type GET_FRAMEWORKS =
    Call_Type_GET_FRAMEWORKS;
  static const Type GET_EXECUTORS =
    Call_Type_GET_EXECUTORS;
  static const Type GET_OPERATIONS =
    Call_Type_GET_OPERATIONS;
  static const Type GET_TASKS =
    Call_Type_GET_TASKS;
  static const Type GET_AGENT =
    Call_Type_GET_AGENT;
  static const Type GET_RESOURCE_PROVIDERS =
    Call_Type_GET_RESOURCE_PROVIDERS;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR static const Type LAUNCH_NESTED_CONTAINER =
    Call_Type_LAUNCH_NESTED_CONTAINER;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR static const Type WAIT_NESTED_CONTAINER =
    Call_Type_WAIT_NESTED_CONTAINER;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR static const Type KILL_NESTED_CONTAINER =
    Call_Type_KILL_NESTED_CONTAINER;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR static const Type REMOVE_NESTED_CONTAINER =
    Call_Type_REMOVE_NESTED_CONTAINER;
  static const Type LAUNCH_NESTED_CONTAINER_SESSION =
    Call_Type_LAUNCH_NESTED_CONTAINER_SESSION;
  static const Type ATTACH_CONTAINER_INPUT =
    Call_Type_ATTACH_CONTAINER_INPUT;
  static const Type ATTACH_CONTAINER_OUTPUT =
    Call_Type_ATTACH_CONTAINER_OUTPUT;
  static const Type LAUNCH_CONTAINER =
    Call_Type_LAUNCH_CONTAINER;
  static const Type WAIT_CONTAINER =
    Call_Type_WAIT_CONTAINER;
  static const Type KILL_CONTAINER =
    Call_Type_KILL_CONTAINER;
  static const Type REMOVE_CONTAINER =
    Call_Type_REMOVE_CONTAINER;
  static const Type ADD_RESOURCE_PROVIDER_CONFIG =
    Call_Type_ADD_RESOURCE_PROVIDER_CONFIG;
  static const Type UPDATE_RESOURCE_PROVIDER_CONFIG =
    Call_Type_UPDATE_RESOURCE_PROVIDER_CONFIG;
  static const Type REMOVE_RESOURCE_PROVIDER_CONFIG =
    Call_Type_REMOVE_RESOURCE_PROVIDER_CONFIG;
  static const Type PRUNE_IMAGES =
    Call_Type_PRUNE_IMAGES;
  static inline bool Type_IsValid(int value) {
    return Call_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Call_Type_Type_MIN;
  static const Type Type_MAX =
    Call_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Call_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Call_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Call_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Call_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .mesos.agent.Call.GetMetrics get_metrics = 2;
  bool has_get_metrics() const;
  void clear_get_metrics();
  static const int kGetMetricsFieldNumber = 2;
  const ::mesos::agent::Call_GetMetrics& get_metrics() const;
  ::mesos::agent::Call_GetMetrics* release_get_metrics();
  ::mesos::agent::Call_GetMetrics* mutable_get_metrics();
  void set_allocated_get_metrics(::mesos::agent::Call_GetMetrics* get_metrics);

  // optional .mesos.agent.Call.SetLoggingLevel set_logging_level = 3;
  bool has_set_logging_level() const;
  void clear_set_logging_level();
  static const int kSetLoggingLevelFieldNumber = 3;
  const ::mesos::agent::Call_SetLoggingLevel& set_logging_level() const;
  ::mesos::agent::Call_SetLoggingLevel* release_set_logging_level();
  ::mesos::agent::Call_SetLoggingLevel* mutable_set_logging_level();
  void set_allocated_set_logging_level(::mesos::agent::Call_SetLoggingLevel* set_logging_level);

  // optional .mesos.agent.Call.ListFiles list_files = 4;
  bool has_list_files() const;
  void clear_list_files();
  static const int kListFilesFieldNumber = 4;
  const ::mesos::agent::Call_ListFiles& list_files() const;
  ::mesos::agent::Call_ListFiles* release_list_files();
  ::mesos::agent::Call_ListFiles* mutable_list_files();
  void set_allocated_list_files(::mesos::agent::Call_ListFiles* list_files);

  // optional .mesos.agent.Call.ReadFile read_file = 5;
  bool has_read_file() const;
  void clear_read_file();
  static const int kReadFileFieldNumber = 5;
  const ::mesos::agent::Call_ReadFile& read_file() const;
  ::mesos::agent::Call_ReadFile* release_read_file();
  ::mesos::agent::Call_ReadFile* mutable_read_file();
  void set_allocated_read_file(::mesos::agent::Call_ReadFile* read_file);

  // optional .mesos.agent.Call.LaunchNestedContainer launch_nested_container = 6 [deprecated = true];
  GOOGLE_PROTOBUF_DEPRECATED_ATTR bool has_launch_nested_container() const;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void clear_launch_nested_container();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR static const int kLaunchNestedContainerFieldNumber = 6;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR const ::mesos::agent::Call_LaunchNestedContainer& launch_nested_container() const;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR ::mesos::agent::Call_LaunchNestedContainer* release_launch_nested_container();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR ::mesos::agent::Call_LaunchNestedContainer* mutable_launch_nested_container();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void set_allocated_launch_nested_container(::mesos::agent::Call_LaunchNestedContainer* launch_nested_container);

  // optional .mesos.agent.Call.WaitNestedContainer wait_nested_container = 7 [deprecated = true];
  GOOGLE_PROTOBUF_DEPRECATED_ATTR bool has_wait_nested_container() const;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void clear_wait_nested_container();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR static const int kWaitNestedContainerFieldNumber = 7;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR const ::mesos::agent::Call_WaitNestedContainer& wait_nested_container() const;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR ::mesos::agent::Call_WaitNestedContainer* release_wait_nested_container();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR ::mesos::agent::Call_WaitNestedContainer* mutable_wait_nested_container();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void set_allocated_wait_nested_container(::mesos::agent::Call_WaitNestedContainer* wait_nested_container);

  // optional .mesos.agent.Call.KillNestedContainer kill_nested_container = 8 [deprecated = true];
  GOOGLE_PROTOBUF_DEPRECATED_ATTR bool has_kill_nested_container() const;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void clear_kill_nested_container();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR static const int kKillNestedContainerFieldNumber = 8;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR const ::mesos::agent::Call_KillNestedContainer& kill_nested_container() const;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR ::mesos::agent::Call_KillNestedContainer* release_kill_nested_container();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR ::mesos::agent::Call_KillNestedContainer* mutable_kill_nested_container();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void set_allocated_kill_nested_container(::mesos::agent::Call_KillNestedContainer* kill_nested_container);

  // optional .mesos.agent.Call.LaunchNestedContainerSession launch_nested_container_session = 9;
  bool has_launch_nested_container_session() const;
  void clear_launch_nested_container_session();
  static const int kLaunchNestedContainerSessionFieldNumber = 9;
  const ::mesos::agent::Call_LaunchNestedContainerSession& launch_nested_container_session() const;
  ::mesos::agent::Call_LaunchNestedContainerSession* release_launch_nested_container_session();
  ::mesos::agent::Call_LaunchNestedContainerSession* mutable_launch_nested_container_session();
  void set_allocated_launch_nested_container_session(::mesos::agent::Call_LaunchNestedContainerSession* launch_nested_container_session);

  // optional .mesos.agent.Call.AttachContainerInput attach_container_input = 10;
  bool has_attach_container_input() const;
  void clear_attach_container_input();
  static const int kAttachContainerInputFieldNumber = 10;
  const ::mesos::agent::Call_AttachContainerInput& attach_container_input() const;
  ::mesos::agent::Call_AttachContainerInput* release_attach_container_input();
  ::mesos::agent::Call_AttachContainerInput* mutable_attach_container_input();
  void set_allocated_attach_container_input(::mesos::agent::Call_AttachContainerInput* attach_container_input);

  // optional .mesos.agent.Call.AttachContainerOutput attach_container_output = 11;
  bool has_attach_container_output() const;
  void clear_attach_container_output();
  static const int kAttachContainerOutputFieldNumber = 11;
  const ::mesos::agent::Call_AttachContainerOutput& attach_container_output() const;
  ::mesos::agent::Call_AttachContainerOutput* release_attach_container_output();
  ::mesos::agent::Call_AttachContainerOutput* mutable_attach_container_output();
  void set_allocated_attach_container_output(::mesos::agent::Call_AttachContainerOutput* attach_container_output);

  // optional .mesos.agent.Call.RemoveNestedContainer remove_nested_container = 12 [deprecated = true];
  GOOGLE_PROTOBUF_DEPRECATED_ATTR bool has_remove_nested_container() const;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void clear_remove_nested_container();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR static const int kRemoveNestedContainerFieldNumber = 12;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR const ::mesos::agent::Call_RemoveNestedContainer& remove_nested_container() const;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR ::mesos::agent::Call_RemoveNestedContainer* release_remove_nested_container();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR ::mesos::agent::Call_RemoveNestedContainer* mutable_remove_nested_container();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void set_allocated_remove_nested_container(::mesos::agent::Call_RemoveNestedContainer* remove_nested_container);

  // optional .mesos.agent.Call.LaunchContainer launch_container = 13;
  bool has_launch_container() const;
  void clear_launch_container();
  static const int kLaunchContainerFieldNumber = 13;
  const ::mesos::agent::Call_LaunchContainer& launch_container() const;
  ::mesos::agent::Call_LaunchContainer* release_launch_container();
  ::mesos::agent::Call_LaunchContainer* mutable_launch_container();
  void set_allocated_launch_container(::mesos::agent::Call_LaunchContainer* launch_container);

  // optional .mesos.agent.Call.WaitContainer wait_container = 14;
  bool has_wait_container() const;
  void clear_wait_container();
  static const int kWaitContainerFieldNumber = 14;
  const ::mesos::agent::Call_WaitContainer& wait_container() const;
  ::mesos::agent::Call_WaitContainer* release_wait_container();
  ::mesos::agent::Call_WaitContainer* mutable_wait_container();
  void set_allocated_wait_container(::mesos::agent::Call_WaitContainer* wait_container);

  // optional .mesos.agent.Call.KillContainer kill_container = 15;
  bool has_kill_container() const;
  void clear_kill_container();
  static const int kKillContainerFieldNumber = 15;
  const ::mesos::agent::Call_KillContainer& kill_container() const;
  ::mesos::agent::Call_KillContainer* release_kill_container();
  ::mesos::agent::Call_KillContainer* mutable_kill_container();
  void set_allocated_kill_container(::mesos::agent::Call_KillContainer* kill_container);

  // optional .mesos.agent.Call.RemoveContainer remove_container = 16;
  bool has_remove_container() const;
  void clear_remove_container();
  static const int kRemoveContainerFieldNumber = 16;
  const ::mesos::agent::Call_RemoveContainer& remove_container() const;
  ::mesos::agent::Call_RemoveContainer* release_remove_container();
  ::mesos::agent::Call_RemoveContainer* mutable_remove_container();
  void set_allocated_remove_container(::mesos::agent::Call_RemoveContainer* remove_container);

  // optional .mesos.agent.Call.AddResourceProviderConfig add_resource_provider_config = 17;
  bool has_add_resource_provider_config() const;
  void clear_add_resource_provider_config();
  static const int kAddResourceProviderConfigFieldNumber = 17;
  const ::mesos::agent::Call_AddResourceProviderConfig& add_resource_provider_config() const;
  ::mesos::agent::Call_AddResourceProviderConfig* release_add_resource_provider_config();
  ::mesos::agent::Call_AddResourceProviderConfig* mutable_add_resource_provider_config();
  void set_allocated_add_resource_provider_config(::mesos::agent::Call_AddResourceProviderConfig* add_resource_provider_config);

  // optional .mesos.agent.Call.UpdateResourceProviderConfig update_resource_provider_config = 18;
  bool has_update_resource_provider_config() const;
  void clear_update_resource_provider_config();
  static const int kUpdateResourceProviderConfigFieldNumber = 18;
  const ::mesos::agent::Call_UpdateResourceProviderConfig& update_resource_provider_config() const;
  ::mesos::agent::Call_UpdateResourceProviderConfig* release_update_resource_provider_config();
  ::mesos::agent::Call_UpdateResourceProviderConfig* mutable_update_resource_provider_config();
  void set_allocated_update_resource_provider_config(::mesos::agent::Call_UpdateResourceProviderConfig* update_resource_provider_config);

  // optional .mesos.agent.Call.RemoveResourceProviderConfig remove_resource_provider_config = 19;
  bool has_remove_resource_provider_config() const;
  void clear_remove_resource_provider_config();
  static const int kRemoveResourceProviderConfigFieldNumber = 19;
  const ::mesos::agent::Call_RemoveResourceProviderConfig& remove_resource_provider_config() const;
  ::mesos::agent::Call_RemoveResourceProviderConfig* release_remove_resource_provider_config();
  ::mesos::agent::Call_RemoveResourceProviderConfig* mutable_remove_resource_provider_config();
  void set_allocated_remove_resource_provider_config(::mesos::agent::Call_RemoveResourceProviderConfig* remove_resource_provider_config);

  // optional .mesos.agent.Call.GetContainers get_containers = 20;
  bool has_get_containers() const;
  void clear_get_containers();
  static const int kGetContainersFieldNumber = 20;
  const ::mesos::agent::Call_GetContainers& get_containers() const;
  ::mesos::agent::Call_GetContainers* release_get_containers();
  ::mesos::agent::Call_GetContainers* mutable_get_containers();
  void set_allocated_get_containers(::mesos::agent::Call_GetContainers* get_containers);

  // optional .mesos.agent.Call.PruneImages prune_images = 21;
  bool has_prune_images() const;
  void clear_prune_images();
  static const int kPruneImagesFieldNumber = 21;
  const ::mesos::agent::Call_PruneImages& prune_images() const;
  ::mesos::agent::Call_PruneImages* release_prune_images();
  ::mesos::agent::Call_PruneImages* mutable_prune_images();
  void set_allocated_prune_images(::mesos::agent::Call_PruneImages* prune_images);

  // optional .mesos.agent.Call.Type type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::mesos::agent::Call_Type type() const;
  void set_type(::mesos::agent::Call_Type value);

  // @@protoc_insertion_point(class_scope:mesos.agent.Call)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_get_metrics();
  void clear_has_get_metrics();
  void set_has_set_logging_level();
  void clear_has_set_logging_level();
  void set_has_list_files();
  void clear_has_list_files();
  void set_has_read_file();
  void clear_has_read_file();
  void set_has_get_containers();
  void clear_has_get_containers();
  void set_has_launch_nested_container();
  void clear_has_launch_nested_container();
  void set_has_wait_nested_container();
  void clear_has_wait_nested_container();
  void set_has_kill_nested_container();
  void clear_has_kill_nested_container();
  void set_has_remove_nested_container();
  void clear_has_remove_nested_container();
  void set_has_launch_nested_container_session();
  void clear_has_launch_nested_container_session();
  void set_has_attach_container_input();
  void clear_has_attach_container_input();
  void set_has_attach_container_output();
  void clear_has_attach_container_output();
  void set_has_launch_container();
  void clear_has_launch_container();
  void set_has_wait_container();
  void clear_has_wait_container();
  void set_has_kill_container();
  void clear_has_kill_container();
  void set_has_remove_container();
  void clear_has_remove_container();
  void set_has_add_resource_provider_config();
  void clear_has_add_resource_provider_config();
  void set_has_update_resource_provider_config();
  void clear_has_update_resource_provider_config();
  void set_has_remove_resource_provider_config();
  void clear_has_remove_resource_provider_config();
  void set_has_prune_images();
  void clear_has_prune_images();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::agent::Call_GetMetrics* get_metrics_;
  ::mesos::agent::Call_SetLoggingLevel* set_logging_level_;
  ::mesos::agent::Call_ListFiles* list_files_;
  ::mesos::agent::Call_ReadFile* read_file_;
  ::mesos::agent::Call_LaunchNestedContainer* launch_nested_container_;
  ::mesos::agent::Call_WaitNestedContainer* wait_nested_container_;
  ::mesos::agent::Call_KillNestedContainer* kill_nested_container_;
  ::mesos::agent::Call_LaunchNestedContainerSession* launch_nested_container_session_;
  ::mesos::agent::Call_AttachContainerInput* attach_container_input_;
  ::mesos::agent::Call_AttachContainerOutput* attach_container_output_;
  ::mesos::agent::Call_RemoveNestedContainer* remove_nested_container_;
  ::mesos::agent::Call_LaunchContainer* launch_container_;
  ::mesos::agent::Call_WaitContainer* wait_container_;
  ::mesos::agent::Call_KillContainer* kill_container_;
  ::mesos::agent::Call_RemoveContainer* remove_container_;
  ::mesos::agent::Call_AddResourceProviderConfig* add_resource_provider_config_;
  ::mesos::agent::Call_UpdateResourceProviderConfig* update_resource_provider_config_;
  ::mesos::agent::Call_RemoveResourceProviderConfig* remove_resource_provider_config_;
  ::mesos::agent::Call_GetContainers* get_containers_;
  ::mesos::agent::Call_PruneImages* prune_images_;
  int type_;
  friend struct ::protobuf_mesos_2fagent_2fagent_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fagent_2fagent_2eproto::InitDefaultsCallImpl();
};
// -------------------------------------------------------------------

class Response_GetHealth : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.agent.Response.GetHealth) */ {
 public:
  Response_GetHealth();
  virtual ~Response_GetHealth();

  Response_GetHealth(const Response_GetHealth& from);

  inline Response_GetHealth& operator=(const Response_GetHealth& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Response_GetHealth(Response_GetHealth&& from) noexcept
    : Response_GetHealth() {
    *this = ::std::move(from);
  }

  inline Response_GetHealth& operator=(Response_GetHealth&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Response_GetHealth& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Response_GetHealth* internal_default_instance() {
    return reinterpret_cast<const Response_GetHealth*>(
               &_Response_GetHealth_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    21;

  void Swap(Response_GetHealth* other);
  friend void swap(Response_GetHealth& a, Response_GetHealth& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Response_GetHealth* New() const PROTOBUF_FINAL { return New(NULL); }

  Response_GetHealth* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Response_GetHealth& from);
  void MergeFrom(const Response_GetHealth& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Response_GetHealth* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool healthy = 1;
  bool has_healthy() const;
  void clear_healthy();
  static const int kHealthyFieldNumber = 1;
  bool healthy() const;
  void set_healthy(bool value);

  // @@protoc_insertion_point(class_scope:mesos.agent.Response.GetHealth)
 private:
  void set_has_healthy();
  void clear_has_healthy();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  bool healthy_;
  friend struct ::protobuf_mesos_2fagent_2fagent_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fagent_2fagent_2eproto::InitDefaultsResponse_GetHealthImpl();
};
// -------------------------------------------------------------------

class Response_GetFlags : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.agent.Response.GetFlags) */ {
 public:
  Response_GetFlags();
  virtual ~Response_GetFlags();

  Response_GetFlags(const Response_GetFlags& from);

  inline Response_GetFlags& operator=(const Response_GetFlags& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Response_GetFlags(Response_GetFlags&& from) noexcept
    : Response_GetFlags() {
    *this = ::std::move(from);
  }

  inline Response_GetFlags& operator=(Response_GetFlags&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Response_GetFlags& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Response_GetFlags* internal_default_instance() {
    return reinterpret_cast<const Response_GetFlags*>(
               &_Response_GetFlags_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    22;

  void Swap(Response_GetFlags* other);
  friend void swap(Response_GetFlags& a, Response_GetFlags& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Response_GetFlags* New() const PROTOBUF_FINAL { return New(NULL); }

  Response_GetFlags* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Response_GetFlags& from);
  void MergeFrom(const Response_GetFlags& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Response_GetFlags* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.Flag flags = 1;
  int flags_size() const;
  void clear_flags();
  static const int kFlagsFieldNumber = 1;
  const ::mesos::Flag& flags(int index) const;
  ::mesos::Flag* mutable_flags(int index);
  ::mesos::Flag* add_flags();
  ::google::protobuf::RepeatedPtrField< ::mesos::Flag >*
      mutable_flags();
  const ::google::protobuf::RepeatedPtrField< ::mesos::Flag >&
      flags() const;

  // @@protoc_insertion_point(class_scope:mesos.agent.Response.GetFlags)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Flag > flags_;
  friend struct ::protobuf_mesos_2fagent_2fagent_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fagent_2fagent_2eproto::InitDefaultsResponse_GetFlagsImpl();
};
// -------------------------------------------------------------------

class Response_GetVersion : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.agent.Response.GetVersion) */ {
 public:
  Response_GetVersion();
  virtual ~Response_GetVersion();

  Response_GetVersion(const Response_GetVersion& from);

  inline Response_GetVersion& operator=(const Response_GetVersion& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Response_GetVersion(Response_GetVersion&& from) noexcept
    : Response_GetVersion() {
    *this = ::std::move(from);
  }

  inline Response_GetVersion& operator=(Response_GetVersion&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Response_GetVersion& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Response_GetVersion* internal_default_instance() {
    return reinterpret_cast<const Response_GetVersion*>(
               &_Response_GetVersion_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    23;

  void Swap(Response_GetVersion* other);
  friend void swap(Response_GetVersion& a, Response_GetVersion& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Response_GetVersion* New() const PROTOBUF_FINAL { return New(NULL); }

  Response_GetVersion* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Response_GetVersion& from);
  void MergeFrom(const Response_GetVersion& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Response_GetVersion* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.VersionInfo version_info = 1;
  bool has_version_info() const;
  void clear_version_info();
  static const int kVersionInfoFieldNumber = 1;
  const ::mesos::VersionInfo& version_info() const;
  ::mesos::VersionInfo* release_version_info();
  ::mesos::VersionInfo* mutable_version_info();
  void set_allocated_version_info(::mesos::VersionInfo* version_info);

  // @@protoc_insertion_point(class_scope:mesos.agent.Response.GetVersion)
 private:
  void set_has_version_info();
  void clear_has_version_info();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::VersionInfo* version_info_;
  friend struct ::protobuf_mesos_2fagent_2fagent_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fagent_2fagent_2eproto::InitDefaultsResponse_GetVersionImpl();
};
// -------------------------------------------------------------------

class Response_GetMetrics : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.agent.Response.GetMetrics) */ {
 public:
  Response_GetMetrics();
  virtual ~Response_GetMetrics();

  Response_GetMetrics(const Response_GetMetrics& from);

  inline Response_GetMetrics& operator=(const Response_GetMetrics& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Response_GetMetrics(Response_GetMetrics&& from) noexcept
    : Response_GetMetrics() {
    *this = ::std::move(from);
  }

  inline Response_GetMetrics& operator=(Response_GetMetrics&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Response_GetMetrics& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Response_GetMetrics* internal_default_instance() {
    return reinterpret_cast<const Response_GetMetrics*>(
               &_Response_GetMetrics_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    24;

  void Swap(Response_GetMetrics* other);
  friend void swap(Response_GetMetrics& a, Response_GetMetrics& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Response_GetMetrics* New() const PROTOBUF_FINAL { return New(NULL); }

  Response_GetMetrics* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Response_GetMetrics& from);
  void MergeFrom(const Response_GetMetrics& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Response_GetMetrics* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.Metric metrics = 1;
  int metrics_size() const;
  void clear_metrics();
  static const int kMetricsFieldNumber = 1;
  const ::mesos::Metric& metrics(int index) const;
  ::mesos::Metric* mutable_metrics(int index);
  ::mesos::Metric* add_metrics();
  ::google::protobuf::RepeatedPtrField< ::mesos::Metric >*
      mutable_metrics();
  const ::google::protobuf::RepeatedPtrField< ::mesos::Metric >&
      metrics() const;

  // @@protoc_insertion_point(class_scope:mesos.agent.Response.GetMetrics)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Metric > metrics_;
  friend struct ::protobuf_mesos_2fagent_2fagent_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fagent_2fagent_2eproto::InitDefaultsResponse_GetMetricsImpl();
};
// -------------------------------------------------------------------

class Response_GetLoggingLevel : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.agent.Response.GetLoggingLevel) */ {
 public:
  Response_GetLoggingLevel();
  virtual ~Response_GetLoggingLevel();

  Response_GetLoggingLevel(const Response_GetLoggingLevel& from);

  inline Response_GetLoggingLevel& operator=(const Response_GetLoggingLevel& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Response_GetLoggingLevel(Response_GetLoggingLevel&& from) noexcept
    : Response_GetLoggingLevel() {
    *this = ::std::move(from);
  }

  inline Response_GetLoggingLevel& operator=(Response_GetLoggingLevel&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Response_GetLoggingLevel& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Response_GetLoggingLevel* internal_default_instance() {
    return reinterpret_cast<const Response_GetLoggingLevel*>(
               &_Response_GetLoggingLevel_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    25;

  void Swap(Response_GetLoggingLevel* other);
  friend void swap(Response_GetLoggingLevel& a, Response_GetLoggingLevel& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Response_GetLoggingLevel* New() const PROTOBUF_FINAL { return New(NULL); }

  Response_GetLoggingLevel* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Response_GetLoggingLevel& from);
  void MergeFrom(const Response_GetLoggingLevel& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Response_GetLoggingLevel* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 level = 1;
  bool has_level() const;
  void clear_level();
  static const int kLevelFieldNumber = 1;
  ::google::protobuf::uint32 level() const;
  void set_level(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mesos.agent.Response.GetLoggingLevel)
 private:
  void set_has_level();
  void clear_has_level();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 level_;
  friend struct ::protobuf_mesos_2fagent_2fagent_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fagent_2fagent_2eproto::InitDefaultsResponse_GetLoggingLevelImpl();
};
// -------------------------------------------------------------------

class Response_ListFiles : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.agent.Response.ListFiles) */ {
 public:
  Response_ListFiles();
  virtual ~Response_ListFiles();

  Response_ListFiles(const Response_ListFiles& from);

  inline Response_ListFiles& operator=(const Response_ListFiles& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Response_ListFiles(Response_ListFiles&& from) noexcept
    : Response_ListFiles() {
    *this = ::std::move(from);
  }

  inline Response_ListFiles& operator=(Response_ListFiles&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Response_ListFiles& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Response_ListFiles* internal_default_instance() {
    return reinterpret_cast<const Response_ListFiles*>(
               &_Response_ListFiles_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    26;

  void Swap(Response_ListFiles* other);
  friend void swap(Response_ListFiles& a, Response_ListFiles& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Response_ListFiles* New() const PROTOBUF_FINAL { return New(NULL); }

  Response_ListFiles* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Response_ListFiles& from);
  void MergeFrom(const Response_ListFiles& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Response_ListFiles* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.FileInfo file_infos = 1;
  int file_infos_size() const;
  void clear_file_infos();
  static const int kFileInfosFieldNumber = 1;
  const ::mesos::FileInfo& file_infos(int index) const;
  ::mesos::FileInfo* mutable_file_infos(int index);
  ::mesos::FileInfo* add_file_infos();
  ::google::protobuf::RepeatedPtrField< ::mesos::FileInfo >*
      mutable_file_infos();
  const ::google::protobuf::RepeatedPtrField< ::mesos::FileInfo >&
      file_infos() const;

  // @@protoc_insertion_point(class_scope:mesos.agent.Response.ListFiles)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::FileInfo > file_infos_;
  friend struct ::protobuf_mesos_2fagent_2fagent_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fagent_2fagent_2eproto::InitDefaultsResponse_ListFilesImpl();
};
// -------------------------------------------------------------------

class Response_ReadFile : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.agent.Response.ReadFile) */ {
 public:
  Response_ReadFile();
  virtual ~Response_ReadFile();

  Response_ReadFile(const Response_ReadFile& from);

  inline Response_ReadFile& operator=(const Response_ReadFile& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Response_ReadFile(Response_ReadFile&& from) noexcept
    : Response_ReadFile() {
    *this = ::std::move(from);
  }

  inline Response_ReadFile& operator=(Response_ReadFile&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Response_ReadFile& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Response_ReadFile* internal_default_instance() {
    return reinterpret_cast<const Response_ReadFile*>(
               &_Response_ReadFile_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    27;

  void Swap(Response_ReadFile* other);
  friend void swap(Response_ReadFile& a, Response_ReadFile& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Response_ReadFile* New() const PROTOBUF_FINAL { return New(NULL); }

  Response_ReadFile* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Response_ReadFile& from);
  void MergeFrom(const Response_ReadFile& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Response_ReadFile* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes data = 2;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 2;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // required uint64 size = 1;
  bool has_size() const;
  void clear_size();
  static const int kSizeFieldNumber = 1;
  ::google::protobuf::uint64 size() const;
  void set_size(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:mesos.agent.Response.ReadFile)
 private:
  void set_has_size();
  void clear_has_size();
  void set_has_data();
  void clear_has_data();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  ::google::protobuf::uint64 size_;
  friend struct ::protobuf_mesos_2fagent_2fagent_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fagent_2fagent_2eproto::InitDefaultsResponse_ReadFileImpl();
};
// -------------------------------------------------------------------

class Response_GetState : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.agent.Response.GetState) */ {
 public:
  Response_GetState();
  virtual ~Response_GetState();

  Response_GetState(const Response_GetState& from);

  inline Response_GetState& operator=(const Response_GetState& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Response_GetState(Response_GetState&& from) noexcept
    : Response_GetState() {
    *this = ::std::move(from);
  }

  inline Response_GetState& operator=(Response_GetState&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Response_GetState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Response_GetState* internal_default_instance() {
    return reinterpret_cast<const Response_GetState*>(
               &_Response_GetState_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    28;

  void Swap(Response_GetState* other);
  friend void swap(Response_GetState& a, Response_GetState& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Response_GetState* New() const PROTOBUF_FINAL { return New(NULL); }

  Response_GetState* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Response_GetState& from);
  void MergeFrom(const Response_GetState& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Response_GetState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mesos.agent.Response.GetTasks get_tasks = 1;
  bool has_get_tasks() const;
  void clear_get_tasks();
  static const int kGetTasksFieldNumber = 1;
  const ::mesos::agent::Response_GetTasks& get_tasks() const;
  ::mesos::agent::Response_GetTasks* release_get_tasks();
  ::mesos::agent::Response_GetTasks* mutable_get_tasks();
  void set_allocated_get_tasks(::mesos::agent::Response_GetTasks* get_tasks);

  // optional .mesos.agent.Response.GetExecutors get_executors = 2;
  bool has_get_executors() const;
  void clear_get_executors();
  static const int kGetExecutorsFieldNumber = 2;
  const ::mesos::agent::Response_GetExecutors& get_executors() const;
  ::mesos::agent::Response_GetExecutors* release_get_executors();
  ::mesos::agent::Response_GetExecutors* mutable_get_executors();
  void set_allocated_get_executors(::mesos::agent::Response_GetExecutors* get_executors);

  // optional .mesos.agent.Response.GetFrameworks get_frameworks = 3;
  bool has_get_frameworks() const;
  void clear_get_frameworks();
  static const int kGetFrameworksFieldNumber = 3;
  const ::mesos::agent::Response_GetFrameworks& get_frameworks() const;
  ::mesos::agent::Response_GetFrameworks* release_get_frameworks();
  ::mesos::agent::Response_GetFrameworks* mutable_get_frameworks();
  void set_allocated_get_frameworks(::mesos::agent::Response_GetFrameworks* get_frameworks);

  // @@protoc_insertion_point(class_scope:mesos.agent.Response.GetState)
 private:
  void set_has_get_tasks();
  void clear_has_get_tasks();
  void set_has_get_executors();
  void clear_has_get_executors();
  void set_has_get_frameworks();
  void clear_has_get_frameworks();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::agent::Response_GetTasks* get_tasks_;
  ::mesos::agent::Response_GetExecutors* get_executors_;
  ::mesos::agent::Response_GetFrameworks* get_frameworks_;
  friend struct ::protobuf_mesos_2fagent_2fagent_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fagent_2fagent_2eproto::InitDefaultsResponse_GetStateImpl();
};
// -------------------------------------------------------------------

class Response_GetContainers_Container : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.agent.Response.GetContainers.Container) */ {
 public:
  Response_GetContainers_Container();
  virtual ~Response_GetContainers_Container();

  Response_GetContainers_Container(const Response_GetContainers_Container& from);

  inline Response_GetContainers_Container& operator=(const Response_GetContainers_Container& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Response_GetContainers_Container(Response_GetContainers_Container&& from) noexcept
    : Response_GetContainers_Container() {
    *this = ::std::move(from);
  }

  inline Response_GetContainers_Container& operator=(Response_GetContainers_Container&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Response_GetContainers_Container& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Response_GetContainers_Container* internal_default_instance() {
    return reinterpret_cast<const Response_GetContainers_Container*>(
               &_Response_GetContainers_Container_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    29;

  void Swap(Response_GetContainers_Container* other);
  friend void swap(Response_GetContainers_Container& a, Response_GetContainers_Container& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Response_GetContainers_Container* New() const PROTOBUF_FINAL { return New(NULL); }

  Response_GetContainers_Container* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Response_GetContainers_Container& from);
  void MergeFrom(const Response_GetContainers_Container& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Response_GetContainers_Container* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string executor_name = 3;
  bool has_executor_name() const;
  void clear_executor_name();
  static const int kExecutorNameFieldNumber = 3;
  const ::std::string& executor_name() const;
  void set_executor_name(const ::std::string& value);
  #if LANG_CXX11
  void set_executor_name(::std::string&& value);
  #endif
  void set_executor_name(const char* value);
  void set_executor_name(const char* value, size_t size);
  ::std::string* mutable_executor_name();
  ::std::string* release_executor_name();
  void set_allocated_executor_name(::std::string* executor_name);

  // optional .mesos.FrameworkID framework_id = 1;
  bool has_framework_id() const;
  void clear_framework_id();
  static const int kFrameworkIdFieldNumber = 1;
  const ::mesos::FrameworkID& framework_id() const;
  ::mesos::FrameworkID* release_framework_id();
  ::mesos::FrameworkID* mutable_framework_id();
  void set_allocated_framework_id(::mesos::FrameworkID* framework_id);

  // optional .mesos.ExecutorID executor_id = 2;
  bool has_executor_id() const;
  void clear_executor_id();
  static const int kExecutorIdFieldNumber = 2;
  const ::mesos::ExecutorID& executor_id() const;
  ::mesos::ExecutorID* release_executor_id();
  ::mesos::ExecutorID* mutable_executor_id();
  void set_allocated_executor_id(::mesos::ExecutorID* executor_id);

  // required .mesos.ContainerID container_id = 4;
  bool has_container_id() const;
  void clear_container_id();
  static const int kContainerIdFieldNumber = 4;
  const ::mesos::ContainerID& container_id() const;
  ::mesos::ContainerID* release_container_id();
  ::mesos::ContainerID* mutable_container_id();
  void set_allocated_container_id(::mesos::ContainerID* container_id);

  // optional .mesos.ContainerStatus container_status = 5;
  bool has_container_status() const;
  void clear_container_status();
  static const int kContainerStatusFieldNumber = 5;
  const ::mesos::ContainerStatus& container_status() const;
  ::mesos::ContainerStatus* release_container_status();
  ::mesos::ContainerStatus* mutable_container_status();
  void set_allocated_container_status(::mesos::ContainerStatus* container_status);

  // optional .mesos.ResourceStatistics resource_statistics = 6;
  bool has_resource_statistics() const;
  void clear_resource_statistics();
  static const int kResourceStatisticsFieldNumber = 6;
  const ::mesos::ResourceStatistics& resource_statistics() const;
  ::mesos::ResourceStatistics* release_resource_statistics();
  ::mesos::ResourceStatistics* mutable_resource_statistics();
  void set_allocated_resource_statistics(::mesos::ResourceStatistics* resource_statistics);

  // @@protoc_insertion_point(class_scope:mesos.agent.Response.GetContainers.Container)
 private:
  void set_has_framework_id();
  void clear_has_framework_id();
  void set_has_executor_id();
  void clear_has_executor_id();
  void set_has_executor_name();
  void clear_has_executor_name();
  void set_has_container_id();
  void clear_has_container_id();
  void set_has_container_status();
  void clear_has_container_status();
  void set_has_resource_statistics();
  void clear_has_resource_statistics();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr executor_name_;
  ::mesos::FrameworkID* framework_id_;
  ::mesos::ExecutorID* executor_id_;
  ::mesos::ContainerID* container_id_;
  ::mesos::ContainerStatus* container_status_;
  ::mesos::ResourceStatistics* resource_statistics_;
  friend struct ::protobuf_mesos_2fagent_2fagent_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fagent_2fagent_2eproto::InitDefaultsResponse_GetContainers_ContainerImpl();
};
// -------------------------------------------------------------------

class Response_GetContainers : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.agent.Response.GetContainers) */ {
 public:
  Response_GetContainers();
  virtual ~Response_GetContainers();

  Response_GetContainers(const Response_GetContainers& from);

  inline Response_GetContainers& operator=(const Response_GetContainers& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Response_GetContainers(Response_GetContainers&& from) noexcept
    : Response_GetContainers() {
    *this = ::std::move(from);
  }

  inline Response_GetContainers& operator=(Response_GetContainers&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Response_GetContainers& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Response_GetContainers* internal_default_instance() {
    return reinterpret_cast<const Response_GetContainers*>(
               &_Response_GetContainers_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    30;

  void Swap(Response_GetContainers* other);
  friend void swap(Response_GetContainers& a, Response_GetContainers& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Response_GetContainers* New() const PROTOBUF_FINAL { return New(NULL); }

  Response_GetContainers* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Response_GetContainers& from);
  void MergeFrom(const Response_GetContainers& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Response_GetContainers* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Response_GetContainers_Container Container;

  // accessors -------------------------------------------------------

  // repeated .mesos.agent.Response.GetContainers.Container containers = 1;
  int containers_size() const;
  void clear_containers();
  static const int kContainersFieldNumber = 1;
  const ::mesos::agent::Response_GetContainers_Container& containers(int index) const;
  ::mesos::agent::Response_GetContainers_Container* mutable_containers(int index);
  ::mesos::agent::Response_GetContainers_Container* add_containers();
  ::google::protobuf::RepeatedPtrField< ::mesos::agent::Response_GetContainers_Container >*
      mutable_containers();
  const ::google::protobuf::RepeatedPtrField< ::mesos::agent::Response_GetContainers_Container >&
      containers() const;

  // @@protoc_insertion_point(class_scope:mesos.agent.Response.GetContainers)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::agent::Response_GetContainers_Container > containers_;
  friend struct ::protobuf_mesos_2fagent_2fagent_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fagent_2fagent_2eproto::InitDefaultsResponse_GetContainersImpl();
};
// -------------------------------------------------------------------

class Response_GetFrameworks_Framework : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.agent.Response.GetFrameworks.Framework) */ {
 public:
  Response_GetFrameworks_Framework();
  virtual ~Response_GetFrameworks_Framework();

  Response_GetFrameworks_Framework(const Response_GetFrameworks_Framework& from);

  inline Response_GetFrameworks_Framework& operator=(const Response_GetFrameworks_Framework& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Response_GetFrameworks_Framework(Response_GetFrameworks_Framework&& from) noexcept
    : Response_GetFrameworks_Framework() {
    *this = ::std::move(from);
  }

  inline Response_GetFrameworks_Framework& operator=(Response_GetFrameworks_Framework&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Response_GetFrameworks_Framework& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Response_GetFrameworks_Framework* internal_default_instance() {
    return reinterpret_cast<const Response_GetFrameworks_Framework*>(
               &_Response_GetFrameworks_Framework_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    31;

  void Swap(Response_GetFrameworks_Framework* other);
  friend void swap(Response_GetFrameworks_Framework& a, Response_GetFrameworks_Framework& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Response_GetFrameworks_Framework* New() const PROTOBUF_FINAL { return New(NULL); }

  Response_GetFrameworks_Framework* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Response_GetFrameworks_Framework& from);
  void MergeFrom(const Response_GetFrameworks_Framework& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Response_GetFrameworks_Framework* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.FrameworkInfo framework_info = 1;
  bool has_framework_info() const;
  void clear_framework_info();
  static const int kFrameworkInfoFieldNumber = 1;
  const ::mesos::FrameworkInfo& framework_info() const;
  ::mesos::FrameworkInfo* release_framework_info();
  ::mesos::FrameworkInfo* mutable_framework_info();
  void set_allocated_framework_info(::mesos::FrameworkInfo* framework_info);

  // @@protoc_insertion_point(class_scope:mesos.agent.Response.GetFrameworks.Framework)
 private:
  void set_has_framework_info();
  void clear_has_framework_info();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::FrameworkInfo* framework_info_;
  friend struct ::protobuf_mesos_2fagent_2fagent_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fagent_2fagent_2eproto::InitDefaultsResponse_GetFrameworks_FrameworkImpl();
};
// -------------------------------------------------------------------

class Response_GetFrameworks : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.agent.Response.GetFrameworks) */ {
 public:
  Response_GetFrameworks();
  virtual ~Response_GetFrameworks();

  Response_GetFrameworks(const Response_GetFrameworks& from);

  inline Response_GetFrameworks& operator=(const Response_GetFrameworks& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Response_GetFrameworks(Response_GetFrameworks&& from) noexcept
    : Response_GetFrameworks() {
    *this = ::std::move(from);
  }

  inline Response_GetFrameworks& operator=(Response_GetFrameworks&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Response_GetFrameworks& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Response_GetFrameworks* internal_default_instance() {
    return reinterpret_cast<const Response_GetFrameworks*>(
               &_Response_GetFrameworks_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    32;

  void Swap(Response_GetFrameworks* other);
  friend void swap(Response_GetFrameworks& a, Response_GetFrameworks& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Response_GetFrameworks* New() const PROTOBUF_FINAL { return New(NULL); }

  Response_GetFrameworks* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Response_GetFrameworks& from);
  void MergeFrom(const Response_GetFrameworks& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Response_GetFrameworks* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Response_GetFrameworks_Framework Framework;

  // accessors -------------------------------------------------------

  // repeated .mesos.agent.Response.GetFrameworks.Framework frameworks = 1;
  int frameworks_size() const;
  void clear_frameworks();
  static const int kFrameworksFieldNumber = 1;
  const ::mesos::agent::Response_GetFrameworks_Framework& frameworks(int index) const;
  ::mesos::agent::Response_GetFrameworks_Framework* mutable_frameworks(int index);
  ::mesos::agent::Response_GetFrameworks_Framework* add_frameworks();
  ::google::protobuf::RepeatedPtrField< ::mesos::agent::Response_GetFrameworks_Framework >*
      mutable_frameworks();
  const ::google::protobuf::RepeatedPtrField< ::mesos::agent::Response_GetFrameworks_Framework >&
      frameworks() const;

  // repeated .mesos.agent.Response.GetFrameworks.Framework completed_frameworks = 2;
  int completed_frameworks_size() const;
  void clear_completed_frameworks();
  static const int kCompletedFrameworksFieldNumber = 2;
  const ::mesos::agent::Response_GetFrameworks_Framework& completed_frameworks(int index) const;
  ::mesos::agent::Response_GetFrameworks_Framework* mutable_completed_frameworks(int index);
  ::mesos::agent::Response_GetFrameworks_Framework* add_completed_frameworks();
  ::google::protobuf::RepeatedPtrField< ::mesos::agent::Response_GetFrameworks_Framework >*
      mutable_completed_frameworks();
  const ::google::protobuf::RepeatedPtrField< ::mesos::agent::Response_GetFrameworks_Framework >&
      completed_frameworks() const;

  // @@protoc_insertion_point(class_scope:mesos.agent.Response.GetFrameworks)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::agent::Response_GetFrameworks_Framework > frameworks_;
  ::google::protobuf::RepeatedPtrField< ::mesos::agent::Response_GetFrameworks_Framework > completed_frameworks_;
  friend struct ::protobuf_mesos_2fagent_2fagent_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fagent_2fagent_2eproto::InitDefaultsResponse_GetFrameworksImpl();
};
// -------------------------------------------------------------------

class Response_GetExecutors_Executor : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.agent.Response.GetExecutors.Executor) */ {
 public:
  Response_GetExecutors_Executor();
  virtual ~Response_GetExecutors_Executor();

  Response_GetExecutors_Executor(const Response_GetExecutors_Executor& from);

  inline Response_GetExecutors_Executor& operator=(const Response_GetExecutors_Executor& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Response_GetExecutors_Executor(Response_GetExecutors_Executor&& from) noexcept
    : Response_GetExecutors_Executor() {
    *this = ::std::move(from);
  }

  inline Response_GetExecutors_Executor& operator=(Response_GetExecutors_Executor&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Response_GetExecutors_Executor& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Response_GetExecutors_Executor* internal_default_instance() {
    return reinterpret_cast<const Response_GetExecutors_Executor*>(
               &_Response_GetExecutors_Executor_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    33;

  void Swap(Response_GetExecutors_Executor* other);
  friend void swap(Response_GetExecutors_Executor& a, Response_GetExecutors_Executor& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Response_GetExecutors_Executor* New() const PROTOBUF_FINAL { return New(NULL); }

  Response_GetExecutors_Executor* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Response_GetExecutors_Executor& from);
  void MergeFrom(const Response_GetExecutors_Executor& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Response_GetExecutors_Executor* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.ExecutorInfo executor_info = 1;
  bool has_executor_info() const;
  void clear_executor_info();
  static const int kExecutorInfoFieldNumber = 1;
  const ::mesos::ExecutorInfo& executor_info() const;
  ::mesos::ExecutorInfo* release_executor_info();
  ::mesos::ExecutorInfo* mutable_executor_info();
  void set_allocated_executor_info(::mesos::ExecutorInfo* executor_info);

  // @@protoc_insertion_point(class_scope:mesos.agent.Response.GetExecutors.Executor)
 private:
  void set_has_executor_info();
  void clear_has_executor_info();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::ExecutorInfo* executor_info_;
  friend struct ::protobuf_mesos_2fagent_2fagent_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fagent_2fagent_2eproto::InitDefaultsResponse_GetExecutors_ExecutorImpl();
};
// -------------------------------------------------------------------

class Response_GetExecutors : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.agent.Response.GetExecutors) */ {
 public:
  Response_GetExecutors();
  virtual ~Response_GetExecutors();

  Response_GetExecutors(const Response_GetExecutors& from);

  inline Response_GetExecutors& operator=(const Response_GetExecutors& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Response_GetExecutors(Response_GetExecutors&& from) noexcept
    : Response_GetExecutors() {
    *this = ::std::move(from);
  }

  inline Response_GetExecutors& operator=(Response_GetExecutors&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Response_GetExecutors& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Response_GetExecutors* internal_default_instance() {
    return reinterpret_cast<const Response_GetExecutors*>(
               &_Response_GetExecutors_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    34;

  void Swap(Response_GetExecutors* other);
  friend void swap(Response_GetExecutors& a, Response_GetExecutors& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Response_GetExecutors* New() const PROTOBUF_FINAL { return New(NULL); }

  Response_GetExecutors* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Response_GetExecutors& from);
  void MergeFrom(const Response_GetExecutors& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Response_GetExecutors* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Response_GetExecutors_Executor Executor;

  // accessors -------------------------------------------------------

  // repeated .mesos.agent.Response.GetExecutors.Executor executors = 1;
  int executors_size() const;
  void clear_executors();
  static const int kExecutorsFieldNumber = 1;
  const ::mesos::agent::Response_GetExecutors_Executor& executors(int index) const;
  ::mesos::agent::Response_GetExecutors_Executor* mutable_executors(int index);
  ::mesos::agent::Response_GetExecutors_Executor* add_executors();
  ::google::protobuf::RepeatedPtrField< ::mesos::agent::Response_GetExecutors_Executor >*
      mutable_executors();
  const ::google::protobuf::RepeatedPtrField< ::mesos::agent::Response_GetExecutors_Executor >&
      executors() const;

  // repeated .mesos.agent.Response.GetExecutors.Executor completed_executors = 2;
  int completed_executors_size() const;
  void clear_completed_executors();
  static const int kCompletedExecutorsFieldNumber = 2;
  const ::mesos::agent::Response_GetExecutors_Executor& completed_executors(int index) const;
  ::mesos::agent::Response_GetExecutors_Executor* mutable_completed_executors(int index);
  ::mesos::agent::Response_GetExecutors_Executor* add_completed_executors();
  ::google::protobuf::RepeatedPtrField< ::mesos::agent::Response_GetExecutors_Executor >*
      mutable_completed_executors();
  const ::google::protobuf::RepeatedPtrField< ::mesos::agent::Response_GetExecutors_Executor >&
      completed_executors() const;

  // @@protoc_insertion_point(class_scope:mesos.agent.Response.GetExecutors)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::agent::Response_GetExecutors_Executor > executors_;
  ::google::protobuf::RepeatedPtrField< ::mesos::agent::Response_GetExecutors_Executor > completed_executors_;
  friend struct ::protobuf_mesos_2fagent_2fagent_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fagent_2fagent_2eproto::InitDefaultsResponse_GetExecutorsImpl();
};
// -------------------------------------------------------------------

class Response_GetOperations : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.agent.Response.GetOperations) */ {
 public:
  Response_GetOperations();
  virtual ~Response_GetOperations();

  Response_GetOperations(const Response_GetOperations& from);

  inline Response_GetOperations& operator=(const Response_GetOperations& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Response_GetOperations(Response_GetOperations&& from) noexcept
    : Response_GetOperations() {
    *this = ::std::move(from);
  }

  inline Response_GetOperations& operator=(Response_GetOperations&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Response_GetOperations& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Response_GetOperations* internal_default_instance() {
    return reinterpret_cast<const Response_GetOperations*>(
               &_Response_GetOperations_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    35;

  void Swap(Response_GetOperations* other);
  friend void swap(Response_GetOperations& a, Response_GetOperations& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Response_GetOperations* New() const PROTOBUF_FINAL { return New(NULL); }

  Response_GetOperations* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Response_GetOperations& from);
  void MergeFrom(const Response_GetOperations& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Response_GetOperations* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.Operation operations = 1;
  int operations_size() const;
  void clear_operations();
  static const int kOperationsFieldNumber = 1;
  const ::mesos::Operation& operations(int index) const;
  ::mesos::Operation* mutable_operations(int index);
  ::mesos::Operation* add_operations();
  ::google::protobuf::RepeatedPtrField< ::mesos::Operation >*
      mutable_operations();
  const ::google::protobuf::RepeatedPtrField< ::mesos::Operation >&
      operations() const;

  // @@protoc_insertion_point(class_scope:mesos.agent.Response.GetOperations)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Operation > operations_;
  friend struct ::protobuf_mesos_2fagent_2fagent_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fagent_2fagent_2eproto::InitDefaultsResponse_GetOperationsImpl();
};
// -------------------------------------------------------------------

class Response_GetTasks : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.agent.Response.GetTasks) */ {
 public:
  Response_GetTasks();
  virtual ~Response_GetTasks();

  Response_GetTasks(const Response_GetTasks& from);

  inline Response_GetTasks& operator=(const Response_GetTasks& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Response_GetTasks(Response_GetTasks&& from) noexcept
    : Response_GetTasks() {
    *this = ::std::move(from);
  }

  inline Response_GetTasks& operator=(Response_GetTasks&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Response_GetTasks& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Response_GetTasks* internal_default_instance() {
    return reinterpret_cast<const Response_GetTasks*>(
               &_Response_GetTasks_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    36;

  void Swap(Response_GetTasks* other);
  friend void swap(Response_GetTasks& a, Response_GetTasks& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Response_GetTasks* New() const PROTOBUF_FINAL { return New(NULL); }

  Response_GetTasks* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Response_GetTasks& from);
  void MergeFrom(const Response_GetTasks& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Response_GetTasks* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.Task pending_tasks = 1;
  int pending_tasks_size() const;
  void clear_pending_tasks();
  static const int kPendingTasksFieldNumber = 1;
  const ::mesos::Task& pending_tasks(int index) const;
  ::mesos::Task* mutable_pending_tasks(int index);
  ::mesos::Task* add_pending_tasks();
  ::google::protobuf::RepeatedPtrField< ::mesos::Task >*
      mutable_pending_tasks();
  const ::google::protobuf::RepeatedPtrField< ::mesos::Task >&
      pending_tasks() const;

  // repeated .mesos.Task queued_tasks = 2;
  int queued_tasks_size() const;
  void clear_queued_tasks();
  static const int kQueuedTasksFieldNumber = 2;
  const ::mesos::Task& queued_tasks(int index) const;
  ::mesos::Task* mutable_queued_tasks(int index);
  ::mesos::Task* add_queued_tasks();
  ::google::protobuf::RepeatedPtrField< ::mesos::Task >*
      mutable_queued_tasks();
  const ::google::protobuf::RepeatedPtrField< ::mesos::Task >&
      queued_tasks() const;

  // repeated .mesos.Task launched_tasks = 3;
  int launched_tasks_size() const;
  void clear_launched_tasks();
  static const int kLaunchedTasksFieldNumber = 3;
  const ::mesos::Task& launched_tasks(int index) const;
  ::mesos::Task* mutable_launched_tasks(int index);
  ::mesos::Task* add_launched_tasks();
  ::google::protobuf::RepeatedPtrField< ::mesos::Task >*
      mutable_launched_tasks();
  const ::google::protobuf::RepeatedPtrField< ::mesos::Task >&
      launched_tasks() const;

  // repeated .mesos.Task terminated_tasks = 4;
  int terminated_tasks_size() const;
  void clear_terminated_tasks();
  static const int kTerminatedTasksFieldNumber = 4;
  const ::mesos::Task& terminated_tasks(int index) const;
  ::mesos::Task* mutable_terminated_tasks(int index);
  ::mesos::Task* add_terminated_tasks();
  ::google::protobuf::RepeatedPtrField< ::mesos::Task >*
      mutable_terminated_tasks();
  const ::google::protobuf::RepeatedPtrField< ::mesos::Task >&
      terminated_tasks() const;

  // repeated .mesos.Task completed_tasks = 5;
  int completed_tasks_size() const;
  void clear_completed_tasks();
  static const int kCompletedTasksFieldNumber = 5;
  const ::mesos::Task& completed_tasks(int index) const;
  ::mesos::Task* mutable_completed_tasks(int index);
  ::mesos::Task* add_completed_tasks();
  ::google::protobuf::RepeatedPtrField< ::mesos::Task >*
      mutable_completed_tasks();
  const ::google::protobuf::RepeatedPtrField< ::mesos::Task >&
      completed_tasks() const;

  // @@protoc_insertion_point(class_scope:mesos.agent.Response.GetTasks)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Task > pending_tasks_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Task > queued_tasks_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Task > launched_tasks_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Task > terminated_tasks_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Task > completed_tasks_;
  friend struct ::protobuf_mesos_2fagent_2fagent_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fagent_2fagent_2eproto::InitDefaultsResponse_GetTasksImpl();
};
// -------------------------------------------------------------------

class Response_GetAgent : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.agent.Response.GetAgent) */ {
 public:
  Response_GetAgent();
  virtual ~Response_GetAgent();

  Response_GetAgent(const Response_GetAgent& from);

  inline Response_GetAgent& operator=(const Response_GetAgent& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Response_GetAgent(Response_GetAgent&& from) noexcept
    : Response_GetAgent() {
    *this = ::std::move(from);
  }

  inline Response_GetAgent& operator=(Response_GetAgent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Response_GetAgent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Response_GetAgent* internal_default_instance() {
    return reinterpret_cast<const Response_GetAgent*>(
               &_Response_GetAgent_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    37;

  void Swap(Response_GetAgent* other);
  friend void swap(Response_GetAgent& a, Response_GetAgent& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Response_GetAgent* New() const PROTOBUF_FINAL { return New(NULL); }

  Response_GetAgent* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Response_GetAgent& from);
  void MergeFrom(const Response_GetAgent& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Response_GetAgent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mesos.SlaveInfo slave_info = 1;
  bool has_slave_info() const;
  void clear_slave_info();
  static const int kSlaveInfoFieldNumber = 1;
  const ::mesos::SlaveInfo& slave_info() const;
  ::mesos::SlaveInfo* release_slave_info();
  ::mesos::SlaveInfo* mutable_slave_info();
  void set_allocated_slave_info(::mesos::SlaveInfo* slave_info);

  // @@protoc_insertion_point(class_scope:mesos.agent.Response.GetAgent)
 private:
  void set_has_slave_info();
  void clear_has_slave_info();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::SlaveInfo* slave_info_;
  friend struct ::protobuf_mesos_2fagent_2fagent_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fagent_2fagent_2eproto::InitDefaultsResponse_GetAgentImpl();
};
// -------------------------------------------------------------------

class Response_GetResourceProviders_ResourceProvider : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.agent.Response.GetResourceProviders.ResourceProvider) */ {
 public:
  Response_GetResourceProviders_ResourceProvider();
  virtual ~Response_GetResourceProviders_ResourceProvider();

  Response_GetResourceProviders_ResourceProvider(const Response_GetResourceProviders_ResourceProvider& from);

  inline Response_GetResourceProviders_ResourceProvider& operator=(const Response_GetResourceProviders_ResourceProvider& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Response_GetResourceProviders_ResourceProvider(Response_GetResourceProviders_ResourceProvider&& from) noexcept
    : Response_GetResourceProviders_ResourceProvider() {
    *this = ::std::move(from);
  }

  inline Response_GetResourceProviders_ResourceProvider& operator=(Response_GetResourceProviders_ResourceProvider&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Response_GetResourceProviders_ResourceProvider& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Response_GetResourceProviders_ResourceProvider* internal_default_instance() {
    return reinterpret_cast<const Response_GetResourceProviders_ResourceProvider*>(
               &_Response_GetResourceProviders_ResourceProvider_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    38;

  void Swap(Response_GetResourceProviders_ResourceProvider* other);
  friend void swap(Response_GetResourceProviders_ResourceProvider& a, Response_GetResourceProviders_ResourceProvider& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Response_GetResourceProviders_ResourceProvider* New() const PROTOBUF_FINAL { return New(NULL); }

  Response_GetResourceProviders_ResourceProvider* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Response_GetResourceProviders_ResourceProvider& from);
  void MergeFrom(const Response_GetResourceProviders_ResourceProvider& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Response_GetResourceProviders_ResourceProvider* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.Resource total_resources = 2;
  int total_resources_size() const;
  void clear_total_resources();
  static const int kTotalResourcesFieldNumber = 2;
  const ::mesos::Resource& total_resources(int index) const;
  ::mesos::Resource* mutable_total_resources(int index);
  ::mesos::Resource* add_total_resources();
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
      mutable_total_resources();
  const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
      total_resources() const;

  // required .mesos.ResourceProviderInfo resource_provider_info = 1;
  bool has_resource_provider_info() const;
  void clear_resource_provider_info();
  static const int kResourceProviderInfoFieldNumber = 1;
  const ::mesos::ResourceProviderInfo& resource_provider_info() const;
  ::mesos::ResourceProviderInfo* release_resource_provider_info();
  ::mesos::ResourceProviderInfo* mutable_resource_provider_info();
  void set_allocated_resource_provider_info(::mesos::ResourceProviderInfo* resource_provider_info);

  // @@protoc_insertion_point(class_scope:mesos.agent.Response.GetResourceProviders.ResourceProvider)
 private:
  void set_has_resource_provider_info();
  void clear_has_resource_provider_info();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource > total_resources_;
  ::mesos::ResourceProviderInfo* resource_provider_info_;
  friend struct ::protobuf_mesos_2fagent_2fagent_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fagent_2fagent_2eproto::InitDefaultsResponse_GetResourceProviders_ResourceProviderImpl();
};
// -------------------------------------------------------------------

class Response_GetResourceProviders : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.agent.Response.GetResourceProviders) */ {
 public:
  Response_GetResourceProviders();
  virtual ~Response_GetResourceProviders();

  Response_GetResourceProviders(const Response_GetResourceProviders& from);

  inline Response_GetResourceProviders& operator=(const Response_GetResourceProviders& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Response_GetResourceProviders(Response_GetResourceProviders&& from) noexcept
    : Response_GetResourceProviders() {
    *this = ::std::move(from);
  }

  inline Response_GetResourceProviders& operator=(Response_GetResourceProviders&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Response_GetResourceProviders& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Response_GetResourceProviders* internal_default_instance() {
    return reinterpret_cast<const Response_GetResourceProviders*>(
               &_Response_GetResourceProviders_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    39;

  void Swap(Response_GetResourceProviders* other);
  friend void swap(Response_GetResourceProviders& a, Response_GetResourceProviders& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Response_GetResourceProviders* New() const PROTOBUF_FINAL { return New(NULL); }

  Response_GetResourceProviders* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Response_GetResourceProviders& from);
  void MergeFrom(const Response_GetResourceProviders& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Response_GetResourceProviders* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Response_GetResourceProviders_ResourceProvider ResourceProvider;

  // accessors -------------------------------------------------------

  // repeated .mesos.agent.Response.GetResourceProviders.ResourceProvider resource_providers = 1;
  int resource_providers_size() const;
  void clear_resource_providers();
  static const int kResourceProvidersFieldNumber = 1;
  const ::mesos::agent::Response_GetResourceProviders_ResourceProvider& resource_providers(int index) const;
  ::mesos::agent::Response_GetResourceProviders_ResourceProvider* mutable_resource_providers(int index);
  ::mesos::agent::Response_GetResourceProviders_ResourceProvider* add_resource_providers();
  ::google::protobuf::RepeatedPtrField< ::mesos::agent::Response_GetResourceProviders_ResourceProvider >*
      mutable_resource_providers();
  const ::google::protobuf::RepeatedPtrField< ::mesos::agent::Response_GetResourceProviders_ResourceProvider >&
      resource_providers() const;

  // @@protoc_insertion_point(class_scope:mesos.agent.Response.GetResourceProviders)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::agent::Response_GetResourceProviders_ResourceProvider > resource_providers_;
  friend struct ::protobuf_mesos_2fagent_2fagent_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fagent_2fagent_2eproto::InitDefaultsResponse_GetResourceProvidersImpl();
};
// -------------------------------------------------------------------

class Response_WaitNestedContainer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.agent.Response.WaitNestedContainer) */ {
 public:
  Response_WaitNestedContainer();
  virtual ~Response_WaitNestedContainer();

  Response_WaitNestedContainer(const Response_WaitNestedContainer& from);

  inline Response_WaitNestedContainer& operator=(const Response_WaitNestedContainer& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Response_WaitNestedContainer(Response_WaitNestedContainer&& from) noexcept
    : Response_WaitNestedContainer() {
    *this = ::std::move(from);
  }

  inline Response_WaitNestedContainer& operator=(Response_WaitNestedContainer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Response_WaitNestedContainer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Response_WaitNestedContainer* internal_default_instance() {
    return reinterpret_cast<const Response_WaitNestedContainer*>(
               &_Response_WaitNestedContainer_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    40;

  void Swap(Response_WaitNestedContainer* other);
  friend void swap(Response_WaitNestedContainer& a, Response_WaitNestedContainer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Response_WaitNestedContainer* New() const PROTOBUF_FINAL { return New(NULL); }

  Response_WaitNestedContainer* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Response_WaitNestedContainer& from);
  void MergeFrom(const Response_WaitNestedContainer& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Response_WaitNestedContainer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string message = 5;
  bool has_message() const;
  void clear_message();
  static const int kMessageFieldNumber = 5;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // optional .mesos.TaskResourceLimitation limitation = 4;
  bool has_limitation() const;
  void clear_limitation();
  static const int kLimitationFieldNumber = 4;
  const ::mesos::TaskResourceLimitation& limitation() const;
  ::mesos::TaskResourceLimitation* release_limitation();
  ::mesos::TaskResourceLimitation* mutable_limitation();
  void set_allocated_limitation(::mesos::TaskResourceLimitation* limitation);

  // optional int32 exit_status = 1;
  bool has_exit_status() const;
  void clear_exit_status();
  static const int kExitStatusFieldNumber = 1;
  ::google::protobuf::int32 exit_status() const;
  void set_exit_status(::google::protobuf::int32 value);

  // optional .mesos.TaskStatus.Reason reason = 3;
  bool has_reason() const;
  void clear_reason();
  static const int kReasonFieldNumber = 3;
  ::mesos::TaskStatus_Reason reason() const;
  void set_reason(::mesos::TaskStatus_Reason value);

  // optional .mesos.TaskState state = 2;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 2;
  ::mesos::TaskState state() const;
  void set_state(::mesos::TaskState value);

  // @@protoc_insertion_point(class_scope:mesos.agent.Response.WaitNestedContainer)
 private:
  void set_has_exit_status();
  void clear_has_exit_status();
  void set_has_state();
  void clear_has_state();
  void set_has_reason();
  void clear_has_reason();
  void set_has_limitation();
  void clear_has_limitation();
  void set_has_message();
  void clear_has_message();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  ::mesos::TaskResourceLimitation* limitation_;
  ::google::protobuf::int32 exit_status_;
  int reason_;
  int state_;
  friend struct ::protobuf_mesos_2fagent_2fagent_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fagent_2fagent_2eproto::InitDefaultsResponse_WaitNestedContainerImpl();
};
// -------------------------------------------------------------------

class Response_WaitContainer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.agent.Response.WaitContainer) */ {
 public:
  Response_WaitContainer();
  virtual ~Response_WaitContainer();

  Response_WaitContainer(const Response_WaitContainer& from);

  inline Response_WaitContainer& operator=(const Response_WaitContainer& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Response_WaitContainer(Response_WaitContainer&& from) noexcept
    : Response_WaitContainer() {
    *this = ::std::move(from);
  }

  inline Response_WaitContainer& operator=(Response_WaitContainer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Response_WaitContainer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Response_WaitContainer* internal_default_instance() {
    return reinterpret_cast<const Response_WaitContainer*>(
               &_Response_WaitContainer_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    41;

  void Swap(Response_WaitContainer* other);
  friend void swap(Response_WaitContainer& a, Response_WaitContainer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Response_WaitContainer* New() const PROTOBUF_FINAL { return New(NULL); }

  Response_WaitContainer* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Response_WaitContainer& from);
  void MergeFrom(const Response_WaitContainer& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Response_WaitContainer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string message = 5;
  bool has_message() const;
  void clear_message();
  static const int kMessageFieldNumber = 5;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // optional .mesos.TaskResourceLimitation limitation = 4;
  bool has_limitation() const;
  void clear_limitation();
  static const int kLimitationFieldNumber = 4;
  const ::mesos::TaskResourceLimitation& limitation() const;
  ::mesos::TaskResourceLimitation* release_limitation();
  ::mesos::TaskResourceLimitation* mutable_limitation();
  void set_allocated_limitation(::mesos::TaskResourceLimitation* limitation);

  // optional int32 exit_status = 1;
  bool has_exit_status() const;
  void clear_exit_status();
  static const int kExitStatusFieldNumber = 1;
  ::google::protobuf::int32 exit_status() const;
  void set_exit_status(::google::protobuf::int32 value);

  // optional .mesos.TaskStatus.Reason reason = 3;
  bool has_reason() const;
  void clear_reason();
  static const int kReasonFieldNumber = 3;
  ::mesos::TaskStatus_Reason reason() const;
  void set_reason(::mesos::TaskStatus_Reason value);

  // optional .mesos.TaskState state = 2;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 2;
  ::mesos::TaskState state() const;
  void set_state(::mesos::TaskState value);

  // @@protoc_insertion_point(class_scope:mesos.agent.Response.WaitContainer)
 private:
  void set_has_exit_status();
  void clear_has_exit_status();
  void set_has_state();
  void clear_has_state();
  void set_has_reason();
  void clear_has_reason();
  void set_has_limitation();
  void clear_has_limitation();
  void set_has_message();
  void clear_has_message();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  ::mesos::TaskResourceLimitation* limitation_;
  ::google::protobuf::int32 exit_status_;
  int reason_;
  int state_;
  friend struct ::protobuf_mesos_2fagent_2fagent_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fagent_2fagent_2eproto::InitDefaultsResponse_WaitContainerImpl();
};
// -------------------------------------------------------------------

class Response : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.agent.Response) */ {
 public:
  Response();
  virtual ~Response();

  Response(const Response& from);

  inline Response& operator=(const Response& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Response(Response&& from) noexcept
    : Response() {
    *this = ::std::move(from);
  }

  inline Response& operator=(Response&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Response& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Response* internal_default_instance() {
    return reinterpret_cast<const Response*>(
               &_Response_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    42;

  void Swap(Response* other);
  friend void swap(Response& a, Response& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Response* New() const PROTOBUF_FINAL { return New(NULL); }

  Response* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Response& from);
  void MergeFrom(const Response& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Response* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Response_GetHealth GetHealth;
  typedef Response_GetFlags GetFlags;
  typedef Response_GetVersion GetVersion;
  typedef Response_GetMetrics GetMetrics;
  typedef Response_GetLoggingLevel GetLoggingLevel;
  typedef Response_ListFiles ListFiles;
  typedef Response_ReadFile ReadFile;
  typedef Response_GetState GetState;
  typedef Response_GetContainers GetContainers;
  typedef Response_GetFrameworks GetFrameworks;
  typedef Response_GetExecutors GetExecutors;
  typedef Response_GetOperations GetOperations;
  typedef Response_GetTasks GetTasks;
  typedef Response_GetAgent GetAgent;
  typedef Response_GetResourceProviders GetResourceProviders;
  typedef Response_WaitNestedContainer WaitNestedContainer;
  typedef Response_WaitContainer WaitContainer;

  typedef Response_Type Type;
  static const Type UNKNOWN =
    Response_Type_UNKNOWN;
  static const Type GET_HEALTH =
    Response_Type_GET_HEALTH;
  static const Type GET_FLAGS =
    Response_Type_GET_FLAGS;
  static const Type GET_VERSION =
    Response_Type_GET_VERSION;
  static const Type GET_METRICS =
    Response_Type_GET_METRICS;
  static const Type GET_LOGGING_LEVEL =
    Response_Type_GET_LOGGING_LEVEL;
  static const Type LIST_FILES =
    Response_Type_LIST_FILES;
  static const Type READ_FILE =
    Response_Type_READ_FILE;
  static const Type GET_STATE =
    Response_Type_GET_STATE;
  static const Type GET_CONTAINERS =
    Response_Type_GET_CONTAINERS;
  static const Type GET_FRAMEWORKS =
    Response_Type_GET_FRAMEWORKS;
  static const Type GET_EXECUTORS =
    Response_Type_GET_EXECUTORS;
  static const Type GET_OPERATIONS =
    Response_Type_GET_OPERATIONS;
  static const Type GET_TASKS =
    Response_Type_GET_TASKS;
  static const Type GET_AGENT =
    Response_Type_GET_AGENT;
  static const Type GET_RESOURCE_PROVIDERS =
    Response_Type_GET_RESOURCE_PROVIDERS;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR static const Type WAIT_NESTED_CONTAINER =
    Response_Type_WAIT_NESTED_CONTAINER;
  static const Type WAIT_CONTAINER =
    Response_Type_WAIT_CONTAINER;
  static inline bool Type_IsValid(int value) {
    return Response_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Response_Type_Type_MIN;
  static const Type Type_MAX =
    Response_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Response_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Response_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Response_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Response_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .mesos.agent.Response.GetHealth get_health = 2;
  bool has_get_health() const;
  void clear_get_health();
  static const int kGetHealthFieldNumber = 2;
  const ::mesos::agent::Response_GetHealth& get_health() const;
  ::mesos::agent::Response_GetHealth* release_get_health();
  ::mesos::agent::Response_GetHealth* mutable_get_health();
  void set_allocated_get_health(::mesos::agent::Response_GetHealth* get_health);

  // optional .mesos.agent.Response.GetFlags get_flags = 3;
  bool has_get_flags() const;
  void clear_get_flags();
  static const int kGetFlagsFieldNumber = 3;
  const ::mesos::agent::Response_GetFlags& get_flags() const;
  ::mesos::agent::Response_GetFlags* release_get_flags();
  ::mesos::agent::Response_GetFlags* mutable_get_flags();
  void set_allocated_get_flags(::mesos::agent::Response_GetFlags* get_flags);

  // optional .mesos.agent.Response.GetVersion get_version = 4;
  bool has_get_version() const;
  void clear_get_version();
  static const int kGetVersionFieldNumber = 4;
  const ::mesos::agent::Response_GetVersion& get_version() const;
  ::mesos::agent::Response_GetVersion* release_get_version();
  ::mesos::agent::Response_GetVersion* mutable_get_version();
  void set_allocated_get_version(::mesos::agent::Response_GetVersion* get_version);

  // optional .mesos.agent.Response.GetMetrics get_metrics = 5;
  bool has_get_metrics() const;
  void clear_get_metrics();
  static const int kGetMetricsFieldNumber = 5;
  const ::mesos::agent::Response_GetMetrics& get_metrics() const;
  ::mesos::agent::Response_GetMetrics* release_get_metrics();
  ::mesos::agent::Response_GetMetrics* mutable_get_metrics();
  void set_allocated_get_metrics(::mesos::agent::Response_GetMetrics* get_metrics);

  // optional .mesos.agent.Response.GetLoggingLevel get_logging_level = 6;
  bool has_get_logging_level() const;
  void clear_get_logging_level();
  static const int kGetLoggingLevelFieldNumber = 6;
  const ::mesos::agent::Response_GetLoggingLevel& get_logging_level() const;
  ::mesos::agent::Response_GetLoggingLevel* release_get_logging_level();
  ::mesos::agent::Response_GetLoggingLevel* mutable_get_logging_level();
  void set_allocated_get_logging_level(::mesos::agent::Response_GetLoggingLevel* get_logging_level);

  // optional .mesos.agent.Response.ListFiles list_files = 7;
  bool has_list_files() const;
  void clear_list_files();
  static const int kListFilesFieldNumber = 7;
  const ::mesos::agent::Response_ListFiles& list_files() const;
  ::mesos::agent::Response_ListFiles* release_list_files();
  ::mesos::agent::Response_ListFiles* mutable_list_files();
  void set_allocated_list_files(::mesos::agent::Response_ListFiles* list_files);

  // optional .mesos.agent.Response.ReadFile read_file = 8;
  bool has_read_file() const;
  void clear_read_file();
  static const int kReadFileFieldNumber = 8;
  const ::mesos::agent::Response_ReadFile& read_file() const;
  ::mesos::agent::Response_ReadFile* release_read_file();
  ::mesos::agent::Response_ReadFile* mutable_read_file();
  void set_allocated_read_file(::mesos::agent::Response_ReadFile* read_file);

  // optional .mesos.agent.Response.GetState get_state = 9;
  bool has_get_state() const;
  void clear_get_state();
  static const int kGetStateFieldNumber = 9;
  const ::mesos::agent::Response_GetState& get_state() const;
  ::mesos::agent::Response_GetState* release_get_state();
  ::mesos::agent::Response_GetState* mutable_get_state();
  void set_allocated_get_state(::mesos::agent::Response_GetState* get_state);

  // optional .mesos.agent.Response.GetContainers get_containers = 10;
  bool has_get_containers() const;
  void clear_get_containers();
  static const int kGetContainersFieldNumber = 10;
  const ::mesos::agent::Response_GetContainers& get_containers() const;
  ::mesos::agent::Response_GetContainers* release_get_containers();
  ::mesos::agent::Response_GetContainers* mutable_get_containers();
  void set_allocated_get_containers(::mesos::agent::Response_GetContainers* get_containers);

  // optional .mesos.agent.Response.GetFrameworks get_frameworks = 11;
  bool has_get_frameworks() const;
  void clear_get_frameworks();
  static const int kGetFrameworksFieldNumber = 11;
  const ::mesos::agent::Response_GetFrameworks& get_frameworks() const;
  ::mesos::agent::Response_GetFrameworks* release_get_frameworks();
  ::mesos::agent::Response_GetFrameworks* mutable_get_frameworks();
  void set_allocated_get_frameworks(::mesos::agent::Response_GetFrameworks* get_frameworks);

  // optional .mesos.agent.Response.GetExecutors get_executors = 12;
  bool has_get_executors() const;
  void clear_get_executors();
  static const int kGetExecutorsFieldNumber = 12;
  const ::mesos::agent::Response_GetExecutors& get_executors() const;
  ::mesos::agent::Response_GetExecutors* release_get_executors();
  ::mesos::agent::Response_GetExecutors* mutable_get_executors();
  void set_allocated_get_executors(::mesos::agent::Response_GetExecutors* get_executors);

  // optional .mesos.agent.Response.GetTasks get_tasks = 13;
  bool has_get_tasks() const;
  void clear_get_tasks();
  static const int kGetTasksFieldNumber = 13;
  const ::mesos::agent::Response_GetTasks& get_tasks() const;
  ::mesos::agent::Response_GetTasks* release_get_tasks();
  ::mesos::agent::Response_GetTasks* mutable_get_tasks();
  void set_allocated_get_tasks(::mesos::agent::Response_GetTasks* get_tasks);

  // optional .mesos.agent.Response.WaitNestedContainer wait_nested_container = 14;
  bool has_wait_nested_container() const;
  void clear_wait_nested_container();
  static const int kWaitNestedContainerFieldNumber = 14;
  const ::mesos::agent::Response_WaitNestedContainer& wait_nested_container() const;
  ::mesos::agent::Response_WaitNestedContainer* release_wait_nested_container();
  ::mesos::agent::Response_WaitNestedContainer* mutable_wait_nested_container();
  void set_allocated_wait_nested_container(::mesos::agent::Response_WaitNestedContainer* wait_nested_container);

  // optional .mesos.agent.Response.GetAgent get_agent = 15;
  bool has_get_agent() const;
  void clear_get_agent();
  static const int kGetAgentFieldNumber = 15;
  const ::mesos::agent::Response_GetAgent& get_agent() const;
  ::mesos::agent::Response_GetAgent* release_get_agent();
  ::mesos::agent::Response_GetAgent* mutable_get_agent();
  void set_allocated_get_agent(::mesos::agent::Response_GetAgent* get_agent);

  // optional .mesos.agent.Response.WaitContainer wait_container = 16;
  bool has_wait_container() const;
  void clear_wait_container();
  static const int kWaitContainerFieldNumber = 16;
  const ::mesos::agent::Response_WaitContainer& wait_container() const;
  ::mesos::agent::Response_WaitContainer* release_wait_container();
  ::mesos::agent::Response_WaitContainer* mutable_wait_container();
  void set_allocated_wait_container(::mesos::agent::Response_WaitContainer* wait_container);

  // optional .mesos.agent.Response.GetResourceProviders get_resource_providers = 17;
  bool has_get_resource_providers() const;
  void clear_get_resource_providers();
  static const int kGetResourceProvidersFieldNumber = 17;
  const ::mesos::agent::Response_GetResourceProviders& get_resource_providers() const;
  ::mesos::agent::Response_GetResourceProviders* release_get_resource_providers();
  ::mesos::agent::Response_GetResourceProviders* mutable_get_resource_providers();
  void set_allocated_get_resource_providers(::mesos::agent::Response_GetResourceProviders* get_resource_providers);

  // optional .mesos.agent.Response.GetOperations get_operations = 18;
  bool has_get_operations() const;
  void clear_get_operations();
  static const int kGetOperationsFieldNumber = 18;
  const ::mesos::agent::Response_GetOperations& get_operations() const;
  ::mesos::agent::Response_GetOperations* release_get_operations();
  ::mesos::agent::Response_GetOperations* mutable_get_operations();
  void set_allocated_get_operations(::mesos::agent::Response_GetOperations* get_operations);

  // optional .mesos.agent.Response.Type type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::mesos::agent::Response_Type type() const;
  void set_type(::mesos::agent::Response_Type value);

  // @@protoc_insertion_point(class_scope:mesos.agent.Response)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_get_health();
  void clear_has_get_health();
  void set_has_get_flags();
  void clear_has_get_flags();
  void set_has_get_version();
  void clear_has_get_version();
  void set_has_get_metrics();
  void clear_has_get_metrics();
  void set_has_get_logging_level();
  void clear_has_get_logging_level();
  void set_has_list_files();
  void clear_has_list_files();
  void set_has_read_file();
  void clear_has_read_file();
  void set_has_get_state();
  void clear_has_get_state();
  void set_has_get_containers();
  void clear_has_get_containers();
  void set_has_get_frameworks();
  void clear_has_get_frameworks();
  void set_has_get_executors();
  void clear_has_get_executors();
  void set_has_get_operations();
  void clear_has_get_operations();
  void set_has_get_tasks();
  void clear_has_get_tasks();
  void set_has_get_agent();
  void clear_has_get_agent();
  void set_has_get_resource_providers();
  void clear_has_get_resource_providers();
  void set_has_wait_nested_container();
  void clear_has_wait_nested_container();
  void set_has_wait_container();
  void clear_has_wait_container();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::agent::Response_GetHealth* get_health_;
  ::mesos::agent::Response_GetFlags* get_flags_;
  ::mesos::agent::Response_GetVersion* get_version_;
  ::mesos::agent::Response_GetMetrics* get_metrics_;
  ::mesos::agent::Response_GetLoggingLevel* get_logging_level_;
  ::mesos::agent::Response_ListFiles* list_files_;
  ::mesos::agent::Response_ReadFile* read_file_;
  ::mesos::agent::Response_GetState* get_state_;
  ::mesos::agent::Response_GetContainers* get_containers_;
  ::mesos::agent::Response_GetFrameworks* get_frameworks_;
  ::mesos::agent::Response_GetExecutors* get_executors_;
  ::mesos::agent::Response_GetTasks* get_tasks_;
  ::mesos::agent::Response_WaitNestedContainer* wait_nested_container_;
  ::mesos::agent::Response_GetAgent* get_agent_;
  ::mesos::agent::Response_WaitContainer* wait_container_;
  ::mesos::agent::Response_GetResourceProviders* get_resource_providers_;
  ::mesos::agent::Response_GetOperations* get_operations_;
  int type_;
  friend struct ::protobuf_mesos_2fagent_2fagent_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fagent_2fagent_2eproto::InitDefaultsResponseImpl();
};
// -------------------------------------------------------------------

class ProcessIO_Data : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.agent.ProcessIO.Data) */ {
 public:
  ProcessIO_Data();
  virtual ~ProcessIO_Data();

  ProcessIO_Data(const ProcessIO_Data& from);

  inline ProcessIO_Data& operator=(const ProcessIO_Data& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProcessIO_Data(ProcessIO_Data&& from) noexcept
    : ProcessIO_Data() {
    *this = ::std::move(from);
  }

  inline ProcessIO_Data& operator=(ProcessIO_Data&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProcessIO_Data& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProcessIO_Data* internal_default_instance() {
    return reinterpret_cast<const ProcessIO_Data*>(
               &_ProcessIO_Data_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    43;

  void Swap(ProcessIO_Data* other);
  friend void swap(ProcessIO_Data& a, ProcessIO_Data& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProcessIO_Data* New() const PROTOBUF_FINAL { return New(NULL); }

  ProcessIO_Data* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ProcessIO_Data& from);
  void MergeFrom(const ProcessIO_Data& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ProcessIO_Data* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef ProcessIO_Data_Type Type;
  static const Type UNKNOWN =
    ProcessIO_Data_Type_UNKNOWN;
  static const Type STDIN =
    ProcessIO_Data_Type_STDIN;
  static const Type STDOUT =
    ProcessIO_Data_Type_STDOUT;
  static const Type STDERR =
    ProcessIO_Data_Type_STDERR;
  static inline bool Type_IsValid(int value) {
    return ProcessIO_Data_Type_IsValid(value);
  }
  static const Type Type_MIN =
    ProcessIO_Data_Type_Type_MIN;
  static const Type Type_MAX =
    ProcessIO_Data_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    ProcessIO_Data_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return ProcessIO_Data_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return ProcessIO_Data_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return ProcessIO_Data_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional bytes data = 2;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 2;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // optional .mesos.agent.ProcessIO.Data.Type type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::mesos::agent::ProcessIO_Data_Type type() const;
  void set_type(::mesos::agent::ProcessIO_Data_Type value);

  // @@protoc_insertion_point(class_scope:mesos.agent.ProcessIO.Data)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_data();
  void clear_has_data();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  int type_;
  friend struct ::protobuf_mesos_2fagent_2fagent_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fagent_2fagent_2eproto::InitDefaultsProcessIO_DataImpl();
};
// -------------------------------------------------------------------

class ProcessIO_Control_Heartbeat : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.agent.ProcessIO.Control.Heartbeat) */ {
 public:
  ProcessIO_Control_Heartbeat();
  virtual ~ProcessIO_Control_Heartbeat();

  ProcessIO_Control_Heartbeat(const ProcessIO_Control_Heartbeat& from);

  inline ProcessIO_Control_Heartbeat& operator=(const ProcessIO_Control_Heartbeat& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProcessIO_Control_Heartbeat(ProcessIO_Control_Heartbeat&& from) noexcept
    : ProcessIO_Control_Heartbeat() {
    *this = ::std::move(from);
  }

  inline ProcessIO_Control_Heartbeat& operator=(ProcessIO_Control_Heartbeat&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProcessIO_Control_Heartbeat& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProcessIO_Control_Heartbeat* internal_default_instance() {
    return reinterpret_cast<const ProcessIO_Control_Heartbeat*>(
               &_ProcessIO_Control_Heartbeat_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    44;

  void Swap(ProcessIO_Control_Heartbeat* other);
  friend void swap(ProcessIO_Control_Heartbeat& a, ProcessIO_Control_Heartbeat& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProcessIO_Control_Heartbeat* New() const PROTOBUF_FINAL { return New(NULL); }

  ProcessIO_Control_Heartbeat* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ProcessIO_Control_Heartbeat& from);
  void MergeFrom(const ProcessIO_Control_Heartbeat& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ProcessIO_Control_Heartbeat* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mesos.DurationInfo interval = 1;
  bool has_interval() const;
  void clear_interval();
  static const int kIntervalFieldNumber = 1;
  const ::mesos::DurationInfo& interval() const;
  ::mesos::DurationInfo* release_interval();
  ::mesos::DurationInfo* mutable_interval();
  void set_allocated_interval(::mesos::DurationInfo* interval);

  // @@protoc_insertion_point(class_scope:mesos.agent.ProcessIO.Control.Heartbeat)
 private:
  void set_has_interval();
  void clear_has_interval();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::DurationInfo* interval_;
  friend struct ::protobuf_mesos_2fagent_2fagent_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fagent_2fagent_2eproto::InitDefaultsProcessIO_Control_HeartbeatImpl();
};
// -------------------------------------------------------------------

class ProcessIO_Control : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.agent.ProcessIO.Control) */ {
 public:
  ProcessIO_Control();
  virtual ~ProcessIO_Control();

  ProcessIO_Control(const ProcessIO_Control& from);

  inline ProcessIO_Control& operator=(const ProcessIO_Control& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProcessIO_Control(ProcessIO_Control&& from) noexcept
    : ProcessIO_Control() {
    *this = ::std::move(from);
  }

  inline ProcessIO_Control& operator=(ProcessIO_Control&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProcessIO_Control& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProcessIO_Control* internal_default_instance() {
    return reinterpret_cast<const ProcessIO_Control*>(
               &_ProcessIO_Control_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    45;

  void Swap(ProcessIO_Control* other);
  friend void swap(ProcessIO_Control& a, ProcessIO_Control& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProcessIO_Control* New() const PROTOBUF_FINAL { return New(NULL); }

  ProcessIO_Control* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ProcessIO_Control& from);
  void MergeFrom(const ProcessIO_Control& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ProcessIO_Control* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef ProcessIO_Control_Heartbeat Heartbeat;

  typedef ProcessIO_Control_Type Type;
  static const Type UNKNOWN =
    ProcessIO_Control_Type_UNKNOWN;
  static const Type TTY_INFO =
    ProcessIO_Control_Type_TTY_INFO;
  static const Type HEARTBEAT =
    ProcessIO_Control_Type_HEARTBEAT;
  static inline bool Type_IsValid(int value) {
    return ProcessIO_Control_Type_IsValid(value);
  }
  static const Type Type_MIN =
    ProcessIO_Control_Type_Type_MIN;
  static const Type Type_MAX =
    ProcessIO_Control_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    ProcessIO_Control_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return ProcessIO_Control_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return ProcessIO_Control_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return ProcessIO_Control_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .mesos.TTYInfo tty_info = 2;
  bool has_tty_info() const;
  void clear_tty_info();
  static const int kTtyInfoFieldNumber = 2;
  const ::mesos::TTYInfo& tty_info() const;
  ::mesos::TTYInfo* release_tty_info();
  ::mesos::TTYInfo* mutable_tty_info();
  void set_allocated_tty_info(::mesos::TTYInfo* tty_info);

  // optional .mesos.agent.ProcessIO.Control.Heartbeat heartbeat = 3;
  bool has_heartbeat() const;
  void clear_heartbeat();
  static const int kHeartbeatFieldNumber = 3;
  const ::mesos::agent::ProcessIO_Control_Heartbeat& heartbeat() const;
  ::mesos::agent::ProcessIO_Control_Heartbeat* release_heartbeat();
  ::mesos::agent::ProcessIO_Control_Heartbeat* mutable_heartbeat();
  void set_allocated_heartbeat(::mesos::agent::ProcessIO_Control_Heartbeat* heartbeat);

  // optional .mesos.agent.ProcessIO.Control.Type type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::mesos::agent::ProcessIO_Control_Type type() const;
  void set_type(::mesos::agent::ProcessIO_Control_Type value);

  // @@protoc_insertion_point(class_scope:mesos.agent.ProcessIO.Control)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_tty_info();
  void clear_has_tty_info();
  void set_has_heartbeat();
  void clear_has_heartbeat();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::TTYInfo* tty_info_;
  ::mesos::agent::ProcessIO_Control_Heartbeat* heartbeat_;
  int type_;
  friend struct ::protobuf_mesos_2fagent_2fagent_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fagent_2fagent_2eproto::InitDefaultsProcessIO_ControlImpl();
};
// -------------------------------------------------------------------

class ProcessIO : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.agent.ProcessIO) */ {
 public:
  ProcessIO();
  virtual ~ProcessIO();

  ProcessIO(const ProcessIO& from);

  inline ProcessIO& operator=(const ProcessIO& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProcessIO(ProcessIO&& from) noexcept
    : ProcessIO() {
    *this = ::std::move(from);
  }

  inline ProcessIO& operator=(ProcessIO&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProcessIO& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProcessIO* internal_default_instance() {
    return reinterpret_cast<const ProcessIO*>(
               &_ProcessIO_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    46;

  void Swap(ProcessIO* other);
  friend void swap(ProcessIO& a, ProcessIO& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProcessIO* New() const PROTOBUF_FINAL { return New(NULL); }

  ProcessIO* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ProcessIO& from);
  void MergeFrom(const ProcessIO& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ProcessIO* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef ProcessIO_Data Data;
  typedef ProcessIO_Control Control;

  typedef ProcessIO_Type Type;
  static const Type UNKNOWN =
    ProcessIO_Type_UNKNOWN;
  static const Type DATA =
    ProcessIO_Type_DATA;
  static const Type CONTROL =
    ProcessIO_Type_CONTROL;
  static inline bool Type_IsValid(int value) {
    return ProcessIO_Type_IsValid(value);
  }
  static const Type Type_MIN =
    ProcessIO_Type_Type_MIN;
  static const Type Type_MAX =
    ProcessIO_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    ProcessIO_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return ProcessIO_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return ProcessIO_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return ProcessIO_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .mesos.agent.ProcessIO.Data data = 2;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 2;
  const ::mesos::agent::ProcessIO_Data& data() const;
  ::mesos::agent::ProcessIO_Data* release_data();
  ::mesos::agent::ProcessIO_Data* mutable_data();
  void set_allocated_data(::mesos::agent::ProcessIO_Data* data);

  // optional .mesos.agent.ProcessIO.Control control = 3;
  bool has_control() const;
  void clear_control();
  static const int kControlFieldNumber = 3;
  const ::mesos::agent::ProcessIO_Control& control() const;
  ::mesos::agent::ProcessIO_Control* release_control();
  ::mesos::agent::ProcessIO_Control* mutable_control();
  void set_allocated_control(::mesos::agent::ProcessIO_Control* control);

  // optional .mesos.agent.ProcessIO.Type type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::mesos::agent::ProcessIO_Type type() const;
  void set_type(::mesos::agent::ProcessIO_Type value);

  // @@protoc_insertion_point(class_scope:mesos.agent.ProcessIO)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_data();
  void clear_has_data();
  void set_has_control();
  void clear_has_control();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::agent::ProcessIO_Data* data_;
  ::mesos::agent::ProcessIO_Control* control_;
  int type_;
  friend struct ::protobuf_mesos_2fagent_2fagent_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fagent_2fagent_2eproto::InitDefaultsProcessIOImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Call_GetMetrics

// optional .mesos.DurationInfo timeout = 1;
inline bool Call_GetMetrics::has_timeout() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Call_GetMetrics::set_has_timeout() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Call_GetMetrics::clear_has_timeout() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::mesos::DurationInfo& Call_GetMetrics::timeout() const {
  const ::mesos::DurationInfo* p = timeout_;
  // @@protoc_insertion_point(field_get:mesos.agent.Call.GetMetrics.timeout)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::DurationInfo*>(
      &::mesos::_DurationInfo_default_instance_);
}
inline ::mesos::DurationInfo* Call_GetMetrics::release_timeout() {
  // @@protoc_insertion_point(field_release:mesos.agent.Call.GetMetrics.timeout)
  clear_has_timeout();
  ::mesos::DurationInfo* temp = timeout_;
  timeout_ = NULL;
  return temp;
}
inline ::mesos::DurationInfo* Call_GetMetrics::mutable_timeout() {
  set_has_timeout();
  if (timeout_ == NULL) {
    timeout_ = new ::mesos::DurationInfo;
  }
  // @@protoc_insertion_point(field_mutable:mesos.agent.Call.GetMetrics.timeout)
  return timeout_;
}
inline void Call_GetMetrics::set_allocated_timeout(::mesos::DurationInfo* timeout) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(timeout_);
  }
  if (timeout) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(timeout)->GetArena();
    if (message_arena != submessage_arena) {
      timeout = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, timeout, submessage_arena);
    }
    set_has_timeout();
  } else {
    clear_has_timeout();
  }
  timeout_ = timeout;
  // @@protoc_insertion_point(field_set_allocated:mesos.agent.Call.GetMetrics.timeout)
}

// -------------------------------------------------------------------

// Call_SetLoggingLevel

// required uint32 level = 1;
inline bool Call_SetLoggingLevel::has_level() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Call_SetLoggingLevel::set_has_level() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Call_SetLoggingLevel::clear_has_level() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Call_SetLoggingLevel::clear_level() {
  level_ = 0u;
  clear_has_level();
}
inline ::google::protobuf::uint32 Call_SetLoggingLevel::level() const {
  // @@protoc_insertion_point(field_get:mesos.agent.Call.SetLoggingLevel.level)
  return level_;
}
inline void Call_SetLoggingLevel::set_level(::google::protobuf::uint32 value) {
  set_has_level();
  level_ = value;
  // @@protoc_insertion_point(field_set:mesos.agent.Call.SetLoggingLevel.level)
}

// required .mesos.DurationInfo duration = 2;
inline bool Call_SetLoggingLevel::has_duration() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Call_SetLoggingLevel::set_has_duration() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Call_SetLoggingLevel::clear_has_duration() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::mesos::DurationInfo& Call_SetLoggingLevel::duration() const {
  const ::mesos::DurationInfo* p = duration_;
  // @@protoc_insertion_point(field_get:mesos.agent.Call.SetLoggingLevel.duration)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::DurationInfo*>(
      &::mesos::_DurationInfo_default_instance_);
}
inline ::mesos::DurationInfo* Call_SetLoggingLevel::release_duration() {
  // @@protoc_insertion_point(field_release:mesos.agent.Call.SetLoggingLevel.duration)
  clear_has_duration();
  ::mesos::DurationInfo* temp = duration_;
  duration_ = NULL;
  return temp;
}
inline ::mesos::DurationInfo* Call_SetLoggingLevel::mutable_duration() {
  set_has_duration();
  if (duration_ == NULL) {
    duration_ = new ::mesos::DurationInfo;
  }
  // @@protoc_insertion_point(field_mutable:mesos.agent.Call.SetLoggingLevel.duration)
  return duration_;
}
inline void Call_SetLoggingLevel::set_allocated_duration(::mesos::DurationInfo* duration) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(duration_);
  }
  if (duration) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(duration)->GetArena();
    if (message_arena != submessage_arena) {
      duration = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, duration, submessage_arena);
    }
    set_has_duration();
  } else {
    clear_has_duration();
  }
  duration_ = duration;
  // @@protoc_insertion_point(field_set_allocated:mesos.agent.Call.SetLoggingLevel.duration)
}

// -------------------------------------------------------------------

// Call_ListFiles

// required string path = 1;
inline bool Call_ListFiles::has_path() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Call_ListFiles::set_has_path() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Call_ListFiles::clear_has_path() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Call_ListFiles::clear_path() {
  path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_path();
}
inline const ::std::string& Call_ListFiles::path() const {
  // @@protoc_insertion_point(field_get:mesos.agent.Call.ListFiles.path)
  return path_.GetNoArena();
}
inline void Call_ListFiles::set_path(const ::std::string& value) {
  set_has_path();
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.agent.Call.ListFiles.path)
}
#if LANG_CXX11
inline void Call_ListFiles::set_path(::std::string&& value) {
  set_has_path();
  path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mesos.agent.Call.ListFiles.path)
}
#endif
inline void Call_ListFiles::set_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_path();
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.agent.Call.ListFiles.path)
}
inline void Call_ListFiles::set_path(const char* value, size_t size) {
  set_has_path();
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.agent.Call.ListFiles.path)
}
inline ::std::string* Call_ListFiles::mutable_path() {
  set_has_path();
  // @@protoc_insertion_point(field_mutable:mesos.agent.Call.ListFiles.path)
  return path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Call_ListFiles::release_path() {
  // @@protoc_insertion_point(field_release:mesos.agent.Call.ListFiles.path)
  clear_has_path();
  return path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Call_ListFiles::set_allocated_path(::std::string* path) {
  if (path != NULL) {
    set_has_path();
  } else {
    clear_has_path();
  }
  path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), path);
  // @@protoc_insertion_point(field_set_allocated:mesos.agent.Call.ListFiles.path)
}

// -------------------------------------------------------------------

// Call_ReadFile

// required string path = 1;
inline bool Call_ReadFile::has_path() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Call_ReadFile::set_has_path() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Call_ReadFile::clear_has_path() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Call_ReadFile::clear_path() {
  path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_path();
}
inline const ::std::string& Call_ReadFile::path() const {
  // @@protoc_insertion_point(field_get:mesos.agent.Call.ReadFile.path)
  return path_.GetNoArena();
}
inline void Call_ReadFile::set_path(const ::std::string& value) {
  set_has_path();
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.agent.Call.ReadFile.path)
}
#if LANG_CXX11
inline void Call_ReadFile::set_path(::std::string&& value) {
  set_has_path();
  path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mesos.agent.Call.ReadFile.path)
}
#endif
inline void Call_ReadFile::set_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_path();
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.agent.Call.ReadFile.path)
}
inline void Call_ReadFile::set_path(const char* value, size_t size) {
  set_has_path();
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.agent.Call.ReadFile.path)
}
inline ::std::string* Call_ReadFile::mutable_path() {
  set_has_path();
  // @@protoc_insertion_point(field_mutable:mesos.agent.Call.ReadFile.path)
  return path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Call_ReadFile::release_path() {
  // @@protoc_insertion_point(field_release:mesos.agent.Call.ReadFile.path)
  clear_has_path();
  return path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Call_ReadFile::set_allocated_path(::std::string* path) {
  if (path != NULL) {
    set_has_path();
  } else {
    clear_has_path();
  }
  path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), path);
  // @@protoc_insertion_point(field_set_allocated:mesos.agent.Call.ReadFile.path)
}

// required uint64 offset = 2;
inline bool Call_ReadFile::has_offset() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Call_ReadFile::set_has_offset() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Call_ReadFile::clear_has_offset() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Call_ReadFile::clear_offset() {
  offset_ = GOOGLE_ULONGLONG(0);
  clear_has_offset();
}
inline ::google::protobuf::uint64 Call_ReadFile::offset() const {
  // @@protoc_insertion_point(field_get:mesos.agent.Call.ReadFile.offset)
  return offset_;
}
inline void Call_ReadFile::set_offset(::google::protobuf::uint64 value) {
  set_has_offset();
  offset_ = value;
  // @@protoc_insertion_point(field_set:mesos.agent.Call.ReadFile.offset)
}

// optional uint64 length = 3;
inline bool Call_ReadFile::has_length() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Call_ReadFile::set_has_length() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Call_ReadFile::clear_has_length() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Call_ReadFile::clear_length() {
  length_ = GOOGLE_ULONGLONG(0);
  clear_has_length();
}
inline ::google::protobuf::uint64 Call_ReadFile::length() const {
  // @@protoc_insertion_point(field_get:mesos.agent.Call.ReadFile.length)
  return length_;
}
inline void Call_ReadFile::set_length(::google::protobuf::uint64 value) {
  set_has_length();
  length_ = value;
  // @@protoc_insertion_point(field_set:mesos.agent.Call.ReadFile.length)
}

// -------------------------------------------------------------------

// Call_GetContainers

// optional bool show_nested = 1;
inline bool Call_GetContainers::has_show_nested() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Call_GetContainers::set_has_show_nested() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Call_GetContainers::clear_has_show_nested() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Call_GetContainers::clear_show_nested() {
  show_nested_ = false;
  clear_has_show_nested();
}
inline bool Call_GetContainers::show_nested() const {
  // @@protoc_insertion_point(field_get:mesos.agent.Call.GetContainers.show_nested)
  return show_nested_;
}
inline void Call_GetContainers::set_show_nested(bool value) {
  set_has_show_nested();
  show_nested_ = value;
  // @@protoc_insertion_point(field_set:mesos.agent.Call.GetContainers.show_nested)
}

// optional bool show_standalone = 2;
inline bool Call_GetContainers::has_show_standalone() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Call_GetContainers::set_has_show_standalone() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Call_GetContainers::clear_has_show_standalone() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Call_GetContainers::clear_show_standalone() {
  show_standalone_ = false;
  clear_has_show_standalone();
}
inline bool Call_GetContainers::show_standalone() const {
  // @@protoc_insertion_point(field_get:mesos.agent.Call.GetContainers.show_standalone)
  return show_standalone_;
}
inline void Call_GetContainers::set_show_standalone(bool value) {
  set_has_show_standalone();
  show_standalone_ = value;
  // @@protoc_insertion_point(field_set:mesos.agent.Call.GetContainers.show_standalone)
}

// -------------------------------------------------------------------

// Call_LaunchNestedContainer

// required .mesos.ContainerID container_id = 1;
inline bool Call_LaunchNestedContainer::has_container_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Call_LaunchNestedContainer::set_has_container_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Call_LaunchNestedContainer::clear_has_container_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::mesos::ContainerID& Call_LaunchNestedContainer::container_id() const {
  const ::mesos::ContainerID* p = container_id_;
  // @@protoc_insertion_point(field_get:mesos.agent.Call.LaunchNestedContainer.container_id)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ContainerID*>(
      &::mesos::_ContainerID_default_instance_);
}
inline ::mesos::ContainerID* Call_LaunchNestedContainer::release_container_id() {
  // @@protoc_insertion_point(field_release:mesos.agent.Call.LaunchNestedContainer.container_id)
  clear_has_container_id();
  ::mesos::ContainerID* temp = container_id_;
  container_id_ = NULL;
  return temp;
}
inline ::mesos::ContainerID* Call_LaunchNestedContainer::mutable_container_id() {
  set_has_container_id();
  if (container_id_ == NULL) {
    container_id_ = new ::mesos::ContainerID;
  }
  // @@protoc_insertion_point(field_mutable:mesos.agent.Call.LaunchNestedContainer.container_id)
  return container_id_;
}
inline void Call_LaunchNestedContainer::set_allocated_container_id(::mesos::ContainerID* container_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(container_id_);
  }
  if (container_id) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(container_id)->GetArena();
    if (message_arena != submessage_arena) {
      container_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, container_id, submessage_arena);
    }
    set_has_container_id();
  } else {
    clear_has_container_id();
  }
  container_id_ = container_id;
  // @@protoc_insertion_point(field_set_allocated:mesos.agent.Call.LaunchNestedContainer.container_id)
}

// optional .mesos.CommandInfo command = 2;
inline bool Call_LaunchNestedContainer::has_command() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Call_LaunchNestedContainer::set_has_command() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Call_LaunchNestedContainer::clear_has_command() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::mesos::CommandInfo& Call_LaunchNestedContainer::command() const {
  const ::mesos::CommandInfo* p = command_;
  // @@protoc_insertion_point(field_get:mesos.agent.Call.LaunchNestedContainer.command)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::CommandInfo*>(
      &::mesos::_CommandInfo_default_instance_);
}
inline ::mesos::CommandInfo* Call_LaunchNestedContainer::release_command() {
  // @@protoc_insertion_point(field_release:mesos.agent.Call.LaunchNestedContainer.command)
  clear_has_command();
  ::mesos::CommandInfo* temp = command_;
  command_ = NULL;
  return temp;
}
inline ::mesos::CommandInfo* Call_LaunchNestedContainer::mutable_command() {
  set_has_command();
  if (command_ == NULL) {
    command_ = new ::mesos::CommandInfo;
  }
  // @@protoc_insertion_point(field_mutable:mesos.agent.Call.LaunchNestedContainer.command)
  return command_;
}
inline void Call_LaunchNestedContainer::set_allocated_command(::mesos::CommandInfo* command) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(command_);
  }
  if (command) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(command)->GetArena();
    if (message_arena != submessage_arena) {
      command = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, command, submessage_arena);
    }
    set_has_command();
  } else {
    clear_has_command();
  }
  command_ = command;
  // @@protoc_insertion_point(field_set_allocated:mesos.agent.Call.LaunchNestedContainer.command)
}

// optional .mesos.ContainerInfo container = 3;
inline bool Call_LaunchNestedContainer::has_container() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Call_LaunchNestedContainer::set_has_container() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Call_LaunchNestedContainer::clear_has_container() {
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::mesos::ContainerInfo& Call_LaunchNestedContainer::container() const {
  const ::mesos::ContainerInfo* p = container_;
  // @@protoc_insertion_point(field_get:mesos.agent.Call.LaunchNestedContainer.container)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ContainerInfo*>(
      &::mesos::_ContainerInfo_default_instance_);
}
inline ::mesos::ContainerInfo* Call_LaunchNestedContainer::release_container() {
  // @@protoc_insertion_point(field_release:mesos.agent.Call.LaunchNestedContainer.container)
  clear_has_container();
  ::mesos::ContainerInfo* temp = container_;
  container_ = NULL;
  return temp;
}
inline ::mesos::ContainerInfo* Call_LaunchNestedContainer::mutable_container() {
  set_has_container();
  if (container_ == NULL) {
    container_ = new ::mesos::ContainerInfo;
  }
  // @@protoc_insertion_point(field_mutable:mesos.agent.Call.LaunchNestedContainer.container)
  return container_;
}
inline void Call_LaunchNestedContainer::set_allocated_container(::mesos::ContainerInfo* container) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(container_);
  }
  if (container) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(container)->GetArena();
    if (message_arena != submessage_arena) {
      container = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, container, submessage_arena);
    }
    set_has_container();
  } else {
    clear_has_container();
  }
  container_ = container;
  // @@protoc_insertion_point(field_set_allocated:mesos.agent.Call.LaunchNestedContainer.container)
}

// -------------------------------------------------------------------

// Call_WaitNestedContainer

// required .mesos.ContainerID container_id = 1;
inline bool Call_WaitNestedContainer::has_container_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Call_WaitNestedContainer::set_has_container_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Call_WaitNestedContainer::clear_has_container_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::mesos::ContainerID& Call_WaitNestedContainer::container_id() const {
  const ::mesos::ContainerID* p = container_id_;
  // @@protoc_insertion_point(field_get:mesos.agent.Call.WaitNestedContainer.container_id)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ContainerID*>(
      &::mesos::_ContainerID_default_instance_);
}
inline ::mesos::ContainerID* Call_WaitNestedContainer::release_container_id() {
  // @@protoc_insertion_point(field_release:mesos.agent.Call.WaitNestedContainer.container_id)
  clear_has_container_id();
  ::mesos::ContainerID* temp = container_id_;
  container_id_ = NULL;
  return temp;
}
inline ::mesos::ContainerID* Call_WaitNestedContainer::mutable_container_id() {
  set_has_container_id();
  if (container_id_ == NULL) {
    container_id_ = new ::mesos::ContainerID;
  }
  // @@protoc_insertion_point(field_mutable:mesos.agent.Call.WaitNestedContainer.container_id)
  return container_id_;
}
inline void Call_WaitNestedContainer::set_allocated_container_id(::mesos::ContainerID* container_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(container_id_);
  }
  if (container_id) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(container_id)->GetArena();
    if (message_arena != submessage_arena) {
      container_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, container_id, submessage_arena);
    }
    set_has_container_id();
  } else {
    clear_has_container_id();
  }
  container_id_ = container_id;
  // @@protoc_insertion_point(field_set_allocated:mesos.agent.Call.WaitNestedContainer.container_id)
}

// -------------------------------------------------------------------

// Call_KillNestedContainer

// required .mesos.ContainerID container_id = 1;
inline bool Call_KillNestedContainer::has_container_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Call_KillNestedContainer::set_has_container_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Call_KillNestedContainer::clear_has_container_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::mesos::ContainerID& Call_KillNestedContainer::container_id() const {
  const ::mesos::ContainerID* p = container_id_;
  // @@protoc_insertion_point(field_get:mesos.agent.Call.KillNestedContainer.container_id)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ContainerID*>(
      &::mesos::_ContainerID_default_instance_);
}
inline ::mesos::ContainerID* Call_KillNestedContainer::release_container_id() {
  // @@protoc_insertion_point(field_release:mesos.agent.Call.KillNestedContainer.container_id)
  clear_has_container_id();
  ::mesos::ContainerID* temp = container_id_;
  container_id_ = NULL;
  return temp;
}
inline ::mesos::ContainerID* Call_KillNestedContainer::mutable_container_id() {
  set_has_container_id();
  if (container_id_ == NULL) {
    container_id_ = new ::mesos::ContainerID;
  }
  // @@protoc_insertion_point(field_mutable:mesos.agent.Call.KillNestedContainer.container_id)
  return container_id_;
}
inline void Call_KillNestedContainer::set_allocated_container_id(::mesos::ContainerID* container_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(container_id_);
  }
  if (container_id) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(container_id)->GetArena();
    if (message_arena != submessage_arena) {
      container_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, container_id, submessage_arena);
    }
    set_has_container_id();
  } else {
    clear_has_container_id();
  }
  container_id_ = container_id;
  // @@protoc_insertion_point(field_set_allocated:mesos.agent.Call.KillNestedContainer.container_id)
}

// optional int32 signal = 2;
inline bool Call_KillNestedContainer::has_signal() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Call_KillNestedContainer::set_has_signal() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Call_KillNestedContainer::clear_has_signal() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Call_KillNestedContainer::clear_signal() {
  signal_ = 0;
  clear_has_signal();
}
inline ::google::protobuf::int32 Call_KillNestedContainer::signal() const {
  // @@protoc_insertion_point(field_get:mesos.agent.Call.KillNestedContainer.signal)
  return signal_;
}
inline void Call_KillNestedContainer::set_signal(::google::protobuf::int32 value) {
  set_has_signal();
  signal_ = value;
  // @@protoc_insertion_point(field_set:mesos.agent.Call.KillNestedContainer.signal)
}

// -------------------------------------------------------------------

// Call_RemoveNestedContainer

// required .mesos.ContainerID container_id = 1;
inline bool Call_RemoveNestedContainer::has_container_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Call_RemoveNestedContainer::set_has_container_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Call_RemoveNestedContainer::clear_has_container_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::mesos::ContainerID& Call_RemoveNestedContainer::container_id() const {
  const ::mesos::ContainerID* p = container_id_;
  // @@protoc_insertion_point(field_get:mesos.agent.Call.RemoveNestedContainer.container_id)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ContainerID*>(
      &::mesos::_ContainerID_default_instance_);
}
inline ::mesos::ContainerID* Call_RemoveNestedContainer::release_container_id() {
  // @@protoc_insertion_point(field_release:mesos.agent.Call.RemoveNestedContainer.container_id)
  clear_has_container_id();
  ::mesos::ContainerID* temp = container_id_;
  container_id_ = NULL;
  return temp;
}
inline ::mesos::ContainerID* Call_RemoveNestedContainer::mutable_container_id() {
  set_has_container_id();
  if (container_id_ == NULL) {
    container_id_ = new ::mesos::ContainerID;
  }
  // @@protoc_insertion_point(field_mutable:mesos.agent.Call.RemoveNestedContainer.container_id)
  return container_id_;
}
inline void Call_RemoveNestedContainer::set_allocated_container_id(::mesos::ContainerID* container_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(container_id_);
  }
  if (container_id) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(container_id)->GetArena();
    if (message_arena != submessage_arena) {
      container_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, container_id, submessage_arena);
    }
    set_has_container_id();
  } else {
    clear_has_container_id();
  }
  container_id_ = container_id;
  // @@protoc_insertion_point(field_set_allocated:mesos.agent.Call.RemoveNestedContainer.container_id)
}

// -------------------------------------------------------------------

// Call_LaunchNestedContainerSession

// required .mesos.ContainerID container_id = 1;
inline bool Call_LaunchNestedContainerSession::has_container_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Call_LaunchNestedContainerSession::set_has_container_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Call_LaunchNestedContainerSession::clear_has_container_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::mesos::ContainerID& Call_LaunchNestedContainerSession::container_id() const {
  const ::mesos::ContainerID* p = container_id_;
  // @@protoc_insertion_point(field_get:mesos.agent.Call.LaunchNestedContainerSession.container_id)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ContainerID*>(
      &::mesos::_ContainerID_default_instance_);
}
inline ::mesos::ContainerID* Call_LaunchNestedContainerSession::release_container_id() {
  // @@protoc_insertion_point(field_release:mesos.agent.Call.LaunchNestedContainerSession.container_id)
  clear_has_container_id();
  ::mesos::ContainerID* temp = container_id_;
  container_id_ = NULL;
  return temp;
}
inline ::mesos::ContainerID* Call_LaunchNestedContainerSession::mutable_container_id() {
  set_has_container_id();
  if (container_id_ == NULL) {
    container_id_ = new ::mesos::ContainerID;
  }
  // @@protoc_insertion_point(field_mutable:mesos.agent.Call.LaunchNestedContainerSession.container_id)
  return container_id_;
}
inline void Call_LaunchNestedContainerSession::set_allocated_container_id(::mesos::ContainerID* container_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(container_id_);
  }
  if (container_id) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(container_id)->GetArena();
    if (message_arena != submessage_arena) {
      container_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, container_id, submessage_arena);
    }
    set_has_container_id();
  } else {
    clear_has_container_id();
  }
  container_id_ = container_id;
  // @@protoc_insertion_point(field_set_allocated:mesos.agent.Call.LaunchNestedContainerSession.container_id)
}

// optional .mesos.CommandInfo command = 2;
inline bool Call_LaunchNestedContainerSession::has_command() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Call_LaunchNestedContainerSession::set_has_command() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Call_LaunchNestedContainerSession::clear_has_command() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::mesos::CommandInfo& Call_LaunchNestedContainerSession::command() const {
  const ::mesos::CommandInfo* p = command_;
  // @@protoc_insertion_point(field_get:mesos.agent.Call.LaunchNestedContainerSession.command)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::CommandInfo*>(
      &::mesos::_CommandInfo_default_instance_);
}
inline ::mesos::CommandInfo* Call_LaunchNestedContainerSession::release_command() {
  // @@protoc_insertion_point(field_release:mesos.agent.Call.LaunchNestedContainerSession.command)
  clear_has_command();
  ::mesos::CommandInfo* temp = command_;
  command_ = NULL;
  return temp;
}
inline ::mesos::CommandInfo* Call_LaunchNestedContainerSession::mutable_command() {
  set_has_command();
  if (command_ == NULL) {
    command_ = new ::mesos::CommandInfo;
  }
  // @@protoc_insertion_point(field_mutable:mesos.agent.Call.LaunchNestedContainerSession.command)
  return command_;
}
inline void Call_LaunchNestedContainerSession::set_allocated_command(::mesos::CommandInfo* command) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(command_);
  }
  if (command) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(command)->GetArena();
    if (message_arena != submessage_arena) {
      command = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, command, submessage_arena);
    }
    set_has_command();
  } else {
    clear_has_command();
  }
  command_ = command;
  // @@protoc_insertion_point(field_set_allocated:mesos.agent.Call.LaunchNestedContainerSession.command)
}

// optional .mesos.ContainerInfo container = 3;
inline bool Call_LaunchNestedContainerSession::has_container() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Call_LaunchNestedContainerSession::set_has_container() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Call_LaunchNestedContainerSession::clear_has_container() {
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::mesos::ContainerInfo& Call_LaunchNestedContainerSession::container() const {
  const ::mesos::ContainerInfo* p = container_;
  // @@protoc_insertion_point(field_get:mesos.agent.Call.LaunchNestedContainerSession.container)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ContainerInfo*>(
      &::mesos::_ContainerInfo_default_instance_);
}
inline ::mesos::ContainerInfo* Call_LaunchNestedContainerSession::release_container() {
  // @@protoc_insertion_point(field_release:mesos.agent.Call.LaunchNestedContainerSession.container)
  clear_has_container();
  ::mesos::ContainerInfo* temp = container_;
  container_ = NULL;
  return temp;
}
inline ::mesos::ContainerInfo* Call_LaunchNestedContainerSession::mutable_container() {
  set_has_container();
  if (container_ == NULL) {
    container_ = new ::mesos::ContainerInfo;
  }
  // @@protoc_insertion_point(field_mutable:mesos.agent.Call.LaunchNestedContainerSession.container)
  return container_;
}
inline void Call_LaunchNestedContainerSession::set_allocated_container(::mesos::ContainerInfo* container) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(container_);
  }
  if (container) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(container)->GetArena();
    if (message_arena != submessage_arena) {
      container = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, container, submessage_arena);
    }
    set_has_container();
  } else {
    clear_has_container();
  }
  container_ = container;
  // @@protoc_insertion_point(field_set_allocated:mesos.agent.Call.LaunchNestedContainerSession.container)
}

// -------------------------------------------------------------------

// Call_AttachContainerInput

// optional .mesos.agent.Call.AttachContainerInput.Type type = 1;
inline bool Call_AttachContainerInput::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Call_AttachContainerInput::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Call_AttachContainerInput::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Call_AttachContainerInput::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::mesos::agent::Call_AttachContainerInput_Type Call_AttachContainerInput::type() const {
  // @@protoc_insertion_point(field_get:mesos.agent.Call.AttachContainerInput.type)
  return static_cast< ::mesos::agent::Call_AttachContainerInput_Type >(type_);
}
inline void Call_AttachContainerInput::set_type(::mesos::agent::Call_AttachContainerInput_Type value) {
  assert(::mesos::agent::Call_AttachContainerInput_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:mesos.agent.Call.AttachContainerInput.type)
}

// optional .mesos.ContainerID container_id = 2;
inline bool Call_AttachContainerInput::has_container_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Call_AttachContainerInput::set_has_container_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Call_AttachContainerInput::clear_has_container_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::mesos::ContainerID& Call_AttachContainerInput::container_id() const {
  const ::mesos::ContainerID* p = container_id_;
  // @@protoc_insertion_point(field_get:mesos.agent.Call.AttachContainerInput.container_id)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ContainerID*>(
      &::mesos::_ContainerID_default_instance_);
}
inline ::mesos::ContainerID* Call_AttachContainerInput::release_container_id() {
  // @@protoc_insertion_point(field_release:mesos.agent.Call.AttachContainerInput.container_id)
  clear_has_container_id();
  ::mesos::ContainerID* temp = container_id_;
  container_id_ = NULL;
  return temp;
}
inline ::mesos::ContainerID* Call_AttachContainerInput::mutable_container_id() {
  set_has_container_id();
  if (container_id_ == NULL) {
    container_id_ = new ::mesos::ContainerID;
  }
  // @@protoc_insertion_point(field_mutable:mesos.agent.Call.AttachContainerInput.container_id)
  return container_id_;
}
inline void Call_AttachContainerInput::set_allocated_container_id(::mesos::ContainerID* container_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(container_id_);
  }
  if (container_id) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(container_id)->GetArena();
    if (message_arena != submessage_arena) {
      container_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, container_id, submessage_arena);
    }
    set_has_container_id();
  } else {
    clear_has_container_id();
  }
  container_id_ = container_id;
  // @@protoc_insertion_point(field_set_allocated:mesos.agent.Call.AttachContainerInput.container_id)
}

// optional .mesos.agent.ProcessIO process_io = 3;
inline bool Call_AttachContainerInput::has_process_io() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Call_AttachContainerInput::set_has_process_io() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Call_AttachContainerInput::clear_has_process_io() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Call_AttachContainerInput::clear_process_io() {
  if (process_io_ != NULL) process_io_->Clear();
  clear_has_process_io();
}
inline const ::mesos::agent::ProcessIO& Call_AttachContainerInput::process_io() const {
  const ::mesos::agent::ProcessIO* p = process_io_;
  // @@protoc_insertion_point(field_get:mesos.agent.Call.AttachContainerInput.process_io)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::agent::ProcessIO*>(
      &::mesos::agent::_ProcessIO_default_instance_);
}
inline ::mesos::agent::ProcessIO* Call_AttachContainerInput::release_process_io() {
  // @@protoc_insertion_point(field_release:mesos.agent.Call.AttachContainerInput.process_io)
  clear_has_process_io();
  ::mesos::agent::ProcessIO* temp = process_io_;
  process_io_ = NULL;
  return temp;
}
inline ::mesos::agent::ProcessIO* Call_AttachContainerInput::mutable_process_io() {
  set_has_process_io();
  if (process_io_ == NULL) {
    process_io_ = new ::mesos::agent::ProcessIO;
  }
  // @@protoc_insertion_point(field_mutable:mesos.agent.Call.AttachContainerInput.process_io)
  return process_io_;
}
inline void Call_AttachContainerInput::set_allocated_process_io(::mesos::agent::ProcessIO* process_io) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete process_io_;
  }
  if (process_io) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      process_io = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, process_io, submessage_arena);
    }
    set_has_process_io();
  } else {
    clear_has_process_io();
  }
  process_io_ = process_io;
  // @@protoc_insertion_point(field_set_allocated:mesos.agent.Call.AttachContainerInput.process_io)
}

// -------------------------------------------------------------------

// Call_AttachContainerOutput

// required .mesos.ContainerID container_id = 1;
inline bool Call_AttachContainerOutput::has_container_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Call_AttachContainerOutput::set_has_container_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Call_AttachContainerOutput::clear_has_container_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::mesos::ContainerID& Call_AttachContainerOutput::container_id() const {
  const ::mesos::ContainerID* p = container_id_;
  // @@protoc_insertion_point(field_get:mesos.agent.Call.AttachContainerOutput.container_id)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ContainerID*>(
      &::mesos::_ContainerID_default_instance_);
}
inline ::mesos::ContainerID* Call_AttachContainerOutput::release_container_id() {
  // @@protoc_insertion_point(field_release:mesos.agent.Call.AttachContainerOutput.container_id)
  clear_has_container_id();
  ::mesos::ContainerID* temp = container_id_;
  container_id_ = NULL;
  return temp;
}
inline ::mesos::ContainerID* Call_AttachContainerOutput::mutable_container_id() {
  set_has_container_id();
  if (container_id_ == NULL) {
    container_id_ = new ::mesos::ContainerID;
  }
  // @@protoc_insertion_point(field_mutable:mesos.agent.Call.AttachContainerOutput.container_id)
  return container_id_;
}
inline void Call_AttachContainerOutput::set_allocated_container_id(::mesos::ContainerID* container_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(container_id_);
  }
  if (container_id) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(container_id)->GetArena();
    if (message_arena != submessage_arena) {
      container_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, container_id, submessage_arena);
    }
    set_has_container_id();
  } else {
    clear_has_container_id();
  }
  container_id_ = container_id;
  // @@protoc_insertion_point(field_set_allocated:mesos.agent.Call.AttachContainerOutput.container_id)
}

// -------------------------------------------------------------------

// Call_LaunchContainer

// required .mesos.ContainerID container_id = 1;
inline bool Call_LaunchContainer::has_container_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Call_LaunchContainer::set_has_container_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Call_LaunchContainer::clear_has_container_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::mesos::ContainerID& Call_LaunchContainer::container_id() const {
  const ::mesos::ContainerID* p = container_id_;
  // @@protoc_insertion_point(field_get:mesos.agent.Call.LaunchContainer.container_id)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ContainerID*>(
      &::mesos::_ContainerID_default_instance_);
}
inline ::mesos::ContainerID* Call_LaunchContainer::release_container_id() {
  // @@protoc_insertion_point(field_release:mesos.agent.Call.LaunchContainer.container_id)
  clear_has_container_id();
  ::mesos::ContainerID* temp = container_id_;
  container_id_ = NULL;
  return temp;
}
inline ::mesos::ContainerID* Call_LaunchContainer::mutable_container_id() {
  set_has_container_id();
  if (container_id_ == NULL) {
    container_id_ = new ::mesos::ContainerID;
  }
  // @@protoc_insertion_point(field_mutable:mesos.agent.Call.LaunchContainer.container_id)
  return container_id_;
}
inline void Call_LaunchContainer::set_allocated_container_id(::mesos::ContainerID* container_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(container_id_);
  }
  if (container_id) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(container_id)->GetArena();
    if (message_arena != submessage_arena) {
      container_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, container_id, submessage_arena);
    }
    set_has_container_id();
  } else {
    clear_has_container_id();
  }
  container_id_ = container_id;
  // @@protoc_insertion_point(field_set_allocated:mesos.agent.Call.LaunchContainer.container_id)
}

// optional .mesos.CommandInfo command = 2;
inline bool Call_LaunchContainer::has_command() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Call_LaunchContainer::set_has_command() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Call_LaunchContainer::clear_has_command() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::mesos::CommandInfo& Call_LaunchContainer::command() const {
  const ::mesos::CommandInfo* p = command_;
  // @@protoc_insertion_point(field_get:mesos.agent.Call.LaunchContainer.command)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::CommandInfo*>(
      &::mesos::_CommandInfo_default_instance_);
}
inline ::mesos::CommandInfo* Call_LaunchContainer::release_command() {
  // @@protoc_insertion_point(field_release:mesos.agent.Call.LaunchContainer.command)
  clear_has_command();
  ::mesos::CommandInfo* temp = command_;
  command_ = NULL;
  return temp;
}
inline ::mesos::CommandInfo* Call_LaunchContainer::mutable_command() {
  set_has_command();
  if (command_ == NULL) {
    command_ = new ::mesos::CommandInfo;
  }
  // @@protoc_insertion_point(field_mutable:mesos.agent.Call.LaunchContainer.command)
  return command_;
}
inline void Call_LaunchContainer::set_allocated_command(::mesos::CommandInfo* command) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(command_);
  }
  if (command) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(command)->GetArena();
    if (message_arena != submessage_arena) {
      command = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, command, submessage_arena);
    }
    set_has_command();
  } else {
    clear_has_command();
  }
  command_ = command;
  // @@protoc_insertion_point(field_set_allocated:mesos.agent.Call.LaunchContainer.command)
}

// repeated .mesos.Resource resources = 3;
inline int Call_LaunchContainer::resources_size() const {
  return resources_.size();
}
inline const ::mesos::Resource& Call_LaunchContainer::resources(int index) const {
  // @@protoc_insertion_point(field_get:mesos.agent.Call.LaunchContainer.resources)
  return resources_.Get(index);
}
inline ::mesos::Resource* Call_LaunchContainer::mutable_resources(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.agent.Call.LaunchContainer.resources)
  return resources_.Mutable(index);
}
inline ::mesos::Resource* Call_LaunchContainer::add_resources() {
  // @@protoc_insertion_point(field_add:mesos.agent.Call.LaunchContainer.resources)
  return resources_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
Call_LaunchContainer::mutable_resources() {
  // @@protoc_insertion_point(field_mutable_list:mesos.agent.Call.LaunchContainer.resources)
  return &resources_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
Call_LaunchContainer::resources() const {
  // @@protoc_insertion_point(field_list:mesos.agent.Call.LaunchContainer.resources)
  return resources_;
}

// optional .mesos.ContainerInfo container = 4;
inline bool Call_LaunchContainer::has_container() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Call_LaunchContainer::set_has_container() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Call_LaunchContainer::clear_has_container() {
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::mesos::ContainerInfo& Call_LaunchContainer::container() const {
  const ::mesos::ContainerInfo* p = container_;
  // @@protoc_insertion_point(field_get:mesos.agent.Call.LaunchContainer.container)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ContainerInfo*>(
      &::mesos::_ContainerInfo_default_instance_);
}
inline ::mesos::ContainerInfo* Call_LaunchContainer::release_container() {
  // @@protoc_insertion_point(field_release:mesos.agent.Call.LaunchContainer.container)
  clear_has_container();
  ::mesos::ContainerInfo* temp = container_;
  container_ = NULL;
  return temp;
}
inline ::mesos::ContainerInfo* Call_LaunchContainer::mutable_container() {
  set_has_container();
  if (container_ == NULL) {
    container_ = new ::mesos::ContainerInfo;
  }
  // @@protoc_insertion_point(field_mutable:mesos.agent.Call.LaunchContainer.container)
  return container_;
}
inline void Call_LaunchContainer::set_allocated_container(::mesos::ContainerInfo* container) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(container_);
  }
  if (container) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(container)->GetArena();
    if (message_arena != submessage_arena) {
      container = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, container, submessage_arena);
    }
    set_has_container();
  } else {
    clear_has_container();
  }
  container_ = container;
  // @@protoc_insertion_point(field_set_allocated:mesos.agent.Call.LaunchContainer.container)
}

// -------------------------------------------------------------------

// Call_WaitContainer

// required .mesos.ContainerID container_id = 1;
inline bool Call_WaitContainer::has_container_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Call_WaitContainer::set_has_container_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Call_WaitContainer::clear_has_container_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::mesos::ContainerID& Call_WaitContainer::container_id() const {
  const ::mesos::ContainerID* p = container_id_;
  // @@protoc_insertion_point(field_get:mesos.agent.Call.WaitContainer.container_id)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ContainerID*>(
      &::mesos::_ContainerID_default_instance_);
}
inline ::mesos::ContainerID* Call_WaitContainer::release_container_id() {
  // @@protoc_insertion_point(field_release:mesos.agent.Call.WaitContainer.container_id)
  clear_has_container_id();
  ::mesos::ContainerID* temp = container_id_;
  container_id_ = NULL;
  return temp;
}
inline ::mesos::ContainerID* Call_WaitContainer::mutable_container_id() {
  set_has_container_id();
  if (container_id_ == NULL) {
    container_id_ = new ::mesos::ContainerID;
  }
  // @@protoc_insertion_point(field_mutable:mesos.agent.Call.WaitContainer.container_id)
  return container_id_;
}
inline void Call_WaitContainer::set_allocated_container_id(::mesos::ContainerID* container_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(container_id_);
  }
  if (container_id) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(container_id)->GetArena();
    if (message_arena != submessage_arena) {
      container_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, container_id, submessage_arena);
    }
    set_has_container_id();
  } else {
    clear_has_container_id();
  }
  container_id_ = container_id;
  // @@protoc_insertion_point(field_set_allocated:mesos.agent.Call.WaitContainer.container_id)
}

// -------------------------------------------------------------------

// Call_KillContainer

// required .mesos.ContainerID container_id = 1;
inline bool Call_KillContainer::has_container_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Call_KillContainer::set_has_container_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Call_KillContainer::clear_has_container_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::mesos::ContainerID& Call_KillContainer::container_id() const {
  const ::mesos::ContainerID* p = container_id_;
  // @@protoc_insertion_point(field_get:mesos.agent.Call.KillContainer.container_id)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ContainerID*>(
      &::mesos::_ContainerID_default_instance_);
}
inline ::mesos::ContainerID* Call_KillContainer::release_container_id() {
  // @@protoc_insertion_point(field_release:mesos.agent.Call.KillContainer.container_id)
  clear_has_container_id();
  ::mesos::ContainerID* temp = container_id_;
  container_id_ = NULL;
  return temp;
}
inline ::mesos::ContainerID* Call_KillContainer::mutable_container_id() {
  set_has_container_id();
  if (container_id_ == NULL) {
    container_id_ = new ::mesos::ContainerID;
  }
  // @@protoc_insertion_point(field_mutable:mesos.agent.Call.KillContainer.container_id)
  return container_id_;
}
inline void Call_KillContainer::set_allocated_container_id(::mesos::ContainerID* container_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(container_id_);
  }
  if (container_id) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(container_id)->GetArena();
    if (message_arena != submessage_arena) {
      container_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, container_id, submessage_arena);
    }
    set_has_container_id();
  } else {
    clear_has_container_id();
  }
  container_id_ = container_id;
  // @@protoc_insertion_point(field_set_allocated:mesos.agent.Call.KillContainer.container_id)
}

// optional int32 signal = 2;
inline bool Call_KillContainer::has_signal() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Call_KillContainer::set_has_signal() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Call_KillContainer::clear_has_signal() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Call_KillContainer::clear_signal() {
  signal_ = 0;
  clear_has_signal();
}
inline ::google::protobuf::int32 Call_KillContainer::signal() const {
  // @@protoc_insertion_point(field_get:mesos.agent.Call.KillContainer.signal)
  return signal_;
}
inline void Call_KillContainer::set_signal(::google::protobuf::int32 value) {
  set_has_signal();
  signal_ = value;
  // @@protoc_insertion_point(field_set:mesos.agent.Call.KillContainer.signal)
}

// -------------------------------------------------------------------

// Call_RemoveContainer

// required .mesos.ContainerID container_id = 1;
inline bool Call_RemoveContainer::has_container_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Call_RemoveContainer::set_has_container_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Call_RemoveContainer::clear_has_container_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::mesos::ContainerID& Call_RemoveContainer::container_id() const {
  const ::mesos::ContainerID* p = container_id_;
  // @@protoc_insertion_point(field_get:mesos.agent.Call.RemoveContainer.container_id)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ContainerID*>(
      &::mesos::_ContainerID_default_instance_);
}
inline ::mesos::ContainerID* Call_RemoveContainer::release_container_id() {
  // @@protoc_insertion_point(field_release:mesos.agent.Call.RemoveContainer.container_id)
  clear_has_container_id();
  ::mesos::ContainerID* temp = container_id_;
  container_id_ = NULL;
  return temp;
}
inline ::mesos::ContainerID* Call_RemoveContainer::mutable_container_id() {
  set_has_container_id();
  if (container_id_ == NULL) {
    container_id_ = new ::mesos::ContainerID;
  }
  // @@protoc_insertion_point(field_mutable:mesos.agent.Call.RemoveContainer.container_id)
  return container_id_;
}
inline void Call_RemoveContainer::set_allocated_container_id(::mesos::ContainerID* container_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(container_id_);
  }
  if (container_id) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(container_id)->GetArena();
    if (message_arena != submessage_arena) {
      container_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, container_id, submessage_arena);
    }
    set_has_container_id();
  } else {
    clear_has_container_id();
  }
  container_id_ = container_id;
  // @@protoc_insertion_point(field_set_allocated:mesos.agent.Call.RemoveContainer.container_id)
}

// -------------------------------------------------------------------

// Call_AddResourceProviderConfig

// required .mesos.ResourceProviderInfo info = 1;
inline bool Call_AddResourceProviderConfig::has_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Call_AddResourceProviderConfig::set_has_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Call_AddResourceProviderConfig::clear_has_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::mesos::ResourceProviderInfo& Call_AddResourceProviderConfig::info() const {
  const ::mesos::ResourceProviderInfo* p = info_;
  // @@protoc_insertion_point(field_get:mesos.agent.Call.AddResourceProviderConfig.info)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ResourceProviderInfo*>(
      &::mesos::_ResourceProviderInfo_default_instance_);
}
inline ::mesos::ResourceProviderInfo* Call_AddResourceProviderConfig::release_info() {
  // @@protoc_insertion_point(field_release:mesos.agent.Call.AddResourceProviderConfig.info)
  clear_has_info();
  ::mesos::ResourceProviderInfo* temp = info_;
  info_ = NULL;
  return temp;
}
inline ::mesos::ResourceProviderInfo* Call_AddResourceProviderConfig::mutable_info() {
  set_has_info();
  if (info_ == NULL) {
    info_ = new ::mesos::ResourceProviderInfo;
  }
  // @@protoc_insertion_point(field_mutable:mesos.agent.Call.AddResourceProviderConfig.info)
  return info_;
}
inline void Call_AddResourceProviderConfig::set_allocated_info(::mesos::ResourceProviderInfo* info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(info_);
  }
  if (info) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(info)->GetArena();
    if (message_arena != submessage_arena) {
      info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    set_has_info();
  } else {
    clear_has_info();
  }
  info_ = info;
  // @@protoc_insertion_point(field_set_allocated:mesos.agent.Call.AddResourceProviderConfig.info)
}

// -------------------------------------------------------------------

// Call_UpdateResourceProviderConfig

// required .mesos.ResourceProviderInfo info = 1;
inline bool Call_UpdateResourceProviderConfig::has_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Call_UpdateResourceProviderConfig::set_has_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Call_UpdateResourceProviderConfig::clear_has_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::mesos::ResourceProviderInfo& Call_UpdateResourceProviderConfig::info() const {
  const ::mesos::ResourceProviderInfo* p = info_;
  // @@protoc_insertion_point(field_get:mesos.agent.Call.UpdateResourceProviderConfig.info)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ResourceProviderInfo*>(
      &::mesos::_ResourceProviderInfo_default_instance_);
}
inline ::mesos::ResourceProviderInfo* Call_UpdateResourceProviderConfig::release_info() {
  // @@protoc_insertion_point(field_release:mesos.agent.Call.UpdateResourceProviderConfig.info)
  clear_has_info();
  ::mesos::ResourceProviderInfo* temp = info_;
  info_ = NULL;
  return temp;
}
inline ::mesos::ResourceProviderInfo* Call_UpdateResourceProviderConfig::mutable_info() {
  set_has_info();
  if (info_ == NULL) {
    info_ = new ::mesos::ResourceProviderInfo;
  }
  // @@protoc_insertion_point(field_mutable:mesos.agent.Call.UpdateResourceProviderConfig.info)
  return info_;
}
inline void Call_UpdateResourceProviderConfig::set_allocated_info(::mesos::ResourceProviderInfo* info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(info_);
  }
  if (info) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(info)->GetArena();
    if (message_arena != submessage_arena) {
      info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    set_has_info();
  } else {
    clear_has_info();
  }
  info_ = info;
  // @@protoc_insertion_point(field_set_allocated:mesos.agent.Call.UpdateResourceProviderConfig.info)
}

// -------------------------------------------------------------------

// Call_RemoveResourceProviderConfig

// required string type = 1;
inline bool Call_RemoveResourceProviderConfig::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Call_RemoveResourceProviderConfig::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Call_RemoveResourceProviderConfig::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Call_RemoveResourceProviderConfig::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_type();
}
inline const ::std::string& Call_RemoveResourceProviderConfig::type() const {
  // @@protoc_insertion_point(field_get:mesos.agent.Call.RemoveResourceProviderConfig.type)
  return type_.GetNoArena();
}
inline void Call_RemoveResourceProviderConfig::set_type(const ::std::string& value) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.agent.Call.RemoveResourceProviderConfig.type)
}
#if LANG_CXX11
inline void Call_RemoveResourceProviderConfig::set_type(::std::string&& value) {
  set_has_type();
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mesos.agent.Call.RemoveResourceProviderConfig.type)
}
#endif
inline void Call_RemoveResourceProviderConfig::set_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.agent.Call.RemoveResourceProviderConfig.type)
}
inline void Call_RemoveResourceProviderConfig::set_type(const char* value, size_t size) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.agent.Call.RemoveResourceProviderConfig.type)
}
inline ::std::string* Call_RemoveResourceProviderConfig::mutable_type() {
  set_has_type();
  // @@protoc_insertion_point(field_mutable:mesos.agent.Call.RemoveResourceProviderConfig.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Call_RemoveResourceProviderConfig::release_type() {
  // @@protoc_insertion_point(field_release:mesos.agent.Call.RemoveResourceProviderConfig.type)
  clear_has_type();
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Call_RemoveResourceProviderConfig::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    set_has_type();
  } else {
    clear_has_type();
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:mesos.agent.Call.RemoveResourceProviderConfig.type)
}

// required string name = 2;
inline bool Call_RemoveResourceProviderConfig::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Call_RemoveResourceProviderConfig::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Call_RemoveResourceProviderConfig::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Call_RemoveResourceProviderConfig::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& Call_RemoveResourceProviderConfig::name() const {
  // @@protoc_insertion_point(field_get:mesos.agent.Call.RemoveResourceProviderConfig.name)
  return name_.GetNoArena();
}
inline void Call_RemoveResourceProviderConfig::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.agent.Call.RemoveResourceProviderConfig.name)
}
#if LANG_CXX11
inline void Call_RemoveResourceProviderConfig::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mesos.agent.Call.RemoveResourceProviderConfig.name)
}
#endif
inline void Call_RemoveResourceProviderConfig::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.agent.Call.RemoveResourceProviderConfig.name)
}
inline void Call_RemoveResourceProviderConfig::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.agent.Call.RemoveResourceProviderConfig.name)
}
inline ::std::string* Call_RemoveResourceProviderConfig::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:mesos.agent.Call.RemoveResourceProviderConfig.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Call_RemoveResourceProviderConfig::release_name() {
  // @@protoc_insertion_point(field_release:mesos.agent.Call.RemoveResourceProviderConfig.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Call_RemoveResourceProviderConfig::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:mesos.agent.Call.RemoveResourceProviderConfig.name)
}

// -------------------------------------------------------------------

// Call_PruneImages

// repeated .mesos.Image excluded_images = 1;
inline int Call_PruneImages::excluded_images_size() const {
  return excluded_images_.size();
}
inline const ::mesos::Image& Call_PruneImages::excluded_images(int index) const {
  // @@protoc_insertion_point(field_get:mesos.agent.Call.PruneImages.excluded_images)
  return excluded_images_.Get(index);
}
inline ::mesos::Image* Call_PruneImages::mutable_excluded_images(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.agent.Call.PruneImages.excluded_images)
  return excluded_images_.Mutable(index);
}
inline ::mesos::Image* Call_PruneImages::add_excluded_images() {
  // @@protoc_insertion_point(field_add:mesos.agent.Call.PruneImages.excluded_images)
  return excluded_images_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Image >*
Call_PruneImages::mutable_excluded_images() {
  // @@protoc_insertion_point(field_mutable_list:mesos.agent.Call.PruneImages.excluded_images)
  return &excluded_images_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Image >&
Call_PruneImages::excluded_images() const {
  // @@protoc_insertion_point(field_list:mesos.agent.Call.PruneImages.excluded_images)
  return excluded_images_;
}

// -------------------------------------------------------------------

// Call

// optional .mesos.agent.Call.Type type = 1;
inline bool Call::has_type() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void Call::set_has_type() {
  _has_bits_[0] |= 0x00100000u;
}
inline void Call::clear_has_type() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void Call::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::mesos::agent::Call_Type Call::type() const {
  // @@protoc_insertion_point(field_get:mesos.agent.Call.type)
  return static_cast< ::mesos::agent::Call_Type >(type_);
}
inline void Call::set_type(::mesos::agent::Call_Type value) {
  assert(::mesos::agent::Call_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:mesos.agent.Call.type)
}

// optional .mesos.agent.Call.GetMetrics get_metrics = 2;
inline bool Call::has_get_metrics() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Call::set_has_get_metrics() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Call::clear_has_get_metrics() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Call::clear_get_metrics() {
  if (get_metrics_ != NULL) get_metrics_->Clear();
  clear_has_get_metrics();
}
inline const ::mesos::agent::Call_GetMetrics& Call::get_metrics() const {
  const ::mesos::agent::Call_GetMetrics* p = get_metrics_;
  // @@protoc_insertion_point(field_get:mesos.agent.Call.get_metrics)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::agent::Call_GetMetrics*>(
      &::mesos::agent::_Call_GetMetrics_default_instance_);
}
inline ::mesos::agent::Call_GetMetrics* Call::release_get_metrics() {
  // @@protoc_insertion_point(field_release:mesos.agent.Call.get_metrics)
  clear_has_get_metrics();
  ::mesos::agent::Call_GetMetrics* temp = get_metrics_;
  get_metrics_ = NULL;
  return temp;
}
inline ::mesos::agent::Call_GetMetrics* Call::mutable_get_metrics() {
  set_has_get_metrics();
  if (get_metrics_ == NULL) {
    get_metrics_ = new ::mesos::agent::Call_GetMetrics;
  }
  // @@protoc_insertion_point(field_mutable:mesos.agent.Call.get_metrics)
  return get_metrics_;
}
inline void Call::set_allocated_get_metrics(::mesos::agent::Call_GetMetrics* get_metrics) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete get_metrics_;
  }
  if (get_metrics) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      get_metrics = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, get_metrics, submessage_arena);
    }
    set_has_get_metrics();
  } else {
    clear_has_get_metrics();
  }
  get_metrics_ = get_metrics;
  // @@protoc_insertion_point(field_set_allocated:mesos.agent.Call.get_metrics)
}

// optional .mesos.agent.Call.SetLoggingLevel set_logging_level = 3;
inline bool Call::has_set_logging_level() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Call::set_has_set_logging_level() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Call::clear_has_set_logging_level() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Call::clear_set_logging_level() {
  if (set_logging_level_ != NULL) set_logging_level_->Clear();
  clear_has_set_logging_level();
}
inline const ::mesos::agent::Call_SetLoggingLevel& Call::set_logging_level() const {
  const ::mesos::agent::Call_SetLoggingLevel* p = set_logging_level_;
  // @@protoc_insertion_point(field_get:mesos.agent.Call.set_logging_level)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::agent::Call_SetLoggingLevel*>(
      &::mesos::agent::_Call_SetLoggingLevel_default_instance_);
}
inline ::mesos::agent::Call_SetLoggingLevel* Call::release_set_logging_level() {
  // @@protoc_insertion_point(field_release:mesos.agent.Call.set_logging_level)
  clear_has_set_logging_level();
  ::mesos::agent::Call_SetLoggingLevel* temp = set_logging_level_;
  set_logging_level_ = NULL;
  return temp;
}
inline ::mesos::agent::Call_SetLoggingLevel* Call::mutable_set_logging_level() {
  set_has_set_logging_level();
  if (set_logging_level_ == NULL) {
    set_logging_level_ = new ::mesos::agent::Call_SetLoggingLevel;
  }
  // @@protoc_insertion_point(field_mutable:mesos.agent.Call.set_logging_level)
  return set_logging_level_;
}
inline void Call::set_allocated_set_logging_level(::mesos::agent::Call_SetLoggingLevel* set_logging_level) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete set_logging_level_;
  }
  if (set_logging_level) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      set_logging_level = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, set_logging_level, submessage_arena);
    }
    set_has_set_logging_level();
  } else {
    clear_has_set_logging_level();
  }
  set_logging_level_ = set_logging_level;
  // @@protoc_insertion_point(field_set_allocated:mesos.agent.Call.set_logging_level)
}

// optional .mesos.agent.Call.ListFiles list_files = 4;
inline bool Call::has_list_files() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Call::set_has_list_files() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Call::clear_has_list_files() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Call::clear_list_files() {
  if (list_files_ != NULL) list_files_->Clear();
  clear_has_list_files();
}
inline const ::mesos::agent::Call_ListFiles& Call::list_files() const {
  const ::mesos::agent::Call_ListFiles* p = list_files_;
  // @@protoc_insertion_point(field_get:mesos.agent.Call.list_files)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::agent::Call_ListFiles*>(
      &::mesos::agent::_Call_ListFiles_default_instance_);
}
inline ::mesos::agent::Call_ListFiles* Call::release_list_files() {
  // @@protoc_insertion_point(field_release:mesos.agent.Call.list_files)
  clear_has_list_files();
  ::mesos::agent::Call_ListFiles* temp = list_files_;
  list_files_ = NULL;
  return temp;
}
inline ::mesos::agent::Call_ListFiles* Call::mutable_list_files() {
  set_has_list_files();
  if (list_files_ == NULL) {
    list_files_ = new ::mesos::agent::Call_ListFiles;
  }
  // @@protoc_insertion_point(field_mutable:mesos.agent.Call.list_files)
  return list_files_;
}
inline void Call::set_allocated_list_files(::mesos::agent::Call_ListFiles* list_files) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete list_files_;
  }
  if (list_files) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      list_files = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, list_files, submessage_arena);
    }
    set_has_list_files();
  } else {
    clear_has_list_files();
  }
  list_files_ = list_files;
  // @@protoc_insertion_point(field_set_allocated:mesos.agent.Call.list_files)
}

// optional .mesos.agent.Call.ReadFile read_file = 5;
inline bool Call::has_read_file() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Call::set_has_read_file() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Call::clear_has_read_file() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Call::clear_read_file() {
  if (read_file_ != NULL) read_file_->Clear();
  clear_has_read_file();
}
inline const ::mesos::agent::Call_ReadFile& Call::read_file() const {
  const ::mesos::agent::Call_ReadFile* p = read_file_;
  // @@protoc_insertion_point(field_get:mesos.agent.Call.read_file)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::agent::Call_ReadFile*>(
      &::mesos::agent::_Call_ReadFile_default_instance_);
}
inline ::mesos::agent::Call_ReadFile* Call::release_read_file() {
  // @@protoc_insertion_point(field_release:mesos.agent.Call.read_file)
  clear_has_read_file();
  ::mesos::agent::Call_ReadFile* temp = read_file_;
  read_file_ = NULL;
  return temp;
}
inline ::mesos::agent::Call_ReadFile* Call::mutable_read_file() {
  set_has_read_file();
  if (read_file_ == NULL) {
    read_file_ = new ::mesos::agent::Call_ReadFile;
  }
  // @@protoc_insertion_point(field_mutable:mesos.agent.Call.read_file)
  return read_file_;
}
inline void Call::set_allocated_read_file(::mesos::agent::Call_ReadFile* read_file) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete read_file_;
  }
  if (read_file) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      read_file = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, read_file, submessage_arena);
    }
    set_has_read_file();
  } else {
    clear_has_read_file();
  }
  read_file_ = read_file;
  // @@protoc_insertion_point(field_set_allocated:mesos.agent.Call.read_file)
}

// optional .mesos.agent.Call.GetContainers get_containers = 20;
inline bool Call::has_get_containers() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void Call::set_has_get_containers() {
  _has_bits_[0] |= 0x00040000u;
}
inline void Call::clear_has_get_containers() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void Call::clear_get_containers() {
  if (get_containers_ != NULL) get_containers_->Clear();
  clear_has_get_containers();
}
inline const ::mesos::agent::Call_GetContainers& Call::get_containers() const {
  const ::mesos::agent::Call_GetContainers* p = get_containers_;
  // @@protoc_insertion_point(field_get:mesos.agent.Call.get_containers)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::agent::Call_GetContainers*>(
      &::mesos::agent::_Call_GetContainers_default_instance_);
}
inline ::mesos::agent::Call_GetContainers* Call::release_get_containers() {
  // @@protoc_insertion_point(field_release:mesos.agent.Call.get_containers)
  clear_has_get_containers();
  ::mesos::agent::Call_GetContainers* temp = get_containers_;
  get_containers_ = NULL;
  return temp;
}
inline ::mesos::agent::Call_GetContainers* Call::mutable_get_containers() {
  set_has_get_containers();
  if (get_containers_ == NULL) {
    get_containers_ = new ::mesos::agent::Call_GetContainers;
  }
  // @@protoc_insertion_point(field_mutable:mesos.agent.Call.get_containers)
  return get_containers_;
}
inline void Call::set_allocated_get_containers(::mesos::agent::Call_GetContainers* get_containers) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete get_containers_;
  }
  if (get_containers) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      get_containers = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, get_containers, submessage_arena);
    }
    set_has_get_containers();
  } else {
    clear_has_get_containers();
  }
  get_containers_ = get_containers;
  // @@protoc_insertion_point(field_set_allocated:mesos.agent.Call.get_containers)
}

// optional .mesos.agent.Call.LaunchNestedContainer launch_nested_container = 6 [deprecated = true];
inline bool Call::has_launch_nested_container() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Call::set_has_launch_nested_container() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Call::clear_has_launch_nested_container() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Call::clear_launch_nested_container() {
  if (launch_nested_container_ != NULL) launch_nested_container_->Clear();
  clear_has_launch_nested_container();
}
inline const ::mesos::agent::Call_LaunchNestedContainer& Call::launch_nested_container() const {
  const ::mesos::agent::Call_LaunchNestedContainer* p = launch_nested_container_;
  // @@protoc_insertion_point(field_get:mesos.agent.Call.launch_nested_container)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::agent::Call_LaunchNestedContainer*>(
      &::mesos::agent::_Call_LaunchNestedContainer_default_instance_);
}
inline ::mesos::agent::Call_LaunchNestedContainer* Call::release_launch_nested_container() {
  // @@protoc_insertion_point(field_release:mesos.agent.Call.launch_nested_container)
  clear_has_launch_nested_container();
  ::mesos::agent::Call_LaunchNestedContainer* temp = launch_nested_container_;
  launch_nested_container_ = NULL;
  return temp;
}
inline ::mesos::agent::Call_LaunchNestedContainer* Call::mutable_launch_nested_container() {
  set_has_launch_nested_container();
  if (launch_nested_container_ == NULL) {
    launch_nested_container_ = new ::mesos::agent::Call_LaunchNestedContainer;
  }
  // @@protoc_insertion_point(field_mutable:mesos.agent.Call.launch_nested_container)
  return launch_nested_container_;
}
inline void Call::set_allocated_launch_nested_container(::mesos::agent::Call_LaunchNestedContainer* launch_nested_container) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete launch_nested_container_;
  }
  if (launch_nested_container) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      launch_nested_container = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, launch_nested_container, submessage_arena);
    }
    set_has_launch_nested_container();
  } else {
    clear_has_launch_nested_container();
  }
  launch_nested_container_ = launch_nested_container;
  // @@protoc_insertion_point(field_set_allocated:mesos.agent.Call.launch_nested_container)
}

// optional .mesos.agent.Call.WaitNestedContainer wait_nested_container = 7 [deprecated = true];
inline bool Call::has_wait_nested_container() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Call::set_has_wait_nested_container() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Call::clear_has_wait_nested_container() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Call::clear_wait_nested_container() {
  if (wait_nested_container_ != NULL) wait_nested_container_->Clear();
  clear_has_wait_nested_container();
}
inline const ::mesos::agent::Call_WaitNestedContainer& Call::wait_nested_container() const {
  const ::mesos::agent::Call_WaitNestedContainer* p = wait_nested_container_;
  // @@protoc_insertion_point(field_get:mesos.agent.Call.wait_nested_container)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::agent::Call_WaitNestedContainer*>(
      &::mesos::agent::_Call_WaitNestedContainer_default_instance_);
}
inline ::mesos::agent::Call_WaitNestedContainer* Call::release_wait_nested_container() {
  // @@protoc_insertion_point(field_release:mesos.agent.Call.wait_nested_container)
  clear_has_wait_nested_container();
  ::mesos::agent::Call_WaitNestedContainer* temp = wait_nested_container_;
  wait_nested_container_ = NULL;
  return temp;
}
inline ::mesos::agent::Call_WaitNestedContainer* Call::mutable_wait_nested_container() {
  set_has_wait_nested_container();
  if (wait_nested_container_ == NULL) {
    wait_nested_container_ = new ::mesos::agent::Call_WaitNestedContainer;
  }
  // @@protoc_insertion_point(field_mutable:mesos.agent.Call.wait_nested_container)
  return wait_nested_container_;
}
inline void Call::set_allocated_wait_nested_container(::mesos::agent::Call_WaitNestedContainer* wait_nested_container) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete wait_nested_container_;
  }
  if (wait_nested_container) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      wait_nested_container = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, wait_nested_container, submessage_arena);
    }
    set_has_wait_nested_container();
  } else {
    clear_has_wait_nested_container();
  }
  wait_nested_container_ = wait_nested_container;
  // @@protoc_insertion_point(field_set_allocated:mesos.agent.Call.wait_nested_container)
}

// optional .mesos.agent.Call.KillNestedContainer kill_nested_container = 8 [deprecated = true];
inline bool Call::has_kill_nested_container() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Call::set_has_kill_nested_container() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Call::clear_has_kill_nested_container() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Call::clear_kill_nested_container() {
  if (kill_nested_container_ != NULL) kill_nested_container_->Clear();
  clear_has_kill_nested_container();
}
inline const ::mesos::agent::Call_KillNestedContainer& Call::kill_nested_container() const {
  const ::mesos::agent::Call_KillNestedContainer* p = kill_nested_container_;
  // @@protoc_insertion_point(field_get:mesos.agent.Call.kill_nested_container)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::agent::Call_KillNestedContainer*>(
      &::mesos::agent::_Call_KillNestedContainer_default_instance_);
}
inline ::mesos::agent::Call_KillNestedContainer* Call::release_kill_nested_container() {
  // @@protoc_insertion_point(field_release:mesos.agent.Call.kill_nested_container)
  clear_has_kill_nested_container();
  ::mesos::agent::Call_KillNestedContainer* temp = kill_nested_container_;
  kill_nested_container_ = NULL;
  return temp;
}
inline ::mesos::agent::Call_KillNestedContainer* Call::mutable_kill_nested_container() {
  set_has_kill_nested_container();
  if (kill_nested_container_ == NULL) {
    kill_nested_container_ = new ::mesos::agent::Call_KillNestedContainer;
  }
  // @@protoc_insertion_point(field_mutable:mesos.agent.Call.kill_nested_container)
  return kill_nested_container_;
}
inline void Call::set_allocated_kill_nested_container(::mesos::agent::Call_KillNestedContainer* kill_nested_container) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete kill_nested_container_;
  }
  if (kill_nested_container) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      kill_nested_container = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, kill_nested_container, submessage_arena);
    }
    set_has_kill_nested_container();
  } else {
    clear_has_kill_nested_container();
  }
  kill_nested_container_ = kill_nested_container;
  // @@protoc_insertion_point(field_set_allocated:mesos.agent.Call.kill_nested_container)
}

// optional .mesos.agent.Call.RemoveNestedContainer remove_nested_container = 12 [deprecated = true];
inline bool Call::has_remove_nested_container() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Call::set_has_remove_nested_container() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Call::clear_has_remove_nested_container() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Call::clear_remove_nested_container() {
  if (remove_nested_container_ != NULL) remove_nested_container_->Clear();
  clear_has_remove_nested_container();
}
inline const ::mesos::agent::Call_RemoveNestedContainer& Call::remove_nested_container() const {
  const ::mesos::agent::Call_RemoveNestedContainer* p = remove_nested_container_;
  // @@protoc_insertion_point(field_get:mesos.agent.Call.remove_nested_container)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::agent::Call_RemoveNestedContainer*>(
      &::mesos::agent::_Call_RemoveNestedContainer_default_instance_);
}
inline ::mesos::agent::Call_RemoveNestedContainer* Call::release_remove_nested_container() {
  // @@protoc_insertion_point(field_release:mesos.agent.Call.remove_nested_container)
  clear_has_remove_nested_container();
  ::mesos::agent::Call_RemoveNestedContainer* temp = remove_nested_container_;
  remove_nested_container_ = NULL;
  return temp;
}
inline ::mesos::agent::Call_RemoveNestedContainer* Call::mutable_remove_nested_container() {
  set_has_remove_nested_container();
  if (remove_nested_container_ == NULL) {
    remove_nested_container_ = new ::mesos::agent::Call_RemoveNestedContainer;
  }
  // @@protoc_insertion_point(field_mutable:mesos.agent.Call.remove_nested_container)
  return remove_nested_container_;
}
inline void Call::set_allocated_remove_nested_container(::mesos::agent::Call_RemoveNestedContainer* remove_nested_container) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete remove_nested_container_;
  }
  if (remove_nested_container) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      remove_nested_container = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, remove_nested_container, submessage_arena);
    }
    set_has_remove_nested_container();
  } else {
    clear_has_remove_nested_container();
  }
  remove_nested_container_ = remove_nested_container;
  // @@protoc_insertion_point(field_set_allocated:mesos.agent.Call.remove_nested_container)
}

// optional .mesos.agent.Call.LaunchNestedContainerSession launch_nested_container_session = 9;
inline bool Call::has_launch_nested_container_session() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Call::set_has_launch_nested_container_session() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Call::clear_has_launch_nested_container_session() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Call::clear_launch_nested_container_session() {
  if (launch_nested_container_session_ != NULL) launch_nested_container_session_->Clear();
  clear_has_launch_nested_container_session();
}
inline const ::mesos::agent::Call_LaunchNestedContainerSession& Call::launch_nested_container_session() const {
  const ::mesos::agent::Call_LaunchNestedContainerSession* p = launch_nested_container_session_;
  // @@protoc_insertion_point(field_get:mesos.agent.Call.launch_nested_container_session)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::agent::Call_LaunchNestedContainerSession*>(
      &::mesos::agent::_Call_LaunchNestedContainerSession_default_instance_);
}
inline ::mesos::agent::Call_LaunchNestedContainerSession* Call::release_launch_nested_container_session() {
  // @@protoc_insertion_point(field_release:mesos.agent.Call.launch_nested_container_session)
  clear_has_launch_nested_container_session();
  ::mesos::agent::Call_LaunchNestedContainerSession* temp = launch_nested_container_session_;
  launch_nested_container_session_ = NULL;
  return temp;
}
inline ::mesos::agent::Call_LaunchNestedContainerSession* Call::mutable_launch_nested_container_session() {
  set_has_launch_nested_container_session();
  if (launch_nested_container_session_ == NULL) {
    launch_nested_container_session_ = new ::mesos::agent::Call_LaunchNestedContainerSession;
  }
  // @@protoc_insertion_point(field_mutable:mesos.agent.Call.launch_nested_container_session)
  return launch_nested_container_session_;
}
inline void Call::set_allocated_launch_nested_container_session(::mesos::agent::Call_LaunchNestedContainerSession* launch_nested_container_session) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete launch_nested_container_session_;
  }
  if (launch_nested_container_session) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      launch_nested_container_session = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, launch_nested_container_session, submessage_arena);
    }
    set_has_launch_nested_container_session();
  } else {
    clear_has_launch_nested_container_session();
  }
  launch_nested_container_session_ = launch_nested_container_session;
  // @@protoc_insertion_point(field_set_allocated:mesos.agent.Call.launch_nested_container_session)
}

// optional .mesos.agent.Call.AttachContainerInput attach_container_input = 10;
inline bool Call::has_attach_container_input() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Call::set_has_attach_container_input() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Call::clear_has_attach_container_input() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Call::clear_attach_container_input() {
  if (attach_container_input_ != NULL) attach_container_input_->Clear();
  clear_has_attach_container_input();
}
inline const ::mesos::agent::Call_AttachContainerInput& Call::attach_container_input() const {
  const ::mesos::agent::Call_AttachContainerInput* p = attach_container_input_;
  // @@protoc_insertion_point(field_get:mesos.agent.Call.attach_container_input)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::agent::Call_AttachContainerInput*>(
      &::mesos::agent::_Call_AttachContainerInput_default_instance_);
}
inline ::mesos::agent::Call_AttachContainerInput* Call::release_attach_container_input() {
  // @@protoc_insertion_point(field_release:mesos.agent.Call.attach_container_input)
  clear_has_attach_container_input();
  ::mesos::agent::Call_AttachContainerInput* temp = attach_container_input_;
  attach_container_input_ = NULL;
  return temp;
}
inline ::mesos::agent::Call_AttachContainerInput* Call::mutable_attach_container_input() {
  set_has_attach_container_input();
  if (attach_container_input_ == NULL) {
    attach_container_input_ = new ::mesos::agent::Call_AttachContainerInput;
  }
  // @@protoc_insertion_point(field_mutable:mesos.agent.Call.attach_container_input)
  return attach_container_input_;
}
inline void Call::set_allocated_attach_container_input(::mesos::agent::Call_AttachContainerInput* attach_container_input) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete attach_container_input_;
  }
  if (attach_container_input) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      attach_container_input = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, attach_container_input, submessage_arena);
    }
    set_has_attach_container_input();
  } else {
    clear_has_attach_container_input();
  }
  attach_container_input_ = attach_container_input;
  // @@protoc_insertion_point(field_set_allocated:mesos.agent.Call.attach_container_input)
}

// optional .mesos.agent.Call.AttachContainerOutput attach_container_output = 11;
inline bool Call::has_attach_container_output() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Call::set_has_attach_container_output() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Call::clear_has_attach_container_output() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Call::clear_attach_container_output() {
  if (attach_container_output_ != NULL) attach_container_output_->Clear();
  clear_has_attach_container_output();
}
inline const ::mesos::agent::Call_AttachContainerOutput& Call::attach_container_output() const {
  const ::mesos::agent::Call_AttachContainerOutput* p = attach_container_output_;
  // @@protoc_insertion_point(field_get:mesos.agent.Call.attach_container_output)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::agent::Call_AttachContainerOutput*>(
      &::mesos::agent::_Call_AttachContainerOutput_default_instance_);
}
inline ::mesos::agent::Call_AttachContainerOutput* Call::release_attach_container_output() {
  // @@protoc_insertion_point(field_release:mesos.agent.Call.attach_container_output)
  clear_has_attach_container_output();
  ::mesos::agent::Call_AttachContainerOutput* temp = attach_container_output_;
  attach_container_output_ = NULL;
  return temp;
}
inline ::mesos::agent::Call_AttachContainerOutput* Call::mutable_attach_container_output() {
  set_has_attach_container_output();
  if (attach_container_output_ == NULL) {
    attach_container_output_ = new ::mesos::agent::Call_AttachContainerOutput;
  }
  // @@protoc_insertion_point(field_mutable:mesos.agent.Call.attach_container_output)
  return attach_container_output_;
}
inline void Call::set_allocated_attach_container_output(::mesos::agent::Call_AttachContainerOutput* attach_container_output) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete attach_container_output_;
  }
  if (attach_container_output) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      attach_container_output = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, attach_container_output, submessage_arena);
    }
    set_has_attach_container_output();
  } else {
    clear_has_attach_container_output();
  }
  attach_container_output_ = attach_container_output;
  // @@protoc_insertion_point(field_set_allocated:mesos.agent.Call.attach_container_output)
}

// optional .mesos.agent.Call.LaunchContainer launch_container = 13;
inline bool Call::has_launch_container() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Call::set_has_launch_container() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Call::clear_has_launch_container() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Call::clear_launch_container() {
  if (launch_container_ != NULL) launch_container_->Clear();
  clear_has_launch_container();
}
inline const ::mesos::agent::Call_LaunchContainer& Call::launch_container() const {
  const ::mesos::agent::Call_LaunchContainer* p = launch_container_;
  // @@protoc_insertion_point(field_get:mesos.agent.Call.launch_container)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::agent::Call_LaunchContainer*>(
      &::mesos::agent::_Call_LaunchContainer_default_instance_);
}
inline ::mesos::agent::Call_LaunchContainer* Call::release_launch_container() {
  // @@protoc_insertion_point(field_release:mesos.agent.Call.launch_container)
  clear_has_launch_container();
  ::mesos::agent::Call_LaunchContainer* temp = launch_container_;
  launch_container_ = NULL;
  return temp;
}
inline ::mesos::agent::Call_LaunchContainer* Call::mutable_launch_container() {
  set_has_launch_container();
  if (launch_container_ == NULL) {
    launch_container_ = new ::mesos::agent::Call_LaunchContainer;
  }
  // @@protoc_insertion_point(field_mutable:mesos.agent.Call.launch_container)
  return launch_container_;
}
inline void Call::set_allocated_launch_container(::mesos::agent::Call_LaunchContainer* launch_container) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete launch_container_;
  }
  if (launch_container) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      launch_container = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, launch_container, submessage_arena);
    }
    set_has_launch_container();
  } else {
    clear_has_launch_container();
  }
  launch_container_ = launch_container;
  // @@protoc_insertion_point(field_set_allocated:mesos.agent.Call.launch_container)
}

// optional .mesos.agent.Call.WaitContainer wait_container = 14;
inline bool Call::has_wait_container() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Call::set_has_wait_container() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Call::clear_has_wait_container() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Call::clear_wait_container() {
  if (wait_container_ != NULL) wait_container_->Clear();
  clear_has_wait_container();
}
inline const ::mesos::agent::Call_WaitContainer& Call::wait_container() const {
  const ::mesos::agent::Call_WaitContainer* p = wait_container_;
  // @@protoc_insertion_point(field_get:mesos.agent.Call.wait_container)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::agent::Call_WaitContainer*>(
      &::mesos::agent::_Call_WaitContainer_default_instance_);
}
inline ::mesos::agent::Call_WaitContainer* Call::release_wait_container() {
  // @@protoc_insertion_point(field_release:mesos.agent.Call.wait_container)
  clear_has_wait_container();
  ::mesos::agent::Call_WaitContainer* temp = wait_container_;
  wait_container_ = NULL;
  return temp;
}
inline ::mesos::agent::Call_WaitContainer* Call::mutable_wait_container() {
  set_has_wait_container();
  if (wait_container_ == NULL) {
    wait_container_ = new ::mesos::agent::Call_WaitContainer;
  }
  // @@protoc_insertion_point(field_mutable:mesos.agent.Call.wait_container)
  return wait_container_;
}
inline void Call::set_allocated_wait_container(::mesos::agent::Call_WaitContainer* wait_container) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete wait_container_;
  }
  if (wait_container) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      wait_container = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, wait_container, submessage_arena);
    }
    set_has_wait_container();
  } else {
    clear_has_wait_container();
  }
  wait_container_ = wait_container;
  // @@protoc_insertion_point(field_set_allocated:mesos.agent.Call.wait_container)
}

// optional .mesos.agent.Call.KillContainer kill_container = 15;
inline bool Call::has_kill_container() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Call::set_has_kill_container() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Call::clear_has_kill_container() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Call::clear_kill_container() {
  if (kill_container_ != NULL) kill_container_->Clear();
  clear_has_kill_container();
}
inline const ::mesos::agent::Call_KillContainer& Call::kill_container() const {
  const ::mesos::agent::Call_KillContainer* p = kill_container_;
  // @@protoc_insertion_point(field_get:mesos.agent.Call.kill_container)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::agent::Call_KillContainer*>(
      &::mesos::agent::_Call_KillContainer_default_instance_);
}
inline ::mesos::agent::Call_KillContainer* Call::release_kill_container() {
  // @@protoc_insertion_point(field_release:mesos.agent.Call.kill_container)
  clear_has_kill_container();
  ::mesos::agent::Call_KillContainer* temp = kill_container_;
  kill_container_ = NULL;
  return temp;
}
inline ::mesos::agent::Call_KillContainer* Call::mutable_kill_container() {
  set_has_kill_container();
  if (kill_container_ == NULL) {
    kill_container_ = new ::mesos::agent::Call_KillContainer;
  }
  // @@protoc_insertion_point(field_mutable:mesos.agent.Call.kill_container)
  return kill_container_;
}
inline void Call::set_allocated_kill_container(::mesos::agent::Call_KillContainer* kill_container) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete kill_container_;
  }
  if (kill_container) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      kill_container = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, kill_container, submessage_arena);
    }
    set_has_kill_container();
  } else {
    clear_has_kill_container();
  }
  kill_container_ = kill_container;
  // @@protoc_insertion_point(field_set_allocated:mesos.agent.Call.kill_container)
}

// optional .mesos.agent.Call.RemoveContainer remove_container = 16;
inline bool Call::has_remove_container() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Call::set_has_remove_container() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Call::clear_has_remove_container() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Call::clear_remove_container() {
  if (remove_container_ != NULL) remove_container_->Clear();
  clear_has_remove_container();
}
inline const ::mesos::agent::Call_RemoveContainer& Call::remove_container() const {
  const ::mesos::agent::Call_RemoveContainer* p = remove_container_;
  // @@protoc_insertion_point(field_get:mesos.agent.Call.remove_container)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::agent::Call_RemoveContainer*>(
      &::mesos::agent::_Call_RemoveContainer_default_instance_);
}
inline ::mesos::agent::Call_RemoveContainer* Call::release_remove_container() {
  // @@protoc_insertion_point(field_release:mesos.agent.Call.remove_container)
  clear_has_remove_container();
  ::mesos::agent::Call_RemoveContainer* temp = remove_container_;
  remove_container_ = NULL;
  return temp;
}
inline ::mesos::agent::Call_RemoveContainer* Call::mutable_remove_container() {
  set_has_remove_container();
  if (remove_container_ == NULL) {
    remove_container_ = new ::mesos::agent::Call_RemoveContainer;
  }
  // @@protoc_insertion_point(field_mutable:mesos.agent.Call.remove_container)
  return remove_container_;
}
inline void Call::set_allocated_remove_container(::mesos::agent::Call_RemoveContainer* remove_container) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete remove_container_;
  }
  if (remove_container) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      remove_container = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, remove_container, submessage_arena);
    }
    set_has_remove_container();
  } else {
    clear_has_remove_container();
  }
  remove_container_ = remove_container;
  // @@protoc_insertion_point(field_set_allocated:mesos.agent.Call.remove_container)
}

// optional .mesos.agent.Call.AddResourceProviderConfig add_resource_provider_config = 17;
inline bool Call::has_add_resource_provider_config() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Call::set_has_add_resource_provider_config() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Call::clear_has_add_resource_provider_config() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Call::clear_add_resource_provider_config() {
  if (add_resource_provider_config_ != NULL) add_resource_provider_config_->Clear();
  clear_has_add_resource_provider_config();
}
inline const ::mesos::agent::Call_AddResourceProviderConfig& Call::add_resource_provider_config() const {
  const ::mesos::agent::Call_AddResourceProviderConfig* p = add_resource_provider_config_;
  // @@protoc_insertion_point(field_get:mesos.agent.Call.add_resource_provider_config)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::agent::Call_AddResourceProviderConfig*>(
      &::mesos::agent::_Call_AddResourceProviderConfig_default_instance_);
}
inline ::mesos::agent::Call_AddResourceProviderConfig* Call::release_add_resource_provider_config() {
  // @@protoc_insertion_point(field_release:mesos.agent.Call.add_resource_provider_config)
  clear_has_add_resource_provider_config();
  ::mesos::agent::Call_AddResourceProviderConfig* temp = add_resource_provider_config_;
  add_resource_provider_config_ = NULL;
  return temp;
}
inline ::mesos::agent::Call_AddResourceProviderConfig* Call::mutable_add_resource_provider_config() {
  set_has_add_resource_provider_config();
  if (add_resource_provider_config_ == NULL) {
    add_resource_provider_config_ = new ::mesos::agent::Call_AddResourceProviderConfig;
  }
  // @@protoc_insertion_point(field_mutable:mesos.agent.Call.add_resource_provider_config)
  return add_resource_provider_config_;
}
inline void Call::set_allocated_add_resource_provider_config(::mesos::agent::Call_AddResourceProviderConfig* add_resource_provider_config) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete add_resource_provider_config_;
  }
  if (add_resource_provider_config) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      add_resource_provider_config = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, add_resource_provider_config, submessage_arena);
    }
    set_has_add_resource_provider_config();
  } else {
    clear_has_add_resource_provider_config();
  }
  add_resource_provider_config_ = add_resource_provider_config;
  // @@protoc_insertion_point(field_set_allocated:mesos.agent.Call.add_resource_provider_config)
}

// optional .mesos.agent.Call.UpdateResourceProviderConfig update_resource_provider_config = 18;
inline bool Call::has_update_resource_provider_config() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Call::set_has_update_resource_provider_config() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Call::clear_has_update_resource_provider_config() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Call::clear_update_resource_provider_config() {
  if (update_resource_provider_config_ != NULL) update_resource_provider_config_->Clear();
  clear_has_update_resource_provider_config();
}
inline const ::mesos::agent::Call_UpdateResourceProviderConfig& Call::update_resource_provider_config() const {
  const ::mesos::agent::Call_UpdateResourceProviderConfig* p = update_resource_provider_config_;
  // @@protoc_insertion_point(field_get:mesos.agent.Call.update_resource_provider_config)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::agent::Call_UpdateResourceProviderConfig*>(
      &::mesos::agent::_Call_UpdateResourceProviderConfig_default_instance_);
}
inline ::mesos::agent::Call_UpdateResourceProviderConfig* Call::release_update_resource_provider_config() {
  // @@protoc_insertion_point(field_release:mesos.agent.Call.update_resource_provider_config)
  clear_has_update_resource_provider_config();
  ::mesos::agent::Call_UpdateResourceProviderConfig* temp = update_resource_provider_config_;
  update_resource_provider_config_ = NULL;
  return temp;
}
inline ::mesos::agent::Call_UpdateResourceProviderConfig* Call::mutable_update_resource_provider_config() {
  set_has_update_resource_provider_config();
  if (update_resource_provider_config_ == NULL) {
    update_resource_provider_config_ = new ::mesos::agent::Call_UpdateResourceProviderConfig;
  }
  // @@protoc_insertion_point(field_mutable:mesos.agent.Call.update_resource_provider_config)
  return update_resource_provider_config_;
}
inline void Call::set_allocated_update_resource_provider_config(::mesos::agent::Call_UpdateResourceProviderConfig* update_resource_provider_config) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete update_resource_provider_config_;
  }
  if (update_resource_provider_config) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      update_resource_provider_config = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, update_resource_provider_config, submessage_arena);
    }
    set_has_update_resource_provider_config();
  } else {
    clear_has_update_resource_provider_config();
  }
  update_resource_provider_config_ = update_resource_provider_config;
  // @@protoc_insertion_point(field_set_allocated:mesos.agent.Call.update_resource_provider_config)
}

// optional .mesos.agent.Call.RemoveResourceProviderConfig remove_resource_provider_config = 19;
inline bool Call::has_remove_resource_provider_config() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void Call::set_has_remove_resource_provider_config() {
  _has_bits_[0] |= 0x00020000u;
}
inline void Call::clear_has_remove_resource_provider_config() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void Call::clear_remove_resource_provider_config() {
  if (remove_resource_provider_config_ != NULL) remove_resource_provider_config_->Clear();
  clear_has_remove_resource_provider_config();
}
inline const ::mesos::agent::Call_RemoveResourceProviderConfig& Call::remove_resource_provider_config() const {
  const ::mesos::agent::Call_RemoveResourceProviderConfig* p = remove_resource_provider_config_;
  // @@protoc_insertion_point(field_get:mesos.agent.Call.remove_resource_provider_config)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::agent::Call_RemoveResourceProviderConfig*>(
      &::mesos::agent::_Call_RemoveResourceProviderConfig_default_instance_);
}
inline ::mesos::agent::Call_RemoveResourceProviderConfig* Call::release_remove_resource_provider_config() {
  // @@protoc_insertion_point(field_release:mesos.agent.Call.remove_resource_provider_config)
  clear_has_remove_resource_provider_config();
  ::mesos::agent::Call_RemoveResourceProviderConfig* temp = remove_resource_provider_config_;
  remove_resource_provider_config_ = NULL;
  return temp;
}
inline ::mesos::agent::Call_RemoveResourceProviderConfig* Call::mutable_remove_resource_provider_config() {
  set_has_remove_resource_provider_config();
  if (remove_resource_provider_config_ == NULL) {
    remove_resource_provider_config_ = new ::mesos::agent::Call_RemoveResourceProviderConfig;
  }
  // @@protoc_insertion_point(field_mutable:mesos.agent.Call.remove_resource_provider_config)
  return remove_resource_provider_config_;
}
inline void Call::set_allocated_remove_resource_provider_config(::mesos::agent::Call_RemoveResourceProviderConfig* remove_resource_provider_config) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete remove_resource_provider_config_;
  }
  if (remove_resource_provider_config) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      remove_resource_provider_config = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, remove_resource_provider_config, submessage_arena);
    }
    set_has_remove_resource_provider_config();
  } else {
    clear_has_remove_resource_provider_config();
  }
  remove_resource_provider_config_ = remove_resource_provider_config;
  // @@protoc_insertion_point(field_set_allocated:mesos.agent.Call.remove_resource_provider_config)
}

// optional .mesos.agent.Call.PruneImages prune_images = 21;
inline bool Call::has_prune_images() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void Call::set_has_prune_images() {
  _has_bits_[0] |= 0x00080000u;
}
inline void Call::clear_has_prune_images() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void Call::clear_prune_images() {
  if (prune_images_ != NULL) prune_images_->Clear();
  clear_has_prune_images();
}
inline const ::mesos::agent::Call_PruneImages& Call::prune_images() const {
  const ::mesos::agent::Call_PruneImages* p = prune_images_;
  // @@protoc_insertion_point(field_get:mesos.agent.Call.prune_images)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::agent::Call_PruneImages*>(
      &::mesos::agent::_Call_PruneImages_default_instance_);
}
inline ::mesos::agent::Call_PruneImages* Call::release_prune_images() {
  // @@protoc_insertion_point(field_release:mesos.agent.Call.prune_images)
  clear_has_prune_images();
  ::mesos::agent::Call_PruneImages* temp = prune_images_;
  prune_images_ = NULL;
  return temp;
}
inline ::mesos::agent::Call_PruneImages* Call::mutable_prune_images() {
  set_has_prune_images();
  if (prune_images_ == NULL) {
    prune_images_ = new ::mesos::agent::Call_PruneImages;
  }
  // @@protoc_insertion_point(field_mutable:mesos.agent.Call.prune_images)
  return prune_images_;
}
inline void Call::set_allocated_prune_images(::mesos::agent::Call_PruneImages* prune_images) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete prune_images_;
  }
  if (prune_images) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      prune_images = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, prune_images, submessage_arena);
    }
    set_has_prune_images();
  } else {
    clear_has_prune_images();
  }
  prune_images_ = prune_images;
  // @@protoc_insertion_point(field_set_allocated:mesos.agent.Call.prune_images)
}

// -------------------------------------------------------------------

// Response_GetHealth

// required bool healthy = 1;
inline bool Response_GetHealth::has_healthy() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Response_GetHealth::set_has_healthy() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Response_GetHealth::clear_has_healthy() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Response_GetHealth::clear_healthy() {
  healthy_ = false;
  clear_has_healthy();
}
inline bool Response_GetHealth::healthy() const {
  // @@protoc_insertion_point(field_get:mesos.agent.Response.GetHealth.healthy)
  return healthy_;
}
inline void Response_GetHealth::set_healthy(bool value) {
  set_has_healthy();
  healthy_ = value;
  // @@protoc_insertion_point(field_set:mesos.agent.Response.GetHealth.healthy)
}

// -------------------------------------------------------------------

// Response_GetFlags

// repeated .mesos.Flag flags = 1;
inline int Response_GetFlags::flags_size() const {
  return flags_.size();
}
inline const ::mesos::Flag& Response_GetFlags::flags(int index) const {
  // @@protoc_insertion_point(field_get:mesos.agent.Response.GetFlags.flags)
  return flags_.Get(index);
}
inline ::mesos::Flag* Response_GetFlags::mutable_flags(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.agent.Response.GetFlags.flags)
  return flags_.Mutable(index);
}
inline ::mesos::Flag* Response_GetFlags::add_flags() {
  // @@protoc_insertion_point(field_add:mesos.agent.Response.GetFlags.flags)
  return flags_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Flag >*
Response_GetFlags::mutable_flags() {
  // @@protoc_insertion_point(field_mutable_list:mesos.agent.Response.GetFlags.flags)
  return &flags_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Flag >&
Response_GetFlags::flags() const {
  // @@protoc_insertion_point(field_list:mesos.agent.Response.GetFlags.flags)
  return flags_;
}

// -------------------------------------------------------------------

// Response_GetVersion

// required .mesos.VersionInfo version_info = 1;
inline bool Response_GetVersion::has_version_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Response_GetVersion::set_has_version_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Response_GetVersion::clear_has_version_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::mesos::VersionInfo& Response_GetVersion::version_info() const {
  const ::mesos::VersionInfo* p = version_info_;
  // @@protoc_insertion_point(field_get:mesos.agent.Response.GetVersion.version_info)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::VersionInfo*>(
      &::mesos::_VersionInfo_default_instance_);
}
inline ::mesos::VersionInfo* Response_GetVersion::release_version_info() {
  // @@protoc_insertion_point(field_release:mesos.agent.Response.GetVersion.version_info)
  clear_has_version_info();
  ::mesos::VersionInfo* temp = version_info_;
  version_info_ = NULL;
  return temp;
}
inline ::mesos::VersionInfo* Response_GetVersion::mutable_version_info() {
  set_has_version_info();
  if (version_info_ == NULL) {
    version_info_ = new ::mesos::VersionInfo;
  }
  // @@protoc_insertion_point(field_mutable:mesos.agent.Response.GetVersion.version_info)
  return version_info_;
}
inline void Response_GetVersion::set_allocated_version_info(::mesos::VersionInfo* version_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(version_info_);
  }
  if (version_info) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(version_info)->GetArena();
    if (message_arena != submessage_arena) {
      version_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, version_info, submessage_arena);
    }
    set_has_version_info();
  } else {
    clear_has_version_info();
  }
  version_info_ = version_info;
  // @@protoc_insertion_point(field_set_allocated:mesos.agent.Response.GetVersion.version_info)
}

// -------------------------------------------------------------------

// Response_GetMetrics

// repeated .mesos.Metric metrics = 1;
inline int Response_GetMetrics::metrics_size() const {
  return metrics_.size();
}
inline const ::mesos::Metric& Response_GetMetrics::metrics(int index) const {
  // @@protoc_insertion_point(field_get:mesos.agent.Response.GetMetrics.metrics)
  return metrics_.Get(index);
}
inline ::mesos::Metric* Response_GetMetrics::mutable_metrics(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.agent.Response.GetMetrics.metrics)
  return metrics_.Mutable(index);
}
inline ::mesos::Metric* Response_GetMetrics::add_metrics() {
  // @@protoc_insertion_point(field_add:mesos.agent.Response.GetMetrics.metrics)
  return metrics_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Metric >*
Response_GetMetrics::mutable_metrics() {
  // @@protoc_insertion_point(field_mutable_list:mesos.agent.Response.GetMetrics.metrics)
  return &metrics_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Metric >&
Response_GetMetrics::metrics() const {
  // @@protoc_insertion_point(field_list:mesos.agent.Response.GetMetrics.metrics)
  return metrics_;
}

// -------------------------------------------------------------------

// Response_GetLoggingLevel

// required uint32 level = 1;
inline bool Response_GetLoggingLevel::has_level() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Response_GetLoggingLevel::set_has_level() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Response_GetLoggingLevel::clear_has_level() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Response_GetLoggingLevel::clear_level() {
  level_ = 0u;
  clear_has_level();
}
inline ::google::protobuf::uint32 Response_GetLoggingLevel::level() const {
  // @@protoc_insertion_point(field_get:mesos.agent.Response.GetLoggingLevel.level)
  return level_;
}
inline void Response_GetLoggingLevel::set_level(::google::protobuf::uint32 value) {
  set_has_level();
  level_ = value;
  // @@protoc_insertion_point(field_set:mesos.agent.Response.GetLoggingLevel.level)
}

// -------------------------------------------------------------------

// Response_ListFiles

// repeated .mesos.FileInfo file_infos = 1;
inline int Response_ListFiles::file_infos_size() const {
  return file_infos_.size();
}
inline const ::mesos::FileInfo& Response_ListFiles::file_infos(int index) const {
  // @@protoc_insertion_point(field_get:mesos.agent.Response.ListFiles.file_infos)
  return file_infos_.Get(index);
}
inline ::mesos::FileInfo* Response_ListFiles::mutable_file_infos(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.agent.Response.ListFiles.file_infos)
  return file_infos_.Mutable(index);
}
inline ::mesos::FileInfo* Response_ListFiles::add_file_infos() {
  // @@protoc_insertion_point(field_add:mesos.agent.Response.ListFiles.file_infos)
  return file_infos_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::FileInfo >*
Response_ListFiles::mutable_file_infos() {
  // @@protoc_insertion_point(field_mutable_list:mesos.agent.Response.ListFiles.file_infos)
  return &file_infos_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::FileInfo >&
Response_ListFiles::file_infos() const {
  // @@protoc_insertion_point(field_list:mesos.agent.Response.ListFiles.file_infos)
  return file_infos_;
}

// -------------------------------------------------------------------

// Response_ReadFile

// required uint64 size = 1;
inline bool Response_ReadFile::has_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Response_ReadFile::set_has_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Response_ReadFile::clear_has_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Response_ReadFile::clear_size() {
  size_ = GOOGLE_ULONGLONG(0);
  clear_has_size();
}
inline ::google::protobuf::uint64 Response_ReadFile::size() const {
  // @@protoc_insertion_point(field_get:mesos.agent.Response.ReadFile.size)
  return size_;
}
inline void Response_ReadFile::set_size(::google::protobuf::uint64 value) {
  set_has_size();
  size_ = value;
  // @@protoc_insertion_point(field_set:mesos.agent.Response.ReadFile.size)
}

// required bytes data = 2;
inline bool Response_ReadFile::has_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Response_ReadFile::set_has_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Response_ReadFile::clear_has_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Response_ReadFile::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_data();
}
inline const ::std::string& Response_ReadFile::data() const {
  // @@protoc_insertion_point(field_get:mesos.agent.Response.ReadFile.data)
  return data_.GetNoArena();
}
inline void Response_ReadFile::set_data(const ::std::string& value) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.agent.Response.ReadFile.data)
}
#if LANG_CXX11
inline void Response_ReadFile::set_data(::std::string&& value) {
  set_has_data();
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mesos.agent.Response.ReadFile.data)
}
#endif
inline void Response_ReadFile::set_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.agent.Response.ReadFile.data)
}
inline void Response_ReadFile::set_data(const void* value, size_t size) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.agent.Response.ReadFile.data)
}
inline ::std::string* Response_ReadFile::mutable_data() {
  set_has_data();
  // @@protoc_insertion_point(field_mutable:mesos.agent.Response.ReadFile.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Response_ReadFile::release_data() {
  // @@protoc_insertion_point(field_release:mesos.agent.Response.ReadFile.data)
  clear_has_data();
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Response_ReadFile::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    set_has_data();
  } else {
    clear_has_data();
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:mesos.agent.Response.ReadFile.data)
}

// -------------------------------------------------------------------

// Response_GetState

// optional .mesos.agent.Response.GetTasks get_tasks = 1;
inline bool Response_GetState::has_get_tasks() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Response_GetState::set_has_get_tasks() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Response_GetState::clear_has_get_tasks() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Response_GetState::clear_get_tasks() {
  if (get_tasks_ != NULL) get_tasks_->Clear();
  clear_has_get_tasks();
}
inline const ::mesos::agent::Response_GetTasks& Response_GetState::get_tasks() const {
  const ::mesos::agent::Response_GetTasks* p = get_tasks_;
  // @@protoc_insertion_point(field_get:mesos.agent.Response.GetState.get_tasks)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::agent::Response_GetTasks*>(
      &::mesos::agent::_Response_GetTasks_default_instance_);
}
inline ::mesos::agent::Response_GetTasks* Response_GetState::release_get_tasks() {
  // @@protoc_insertion_point(field_release:mesos.agent.Response.GetState.get_tasks)
  clear_has_get_tasks();
  ::mesos::agent::Response_GetTasks* temp = get_tasks_;
  get_tasks_ = NULL;
  return temp;
}
inline ::mesos::agent::Response_GetTasks* Response_GetState::mutable_get_tasks() {
  set_has_get_tasks();
  if (get_tasks_ == NULL) {
    get_tasks_ = new ::mesos::agent::Response_GetTasks;
  }
  // @@protoc_insertion_point(field_mutable:mesos.agent.Response.GetState.get_tasks)
  return get_tasks_;
}
inline void Response_GetState::set_allocated_get_tasks(::mesos::agent::Response_GetTasks* get_tasks) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete get_tasks_;
  }
  if (get_tasks) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      get_tasks = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, get_tasks, submessage_arena);
    }
    set_has_get_tasks();
  } else {
    clear_has_get_tasks();
  }
  get_tasks_ = get_tasks;
  // @@protoc_insertion_point(field_set_allocated:mesos.agent.Response.GetState.get_tasks)
}

// optional .mesos.agent.Response.GetExecutors get_executors = 2;
inline bool Response_GetState::has_get_executors() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Response_GetState::set_has_get_executors() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Response_GetState::clear_has_get_executors() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Response_GetState::clear_get_executors() {
  if (get_executors_ != NULL) get_executors_->Clear();
  clear_has_get_executors();
}
inline const ::mesos::agent::Response_GetExecutors& Response_GetState::get_executors() const {
  const ::mesos::agent::Response_GetExecutors* p = get_executors_;
  // @@protoc_insertion_point(field_get:mesos.agent.Response.GetState.get_executors)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::agent::Response_GetExecutors*>(
      &::mesos::agent::_Response_GetExecutors_default_instance_);
}
inline ::mesos::agent::Response_GetExecutors* Response_GetState::release_get_executors() {
  // @@protoc_insertion_point(field_release:mesos.agent.Response.GetState.get_executors)
  clear_has_get_executors();
  ::mesos::agent::Response_GetExecutors* temp = get_executors_;
  get_executors_ = NULL;
  return temp;
}
inline ::mesos::agent::Response_GetExecutors* Response_GetState::mutable_get_executors() {
  set_has_get_executors();
  if (get_executors_ == NULL) {
    get_executors_ = new ::mesos::agent::Response_GetExecutors;
  }
  // @@protoc_insertion_point(field_mutable:mesos.agent.Response.GetState.get_executors)
  return get_executors_;
}
inline void Response_GetState::set_allocated_get_executors(::mesos::agent::Response_GetExecutors* get_executors) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete get_executors_;
  }
  if (get_executors) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      get_executors = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, get_executors, submessage_arena);
    }
    set_has_get_executors();
  } else {
    clear_has_get_executors();
  }
  get_executors_ = get_executors;
  // @@protoc_insertion_point(field_set_allocated:mesos.agent.Response.GetState.get_executors)
}

// optional .mesos.agent.Response.GetFrameworks get_frameworks = 3;
inline bool Response_GetState::has_get_frameworks() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Response_GetState::set_has_get_frameworks() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Response_GetState::clear_has_get_frameworks() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Response_GetState::clear_get_frameworks() {
  if (get_frameworks_ != NULL) get_frameworks_->Clear();
  clear_has_get_frameworks();
}
inline const ::mesos::agent::Response_GetFrameworks& Response_GetState::get_frameworks() const {
  const ::mesos::agent::Response_GetFrameworks* p = get_frameworks_;
  // @@protoc_insertion_point(field_get:mesos.agent.Response.GetState.get_frameworks)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::agent::Response_GetFrameworks*>(
      &::mesos::agent::_Response_GetFrameworks_default_instance_);
}
inline ::mesos::agent::Response_GetFrameworks* Response_GetState::release_get_frameworks() {
  // @@protoc_insertion_point(field_release:mesos.agent.Response.GetState.get_frameworks)
  clear_has_get_frameworks();
  ::mesos::agent::Response_GetFrameworks* temp = get_frameworks_;
  get_frameworks_ = NULL;
  return temp;
}
inline ::mesos::agent::Response_GetFrameworks* Response_GetState::mutable_get_frameworks() {
  set_has_get_frameworks();
  if (get_frameworks_ == NULL) {
    get_frameworks_ = new ::mesos::agent::Response_GetFrameworks;
  }
  // @@protoc_insertion_point(field_mutable:mesos.agent.Response.GetState.get_frameworks)
  return get_frameworks_;
}
inline void Response_GetState::set_allocated_get_frameworks(::mesos::agent::Response_GetFrameworks* get_frameworks) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete get_frameworks_;
  }
  if (get_frameworks) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      get_frameworks = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, get_frameworks, submessage_arena);
    }
    set_has_get_frameworks();
  } else {
    clear_has_get_frameworks();
  }
  get_frameworks_ = get_frameworks;
  // @@protoc_insertion_point(field_set_allocated:mesos.agent.Response.GetState.get_frameworks)
}

// -------------------------------------------------------------------

// Response_GetContainers_Container

// optional .mesos.FrameworkID framework_id = 1;
inline bool Response_GetContainers_Container::has_framework_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Response_GetContainers_Container::set_has_framework_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Response_GetContainers_Container::clear_has_framework_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::mesos::FrameworkID& Response_GetContainers_Container::framework_id() const {
  const ::mesos::FrameworkID* p = framework_id_;
  // @@protoc_insertion_point(field_get:mesos.agent.Response.GetContainers.Container.framework_id)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::FrameworkID*>(
      &::mesos::_FrameworkID_default_instance_);
}
inline ::mesos::FrameworkID* Response_GetContainers_Container::release_framework_id() {
  // @@protoc_insertion_point(field_release:mesos.agent.Response.GetContainers.Container.framework_id)
  clear_has_framework_id();
  ::mesos::FrameworkID* temp = framework_id_;
  framework_id_ = NULL;
  return temp;
}
inline ::mesos::FrameworkID* Response_GetContainers_Container::mutable_framework_id() {
  set_has_framework_id();
  if (framework_id_ == NULL) {
    framework_id_ = new ::mesos::FrameworkID;
  }
  // @@protoc_insertion_point(field_mutable:mesos.agent.Response.GetContainers.Container.framework_id)
  return framework_id_;
}
inline void Response_GetContainers_Container::set_allocated_framework_id(::mesos::FrameworkID* framework_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(framework_id_);
  }
  if (framework_id) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(framework_id)->GetArena();
    if (message_arena != submessage_arena) {
      framework_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, framework_id, submessage_arena);
    }
    set_has_framework_id();
  } else {
    clear_has_framework_id();
  }
  framework_id_ = framework_id;
  // @@protoc_insertion_point(field_set_allocated:mesos.agent.Response.GetContainers.Container.framework_id)
}

// optional .mesos.ExecutorID executor_id = 2;
inline bool Response_GetContainers_Container::has_executor_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Response_GetContainers_Container::set_has_executor_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Response_GetContainers_Container::clear_has_executor_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::mesos::ExecutorID& Response_GetContainers_Container::executor_id() const {
  const ::mesos::ExecutorID* p = executor_id_;
  // @@protoc_insertion_point(field_get:mesos.agent.Response.GetContainers.Container.executor_id)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ExecutorID*>(
      &::mesos::_ExecutorID_default_instance_);
}
inline ::mesos::ExecutorID* Response_GetContainers_Container::release_executor_id() {
  // @@protoc_insertion_point(field_release:mesos.agent.Response.GetContainers.Container.executor_id)
  clear_has_executor_id();
  ::mesos::ExecutorID* temp = executor_id_;
  executor_id_ = NULL;
  return temp;
}
inline ::mesos::ExecutorID* Response_GetContainers_Container::mutable_executor_id() {
  set_has_executor_id();
  if (executor_id_ == NULL) {
    executor_id_ = new ::mesos::ExecutorID;
  }
  // @@protoc_insertion_point(field_mutable:mesos.agent.Response.GetContainers.Container.executor_id)
  return executor_id_;
}
inline void Response_GetContainers_Container::set_allocated_executor_id(::mesos::ExecutorID* executor_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(executor_id_);
  }
  if (executor_id) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(executor_id)->GetArena();
    if (message_arena != submessage_arena) {
      executor_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, executor_id, submessage_arena);
    }
    set_has_executor_id();
  } else {
    clear_has_executor_id();
  }
  executor_id_ = executor_id;
  // @@protoc_insertion_point(field_set_allocated:mesos.agent.Response.GetContainers.Container.executor_id)
}

// optional string executor_name = 3;
inline bool Response_GetContainers_Container::has_executor_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Response_GetContainers_Container::set_has_executor_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Response_GetContainers_Container::clear_has_executor_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Response_GetContainers_Container::clear_executor_name() {
  executor_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_executor_name();
}
inline const ::std::string& Response_GetContainers_Container::executor_name() const {
  // @@protoc_insertion_point(field_get:mesos.agent.Response.GetContainers.Container.executor_name)
  return executor_name_.GetNoArena();
}
inline void Response_GetContainers_Container::set_executor_name(const ::std::string& value) {
  set_has_executor_name();
  executor_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.agent.Response.GetContainers.Container.executor_name)
}
#if LANG_CXX11
inline void Response_GetContainers_Container::set_executor_name(::std::string&& value) {
  set_has_executor_name();
  executor_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mesos.agent.Response.GetContainers.Container.executor_name)
}
#endif
inline void Response_GetContainers_Container::set_executor_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_executor_name();
  executor_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.agent.Response.GetContainers.Container.executor_name)
}
inline void Response_GetContainers_Container::set_executor_name(const char* value, size_t size) {
  set_has_executor_name();
  executor_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.agent.Response.GetContainers.Container.executor_name)
}
inline ::std::string* Response_GetContainers_Container::mutable_executor_name() {
  set_has_executor_name();
  // @@protoc_insertion_point(field_mutable:mesos.agent.Response.GetContainers.Container.executor_name)
  return executor_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Response_GetContainers_Container::release_executor_name() {
  // @@protoc_insertion_point(field_release:mesos.agent.Response.GetContainers.Container.executor_name)
  clear_has_executor_name();
  return executor_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Response_GetContainers_Container::set_allocated_executor_name(::std::string* executor_name) {
  if (executor_name != NULL) {
    set_has_executor_name();
  } else {
    clear_has_executor_name();
  }
  executor_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), executor_name);
  // @@protoc_insertion_point(field_set_allocated:mesos.agent.Response.GetContainers.Container.executor_name)
}

// required .mesos.ContainerID container_id = 4;
inline bool Response_GetContainers_Container::has_container_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Response_GetContainers_Container::set_has_container_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Response_GetContainers_Container::clear_has_container_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::mesos::ContainerID& Response_GetContainers_Container::container_id() const {
  const ::mesos::ContainerID* p = container_id_;
  // @@protoc_insertion_point(field_get:mesos.agent.Response.GetContainers.Container.container_id)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ContainerID*>(
      &::mesos::_ContainerID_default_instance_);
}
inline ::mesos::ContainerID* Response_GetContainers_Container::release_container_id() {
  // @@protoc_insertion_point(field_release:mesos.agent.Response.GetContainers.Container.container_id)
  clear_has_container_id();
  ::mesos::ContainerID* temp = container_id_;
  container_id_ = NULL;
  return temp;
}
inline ::mesos::ContainerID* Response_GetContainers_Container::mutable_container_id() {
  set_has_container_id();
  if (container_id_ == NULL) {
    container_id_ = new ::mesos::ContainerID;
  }
  // @@protoc_insertion_point(field_mutable:mesos.agent.Response.GetContainers.Container.container_id)
  return container_id_;
}
inline void Response_GetContainers_Container::set_allocated_container_id(::mesos::ContainerID* container_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(container_id_);
  }
  if (container_id) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(container_id)->GetArena();
    if (message_arena != submessage_arena) {
      container_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, container_id, submessage_arena);
    }
    set_has_container_id();
  } else {
    clear_has_container_id();
  }
  container_id_ = container_id;
  // @@protoc_insertion_point(field_set_allocated:mesos.agent.Response.GetContainers.Container.container_id)
}

// optional .mesos.ContainerStatus container_status = 5;
inline bool Response_GetContainers_Container::has_container_status() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Response_GetContainers_Container::set_has_container_status() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Response_GetContainers_Container::clear_has_container_status() {
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::mesos::ContainerStatus& Response_GetContainers_Container::container_status() const {
  const ::mesos::ContainerStatus* p = container_status_;
  // @@protoc_insertion_point(field_get:mesos.agent.Response.GetContainers.Container.container_status)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ContainerStatus*>(
      &::mesos::_ContainerStatus_default_instance_);
}
inline ::mesos::ContainerStatus* Response_GetContainers_Container::release_container_status() {
  // @@protoc_insertion_point(field_release:mesos.agent.Response.GetContainers.Container.container_status)
  clear_has_container_status();
  ::mesos::ContainerStatus* temp = container_status_;
  container_status_ = NULL;
  return temp;
}
inline ::mesos::ContainerStatus* Response_GetContainers_Container::mutable_container_status() {
  set_has_container_status();
  if (container_status_ == NULL) {
    container_status_ = new ::mesos::ContainerStatus;
  }
  // @@protoc_insertion_point(field_mutable:mesos.agent.Response.GetContainers.Container.container_status)
  return container_status_;
}
inline void Response_GetContainers_Container::set_allocated_container_status(::mesos::ContainerStatus* container_status) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(container_status_);
  }
  if (container_status) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(container_status)->GetArena();
    if (message_arena != submessage_arena) {
      container_status = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, container_status, submessage_arena);
    }
    set_has_container_status();
  } else {
    clear_has_container_status();
  }
  container_status_ = container_status;
  // @@protoc_insertion_point(field_set_allocated:mesos.agent.Response.GetContainers.Container.container_status)
}

// optional .mesos.ResourceStatistics resource_statistics = 6;
inline bool Response_GetContainers_Container::has_resource_statistics() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Response_GetContainers_Container::set_has_resource_statistics() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Response_GetContainers_Container::clear_has_resource_statistics() {
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::mesos::ResourceStatistics& Response_GetContainers_Container::resource_statistics() const {
  const ::mesos::ResourceStatistics* p = resource_statistics_;
  // @@protoc_insertion_point(field_get:mesos.agent.Response.GetContainers.Container.resource_statistics)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ResourceStatistics*>(
      &::mesos::_ResourceStatistics_default_instance_);
}
inline ::mesos::ResourceStatistics* Response_GetContainers_Container::release_resource_statistics() {
  // @@protoc_insertion_point(field_release:mesos.agent.Response.GetContainers.Container.resource_statistics)
  clear_has_resource_statistics();
  ::mesos::ResourceStatistics* temp = resource_statistics_;
  resource_statistics_ = NULL;
  return temp;
}
inline ::mesos::ResourceStatistics* Response_GetContainers_Container::mutable_resource_statistics() {
  set_has_resource_statistics();
  if (resource_statistics_ == NULL) {
    resource_statistics_ = new ::mesos::ResourceStatistics;
  }
  // @@protoc_insertion_point(field_mutable:mesos.agent.Response.GetContainers.Container.resource_statistics)
  return resource_statistics_;
}
inline void Response_GetContainers_Container::set_allocated_resource_statistics(::mesos::ResourceStatistics* resource_statistics) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(resource_statistics_);
  }
  if (resource_statistics) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(resource_statistics)->GetArena();
    if (message_arena != submessage_arena) {
      resource_statistics = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, resource_statistics, submessage_arena);
    }
    set_has_resource_statistics();
  } else {
    clear_has_resource_statistics();
  }
  resource_statistics_ = resource_statistics;
  // @@protoc_insertion_point(field_set_allocated:mesos.agent.Response.GetContainers.Container.resource_statistics)
}

// -------------------------------------------------------------------

// Response_GetContainers

// repeated .mesos.agent.Response.GetContainers.Container containers = 1;
inline int Response_GetContainers::containers_size() const {
  return containers_.size();
}
inline void Response_GetContainers::clear_containers() {
  containers_.Clear();
}
inline const ::mesos::agent::Response_GetContainers_Container& Response_GetContainers::containers(int index) const {
  // @@protoc_insertion_point(field_get:mesos.agent.Response.GetContainers.containers)
  return containers_.Get(index);
}
inline ::mesos::agent::Response_GetContainers_Container* Response_GetContainers::mutable_containers(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.agent.Response.GetContainers.containers)
  return containers_.Mutable(index);
}
inline ::mesos::agent::Response_GetContainers_Container* Response_GetContainers::add_containers() {
  // @@protoc_insertion_point(field_add:mesos.agent.Response.GetContainers.containers)
  return containers_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::agent::Response_GetContainers_Container >*
Response_GetContainers::mutable_containers() {
  // @@protoc_insertion_point(field_mutable_list:mesos.agent.Response.GetContainers.containers)
  return &containers_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::agent::Response_GetContainers_Container >&
Response_GetContainers::containers() const {
  // @@protoc_insertion_point(field_list:mesos.agent.Response.GetContainers.containers)
  return containers_;
}

// -------------------------------------------------------------------

// Response_GetFrameworks_Framework

// required .mesos.FrameworkInfo framework_info = 1;
inline bool Response_GetFrameworks_Framework::has_framework_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Response_GetFrameworks_Framework::set_has_framework_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Response_GetFrameworks_Framework::clear_has_framework_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::mesos::FrameworkInfo& Response_GetFrameworks_Framework::framework_info() const {
  const ::mesos::FrameworkInfo* p = framework_info_;
  // @@protoc_insertion_point(field_get:mesos.agent.Response.GetFrameworks.Framework.framework_info)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::FrameworkInfo*>(
      &::mesos::_FrameworkInfo_default_instance_);
}
inline ::mesos::FrameworkInfo* Response_GetFrameworks_Framework::release_framework_info() {
  // @@protoc_insertion_point(field_release:mesos.agent.Response.GetFrameworks.Framework.framework_info)
  clear_has_framework_info();
  ::mesos::FrameworkInfo* temp = framework_info_;
  framework_info_ = NULL;
  return temp;
}
inline ::mesos::FrameworkInfo* Response_GetFrameworks_Framework::mutable_framework_info() {
  set_has_framework_info();
  if (framework_info_ == NULL) {
    framework_info_ = new ::mesos::FrameworkInfo;
  }
  // @@protoc_insertion_point(field_mutable:mesos.agent.Response.GetFrameworks.Framework.framework_info)
  return framework_info_;
}
inline void Response_GetFrameworks_Framework::set_allocated_framework_info(::mesos::FrameworkInfo* framework_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(framework_info_);
  }
  if (framework_info) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(framework_info)->GetArena();
    if (message_arena != submessage_arena) {
      framework_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, framework_info, submessage_arena);
    }
    set_has_framework_info();
  } else {
    clear_has_framework_info();
  }
  framework_info_ = framework_info;
  // @@protoc_insertion_point(field_set_allocated:mesos.agent.Response.GetFrameworks.Framework.framework_info)
}

// -------------------------------------------------------------------

// Response_GetFrameworks

// repeated .mesos.agent.Response.GetFrameworks.Framework frameworks = 1;
inline int Response_GetFrameworks::frameworks_size() const {
  return frameworks_.size();
}
inline void Response_GetFrameworks::clear_frameworks() {
  frameworks_.Clear();
}
inline const ::mesos::agent::Response_GetFrameworks_Framework& Response_GetFrameworks::frameworks(int index) const {
  // @@protoc_insertion_point(field_get:mesos.agent.Response.GetFrameworks.frameworks)
  return frameworks_.Get(index);
}
inline ::mesos::agent::Response_GetFrameworks_Framework* Response_GetFrameworks::mutable_frameworks(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.agent.Response.GetFrameworks.frameworks)
  return frameworks_.Mutable(index);
}
inline ::mesos::agent::Response_GetFrameworks_Framework* Response_GetFrameworks::add_frameworks() {
  // @@protoc_insertion_point(field_add:mesos.agent.Response.GetFrameworks.frameworks)
  return frameworks_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::agent::Response_GetFrameworks_Framework >*
Response_GetFrameworks::mutable_frameworks() {
  // @@protoc_insertion_point(field_mutable_list:mesos.agent.Response.GetFrameworks.frameworks)
  return &frameworks_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::agent::Response_GetFrameworks_Framework >&
Response_GetFrameworks::frameworks() const {
  // @@protoc_insertion_point(field_list:mesos.agent.Response.GetFrameworks.frameworks)
  return frameworks_;
}

// repeated .mesos.agent.Response.GetFrameworks.Framework completed_frameworks = 2;
inline int Response_GetFrameworks::completed_frameworks_size() const {
  return completed_frameworks_.size();
}
inline void Response_GetFrameworks::clear_completed_frameworks() {
  completed_frameworks_.Clear();
}
inline const ::mesos::agent::Response_GetFrameworks_Framework& Response_GetFrameworks::completed_frameworks(int index) const {
  // @@protoc_insertion_point(field_get:mesos.agent.Response.GetFrameworks.completed_frameworks)
  return completed_frameworks_.Get(index);
}
inline ::mesos::agent::Response_GetFrameworks_Framework* Response_GetFrameworks::mutable_completed_frameworks(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.agent.Response.GetFrameworks.completed_frameworks)
  return completed_frameworks_.Mutable(index);
}
inline ::mesos::agent::Response_GetFrameworks_Framework* Response_GetFrameworks::add_completed_frameworks() {
  // @@protoc_insertion_point(field_add:mesos.agent.Response.GetFrameworks.completed_frameworks)
  return completed_frameworks_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::agent::Response_GetFrameworks_Framework >*
Response_GetFrameworks::mutable_completed_frameworks() {
  // @@protoc_insertion_point(field_mutable_list:mesos.agent.Response.GetFrameworks.completed_frameworks)
  return &completed_frameworks_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::agent::Response_GetFrameworks_Framework >&
Response_GetFrameworks::completed_frameworks() const {
  // @@protoc_insertion_point(field_list:mesos.agent.Response.GetFrameworks.completed_frameworks)
  return completed_frameworks_;
}

// -------------------------------------------------------------------

// Response_GetExecutors_Executor

// required .mesos.ExecutorInfo executor_info = 1;
inline bool Response_GetExecutors_Executor::has_executor_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Response_GetExecutors_Executor::set_has_executor_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Response_GetExecutors_Executor::clear_has_executor_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::mesos::ExecutorInfo& Response_GetExecutors_Executor::executor_info() const {
  const ::mesos::ExecutorInfo* p = executor_info_;
  // @@protoc_insertion_point(field_get:mesos.agent.Response.GetExecutors.Executor.executor_info)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ExecutorInfo*>(
      &::mesos::_ExecutorInfo_default_instance_);
}
inline ::mesos::ExecutorInfo* Response_GetExecutors_Executor::release_executor_info() {
  // @@protoc_insertion_point(field_release:mesos.agent.Response.GetExecutors.Executor.executor_info)
  clear_has_executor_info();
  ::mesos::ExecutorInfo* temp = executor_info_;
  executor_info_ = NULL;
  return temp;
}
inline ::mesos::ExecutorInfo* Response_GetExecutors_Executor::mutable_executor_info() {
  set_has_executor_info();
  if (executor_info_ == NULL) {
    executor_info_ = new ::mesos::ExecutorInfo;
  }
  // @@protoc_insertion_point(field_mutable:mesos.agent.Response.GetExecutors.Executor.executor_info)
  return executor_info_;
}
inline void Response_GetExecutors_Executor::set_allocated_executor_info(::mesos::ExecutorInfo* executor_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(executor_info_);
  }
  if (executor_info) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(executor_info)->GetArena();
    if (message_arena != submessage_arena) {
      executor_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, executor_info, submessage_arena);
    }
    set_has_executor_info();
  } else {
    clear_has_executor_info();
  }
  executor_info_ = executor_info;
  // @@protoc_insertion_point(field_set_allocated:mesos.agent.Response.GetExecutors.Executor.executor_info)
}

// -------------------------------------------------------------------

// Response_GetExecutors

// repeated .mesos.agent.Response.GetExecutors.Executor executors = 1;
inline int Response_GetExecutors::executors_size() const {
  return executors_.size();
}
inline void Response_GetExecutors::clear_executors() {
  executors_.Clear();
}
inline const ::mesos::agent::Response_GetExecutors_Executor& Response_GetExecutors::executors(int index) const {
  // @@protoc_insertion_point(field_get:mesos.agent.Response.GetExecutors.executors)
  return executors_.Get(index);
}
inline ::mesos::agent::Response_GetExecutors_Executor* Response_GetExecutors::mutable_executors(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.agent.Response.GetExecutors.executors)
  return executors_.Mutable(index);
}
inline ::mesos::agent::Response_GetExecutors_Executor* Response_GetExecutors::add_executors() {
  // @@protoc_insertion_point(field_add:mesos.agent.Response.GetExecutors.executors)
  return executors_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::agent::Response_GetExecutors_Executor >*
Response_GetExecutors::mutable_executors() {
  // @@protoc_insertion_point(field_mutable_list:mesos.agent.Response.GetExecutors.executors)
  return &executors_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::agent::Response_GetExecutors_Executor >&
Response_GetExecutors::executors() const {
  // @@protoc_insertion_point(field_list:mesos.agent.Response.GetExecutors.executors)
  return executors_;
}

// repeated .mesos.agent.Response.GetExecutors.Executor completed_executors = 2;
inline int Response_GetExecutors::completed_executors_size() const {
  return completed_executors_.size();
}
inline void Response_GetExecutors::clear_completed_executors() {
  completed_executors_.Clear();
}
inline const ::mesos::agent::Response_GetExecutors_Executor& Response_GetExecutors::completed_executors(int index) const {
  // @@protoc_insertion_point(field_get:mesos.agent.Response.GetExecutors.completed_executors)
  return completed_executors_.Get(index);
}
inline ::mesos::agent::Response_GetExecutors_Executor* Response_GetExecutors::mutable_completed_executors(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.agent.Response.GetExecutors.completed_executors)
  return completed_executors_.Mutable(index);
}
inline ::mesos::agent::Response_GetExecutors_Executor* Response_GetExecutors::add_completed_executors() {
  // @@protoc_insertion_point(field_add:mesos.agent.Response.GetExecutors.completed_executors)
  return completed_executors_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::agent::Response_GetExecutors_Executor >*
Response_GetExecutors::mutable_completed_executors() {
  // @@protoc_insertion_point(field_mutable_list:mesos.agent.Response.GetExecutors.completed_executors)
  return &completed_executors_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::agent::Response_GetExecutors_Executor >&
Response_GetExecutors::completed_executors() const {
  // @@protoc_insertion_point(field_list:mesos.agent.Response.GetExecutors.completed_executors)
  return completed_executors_;
}

// -------------------------------------------------------------------

// Response_GetOperations

// repeated .mesos.Operation operations = 1;
inline int Response_GetOperations::operations_size() const {
  return operations_.size();
}
inline const ::mesos::Operation& Response_GetOperations::operations(int index) const {
  // @@protoc_insertion_point(field_get:mesos.agent.Response.GetOperations.operations)
  return operations_.Get(index);
}
inline ::mesos::Operation* Response_GetOperations::mutable_operations(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.agent.Response.GetOperations.operations)
  return operations_.Mutable(index);
}
inline ::mesos::Operation* Response_GetOperations::add_operations() {
  // @@protoc_insertion_point(field_add:mesos.agent.Response.GetOperations.operations)
  return operations_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Operation >*
Response_GetOperations::mutable_operations() {
  // @@protoc_insertion_point(field_mutable_list:mesos.agent.Response.GetOperations.operations)
  return &operations_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Operation >&
Response_GetOperations::operations() const {
  // @@protoc_insertion_point(field_list:mesos.agent.Response.GetOperations.operations)
  return operations_;
}

// -------------------------------------------------------------------

// Response_GetTasks

// repeated .mesos.Task pending_tasks = 1;
inline int Response_GetTasks::pending_tasks_size() const {
  return pending_tasks_.size();
}
inline const ::mesos::Task& Response_GetTasks::pending_tasks(int index) const {
  // @@protoc_insertion_point(field_get:mesos.agent.Response.GetTasks.pending_tasks)
  return pending_tasks_.Get(index);
}
inline ::mesos::Task* Response_GetTasks::mutable_pending_tasks(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.agent.Response.GetTasks.pending_tasks)
  return pending_tasks_.Mutable(index);
}
inline ::mesos::Task* Response_GetTasks::add_pending_tasks() {
  // @@protoc_insertion_point(field_add:mesos.agent.Response.GetTasks.pending_tasks)
  return pending_tasks_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Task >*
Response_GetTasks::mutable_pending_tasks() {
  // @@protoc_insertion_point(field_mutable_list:mesos.agent.Response.GetTasks.pending_tasks)
  return &pending_tasks_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Task >&
Response_GetTasks::pending_tasks() const {
  // @@protoc_insertion_point(field_list:mesos.agent.Response.GetTasks.pending_tasks)
  return pending_tasks_;
}

// repeated .mesos.Task queued_tasks = 2;
inline int Response_GetTasks::queued_tasks_size() const {
  return queued_tasks_.size();
}
inline const ::mesos::Task& Response_GetTasks::queued_tasks(int index) const {
  // @@protoc_insertion_point(field_get:mesos.agent.Response.GetTasks.queued_tasks)
  return queued_tasks_.Get(index);
}
inline ::mesos::Task* Response_GetTasks::mutable_queued_tasks(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.agent.Response.GetTasks.queued_tasks)
  return queued_tasks_.Mutable(index);
}
inline ::mesos::Task* Response_GetTasks::add_queued_tasks() {
  // @@protoc_insertion_point(field_add:mesos.agent.Response.GetTasks.queued_tasks)
  return queued_tasks_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Task >*
Response_GetTasks::mutable_queued_tasks() {
  // @@protoc_insertion_point(field_mutable_list:mesos.agent.Response.GetTasks.queued_tasks)
  return &queued_tasks_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Task >&
Response_GetTasks::queued_tasks() const {
  // @@protoc_insertion_point(field_list:mesos.agent.Response.GetTasks.queued_tasks)
  return queued_tasks_;
}

// repeated .mesos.Task launched_tasks = 3;
inline int Response_GetTasks::launched_tasks_size() const {
  return launched_tasks_.size();
}
inline const ::mesos::Task& Response_GetTasks::launched_tasks(int index) const {
  // @@protoc_insertion_point(field_get:mesos.agent.Response.GetTasks.launched_tasks)
  return launched_tasks_.Get(index);
}
inline ::mesos::Task* Response_GetTasks::mutable_launched_tasks(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.agent.Response.GetTasks.launched_tasks)
  return launched_tasks_.Mutable(index);
}
inline ::mesos::Task* Response_GetTasks::add_launched_tasks() {
  // @@protoc_insertion_point(field_add:mesos.agent.Response.GetTasks.launched_tasks)
  return launched_tasks_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Task >*
Response_GetTasks::mutable_launched_tasks() {
  // @@protoc_insertion_point(field_mutable_list:mesos.agent.Response.GetTasks.launched_tasks)
  return &launched_tasks_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Task >&
Response_GetTasks::launched_tasks() const {
  // @@protoc_insertion_point(field_list:mesos.agent.Response.GetTasks.launched_tasks)
  return launched_tasks_;
}

// repeated .mesos.Task terminated_tasks = 4;
inline int Response_GetTasks::terminated_tasks_size() const {
  return terminated_tasks_.size();
}
inline const ::mesos::Task& Response_GetTasks::terminated_tasks(int index) const {
  // @@protoc_insertion_point(field_get:mesos.agent.Response.GetTasks.terminated_tasks)
  return terminated_tasks_.Get(index);
}
inline ::mesos::Task* Response_GetTasks::mutable_terminated_tasks(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.agent.Response.GetTasks.terminated_tasks)
  return terminated_tasks_.Mutable(index);
}
inline ::mesos::Task* Response_GetTasks::add_terminated_tasks() {
  // @@protoc_insertion_point(field_add:mesos.agent.Response.GetTasks.terminated_tasks)
  return terminated_tasks_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Task >*
Response_GetTasks::mutable_terminated_tasks() {
  // @@protoc_insertion_point(field_mutable_list:mesos.agent.Response.GetTasks.terminated_tasks)
  return &terminated_tasks_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Task >&
Response_GetTasks::terminated_tasks() const {
  // @@protoc_insertion_point(field_list:mesos.agent.Response.GetTasks.terminated_tasks)
  return terminated_tasks_;
}

// repeated .mesos.Task completed_tasks = 5;
inline int Response_GetTasks::completed_tasks_size() const {
  return completed_tasks_.size();
}
inline const ::mesos::Task& Response_GetTasks::completed_tasks(int index) const {
  // @@protoc_insertion_point(field_get:mesos.agent.Response.GetTasks.completed_tasks)
  return completed_tasks_.Get(index);
}
inline ::mesos::Task* Response_GetTasks::mutable_completed_tasks(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.agent.Response.GetTasks.completed_tasks)
  return completed_tasks_.Mutable(index);
}
inline ::mesos::Task* Response_GetTasks::add_completed_tasks() {
  // @@protoc_insertion_point(field_add:mesos.agent.Response.GetTasks.completed_tasks)
  return completed_tasks_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Task >*
Response_GetTasks::mutable_completed_tasks() {
  // @@protoc_insertion_point(field_mutable_list:mesos.agent.Response.GetTasks.completed_tasks)
  return &completed_tasks_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Task >&
Response_GetTasks::completed_tasks() const {
  // @@protoc_insertion_point(field_list:mesos.agent.Response.GetTasks.completed_tasks)
  return completed_tasks_;
}

// -------------------------------------------------------------------

// Response_GetAgent

// optional .mesos.SlaveInfo slave_info = 1;
inline bool Response_GetAgent::has_slave_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Response_GetAgent::set_has_slave_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Response_GetAgent::clear_has_slave_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::mesos::SlaveInfo& Response_GetAgent::slave_info() const {
  const ::mesos::SlaveInfo* p = slave_info_;
  // @@protoc_insertion_point(field_get:mesos.agent.Response.GetAgent.slave_info)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::SlaveInfo*>(
      &::mesos::_SlaveInfo_default_instance_);
}
inline ::mesos::SlaveInfo* Response_GetAgent::release_slave_info() {
  // @@protoc_insertion_point(field_release:mesos.agent.Response.GetAgent.slave_info)
  clear_has_slave_info();
  ::mesos::SlaveInfo* temp = slave_info_;
  slave_info_ = NULL;
  return temp;
}
inline ::mesos::SlaveInfo* Response_GetAgent::mutable_slave_info() {
  set_has_slave_info();
  if (slave_info_ == NULL) {
    slave_info_ = new ::mesos::SlaveInfo;
  }
  // @@protoc_insertion_point(field_mutable:mesos.agent.Response.GetAgent.slave_info)
  return slave_info_;
}
inline void Response_GetAgent::set_allocated_slave_info(::mesos::SlaveInfo* slave_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(slave_info_);
  }
  if (slave_info) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(slave_info)->GetArena();
    if (message_arena != submessage_arena) {
      slave_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, slave_info, submessage_arena);
    }
    set_has_slave_info();
  } else {
    clear_has_slave_info();
  }
  slave_info_ = slave_info;
  // @@protoc_insertion_point(field_set_allocated:mesos.agent.Response.GetAgent.slave_info)
}

// -------------------------------------------------------------------

// Response_GetResourceProviders_ResourceProvider

// required .mesos.ResourceProviderInfo resource_provider_info = 1;
inline bool Response_GetResourceProviders_ResourceProvider::has_resource_provider_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Response_GetResourceProviders_ResourceProvider::set_has_resource_provider_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Response_GetResourceProviders_ResourceProvider::clear_has_resource_provider_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::mesos::ResourceProviderInfo& Response_GetResourceProviders_ResourceProvider::resource_provider_info() const {
  const ::mesos::ResourceProviderInfo* p = resource_provider_info_;
  // @@protoc_insertion_point(field_get:mesos.agent.Response.GetResourceProviders.ResourceProvider.resource_provider_info)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ResourceProviderInfo*>(
      &::mesos::_ResourceProviderInfo_default_instance_);
}
inline ::mesos::ResourceProviderInfo* Response_GetResourceProviders_ResourceProvider::release_resource_provider_info() {
  // @@protoc_insertion_point(field_release:mesos.agent.Response.GetResourceProviders.ResourceProvider.resource_provider_info)
  clear_has_resource_provider_info();
  ::mesos::ResourceProviderInfo* temp = resource_provider_info_;
  resource_provider_info_ = NULL;
  return temp;
}
inline ::mesos::ResourceProviderInfo* Response_GetResourceProviders_ResourceProvider::mutable_resource_provider_info() {
  set_has_resource_provider_info();
  if (resource_provider_info_ == NULL) {
    resource_provider_info_ = new ::mesos::ResourceProviderInfo;
  }
  // @@protoc_insertion_point(field_mutable:mesos.agent.Response.GetResourceProviders.ResourceProvider.resource_provider_info)
  return resource_provider_info_;
}
inline void Response_GetResourceProviders_ResourceProvider::set_allocated_resource_provider_info(::mesos::ResourceProviderInfo* resource_provider_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(resource_provider_info_);
  }
  if (resource_provider_info) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(resource_provider_info)->GetArena();
    if (message_arena != submessage_arena) {
      resource_provider_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, resource_provider_info, submessage_arena);
    }
    set_has_resource_provider_info();
  } else {
    clear_has_resource_provider_info();
  }
  resource_provider_info_ = resource_provider_info;
  // @@protoc_insertion_point(field_set_allocated:mesos.agent.Response.GetResourceProviders.ResourceProvider.resource_provider_info)
}

// repeated .mesos.Resource total_resources = 2;
inline int Response_GetResourceProviders_ResourceProvider::total_resources_size() const {
  return total_resources_.size();
}
inline const ::mesos::Resource& Response_GetResourceProviders_ResourceProvider::total_resources(int index) const {
  // @@protoc_insertion_point(field_get:mesos.agent.Response.GetResourceProviders.ResourceProvider.total_resources)
  return total_resources_.Get(index);
}
inline ::mesos::Resource* Response_GetResourceProviders_ResourceProvider::mutable_total_resources(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.agent.Response.GetResourceProviders.ResourceProvider.total_resources)
  return total_resources_.Mutable(index);
}
inline ::mesos::Resource* Response_GetResourceProviders_ResourceProvider::add_total_resources() {
  // @@protoc_insertion_point(field_add:mesos.agent.Response.GetResourceProviders.ResourceProvider.total_resources)
  return total_resources_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
Response_GetResourceProviders_ResourceProvider::mutable_total_resources() {
  // @@protoc_insertion_point(field_mutable_list:mesos.agent.Response.GetResourceProviders.ResourceProvider.total_resources)
  return &total_resources_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
Response_GetResourceProviders_ResourceProvider::total_resources() const {
  // @@protoc_insertion_point(field_list:mesos.agent.Response.GetResourceProviders.ResourceProvider.total_resources)
  return total_resources_;
}

// -------------------------------------------------------------------

// Response_GetResourceProviders

// repeated .mesos.agent.Response.GetResourceProviders.ResourceProvider resource_providers = 1;
inline int Response_GetResourceProviders::resource_providers_size() const {
  return resource_providers_.size();
}
inline void Response_GetResourceProviders::clear_resource_providers() {
  resource_providers_.Clear();
}
inline const ::mesos::agent::Response_GetResourceProviders_ResourceProvider& Response_GetResourceProviders::resource_providers(int index) const {
  // @@protoc_insertion_point(field_get:mesos.agent.Response.GetResourceProviders.resource_providers)
  return resource_providers_.Get(index);
}
inline ::mesos::agent::Response_GetResourceProviders_ResourceProvider* Response_GetResourceProviders::mutable_resource_providers(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.agent.Response.GetResourceProviders.resource_providers)
  return resource_providers_.Mutable(index);
}
inline ::mesos::agent::Response_GetResourceProviders_ResourceProvider* Response_GetResourceProviders::add_resource_providers() {
  // @@protoc_insertion_point(field_add:mesos.agent.Response.GetResourceProviders.resource_providers)
  return resource_providers_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::agent::Response_GetResourceProviders_ResourceProvider >*
Response_GetResourceProviders::mutable_resource_providers() {
  // @@protoc_insertion_point(field_mutable_list:mesos.agent.Response.GetResourceProviders.resource_providers)
  return &resource_providers_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::agent::Response_GetResourceProviders_ResourceProvider >&
Response_GetResourceProviders::resource_providers() const {
  // @@protoc_insertion_point(field_list:mesos.agent.Response.GetResourceProviders.resource_providers)
  return resource_providers_;
}

// -------------------------------------------------------------------

// Response_WaitNestedContainer

// optional int32 exit_status = 1;
inline bool Response_WaitNestedContainer::has_exit_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Response_WaitNestedContainer::set_has_exit_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Response_WaitNestedContainer::clear_has_exit_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Response_WaitNestedContainer::clear_exit_status() {
  exit_status_ = 0;
  clear_has_exit_status();
}
inline ::google::protobuf::int32 Response_WaitNestedContainer::exit_status() const {
  // @@protoc_insertion_point(field_get:mesos.agent.Response.WaitNestedContainer.exit_status)
  return exit_status_;
}
inline void Response_WaitNestedContainer::set_exit_status(::google::protobuf::int32 value) {
  set_has_exit_status();
  exit_status_ = value;
  // @@protoc_insertion_point(field_set:mesos.agent.Response.WaitNestedContainer.exit_status)
}

// optional .mesos.TaskState state = 2;
inline bool Response_WaitNestedContainer::has_state() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Response_WaitNestedContainer::set_has_state() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Response_WaitNestedContainer::clear_has_state() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Response_WaitNestedContainer::clear_state() {
  state_ = 6;
  clear_has_state();
}
inline ::mesos::TaskState Response_WaitNestedContainer::state() const {
  // @@protoc_insertion_point(field_get:mesos.agent.Response.WaitNestedContainer.state)
  return static_cast< ::mesos::TaskState >(state_);
}
inline void Response_WaitNestedContainer::set_state(::mesos::TaskState value) {
  assert(::mesos::TaskState_IsValid(value));
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:mesos.agent.Response.WaitNestedContainer.state)
}

// optional .mesos.TaskStatus.Reason reason = 3;
inline bool Response_WaitNestedContainer::has_reason() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Response_WaitNestedContainer::set_has_reason() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Response_WaitNestedContainer::clear_has_reason() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Response_WaitNestedContainer::clear_reason() {
  reason_ = 0;
  clear_has_reason();
}
inline ::mesos::TaskStatus_Reason Response_WaitNestedContainer::reason() const {
  // @@protoc_insertion_point(field_get:mesos.agent.Response.WaitNestedContainer.reason)
  return static_cast< ::mesos::TaskStatus_Reason >(reason_);
}
inline void Response_WaitNestedContainer::set_reason(::mesos::TaskStatus_Reason value) {
  assert(::mesos::TaskStatus_Reason_IsValid(value));
  set_has_reason();
  reason_ = value;
  // @@protoc_insertion_point(field_set:mesos.agent.Response.WaitNestedContainer.reason)
}

// optional .mesos.TaskResourceLimitation limitation = 4;
inline bool Response_WaitNestedContainer::has_limitation() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Response_WaitNestedContainer::set_has_limitation() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Response_WaitNestedContainer::clear_has_limitation() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::mesos::TaskResourceLimitation& Response_WaitNestedContainer::limitation() const {
  const ::mesos::TaskResourceLimitation* p = limitation_;
  // @@protoc_insertion_point(field_get:mesos.agent.Response.WaitNestedContainer.limitation)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::TaskResourceLimitation*>(
      &::mesos::_TaskResourceLimitation_default_instance_);
}
inline ::mesos::TaskResourceLimitation* Response_WaitNestedContainer::release_limitation() {
  // @@protoc_insertion_point(field_release:mesos.agent.Response.WaitNestedContainer.limitation)
  clear_has_limitation();
  ::mesos::TaskResourceLimitation* temp = limitation_;
  limitation_ = NULL;
  return temp;
}
inline ::mesos::TaskResourceLimitation* Response_WaitNestedContainer::mutable_limitation() {
  set_has_limitation();
  if (limitation_ == NULL) {
    limitation_ = new ::mesos::TaskResourceLimitation;
  }
  // @@protoc_insertion_point(field_mutable:mesos.agent.Response.WaitNestedContainer.limitation)
  return limitation_;
}
inline void Response_WaitNestedContainer::set_allocated_limitation(::mesos::TaskResourceLimitation* limitation) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(limitation_);
  }
  if (limitation) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(limitation)->GetArena();
    if (message_arena != submessage_arena) {
      limitation = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, limitation, submessage_arena);
    }
    set_has_limitation();
  } else {
    clear_has_limitation();
  }
  limitation_ = limitation;
  // @@protoc_insertion_point(field_set_allocated:mesos.agent.Response.WaitNestedContainer.limitation)
}

// optional string message = 5;
inline bool Response_WaitNestedContainer::has_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Response_WaitNestedContainer::set_has_message() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Response_WaitNestedContainer::clear_has_message() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Response_WaitNestedContainer::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_message();
}
inline const ::std::string& Response_WaitNestedContainer::message() const {
  // @@protoc_insertion_point(field_get:mesos.agent.Response.WaitNestedContainer.message)
  return message_.GetNoArena();
}
inline void Response_WaitNestedContainer::set_message(const ::std::string& value) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.agent.Response.WaitNestedContainer.message)
}
#if LANG_CXX11
inline void Response_WaitNestedContainer::set_message(::std::string&& value) {
  set_has_message();
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mesos.agent.Response.WaitNestedContainer.message)
}
#endif
inline void Response_WaitNestedContainer::set_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.agent.Response.WaitNestedContainer.message)
}
inline void Response_WaitNestedContainer::set_message(const char* value, size_t size) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.agent.Response.WaitNestedContainer.message)
}
inline ::std::string* Response_WaitNestedContainer::mutable_message() {
  set_has_message();
  // @@protoc_insertion_point(field_mutable:mesos.agent.Response.WaitNestedContainer.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Response_WaitNestedContainer::release_message() {
  // @@protoc_insertion_point(field_release:mesos.agent.Response.WaitNestedContainer.message)
  clear_has_message();
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Response_WaitNestedContainer::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    set_has_message();
  } else {
    clear_has_message();
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:mesos.agent.Response.WaitNestedContainer.message)
}

// -------------------------------------------------------------------

// Response_WaitContainer

// optional int32 exit_status = 1;
inline bool Response_WaitContainer::has_exit_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Response_WaitContainer::set_has_exit_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Response_WaitContainer::clear_has_exit_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Response_WaitContainer::clear_exit_status() {
  exit_status_ = 0;
  clear_has_exit_status();
}
inline ::google::protobuf::int32 Response_WaitContainer::exit_status() const {
  // @@protoc_insertion_point(field_get:mesos.agent.Response.WaitContainer.exit_status)
  return exit_status_;
}
inline void Response_WaitContainer::set_exit_status(::google::protobuf::int32 value) {
  set_has_exit_status();
  exit_status_ = value;
  // @@protoc_insertion_point(field_set:mesos.agent.Response.WaitContainer.exit_status)
}

// optional .mesos.TaskState state = 2;
inline bool Response_WaitContainer::has_state() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Response_WaitContainer::set_has_state() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Response_WaitContainer::clear_has_state() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Response_WaitContainer::clear_state() {
  state_ = 6;
  clear_has_state();
}
inline ::mesos::TaskState Response_WaitContainer::state() const {
  // @@protoc_insertion_point(field_get:mesos.agent.Response.WaitContainer.state)
  return static_cast< ::mesos::TaskState >(state_);
}
inline void Response_WaitContainer::set_state(::mesos::TaskState value) {
  assert(::mesos::TaskState_IsValid(value));
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:mesos.agent.Response.WaitContainer.state)
}

// optional .mesos.TaskStatus.Reason reason = 3;
inline bool Response_WaitContainer::has_reason() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Response_WaitContainer::set_has_reason() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Response_WaitContainer::clear_has_reason() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Response_WaitContainer::clear_reason() {
  reason_ = 0;
  clear_has_reason();
}
inline ::mesos::TaskStatus_Reason Response_WaitContainer::reason() const {
  // @@protoc_insertion_point(field_get:mesos.agent.Response.WaitContainer.reason)
  return static_cast< ::mesos::TaskStatus_Reason >(reason_);
}
inline void Response_WaitContainer::set_reason(::mesos::TaskStatus_Reason value) {
  assert(::mesos::TaskStatus_Reason_IsValid(value));
  set_has_reason();
  reason_ = value;
  // @@protoc_insertion_point(field_set:mesos.agent.Response.WaitContainer.reason)
}

// optional .mesos.TaskResourceLimitation limitation = 4;
inline bool Response_WaitContainer::has_limitation() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Response_WaitContainer::set_has_limitation() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Response_WaitContainer::clear_has_limitation() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::mesos::TaskResourceLimitation& Response_WaitContainer::limitation() const {
  const ::mesos::TaskResourceLimitation* p = limitation_;
  // @@protoc_insertion_point(field_get:mesos.agent.Response.WaitContainer.limitation)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::TaskResourceLimitation*>(
      &::mesos::_TaskResourceLimitation_default_instance_);
}
inline ::mesos::TaskResourceLimitation* Response_WaitContainer::release_limitation() {
  // @@protoc_insertion_point(field_release:mesos.agent.Response.WaitContainer.limitation)
  clear_has_limitation();
  ::mesos::TaskResourceLimitation* temp = limitation_;
  limitation_ = NULL;
  return temp;
}
inline ::mesos::TaskResourceLimitation* Response_WaitContainer::mutable_limitation() {
  set_has_limitation();
  if (limitation_ == NULL) {
    limitation_ = new ::mesos::TaskResourceLimitation;
  }
  // @@protoc_insertion_point(field_mutable:mesos.agent.Response.WaitContainer.limitation)
  return limitation_;
}
inline void Response_WaitContainer::set_allocated_limitation(::mesos::TaskResourceLimitation* limitation) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(limitation_);
  }
  if (limitation) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(limitation)->GetArena();
    if (message_arena != submessage_arena) {
      limitation = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, limitation, submessage_arena);
    }
    set_has_limitation();
  } else {
    clear_has_limitation();
  }
  limitation_ = limitation;
  // @@protoc_insertion_point(field_set_allocated:mesos.agent.Response.WaitContainer.limitation)
}

// optional string message = 5;
inline bool Response_WaitContainer::has_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Response_WaitContainer::set_has_message() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Response_WaitContainer::clear_has_message() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Response_WaitContainer::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_message();
}
inline const ::std::string& Response_WaitContainer::message() const {
  // @@protoc_insertion_point(field_get:mesos.agent.Response.WaitContainer.message)
  return message_.GetNoArena();
}
inline void Response_WaitContainer::set_message(const ::std::string& value) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.agent.Response.WaitContainer.message)
}
#if LANG_CXX11
inline void Response_WaitContainer::set_message(::std::string&& value) {
  set_has_message();
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mesos.agent.Response.WaitContainer.message)
}
#endif
inline void Response_WaitContainer::set_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.agent.Response.WaitContainer.message)
}
inline void Response_WaitContainer::set_message(const char* value, size_t size) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.agent.Response.WaitContainer.message)
}
inline ::std::string* Response_WaitContainer::mutable_message() {
  set_has_message();
  // @@protoc_insertion_point(field_mutable:mesos.agent.Response.WaitContainer.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Response_WaitContainer::release_message() {
  // @@protoc_insertion_point(field_release:mesos.agent.Response.WaitContainer.message)
  clear_has_message();
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Response_WaitContainer::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    set_has_message();
  } else {
    clear_has_message();
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:mesos.agent.Response.WaitContainer.message)
}

// -------------------------------------------------------------------

// Response

// optional .mesos.agent.Response.Type type = 1;
inline bool Response::has_type() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void Response::set_has_type() {
  _has_bits_[0] |= 0x00020000u;
}
inline void Response::clear_has_type() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void Response::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::mesos::agent::Response_Type Response::type() const {
  // @@protoc_insertion_point(field_get:mesos.agent.Response.type)
  return static_cast< ::mesos::agent::Response_Type >(type_);
}
inline void Response::set_type(::mesos::agent::Response_Type value) {
  assert(::mesos::agent::Response_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:mesos.agent.Response.type)
}

// optional .mesos.agent.Response.GetHealth get_health = 2;
inline bool Response::has_get_health() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Response::set_has_get_health() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Response::clear_has_get_health() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Response::clear_get_health() {
  if (get_health_ != NULL) get_health_->Clear();
  clear_has_get_health();
}
inline const ::mesos::agent::Response_GetHealth& Response::get_health() const {
  const ::mesos::agent::Response_GetHealth* p = get_health_;
  // @@protoc_insertion_point(field_get:mesos.agent.Response.get_health)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::agent::Response_GetHealth*>(
      &::mesos::agent::_Response_GetHealth_default_instance_);
}
inline ::mesos::agent::Response_GetHealth* Response::release_get_health() {
  // @@protoc_insertion_point(field_release:mesos.agent.Response.get_health)
  clear_has_get_health();
  ::mesos::agent::Response_GetHealth* temp = get_health_;
  get_health_ = NULL;
  return temp;
}
inline ::mesos::agent::Response_GetHealth* Response::mutable_get_health() {
  set_has_get_health();
  if (get_health_ == NULL) {
    get_health_ = new ::mesos::agent::Response_GetHealth;
  }
  // @@protoc_insertion_point(field_mutable:mesos.agent.Response.get_health)
  return get_health_;
}
inline void Response::set_allocated_get_health(::mesos::agent::Response_GetHealth* get_health) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete get_health_;
  }
  if (get_health) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      get_health = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, get_health, submessage_arena);
    }
    set_has_get_health();
  } else {
    clear_has_get_health();
  }
  get_health_ = get_health;
  // @@protoc_insertion_point(field_set_allocated:mesos.agent.Response.get_health)
}

// optional .mesos.agent.Response.GetFlags get_flags = 3;
inline bool Response::has_get_flags() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Response::set_has_get_flags() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Response::clear_has_get_flags() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Response::clear_get_flags() {
  if (get_flags_ != NULL) get_flags_->Clear();
  clear_has_get_flags();
}
inline const ::mesos::agent::Response_GetFlags& Response::get_flags() const {
  const ::mesos::agent::Response_GetFlags* p = get_flags_;
  // @@protoc_insertion_point(field_get:mesos.agent.Response.get_flags)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::agent::Response_GetFlags*>(
      &::mesos::agent::_Response_GetFlags_default_instance_);
}
inline ::mesos::agent::Response_GetFlags* Response::release_get_flags() {
  // @@protoc_insertion_point(field_release:mesos.agent.Response.get_flags)
  clear_has_get_flags();
  ::mesos::agent::Response_GetFlags* temp = get_flags_;
  get_flags_ = NULL;
  return temp;
}
inline ::mesos::agent::Response_GetFlags* Response::mutable_get_flags() {
  set_has_get_flags();
  if (get_flags_ == NULL) {
    get_flags_ = new ::mesos::agent::Response_GetFlags;
  }
  // @@protoc_insertion_point(field_mutable:mesos.agent.Response.get_flags)
  return get_flags_;
}
inline void Response::set_allocated_get_flags(::mesos::agent::Response_GetFlags* get_flags) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete get_flags_;
  }
  if (get_flags) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      get_flags = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, get_flags, submessage_arena);
    }
    set_has_get_flags();
  } else {
    clear_has_get_flags();
  }
  get_flags_ = get_flags;
  // @@protoc_insertion_point(field_set_allocated:mesos.agent.Response.get_flags)
}

// optional .mesos.agent.Response.GetVersion get_version = 4;
inline bool Response::has_get_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Response::set_has_get_version() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Response::clear_has_get_version() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Response::clear_get_version() {
  if (get_version_ != NULL) get_version_->Clear();
  clear_has_get_version();
}
inline const ::mesos::agent::Response_GetVersion& Response::get_version() const {
  const ::mesos::agent::Response_GetVersion* p = get_version_;
  // @@protoc_insertion_point(field_get:mesos.agent.Response.get_version)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::agent::Response_GetVersion*>(
      &::mesos::agent::_Response_GetVersion_default_instance_);
}
inline ::mesos::agent::Response_GetVersion* Response::release_get_version() {
  // @@protoc_insertion_point(field_release:mesos.agent.Response.get_version)
  clear_has_get_version();
  ::mesos::agent::Response_GetVersion* temp = get_version_;
  get_version_ = NULL;
  return temp;
}
inline ::mesos::agent::Response_GetVersion* Response::mutable_get_version() {
  set_has_get_version();
  if (get_version_ == NULL) {
    get_version_ = new ::mesos::agent::Response_GetVersion;
  }
  // @@protoc_insertion_point(field_mutable:mesos.agent.Response.get_version)
  return get_version_;
}
inline void Response::set_allocated_get_version(::mesos::agent::Response_GetVersion* get_version) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete get_version_;
  }
  if (get_version) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      get_version = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, get_version, submessage_arena);
    }
    set_has_get_version();
  } else {
    clear_has_get_version();
  }
  get_version_ = get_version;
  // @@protoc_insertion_point(field_set_allocated:mesos.agent.Response.get_version)
}

// optional .mesos.agent.Response.GetMetrics get_metrics = 5;
inline bool Response::has_get_metrics() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Response::set_has_get_metrics() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Response::clear_has_get_metrics() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Response::clear_get_metrics() {
  if (get_metrics_ != NULL) get_metrics_->Clear();
  clear_has_get_metrics();
}
inline const ::mesos::agent::Response_GetMetrics& Response::get_metrics() const {
  const ::mesos::agent::Response_GetMetrics* p = get_metrics_;
  // @@protoc_insertion_point(field_get:mesos.agent.Response.get_metrics)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::agent::Response_GetMetrics*>(
      &::mesos::agent::_Response_GetMetrics_default_instance_);
}
inline ::mesos::agent::Response_GetMetrics* Response::release_get_metrics() {
  // @@protoc_insertion_point(field_release:mesos.agent.Response.get_metrics)
  clear_has_get_metrics();
  ::mesos::agent::Response_GetMetrics* temp = get_metrics_;
  get_metrics_ = NULL;
  return temp;
}
inline ::mesos::agent::Response_GetMetrics* Response::mutable_get_metrics() {
  set_has_get_metrics();
  if (get_metrics_ == NULL) {
    get_metrics_ = new ::mesos::agent::Response_GetMetrics;
  }
  // @@protoc_insertion_point(field_mutable:mesos.agent.Response.get_metrics)
  return get_metrics_;
}
inline void Response::set_allocated_get_metrics(::mesos::agent::Response_GetMetrics* get_metrics) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete get_metrics_;
  }
  if (get_metrics) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      get_metrics = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, get_metrics, submessage_arena);
    }
    set_has_get_metrics();
  } else {
    clear_has_get_metrics();
  }
  get_metrics_ = get_metrics;
  // @@protoc_insertion_point(field_set_allocated:mesos.agent.Response.get_metrics)
}

// optional .mesos.agent.Response.GetLoggingLevel get_logging_level = 6;
inline bool Response::has_get_logging_level() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Response::set_has_get_logging_level() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Response::clear_has_get_logging_level() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Response::clear_get_logging_level() {
  if (get_logging_level_ != NULL) get_logging_level_->Clear();
  clear_has_get_logging_level();
}
inline const ::mesos::agent::Response_GetLoggingLevel& Response::get_logging_level() const {
  const ::mesos::agent::Response_GetLoggingLevel* p = get_logging_level_;
  // @@protoc_insertion_point(field_get:mesos.agent.Response.get_logging_level)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::agent::Response_GetLoggingLevel*>(
      &::mesos::agent::_Response_GetLoggingLevel_default_instance_);
}
inline ::mesos::agent::Response_GetLoggingLevel* Response::release_get_logging_level() {
  // @@protoc_insertion_point(field_release:mesos.agent.Response.get_logging_level)
  clear_has_get_logging_level();
  ::mesos::agent::Response_GetLoggingLevel* temp = get_logging_level_;
  get_logging_level_ = NULL;
  return temp;
}
inline ::mesos::agent::Response_GetLoggingLevel* Response::mutable_get_logging_level() {
  set_has_get_logging_level();
  if (get_logging_level_ == NULL) {
    get_logging_level_ = new ::mesos::agent::Response_GetLoggingLevel;
  }
  // @@protoc_insertion_point(field_mutable:mesos.agent.Response.get_logging_level)
  return get_logging_level_;
}
inline void Response::set_allocated_get_logging_level(::mesos::agent::Response_GetLoggingLevel* get_logging_level) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete get_logging_level_;
  }
  if (get_logging_level) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      get_logging_level = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, get_logging_level, submessage_arena);
    }
    set_has_get_logging_level();
  } else {
    clear_has_get_logging_level();
  }
  get_logging_level_ = get_logging_level;
  // @@protoc_insertion_point(field_set_allocated:mesos.agent.Response.get_logging_level)
}

// optional .mesos.agent.Response.ListFiles list_files = 7;
inline bool Response::has_list_files() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Response::set_has_list_files() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Response::clear_has_list_files() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Response::clear_list_files() {
  if (list_files_ != NULL) list_files_->Clear();
  clear_has_list_files();
}
inline const ::mesos::agent::Response_ListFiles& Response::list_files() const {
  const ::mesos::agent::Response_ListFiles* p = list_files_;
  // @@protoc_insertion_point(field_get:mesos.agent.Response.list_files)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::agent::Response_ListFiles*>(
      &::mesos::agent::_Response_ListFiles_default_instance_);
}
inline ::mesos::agent::Response_ListFiles* Response::release_list_files() {
  // @@protoc_insertion_point(field_release:mesos.agent.Response.list_files)
  clear_has_list_files();
  ::mesos::agent::Response_ListFiles* temp = list_files_;
  list_files_ = NULL;
  return temp;
}
inline ::mesos::agent::Response_ListFiles* Response::mutable_list_files() {
  set_has_list_files();
  if (list_files_ == NULL) {
    list_files_ = new ::mesos::agent::Response_ListFiles;
  }
  // @@protoc_insertion_point(field_mutable:mesos.agent.Response.list_files)
  return list_files_;
}
inline void Response::set_allocated_list_files(::mesos::agent::Response_ListFiles* list_files) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete list_files_;
  }
  if (list_files) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      list_files = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, list_files, submessage_arena);
    }
    set_has_list_files();
  } else {
    clear_has_list_files();
  }
  list_files_ = list_files;
  // @@protoc_insertion_point(field_set_allocated:mesos.agent.Response.list_files)
}

// optional .mesos.agent.Response.ReadFile read_file = 8;
inline bool Response::has_read_file() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Response::set_has_read_file() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Response::clear_has_read_file() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Response::clear_read_file() {
  if (read_file_ != NULL) read_file_->Clear();
  clear_has_read_file();
}
inline const ::mesos::agent::Response_ReadFile& Response::read_file() const {
  const ::mesos::agent::Response_ReadFile* p = read_file_;
  // @@protoc_insertion_point(field_get:mesos.agent.Response.read_file)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::agent::Response_ReadFile*>(
      &::mesos::agent::_Response_ReadFile_default_instance_);
}
inline ::mesos::agent::Response_ReadFile* Response::release_read_file() {
  // @@protoc_insertion_point(field_release:mesos.agent.Response.read_file)
  clear_has_read_file();
  ::mesos::agent::Response_ReadFile* temp = read_file_;
  read_file_ = NULL;
  return temp;
}
inline ::mesos::agent::Response_ReadFile* Response::mutable_read_file() {
  set_has_read_file();
  if (read_file_ == NULL) {
    read_file_ = new ::mesos::agent::Response_ReadFile;
  }
  // @@protoc_insertion_point(field_mutable:mesos.agent.Response.read_file)
  return read_file_;
}
inline void Response::set_allocated_read_file(::mesos::agent::Response_ReadFile* read_file) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete read_file_;
  }
  if (read_file) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      read_file = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, read_file, submessage_arena);
    }
    set_has_read_file();
  } else {
    clear_has_read_file();
  }
  read_file_ = read_file;
  // @@protoc_insertion_point(field_set_allocated:mesos.agent.Response.read_file)
}

// optional .mesos.agent.Response.GetState get_state = 9;
inline bool Response::has_get_state() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Response::set_has_get_state() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Response::clear_has_get_state() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Response::clear_get_state() {
  if (get_state_ != NULL) get_state_->Clear();
  clear_has_get_state();
}
inline const ::mesos::agent::Response_GetState& Response::get_state() const {
  const ::mesos::agent::Response_GetState* p = get_state_;
  // @@protoc_insertion_point(field_get:mesos.agent.Response.get_state)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::agent::Response_GetState*>(
      &::mesos::agent::_Response_GetState_default_instance_);
}
inline ::mesos::agent::Response_GetState* Response::release_get_state() {
  // @@protoc_insertion_point(field_release:mesos.agent.Response.get_state)
  clear_has_get_state();
  ::mesos::agent::Response_GetState* temp = get_state_;
  get_state_ = NULL;
  return temp;
}
inline ::mesos::agent::Response_GetState* Response::mutable_get_state() {
  set_has_get_state();
  if (get_state_ == NULL) {
    get_state_ = new ::mesos::agent::Response_GetState;
  }
  // @@protoc_insertion_point(field_mutable:mesos.agent.Response.get_state)
  return get_state_;
}
inline void Response::set_allocated_get_state(::mesos::agent::Response_GetState* get_state) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete get_state_;
  }
  if (get_state) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      get_state = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, get_state, submessage_arena);
    }
    set_has_get_state();
  } else {
    clear_has_get_state();
  }
  get_state_ = get_state;
  // @@protoc_insertion_point(field_set_allocated:mesos.agent.Response.get_state)
}

// optional .mesos.agent.Response.GetContainers get_containers = 10;
inline bool Response::has_get_containers() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Response::set_has_get_containers() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Response::clear_has_get_containers() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Response::clear_get_containers() {
  if (get_containers_ != NULL) get_containers_->Clear();
  clear_has_get_containers();
}
inline const ::mesos::agent::Response_GetContainers& Response::get_containers() const {
  const ::mesos::agent::Response_GetContainers* p = get_containers_;
  // @@protoc_insertion_point(field_get:mesos.agent.Response.get_containers)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::agent::Response_GetContainers*>(
      &::mesos::agent::_Response_GetContainers_default_instance_);
}
inline ::mesos::agent::Response_GetContainers* Response::release_get_containers() {
  // @@protoc_insertion_point(field_release:mesos.agent.Response.get_containers)
  clear_has_get_containers();
  ::mesos::agent::Response_GetContainers* temp = get_containers_;
  get_containers_ = NULL;
  return temp;
}
inline ::mesos::agent::Response_GetContainers* Response::mutable_get_containers() {
  set_has_get_containers();
  if (get_containers_ == NULL) {
    get_containers_ = new ::mesos::agent::Response_GetContainers;
  }
  // @@protoc_insertion_point(field_mutable:mesos.agent.Response.get_containers)
  return get_containers_;
}
inline void Response::set_allocated_get_containers(::mesos::agent::Response_GetContainers* get_containers) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete get_containers_;
  }
  if (get_containers) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      get_containers = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, get_containers, submessage_arena);
    }
    set_has_get_containers();
  } else {
    clear_has_get_containers();
  }
  get_containers_ = get_containers;
  // @@protoc_insertion_point(field_set_allocated:mesos.agent.Response.get_containers)
}

// optional .mesos.agent.Response.GetFrameworks get_frameworks = 11;
inline bool Response::has_get_frameworks() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Response::set_has_get_frameworks() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Response::clear_has_get_frameworks() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Response::clear_get_frameworks() {
  if (get_frameworks_ != NULL) get_frameworks_->Clear();
  clear_has_get_frameworks();
}
inline const ::mesos::agent::Response_GetFrameworks& Response::get_frameworks() const {
  const ::mesos::agent::Response_GetFrameworks* p = get_frameworks_;
  // @@protoc_insertion_point(field_get:mesos.agent.Response.get_frameworks)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::agent::Response_GetFrameworks*>(
      &::mesos::agent::_Response_GetFrameworks_default_instance_);
}
inline ::mesos::agent::Response_GetFrameworks* Response::release_get_frameworks() {
  // @@protoc_insertion_point(field_release:mesos.agent.Response.get_frameworks)
  clear_has_get_frameworks();
  ::mesos::agent::Response_GetFrameworks* temp = get_frameworks_;
  get_frameworks_ = NULL;
  return temp;
}
inline ::mesos::agent::Response_GetFrameworks* Response::mutable_get_frameworks() {
  set_has_get_frameworks();
  if (get_frameworks_ == NULL) {
    get_frameworks_ = new ::mesos::agent::Response_GetFrameworks;
  }
  // @@protoc_insertion_point(field_mutable:mesos.agent.Response.get_frameworks)
  return get_frameworks_;
}
inline void Response::set_allocated_get_frameworks(::mesos::agent::Response_GetFrameworks* get_frameworks) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete get_frameworks_;
  }
  if (get_frameworks) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      get_frameworks = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, get_frameworks, submessage_arena);
    }
    set_has_get_frameworks();
  } else {
    clear_has_get_frameworks();
  }
  get_frameworks_ = get_frameworks;
  // @@protoc_insertion_point(field_set_allocated:mesos.agent.Response.get_frameworks)
}

// optional .mesos.agent.Response.GetExecutors get_executors = 12;
inline bool Response::has_get_executors() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Response::set_has_get_executors() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Response::clear_has_get_executors() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Response::clear_get_executors() {
  if (get_executors_ != NULL) get_executors_->Clear();
  clear_has_get_executors();
}
inline const ::mesos::agent::Response_GetExecutors& Response::get_executors() const {
  const ::mesos::agent::Response_GetExecutors* p = get_executors_;
  // @@protoc_insertion_point(field_get:mesos.agent.Response.get_executors)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::agent::Response_GetExecutors*>(
      &::mesos::agent::_Response_GetExecutors_default_instance_);
}
inline ::mesos::agent::Response_GetExecutors* Response::release_get_executors() {
  // @@protoc_insertion_point(field_release:mesos.agent.Response.get_executors)
  clear_has_get_executors();
  ::mesos::agent::Response_GetExecutors* temp = get_executors_;
  get_executors_ = NULL;
  return temp;
}
inline ::mesos::agent::Response_GetExecutors* Response::mutable_get_executors() {
  set_has_get_executors();
  if (get_executors_ == NULL) {
    get_executors_ = new ::mesos::agent::Response_GetExecutors;
  }
  // @@protoc_insertion_point(field_mutable:mesos.agent.Response.get_executors)
  return get_executors_;
}
inline void Response::set_allocated_get_executors(::mesos::agent::Response_GetExecutors* get_executors) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete get_executors_;
  }
  if (get_executors) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      get_executors = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, get_executors, submessage_arena);
    }
    set_has_get_executors();
  } else {
    clear_has_get_executors();
  }
  get_executors_ = get_executors;
  // @@protoc_insertion_point(field_set_allocated:mesos.agent.Response.get_executors)
}

// optional .mesos.agent.Response.GetOperations get_operations = 18;
inline bool Response::has_get_operations() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Response::set_has_get_operations() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Response::clear_has_get_operations() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Response::clear_get_operations() {
  if (get_operations_ != NULL) get_operations_->Clear();
  clear_has_get_operations();
}
inline const ::mesos::agent::Response_GetOperations& Response::get_operations() const {
  const ::mesos::agent::Response_GetOperations* p = get_operations_;
  // @@protoc_insertion_point(field_get:mesos.agent.Response.get_operations)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::agent::Response_GetOperations*>(
      &::mesos::agent::_Response_GetOperations_default_instance_);
}
inline ::mesos::agent::Response_GetOperations* Response::release_get_operations() {
  // @@protoc_insertion_point(field_release:mesos.agent.Response.get_operations)
  clear_has_get_operations();
  ::mesos::agent::Response_GetOperations* temp = get_operations_;
  get_operations_ = NULL;
  return temp;
}
inline ::mesos::agent::Response_GetOperations* Response::mutable_get_operations() {
  set_has_get_operations();
  if (get_operations_ == NULL) {
    get_operations_ = new ::mesos::agent::Response_GetOperations;
  }
  // @@protoc_insertion_point(field_mutable:mesos.agent.Response.get_operations)
  return get_operations_;
}
inline void Response::set_allocated_get_operations(::mesos::agent::Response_GetOperations* get_operations) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete get_operations_;
  }
  if (get_operations) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      get_operations = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, get_operations, submessage_arena);
    }
    set_has_get_operations();
  } else {
    clear_has_get_operations();
  }
  get_operations_ = get_operations;
  // @@protoc_insertion_point(field_set_allocated:mesos.agent.Response.get_operations)
}

// optional .mesos.agent.Response.GetTasks get_tasks = 13;
inline bool Response::has_get_tasks() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Response::set_has_get_tasks() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Response::clear_has_get_tasks() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Response::clear_get_tasks() {
  if (get_tasks_ != NULL) get_tasks_->Clear();
  clear_has_get_tasks();
}
inline const ::mesos::agent::Response_GetTasks& Response::get_tasks() const {
  const ::mesos::agent::Response_GetTasks* p = get_tasks_;
  // @@protoc_insertion_point(field_get:mesos.agent.Response.get_tasks)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::agent::Response_GetTasks*>(
      &::mesos::agent::_Response_GetTasks_default_instance_);
}
inline ::mesos::agent::Response_GetTasks* Response::release_get_tasks() {
  // @@protoc_insertion_point(field_release:mesos.agent.Response.get_tasks)
  clear_has_get_tasks();
  ::mesos::agent::Response_GetTasks* temp = get_tasks_;
  get_tasks_ = NULL;
  return temp;
}
inline ::mesos::agent::Response_GetTasks* Response::mutable_get_tasks() {
  set_has_get_tasks();
  if (get_tasks_ == NULL) {
    get_tasks_ = new ::mesos::agent::Response_GetTasks;
  }
  // @@protoc_insertion_point(field_mutable:mesos.agent.Response.get_tasks)
  return get_tasks_;
}
inline void Response::set_allocated_get_tasks(::mesos::agent::Response_GetTasks* get_tasks) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete get_tasks_;
  }
  if (get_tasks) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      get_tasks = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, get_tasks, submessage_arena);
    }
    set_has_get_tasks();
  } else {
    clear_has_get_tasks();
  }
  get_tasks_ = get_tasks;
  // @@protoc_insertion_point(field_set_allocated:mesos.agent.Response.get_tasks)
}

// optional .mesos.agent.Response.GetAgent get_agent = 15;
inline bool Response::has_get_agent() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Response::set_has_get_agent() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Response::clear_has_get_agent() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Response::clear_get_agent() {
  if (get_agent_ != NULL) get_agent_->Clear();
  clear_has_get_agent();
}
inline const ::mesos::agent::Response_GetAgent& Response::get_agent() const {
  const ::mesos::agent::Response_GetAgent* p = get_agent_;
  // @@protoc_insertion_point(field_get:mesos.agent.Response.get_agent)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::agent::Response_GetAgent*>(
      &::mesos::agent::_Response_GetAgent_default_instance_);
}
inline ::mesos::agent::Response_GetAgent* Response::release_get_agent() {
  // @@protoc_insertion_point(field_release:mesos.agent.Response.get_agent)
  clear_has_get_agent();
  ::mesos::agent::Response_GetAgent* temp = get_agent_;
  get_agent_ = NULL;
  return temp;
}
inline ::mesos::agent::Response_GetAgent* Response::mutable_get_agent() {
  set_has_get_agent();
  if (get_agent_ == NULL) {
    get_agent_ = new ::mesos::agent::Response_GetAgent;
  }
  // @@protoc_insertion_point(field_mutable:mesos.agent.Response.get_agent)
  return get_agent_;
}
inline void Response::set_allocated_get_agent(::mesos::agent::Response_GetAgent* get_agent) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete get_agent_;
  }
  if (get_agent) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      get_agent = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, get_agent, submessage_arena);
    }
    set_has_get_agent();
  } else {
    clear_has_get_agent();
  }
  get_agent_ = get_agent;
  // @@protoc_insertion_point(field_set_allocated:mesos.agent.Response.get_agent)
}

// optional .mesos.agent.Response.GetResourceProviders get_resource_providers = 17;
inline bool Response::has_get_resource_providers() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Response::set_has_get_resource_providers() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Response::clear_has_get_resource_providers() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Response::clear_get_resource_providers() {
  if (get_resource_providers_ != NULL) get_resource_providers_->Clear();
  clear_has_get_resource_providers();
}
inline const ::mesos::agent::Response_GetResourceProviders& Response::get_resource_providers() const {
  const ::mesos::agent::Response_GetResourceProviders* p = get_resource_providers_;
  // @@protoc_insertion_point(field_get:mesos.agent.Response.get_resource_providers)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::agent::Response_GetResourceProviders*>(
      &::mesos::agent::_Response_GetResourceProviders_default_instance_);
}
inline ::mesos::agent::Response_GetResourceProviders* Response::release_get_resource_providers() {
  // @@protoc_insertion_point(field_release:mesos.agent.Response.get_resource_providers)
  clear_has_get_resource_providers();
  ::mesos::agent::Response_GetResourceProviders* temp = get_resource_providers_;
  get_resource_providers_ = NULL;
  return temp;
}
inline ::mesos::agent::Response_GetResourceProviders* Response::mutable_get_resource_providers() {
  set_has_get_resource_providers();
  if (get_resource_providers_ == NULL) {
    get_resource_providers_ = new ::mesos::agent::Response_GetResourceProviders;
  }
  // @@protoc_insertion_point(field_mutable:mesos.agent.Response.get_resource_providers)
  return get_resource_providers_;
}
inline void Response::set_allocated_get_resource_providers(::mesos::agent::Response_GetResourceProviders* get_resource_providers) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete get_resource_providers_;
  }
  if (get_resource_providers) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      get_resource_providers = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, get_resource_providers, submessage_arena);
    }
    set_has_get_resource_providers();
  } else {
    clear_has_get_resource_providers();
  }
  get_resource_providers_ = get_resource_providers;
  // @@protoc_insertion_point(field_set_allocated:mesos.agent.Response.get_resource_providers)
}

// optional .mesos.agent.Response.WaitNestedContainer wait_nested_container = 14;
inline bool Response::has_wait_nested_container() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Response::set_has_wait_nested_container() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Response::clear_has_wait_nested_container() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Response::clear_wait_nested_container() {
  if (wait_nested_container_ != NULL) wait_nested_container_->Clear();
  clear_has_wait_nested_container();
}
inline const ::mesos::agent::Response_WaitNestedContainer& Response::wait_nested_container() const {
  const ::mesos::agent::Response_WaitNestedContainer* p = wait_nested_container_;
  // @@protoc_insertion_point(field_get:mesos.agent.Response.wait_nested_container)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::agent::Response_WaitNestedContainer*>(
      &::mesos::agent::_Response_WaitNestedContainer_default_instance_);
}
inline ::mesos::agent::Response_WaitNestedContainer* Response::release_wait_nested_container() {
  // @@protoc_insertion_point(field_release:mesos.agent.Response.wait_nested_container)
  clear_has_wait_nested_container();
  ::mesos::agent::Response_WaitNestedContainer* temp = wait_nested_container_;
  wait_nested_container_ = NULL;
  return temp;
}
inline ::mesos::agent::Response_WaitNestedContainer* Response::mutable_wait_nested_container() {
  set_has_wait_nested_container();
  if (wait_nested_container_ == NULL) {
    wait_nested_container_ = new ::mesos::agent::Response_WaitNestedContainer;
  }
  // @@protoc_insertion_point(field_mutable:mesos.agent.Response.wait_nested_container)
  return wait_nested_container_;
}
inline void Response::set_allocated_wait_nested_container(::mesos::agent::Response_WaitNestedContainer* wait_nested_container) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete wait_nested_container_;
  }
  if (wait_nested_container) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      wait_nested_container = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, wait_nested_container, submessage_arena);
    }
    set_has_wait_nested_container();
  } else {
    clear_has_wait_nested_container();
  }
  wait_nested_container_ = wait_nested_container;
  // @@protoc_insertion_point(field_set_allocated:mesos.agent.Response.wait_nested_container)
}

// optional .mesos.agent.Response.WaitContainer wait_container = 16;
inline bool Response::has_wait_container() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Response::set_has_wait_container() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Response::clear_has_wait_container() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Response::clear_wait_container() {
  if (wait_container_ != NULL) wait_container_->Clear();
  clear_has_wait_container();
}
inline const ::mesos::agent::Response_WaitContainer& Response::wait_container() const {
  const ::mesos::agent::Response_WaitContainer* p = wait_container_;
  // @@protoc_insertion_point(field_get:mesos.agent.Response.wait_container)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::agent::Response_WaitContainer*>(
      &::mesos::agent::_Response_WaitContainer_default_instance_);
}
inline ::mesos::agent::Response_WaitContainer* Response::release_wait_container() {
  // @@protoc_insertion_point(field_release:mesos.agent.Response.wait_container)
  clear_has_wait_container();
  ::mesos::agent::Response_WaitContainer* temp = wait_container_;
  wait_container_ = NULL;
  return temp;
}
inline ::mesos::agent::Response_WaitContainer* Response::mutable_wait_container() {
  set_has_wait_container();
  if (wait_container_ == NULL) {
    wait_container_ = new ::mesos::agent::Response_WaitContainer;
  }
  // @@protoc_insertion_point(field_mutable:mesos.agent.Response.wait_container)
  return wait_container_;
}
inline void Response::set_allocated_wait_container(::mesos::agent::Response_WaitContainer* wait_container) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete wait_container_;
  }
  if (wait_container) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      wait_container = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, wait_container, submessage_arena);
    }
    set_has_wait_container();
  } else {
    clear_has_wait_container();
  }
  wait_container_ = wait_container;
  // @@protoc_insertion_point(field_set_allocated:mesos.agent.Response.wait_container)
}

// -------------------------------------------------------------------

// ProcessIO_Data

// optional .mesos.agent.ProcessIO.Data.Type type = 1;
inline bool ProcessIO_Data::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProcessIO_Data::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProcessIO_Data::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProcessIO_Data::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::mesos::agent::ProcessIO_Data_Type ProcessIO_Data::type() const {
  // @@protoc_insertion_point(field_get:mesos.agent.ProcessIO.Data.type)
  return static_cast< ::mesos::agent::ProcessIO_Data_Type >(type_);
}
inline void ProcessIO_Data::set_type(::mesos::agent::ProcessIO_Data_Type value) {
  assert(::mesos::agent::ProcessIO_Data_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:mesos.agent.ProcessIO.Data.type)
}

// optional bytes data = 2;
inline bool ProcessIO_Data::has_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProcessIO_Data::set_has_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProcessIO_Data::clear_has_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProcessIO_Data::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_data();
}
inline const ::std::string& ProcessIO_Data::data() const {
  // @@protoc_insertion_point(field_get:mesos.agent.ProcessIO.Data.data)
  return data_.GetNoArena();
}
inline void ProcessIO_Data::set_data(const ::std::string& value) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.agent.ProcessIO.Data.data)
}
#if LANG_CXX11
inline void ProcessIO_Data::set_data(::std::string&& value) {
  set_has_data();
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mesos.agent.ProcessIO.Data.data)
}
#endif
inline void ProcessIO_Data::set_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.agent.ProcessIO.Data.data)
}
inline void ProcessIO_Data::set_data(const void* value, size_t size) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.agent.ProcessIO.Data.data)
}
inline ::std::string* ProcessIO_Data::mutable_data() {
  set_has_data();
  // @@protoc_insertion_point(field_mutable:mesos.agent.ProcessIO.Data.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ProcessIO_Data::release_data() {
  // @@protoc_insertion_point(field_release:mesos.agent.ProcessIO.Data.data)
  clear_has_data();
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ProcessIO_Data::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    set_has_data();
  } else {
    clear_has_data();
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:mesos.agent.ProcessIO.Data.data)
}

// -------------------------------------------------------------------

// ProcessIO_Control_Heartbeat

// optional .mesos.DurationInfo interval = 1;
inline bool ProcessIO_Control_Heartbeat::has_interval() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProcessIO_Control_Heartbeat::set_has_interval() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProcessIO_Control_Heartbeat::clear_has_interval() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::mesos::DurationInfo& ProcessIO_Control_Heartbeat::interval() const {
  const ::mesos::DurationInfo* p = interval_;
  // @@protoc_insertion_point(field_get:mesos.agent.ProcessIO.Control.Heartbeat.interval)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::DurationInfo*>(
      &::mesos::_DurationInfo_default_instance_);
}
inline ::mesos::DurationInfo* ProcessIO_Control_Heartbeat::release_interval() {
  // @@protoc_insertion_point(field_release:mesos.agent.ProcessIO.Control.Heartbeat.interval)
  clear_has_interval();
  ::mesos::DurationInfo* temp = interval_;
  interval_ = NULL;
  return temp;
}
inline ::mesos::DurationInfo* ProcessIO_Control_Heartbeat::mutable_interval() {
  set_has_interval();
  if (interval_ == NULL) {
    interval_ = new ::mesos::DurationInfo;
  }
  // @@protoc_insertion_point(field_mutable:mesos.agent.ProcessIO.Control.Heartbeat.interval)
  return interval_;
}
inline void ProcessIO_Control_Heartbeat::set_allocated_interval(::mesos::DurationInfo* interval) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(interval_);
  }
  if (interval) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(interval)->GetArena();
    if (message_arena != submessage_arena) {
      interval = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, interval, submessage_arena);
    }
    set_has_interval();
  } else {
    clear_has_interval();
  }
  interval_ = interval;
  // @@protoc_insertion_point(field_set_allocated:mesos.agent.ProcessIO.Control.Heartbeat.interval)
}

// -------------------------------------------------------------------

// ProcessIO_Control

// optional .mesos.agent.ProcessIO.Control.Type type = 1;
inline bool ProcessIO_Control::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ProcessIO_Control::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ProcessIO_Control::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ProcessIO_Control::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::mesos::agent::ProcessIO_Control_Type ProcessIO_Control::type() const {
  // @@protoc_insertion_point(field_get:mesos.agent.ProcessIO.Control.type)
  return static_cast< ::mesos::agent::ProcessIO_Control_Type >(type_);
}
inline void ProcessIO_Control::set_type(::mesos::agent::ProcessIO_Control_Type value) {
  assert(::mesos::agent::ProcessIO_Control_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:mesos.agent.ProcessIO.Control.type)
}

// optional .mesos.TTYInfo tty_info = 2;
inline bool ProcessIO_Control::has_tty_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProcessIO_Control::set_has_tty_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProcessIO_Control::clear_has_tty_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::mesos::TTYInfo& ProcessIO_Control::tty_info() const {
  const ::mesos::TTYInfo* p = tty_info_;
  // @@protoc_insertion_point(field_get:mesos.agent.ProcessIO.Control.tty_info)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::TTYInfo*>(
      &::mesos::_TTYInfo_default_instance_);
}
inline ::mesos::TTYInfo* ProcessIO_Control::release_tty_info() {
  // @@protoc_insertion_point(field_release:mesos.agent.ProcessIO.Control.tty_info)
  clear_has_tty_info();
  ::mesos::TTYInfo* temp = tty_info_;
  tty_info_ = NULL;
  return temp;
}
inline ::mesos::TTYInfo* ProcessIO_Control::mutable_tty_info() {
  set_has_tty_info();
  if (tty_info_ == NULL) {
    tty_info_ = new ::mesos::TTYInfo;
  }
  // @@protoc_insertion_point(field_mutable:mesos.agent.ProcessIO.Control.tty_info)
  return tty_info_;
}
inline void ProcessIO_Control::set_allocated_tty_info(::mesos::TTYInfo* tty_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(tty_info_);
  }
  if (tty_info) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(tty_info)->GetArena();
    if (message_arena != submessage_arena) {
      tty_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, tty_info, submessage_arena);
    }
    set_has_tty_info();
  } else {
    clear_has_tty_info();
  }
  tty_info_ = tty_info;
  // @@protoc_insertion_point(field_set_allocated:mesos.agent.ProcessIO.Control.tty_info)
}

// optional .mesos.agent.ProcessIO.Control.Heartbeat heartbeat = 3;
inline bool ProcessIO_Control::has_heartbeat() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProcessIO_Control::set_has_heartbeat() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProcessIO_Control::clear_has_heartbeat() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProcessIO_Control::clear_heartbeat() {
  if (heartbeat_ != NULL) heartbeat_->Clear();
  clear_has_heartbeat();
}
inline const ::mesos::agent::ProcessIO_Control_Heartbeat& ProcessIO_Control::heartbeat() const {
  const ::mesos::agent::ProcessIO_Control_Heartbeat* p = heartbeat_;
  // @@protoc_insertion_point(field_get:mesos.agent.ProcessIO.Control.heartbeat)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::agent::ProcessIO_Control_Heartbeat*>(
      &::mesos::agent::_ProcessIO_Control_Heartbeat_default_instance_);
}
inline ::mesos::agent::ProcessIO_Control_Heartbeat* ProcessIO_Control::release_heartbeat() {
  // @@protoc_insertion_point(field_release:mesos.agent.ProcessIO.Control.heartbeat)
  clear_has_heartbeat();
  ::mesos::agent::ProcessIO_Control_Heartbeat* temp = heartbeat_;
  heartbeat_ = NULL;
  return temp;
}
inline ::mesos::agent::ProcessIO_Control_Heartbeat* ProcessIO_Control::mutable_heartbeat() {
  set_has_heartbeat();
  if (heartbeat_ == NULL) {
    heartbeat_ = new ::mesos::agent::ProcessIO_Control_Heartbeat;
  }
  // @@protoc_insertion_point(field_mutable:mesos.agent.ProcessIO.Control.heartbeat)
  return heartbeat_;
}
inline void ProcessIO_Control::set_allocated_heartbeat(::mesos::agent::ProcessIO_Control_Heartbeat* heartbeat) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete heartbeat_;
  }
  if (heartbeat) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      heartbeat = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, heartbeat, submessage_arena);
    }
    set_has_heartbeat();
  } else {
    clear_has_heartbeat();
  }
  heartbeat_ = heartbeat;
  // @@protoc_insertion_point(field_set_allocated:mesos.agent.ProcessIO.Control.heartbeat)
}

// -------------------------------------------------------------------

// ProcessIO

// optional .mesos.agent.ProcessIO.Type type = 1;
inline bool ProcessIO::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ProcessIO::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ProcessIO::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ProcessIO::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::mesos::agent::ProcessIO_Type ProcessIO::type() const {
  // @@protoc_insertion_point(field_get:mesos.agent.ProcessIO.type)
  return static_cast< ::mesos::agent::ProcessIO_Type >(type_);
}
inline void ProcessIO::set_type(::mesos::agent::ProcessIO_Type value) {
  assert(::mesos::agent::ProcessIO_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:mesos.agent.ProcessIO.type)
}

// optional .mesos.agent.ProcessIO.Data data = 2;
inline bool ProcessIO::has_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProcessIO::set_has_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProcessIO::clear_has_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProcessIO::clear_data() {
  if (data_ != NULL) data_->Clear();
  clear_has_data();
}
inline const ::mesos::agent::ProcessIO_Data& ProcessIO::data() const {
  const ::mesos::agent::ProcessIO_Data* p = data_;
  // @@protoc_insertion_point(field_get:mesos.agent.ProcessIO.data)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::agent::ProcessIO_Data*>(
      &::mesos::agent::_ProcessIO_Data_default_instance_);
}
inline ::mesos::agent::ProcessIO_Data* ProcessIO::release_data() {
  // @@protoc_insertion_point(field_release:mesos.agent.ProcessIO.data)
  clear_has_data();
  ::mesos::agent::ProcessIO_Data* temp = data_;
  data_ = NULL;
  return temp;
}
inline ::mesos::agent::ProcessIO_Data* ProcessIO::mutable_data() {
  set_has_data();
  if (data_ == NULL) {
    data_ = new ::mesos::agent::ProcessIO_Data;
  }
  // @@protoc_insertion_point(field_mutable:mesos.agent.ProcessIO.data)
  return data_;
}
inline void ProcessIO::set_allocated_data(::mesos::agent::ProcessIO_Data* data) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete data_;
  }
  if (data) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      data = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    set_has_data();
  } else {
    clear_has_data();
  }
  data_ = data;
  // @@protoc_insertion_point(field_set_allocated:mesos.agent.ProcessIO.data)
}

// optional .mesos.agent.ProcessIO.Control control = 3;
inline bool ProcessIO::has_control() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProcessIO::set_has_control() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProcessIO::clear_has_control() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProcessIO::clear_control() {
  if (control_ != NULL) control_->Clear();
  clear_has_control();
}
inline const ::mesos::agent::ProcessIO_Control& ProcessIO::control() const {
  const ::mesos::agent::ProcessIO_Control* p = control_;
  // @@protoc_insertion_point(field_get:mesos.agent.ProcessIO.control)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::agent::ProcessIO_Control*>(
      &::mesos::agent::_ProcessIO_Control_default_instance_);
}
inline ::mesos::agent::ProcessIO_Control* ProcessIO::release_control() {
  // @@protoc_insertion_point(field_release:mesos.agent.ProcessIO.control)
  clear_has_control();
  ::mesos::agent::ProcessIO_Control* temp = control_;
  control_ = NULL;
  return temp;
}
inline ::mesos::agent::ProcessIO_Control* ProcessIO::mutable_control() {
  set_has_control();
  if (control_ == NULL) {
    control_ = new ::mesos::agent::ProcessIO_Control;
  }
  // @@protoc_insertion_point(field_mutable:mesos.agent.ProcessIO.control)
  return control_;
}
inline void ProcessIO::set_allocated_control(::mesos::agent::ProcessIO_Control* control) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete control_;
  }
  if (control) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      control = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, control, submessage_arena);
    }
    set_has_control();
  } else {
    clear_has_control();
  }
  control_ = control;
  // @@protoc_insertion_point(field_set_allocated:mesos.agent.ProcessIO.control)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace agent
}  // namespace mesos

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::mesos::agent::Call_AttachContainerInput_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mesos::agent::Call_AttachContainerInput_Type>() {
  return ::mesos::agent::Call_AttachContainerInput_Type_descriptor();
}
template <> struct is_proto_enum< ::mesos::agent::Call_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mesos::agent::Call_Type>() {
  return ::mesos::agent::Call_Type_descriptor();
}
template <> struct is_proto_enum< ::mesos::agent::Response_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mesos::agent::Response_Type>() {
  return ::mesos::agent::Response_Type_descriptor();
}
template <> struct is_proto_enum< ::mesos::agent::ProcessIO_Data_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mesos::agent::ProcessIO_Data_Type>() {
  return ::mesos::agent::ProcessIO_Data_Type_descriptor();
}
template <> struct is_proto_enum< ::mesos::agent::ProcessIO_Control_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mesos::agent::ProcessIO_Control_Type>() {
  return ::mesos::agent::ProcessIO_Control_Type_descriptor();
}
template <> struct is_proto_enum< ::mesos::agent::ProcessIO_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mesos::agent::ProcessIO_Type>() {
  return ::mesos::agent::ProcessIO_Type_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_mesos_2fagent_2fagent_2eproto__INCLUDED
