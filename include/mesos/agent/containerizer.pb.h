// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mesos/slave/containerizer.proto

#ifndef PROTOBUF_mesos_2fslave_2fcontainerizer_2eproto__INCLUDED
#define PROTOBUF_mesos_2fslave_2fcontainerizer_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "mesos/mesos.pb.h"
#include "mesos/appc/spec.pb.h"
#include "mesos/docker/v1.pb.h"
// @@protoc_insertion_point(includes)

namespace protobuf_mesos_2fslave_2fcontainerizer_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[10];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsContainerLimitationImpl();
void InitDefaultsContainerLimitation();
void InitDefaultsContainerStateImpl();
void InitDefaultsContainerState();
void InitDefaultsContainerRecoverInfoImpl();
void InitDefaultsContainerRecoverInfo();
void InitDefaultsContainerConfig_DockerImpl();
void InitDefaultsContainerConfig_Docker();
void InitDefaultsContainerConfig_AppcImpl();
void InitDefaultsContainerConfig_Appc();
void InitDefaultsContainerConfigImpl();
void InitDefaultsContainerConfig();
void InitDefaultsContainerMountInfoImpl();
void InitDefaultsContainerMountInfo();
void InitDefaultsContainerLaunchInfoImpl();
void InitDefaultsContainerLaunchInfo();
void InitDefaultsContainerTerminationImpl();
void InitDefaultsContainerTermination();
void InitDefaultsContainerLayersImpl();
void InitDefaultsContainerLayers();
inline void InitDefaults() {
  InitDefaultsContainerLimitation();
  InitDefaultsContainerState();
  InitDefaultsContainerRecoverInfo();
  InitDefaultsContainerConfig_Docker();
  InitDefaultsContainerConfig_Appc();
  InitDefaultsContainerConfig();
  InitDefaultsContainerMountInfo();
  InitDefaultsContainerLaunchInfo();
  InitDefaultsContainerTermination();
  InitDefaultsContainerLayers();
}
}  // namespace protobuf_mesos_2fslave_2fcontainerizer_2eproto
namespace mesos {
namespace slave {
class ContainerConfig;
class ContainerConfigDefaultTypeInternal;
extern ContainerConfigDefaultTypeInternal _ContainerConfig_default_instance_;
class ContainerConfig_Appc;
class ContainerConfig_AppcDefaultTypeInternal;
extern ContainerConfig_AppcDefaultTypeInternal _ContainerConfig_Appc_default_instance_;
class ContainerConfig_Docker;
class ContainerConfig_DockerDefaultTypeInternal;
extern ContainerConfig_DockerDefaultTypeInternal _ContainerConfig_Docker_default_instance_;
class ContainerLaunchInfo;
class ContainerLaunchInfoDefaultTypeInternal;
extern ContainerLaunchInfoDefaultTypeInternal _ContainerLaunchInfo_default_instance_;
class ContainerLayers;
class ContainerLayersDefaultTypeInternal;
extern ContainerLayersDefaultTypeInternal _ContainerLayers_default_instance_;
class ContainerLimitation;
class ContainerLimitationDefaultTypeInternal;
extern ContainerLimitationDefaultTypeInternal _ContainerLimitation_default_instance_;
class ContainerMountInfo;
class ContainerMountInfoDefaultTypeInternal;
extern ContainerMountInfoDefaultTypeInternal _ContainerMountInfo_default_instance_;
class ContainerRecoverInfo;
class ContainerRecoverInfoDefaultTypeInternal;
extern ContainerRecoverInfoDefaultTypeInternal _ContainerRecoverInfo_default_instance_;
class ContainerState;
class ContainerStateDefaultTypeInternal;
extern ContainerStateDefaultTypeInternal _ContainerState_default_instance_;
class ContainerTermination;
class ContainerTerminationDefaultTypeInternal;
extern ContainerTerminationDefaultTypeInternal _ContainerTermination_default_instance_;
}  // namespace slave
}  // namespace mesos
namespace mesos {
namespace slave {

enum ContainerClass {
  DEFAULT = 1,
  DEBUG = 2
};
bool ContainerClass_IsValid(int value);
const ContainerClass ContainerClass_MIN = DEFAULT;
const ContainerClass ContainerClass_MAX = DEBUG;
const int ContainerClass_ARRAYSIZE = ContainerClass_MAX + 1;

const ::google::protobuf::EnumDescriptor* ContainerClass_descriptor();
inline const ::std::string& ContainerClass_Name(ContainerClass value) {
  return ::google::protobuf::internal::NameOfEnum(
    ContainerClass_descriptor(), value);
}
inline bool ContainerClass_Parse(
    const ::std::string& name, ContainerClass* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ContainerClass>(
    ContainerClass_descriptor(), name, value);
}
// ===================================================================

class ContainerLimitation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.slave.ContainerLimitation) */ {
 public:
  ContainerLimitation();
  virtual ~ContainerLimitation();

  ContainerLimitation(const ContainerLimitation& from);

  inline ContainerLimitation& operator=(const ContainerLimitation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ContainerLimitation(ContainerLimitation&& from) noexcept
    : ContainerLimitation() {
    *this = ::std::move(from);
  }

  inline ContainerLimitation& operator=(ContainerLimitation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ContainerLimitation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ContainerLimitation* internal_default_instance() {
    return reinterpret_cast<const ContainerLimitation*>(
               &_ContainerLimitation_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(ContainerLimitation* other);
  friend void swap(ContainerLimitation& a, ContainerLimitation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ContainerLimitation* New() const PROTOBUF_FINAL { return New(NULL); }

  ContainerLimitation* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ContainerLimitation& from);
  void MergeFrom(const ContainerLimitation& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ContainerLimitation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.Resource resources = 1;
  int resources_size() const;
  void clear_resources();
  static const int kResourcesFieldNumber = 1;
  const ::mesos::Resource& resources(int index) const;
  ::mesos::Resource* mutable_resources(int index);
  ::mesos::Resource* add_resources();
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
      mutable_resources();
  const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
      resources() const;

  // optional string message = 2;
  bool has_message() const;
  void clear_message();
  static const int kMessageFieldNumber = 2;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // optional .mesos.TaskStatus.Reason reason = 3;
  bool has_reason() const;
  void clear_reason();
  static const int kReasonFieldNumber = 3;
  ::mesos::TaskStatus_Reason reason() const;
  void set_reason(::mesos::TaskStatus_Reason value);

  // @@protoc_insertion_point(class_scope:mesos.slave.ContainerLimitation)
 private:
  void set_has_message();
  void clear_has_message();
  void set_has_reason();
  void clear_has_reason();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource > resources_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  int reason_;
  friend struct ::protobuf_mesos_2fslave_2fcontainerizer_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fslave_2fcontainerizer_2eproto::InitDefaultsContainerLimitationImpl();
};
// -------------------------------------------------------------------

class ContainerState : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.slave.ContainerState) */ {
 public:
  ContainerState();
  virtual ~ContainerState();

  ContainerState(const ContainerState& from);

  inline ContainerState& operator=(const ContainerState& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ContainerState(ContainerState&& from) noexcept
    : ContainerState() {
    *this = ::std::move(from);
  }

  inline ContainerState& operator=(ContainerState&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ContainerState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ContainerState* internal_default_instance() {
    return reinterpret_cast<const ContainerState*>(
               &_ContainerState_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(ContainerState* other);
  friend void swap(ContainerState& a, ContainerState& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ContainerState* New() const PROTOBUF_FINAL { return New(NULL); }

  ContainerState* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ContainerState& from);
  void MergeFrom(const ContainerState& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ContainerState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string directory = 4;
  bool has_directory() const;
  void clear_directory();
  static const int kDirectoryFieldNumber = 4;
  const ::std::string& directory() const;
  void set_directory(const ::std::string& value);
  #if LANG_CXX11
  void set_directory(::std::string&& value);
  #endif
  void set_directory(const char* value);
  void set_directory(const char* value, size_t size);
  ::std::string* mutable_directory();
  ::std::string* release_directory();
  void set_allocated_directory(::std::string* directory);

  // optional .mesos.ExecutorInfo executor_info = 1;
  bool has_executor_info() const;
  void clear_executor_info();
  static const int kExecutorInfoFieldNumber = 1;
  const ::mesos::ExecutorInfo& executor_info() const;
  ::mesos::ExecutorInfo* release_executor_info();
  ::mesos::ExecutorInfo* mutable_executor_info();
  void set_allocated_executor_info(::mesos::ExecutorInfo* executor_info);

  // required .mesos.ContainerID container_id = 2;
  bool has_container_id() const;
  void clear_container_id();
  static const int kContainerIdFieldNumber = 2;
  const ::mesos::ContainerID& container_id() const;
  ::mesos::ContainerID* release_container_id();
  ::mesos::ContainerID* mutable_container_id();
  void set_allocated_container_id(::mesos::ContainerID* container_id);

  // required uint64 pid = 3;
  bool has_pid() const;
  void clear_pid();
  static const int kPidFieldNumber = 3;
  ::google::protobuf::uint64 pid() const;
  void set_pid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:mesos.slave.ContainerState)
 private:
  void set_has_executor_info();
  void clear_has_executor_info();
  void set_has_container_id();
  void clear_has_container_id();
  void set_has_pid();
  void clear_has_pid();
  void set_has_directory();
  void clear_has_directory();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr directory_;
  ::mesos::ExecutorInfo* executor_info_;
  ::mesos::ContainerID* container_id_;
  ::google::protobuf::uint64 pid_;
  friend struct ::protobuf_mesos_2fslave_2fcontainerizer_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fslave_2fcontainerizer_2eproto::InitDefaultsContainerStateImpl();
};
// -------------------------------------------------------------------

class ContainerRecoverInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.slave.ContainerRecoverInfo) */ {
 public:
  ContainerRecoverInfo();
  virtual ~ContainerRecoverInfo();

  ContainerRecoverInfo(const ContainerRecoverInfo& from);

  inline ContainerRecoverInfo& operator=(const ContainerRecoverInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ContainerRecoverInfo(ContainerRecoverInfo&& from) noexcept
    : ContainerRecoverInfo() {
    *this = ::std::move(from);
  }

  inline ContainerRecoverInfo& operator=(ContainerRecoverInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ContainerRecoverInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ContainerRecoverInfo* internal_default_instance() {
    return reinterpret_cast<const ContainerRecoverInfo*>(
               &_ContainerRecoverInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(ContainerRecoverInfo* other);
  friend void swap(ContainerRecoverInfo& a, ContainerRecoverInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ContainerRecoverInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  ContainerRecoverInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ContainerRecoverInfo& from);
  void MergeFrom(const ContainerRecoverInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ContainerRecoverInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.slave.ContainerState checkpointed_container_states = 1;
  int checkpointed_container_states_size() const;
  void clear_checkpointed_container_states();
  static const int kCheckpointedContainerStatesFieldNumber = 1;
  const ::mesos::slave::ContainerState& checkpointed_container_states(int index) const;
  ::mesos::slave::ContainerState* mutable_checkpointed_container_states(int index);
  ::mesos::slave::ContainerState* add_checkpointed_container_states();
  ::google::protobuf::RepeatedPtrField< ::mesos::slave::ContainerState >*
      mutable_checkpointed_container_states();
  const ::google::protobuf::RepeatedPtrField< ::mesos::slave::ContainerState >&
      checkpointed_container_states() const;

  // repeated .mesos.ContainerID orphan_container_ids = 2;
  int orphan_container_ids_size() const;
  void clear_orphan_container_ids();
  static const int kOrphanContainerIdsFieldNumber = 2;
  const ::mesos::ContainerID& orphan_container_ids(int index) const;
  ::mesos::ContainerID* mutable_orphan_container_ids(int index);
  ::mesos::ContainerID* add_orphan_container_ids();
  ::google::protobuf::RepeatedPtrField< ::mesos::ContainerID >*
      mutable_orphan_container_ids();
  const ::google::protobuf::RepeatedPtrField< ::mesos::ContainerID >&
      orphan_container_ids() const;

  // repeated .mesos.ContainerID known_container_ids = 3;
  int known_container_ids_size() const;
  void clear_known_container_ids();
  static const int kKnownContainerIdsFieldNumber = 3;
  const ::mesos::ContainerID& known_container_ids(int index) const;
  ::mesos::ContainerID* mutable_known_container_ids(int index);
  ::mesos::ContainerID* add_known_container_ids();
  ::google::protobuf::RepeatedPtrField< ::mesos::ContainerID >*
      mutable_known_container_ids();
  const ::google::protobuf::RepeatedPtrField< ::mesos::ContainerID >&
      known_container_ids() const;

  // @@protoc_insertion_point(class_scope:mesos.slave.ContainerRecoverInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::slave::ContainerState > checkpointed_container_states_;
  ::google::protobuf::RepeatedPtrField< ::mesos::ContainerID > orphan_container_ids_;
  ::google::protobuf::RepeatedPtrField< ::mesos::ContainerID > known_container_ids_;
  friend struct ::protobuf_mesos_2fslave_2fcontainerizer_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fslave_2fcontainerizer_2eproto::InitDefaultsContainerRecoverInfoImpl();
};
// -------------------------------------------------------------------

class ContainerConfig_Docker : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.slave.ContainerConfig.Docker) */ {
 public:
  ContainerConfig_Docker();
  virtual ~ContainerConfig_Docker();

  ContainerConfig_Docker(const ContainerConfig_Docker& from);

  inline ContainerConfig_Docker& operator=(const ContainerConfig_Docker& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ContainerConfig_Docker(ContainerConfig_Docker&& from) noexcept
    : ContainerConfig_Docker() {
    *this = ::std::move(from);
  }

  inline ContainerConfig_Docker& operator=(ContainerConfig_Docker&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ContainerConfig_Docker& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ContainerConfig_Docker* internal_default_instance() {
    return reinterpret_cast<const ContainerConfig_Docker*>(
               &_ContainerConfig_Docker_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(ContainerConfig_Docker* other);
  friend void swap(ContainerConfig_Docker& a, ContainerConfig_Docker& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ContainerConfig_Docker* New() const PROTOBUF_FINAL { return New(NULL); }

  ContainerConfig_Docker* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ContainerConfig_Docker& from);
  void MergeFrom(const ContainerConfig_Docker& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ContainerConfig_Docker* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .docker.spec.v1.ImageManifest manifest = 1;
  bool has_manifest() const;
  void clear_manifest();
  static const int kManifestFieldNumber = 1;
  const ::docker::spec::v1::ImageManifest& manifest() const;
  ::docker::spec::v1::ImageManifest* release_manifest();
  ::docker::spec::v1::ImageManifest* mutable_manifest();
  void set_allocated_manifest(::docker::spec::v1::ImageManifest* manifest);

  // @@protoc_insertion_point(class_scope:mesos.slave.ContainerConfig.Docker)
 private:
  void set_has_manifest();
  void clear_has_manifest();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::docker::spec::v1::ImageManifest* manifest_;
  friend struct ::protobuf_mesos_2fslave_2fcontainerizer_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fslave_2fcontainerizer_2eproto::InitDefaultsContainerConfig_DockerImpl();
};
// -------------------------------------------------------------------

class ContainerConfig_Appc : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.slave.ContainerConfig.Appc) */ {
 public:
  ContainerConfig_Appc();
  virtual ~ContainerConfig_Appc();

  ContainerConfig_Appc(const ContainerConfig_Appc& from);

  inline ContainerConfig_Appc& operator=(const ContainerConfig_Appc& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ContainerConfig_Appc(ContainerConfig_Appc&& from) noexcept
    : ContainerConfig_Appc() {
    *this = ::std::move(from);
  }

  inline ContainerConfig_Appc& operator=(ContainerConfig_Appc&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ContainerConfig_Appc& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ContainerConfig_Appc* internal_default_instance() {
    return reinterpret_cast<const ContainerConfig_Appc*>(
               &_ContainerConfig_Appc_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(ContainerConfig_Appc* other);
  friend void swap(ContainerConfig_Appc& a, ContainerConfig_Appc& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ContainerConfig_Appc* New() const PROTOBUF_FINAL { return New(NULL); }

  ContainerConfig_Appc* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ContainerConfig_Appc& from);
  void MergeFrom(const ContainerConfig_Appc& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ContainerConfig_Appc* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .appc.spec.ImageManifest manifest = 1;
  bool has_manifest() const;
  void clear_manifest();
  static const int kManifestFieldNumber = 1;
  const ::appc::spec::ImageManifest& manifest() const;
  ::appc::spec::ImageManifest* release_manifest();
  ::appc::spec::ImageManifest* mutable_manifest();
  void set_allocated_manifest(::appc::spec::ImageManifest* manifest);

  // @@protoc_insertion_point(class_scope:mesos.slave.ContainerConfig.Appc)
 private:
  void set_has_manifest();
  void clear_has_manifest();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::appc::spec::ImageManifest* manifest_;
  friend struct ::protobuf_mesos_2fslave_2fcontainerizer_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fslave_2fcontainerizer_2eproto::InitDefaultsContainerConfig_AppcImpl();
};
// -------------------------------------------------------------------

class ContainerConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.slave.ContainerConfig) */ {
 public:
  ContainerConfig();
  virtual ~ContainerConfig();

  ContainerConfig(const ContainerConfig& from);

  inline ContainerConfig& operator=(const ContainerConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ContainerConfig(ContainerConfig&& from) noexcept
    : ContainerConfig() {
    *this = ::std::move(from);
  }

  inline ContainerConfig& operator=(ContainerConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ContainerConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ContainerConfig* internal_default_instance() {
    return reinterpret_cast<const ContainerConfig*>(
               &_ContainerConfig_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(ContainerConfig* other);
  friend void swap(ContainerConfig& a, ContainerConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ContainerConfig* New() const PROTOBUF_FINAL { return New(NULL); }

  ContainerConfig* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ContainerConfig& from);
  void MergeFrom(const ContainerConfig& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ContainerConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef ContainerConfig_Docker Docker;
  typedef ContainerConfig_Appc Appc;

  // accessors -------------------------------------------------------

  // repeated .mesos.Resource resources = 13;
  int resources_size() const;
  void clear_resources();
  static const int kResourcesFieldNumber = 13;
  const ::mesos::Resource& resources(int index) const;
  ::mesos::Resource* mutable_resources(int index);
  ::mesos::Resource* add_resources();
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
      mutable_resources();
  const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
      resources() const;

  // required string directory = 3;
  bool has_directory() const;
  void clear_directory();
  static const int kDirectoryFieldNumber = 3;
  const ::std::string& directory() const;
  void set_directory(const ::std::string& value);
  #if LANG_CXX11
  void set_directory(::std::string&& value);
  #endif
  void set_directory(const char* value);
  void set_directory(const char* value, size_t size);
  ::std::string* mutable_directory();
  ::std::string* release_directory();
  void set_allocated_directory(::std::string* directory);

  // optional string user = 4;
  bool has_user() const;
  void clear_user();
  static const int kUserFieldNumber = 4;
  const ::std::string& user() const;
  void set_user(const ::std::string& value);
  #if LANG_CXX11
  void set_user(::std::string&& value);
  #endif
  void set_user(const char* value);
  void set_user(const char* value, size_t size);
  ::std::string* mutable_user();
  ::std::string* release_user();
  void set_allocated_user(::std::string* user);

  // optional string rootfs = 5;
  bool has_rootfs() const;
  void clear_rootfs();
  static const int kRootfsFieldNumber = 5;
  const ::std::string& rootfs() const;
  void set_rootfs(const ::std::string& value);
  #if LANG_CXX11
  void set_rootfs(::std::string&& value);
  #endif
  void set_rootfs(const char* value);
  void set_rootfs(const char* value, size_t size);
  ::std::string* mutable_rootfs();
  ::std::string* release_rootfs();
  void set_allocated_rootfs(::std::string* rootfs);

  // optional .mesos.slave.ContainerConfig.Docker docker = 7;
  bool has_docker() const;
  void clear_docker();
  static const int kDockerFieldNumber = 7;
  const ::mesos::slave::ContainerConfig_Docker& docker() const;
  ::mesos::slave::ContainerConfig_Docker* release_docker();
  ::mesos::slave::ContainerConfig_Docker* mutable_docker();
  void set_allocated_docker(::mesos::slave::ContainerConfig_Docker* docker);

  // optional .mesos.ExecutorInfo executor_info = 8;
  bool has_executor_info() const;
  void clear_executor_info();
  static const int kExecutorInfoFieldNumber = 8;
  const ::mesos::ExecutorInfo& executor_info() const;
  ::mesos::ExecutorInfo* release_executor_info();
  ::mesos::ExecutorInfo* mutable_executor_info();
  void set_allocated_executor_info(::mesos::ExecutorInfo* executor_info);

  // optional .mesos.TaskInfo task_info = 9;
  bool has_task_info() const;
  void clear_task_info();
  static const int kTaskInfoFieldNumber = 9;
  const ::mesos::TaskInfo& task_info() const;
  ::mesos::TaskInfo* release_task_info();
  ::mesos::TaskInfo* mutable_task_info();
  void set_allocated_task_info(::mesos::TaskInfo* task_info);

  // optional .mesos.slave.ContainerConfig.Appc appc = 10;
  bool has_appc() const;
  void clear_appc();
  static const int kAppcFieldNumber = 10;
  const ::mesos::slave::ContainerConfig_Appc& appc() const;
  ::mesos::slave::ContainerConfig_Appc* release_appc();
  ::mesos::slave::ContainerConfig_Appc* mutable_appc();
  void set_allocated_appc(::mesos::slave::ContainerConfig_Appc* appc);

  // required .mesos.CommandInfo command_info = 11;
  bool has_command_info() const;
  void clear_command_info();
  static const int kCommandInfoFieldNumber = 11;
  const ::mesos::CommandInfo& command_info() const;
  ::mesos::CommandInfo* release_command_info();
  ::mesos::CommandInfo* mutable_command_info();
  void set_allocated_command_info(::mesos::CommandInfo* command_info);

  // optional .mesos.ContainerInfo container_info = 12;
  bool has_container_info() const;
  void clear_container_info();
  static const int kContainerInfoFieldNumber = 12;
  const ::mesos::ContainerInfo& container_info() const;
  ::mesos::ContainerInfo* release_container_info();
  ::mesos::ContainerInfo* mutable_container_info();
  void set_allocated_container_info(::mesos::ContainerInfo* container_info);

  // optional .mesos.slave.ContainerClass container_class = 14;
  bool has_container_class() const;
  void clear_container_class();
  static const int kContainerClassFieldNumber = 14;
  ::mesos::slave::ContainerClass container_class() const;
  void set_container_class(::mesos::slave::ContainerClass value);

  // @@protoc_insertion_point(class_scope:mesos.slave.ContainerConfig)
 private:
  void set_has_executor_info();
  void clear_has_executor_info();
  void set_has_task_info();
  void clear_has_task_info();
  void set_has_command_info();
  void clear_has_command_info();
  void set_has_container_info();
  void clear_has_container_info();
  void set_has_container_class();
  void clear_has_container_class();
  void set_has_directory();
  void clear_has_directory();
  void set_has_user();
  void clear_has_user();
  void set_has_rootfs();
  void clear_has_rootfs();
  void set_has_docker();
  void clear_has_docker();
  void set_has_appc();
  void clear_has_appc();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource > resources_;
  ::google::protobuf::internal::ArenaStringPtr directory_;
  ::google::protobuf::internal::ArenaStringPtr user_;
  ::google::protobuf::internal::ArenaStringPtr rootfs_;
  ::mesos::slave::ContainerConfig_Docker* docker_;
  ::mesos::ExecutorInfo* executor_info_;
  ::mesos::TaskInfo* task_info_;
  ::mesos::slave::ContainerConfig_Appc* appc_;
  ::mesos::CommandInfo* command_info_;
  ::mesos::ContainerInfo* container_info_;
  int container_class_;
  friend struct ::protobuf_mesos_2fslave_2fcontainerizer_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fslave_2fcontainerizer_2eproto::InitDefaultsContainerConfigImpl();
};
// -------------------------------------------------------------------

class ContainerMountInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.slave.ContainerMountInfo) */ {
 public:
  ContainerMountInfo();
  virtual ~ContainerMountInfo();

  ContainerMountInfo(const ContainerMountInfo& from);

  inline ContainerMountInfo& operator=(const ContainerMountInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ContainerMountInfo(ContainerMountInfo&& from) noexcept
    : ContainerMountInfo() {
    *this = ::std::move(from);
  }

  inline ContainerMountInfo& operator=(ContainerMountInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ContainerMountInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ContainerMountInfo* internal_default_instance() {
    return reinterpret_cast<const ContainerMountInfo*>(
               &_ContainerMountInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(ContainerMountInfo* other);
  friend void swap(ContainerMountInfo& a, ContainerMountInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ContainerMountInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  ContainerMountInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ContainerMountInfo& from);
  void MergeFrom(const ContainerMountInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ContainerMountInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string target = 1;
  bool has_target() const;
  void clear_target();
  static const int kTargetFieldNumber = 1;
  const ::std::string& target() const;
  void set_target(const ::std::string& value);
  #if LANG_CXX11
  void set_target(::std::string&& value);
  #endif
  void set_target(const char* value);
  void set_target(const char* value, size_t size);
  ::std::string* mutable_target();
  ::std::string* release_target();
  void set_allocated_target(::std::string* target);

  // optional string source = 2;
  bool has_source() const;
  void clear_source();
  static const int kSourceFieldNumber = 2;
  const ::std::string& source() const;
  void set_source(const ::std::string& value);
  #if LANG_CXX11
  void set_source(::std::string&& value);
  #endif
  void set_source(const char* value);
  void set_source(const char* value, size_t size);
  ::std::string* mutable_source();
  ::std::string* release_source();
  void set_allocated_source(::std::string* source);

  // optional string type = 3;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 3;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // optional string options = 5;
  bool has_options() const;
  void clear_options();
  static const int kOptionsFieldNumber = 5;
  const ::std::string& options() const;
  void set_options(const ::std::string& value);
  #if LANG_CXX11
  void set_options(::std::string&& value);
  #endif
  void set_options(const char* value);
  void set_options(const char* value, size_t size);
  ::std::string* mutable_options();
  ::std::string* release_options();
  void set_allocated_options(::std::string* options);

  // optional uint32 flags = 4;
  bool has_flags() const;
  void clear_flags();
  static const int kFlagsFieldNumber = 4;
  ::google::protobuf::uint32 flags() const;
  void set_flags(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mesos.slave.ContainerMountInfo)
 private:
  void set_has_target();
  void clear_has_target();
  void set_has_source();
  void clear_has_source();
  void set_has_type();
  void clear_has_type();
  void set_has_flags();
  void clear_has_flags();
  void set_has_options();
  void clear_has_options();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr target_;
  ::google::protobuf::internal::ArenaStringPtr source_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  ::google::protobuf::internal::ArenaStringPtr options_;
  ::google::protobuf::uint32 flags_;
  friend struct ::protobuf_mesos_2fslave_2fcontainerizer_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fslave_2fcontainerizer_2eproto::InitDefaultsContainerMountInfoImpl();
};
// -------------------------------------------------------------------

class ContainerLaunchInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.slave.ContainerLaunchInfo) */ {
 public:
  ContainerLaunchInfo();
  virtual ~ContainerLaunchInfo();

  ContainerLaunchInfo(const ContainerLaunchInfo& from);

  inline ContainerLaunchInfo& operator=(const ContainerLaunchInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ContainerLaunchInfo(ContainerLaunchInfo&& from) noexcept
    : ContainerLaunchInfo() {
    *this = ::std::move(from);
  }

  inline ContainerLaunchInfo& operator=(ContainerLaunchInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ContainerLaunchInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ContainerLaunchInfo* internal_default_instance() {
    return reinterpret_cast<const ContainerLaunchInfo*>(
               &_ContainerLaunchInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(ContainerLaunchInfo* other);
  friend void swap(ContainerLaunchInfo& a, ContainerLaunchInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ContainerLaunchInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  ContainerLaunchInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ContainerLaunchInfo& from);
  void MergeFrom(const ContainerLaunchInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ContainerLaunchInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.CommandInfo pre_exec_commands = 1;
  int pre_exec_commands_size() const;
  void clear_pre_exec_commands();
  static const int kPreExecCommandsFieldNumber = 1;
  const ::mesos::CommandInfo& pre_exec_commands(int index) const;
  ::mesos::CommandInfo* mutable_pre_exec_commands(int index);
  ::mesos::CommandInfo* add_pre_exec_commands();
  ::google::protobuf::RepeatedPtrField< ::mesos::CommandInfo >*
      mutable_pre_exec_commands();
  const ::google::protobuf::RepeatedPtrField< ::mesos::CommandInfo >&
      pre_exec_commands() const;

  // repeated int32 clone_namespaces = 4;
  int clone_namespaces_size() const;
  void clear_clone_namespaces();
  static const int kCloneNamespacesFieldNumber = 4;
  ::google::protobuf::int32 clone_namespaces(int index) const;
  void set_clone_namespaces(int index, ::google::protobuf::int32 value);
  void add_clone_namespaces(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      clone_namespaces() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_clone_namespaces();

  // repeated int32 enter_namespaces = 9;
  int enter_namespaces_size() const;
  void clear_enter_namespaces();
  static const int kEnterNamespacesFieldNumber = 9;
  ::google::protobuf::int32 enter_namespaces(int index) const;
  void set_enter_namespaces(int index, ::google::protobuf::int32 value);
  void add_enter_namespaces(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      enter_namespaces() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_enter_namespaces();

  // repeated .mesos.slave.ContainerMountInfo mounts = 17;
  int mounts_size() const;
  void clear_mounts();
  static const int kMountsFieldNumber = 17;
  const ::mesos::slave::ContainerMountInfo& mounts(int index) const;
  ::mesos::slave::ContainerMountInfo* mutable_mounts(int index);
  ::mesos::slave::ContainerMountInfo* add_mounts();
  ::google::protobuf::RepeatedPtrField< ::mesos::slave::ContainerMountInfo >*
      mutable_mounts();
  const ::google::protobuf::RepeatedPtrField< ::mesos::slave::ContainerMountInfo >&
      mounts() const;

  // optional string rootfs = 3;
  bool has_rootfs() const;
  void clear_rootfs();
  static const int kRootfsFieldNumber = 3;
  const ::std::string& rootfs() const;
  void set_rootfs(const ::std::string& value);
  #if LANG_CXX11
  void set_rootfs(::std::string&& value);
  #endif
  void set_rootfs(const char* value);
  void set_rootfs(const char* value, size_t size);
  ::std::string* mutable_rootfs();
  ::std::string* release_rootfs();
  void set_allocated_rootfs(::std::string* rootfs);

  // optional string working_directory = 6;
  bool has_working_directory() const;
  void clear_working_directory();
  static const int kWorkingDirectoryFieldNumber = 6;
  const ::std::string& working_directory() const;
  void set_working_directory(const ::std::string& value);
  #if LANG_CXX11
  void set_working_directory(::std::string&& value);
  #endif
  void set_working_directory(const char* value);
  void set_working_directory(const char* value, size_t size);
  ::std::string* mutable_working_directory();
  ::std::string* release_working_directory();
  void set_allocated_working_directory(::std::string* working_directory);

  // optional string user = 10;
  bool has_user() const;
  void clear_user();
  static const int kUserFieldNumber = 10;
  const ::std::string& user() const;
  void set_user(const ::std::string& value);
  #if LANG_CXX11
  void set_user(::std::string&& value);
  #endif
  void set_user(const char* value);
  void set_user(const char* value, size_t size);
  ::std::string* mutable_user();
  ::std::string* release_user();
  void set_allocated_user(::std::string* user);

  // optional string tty_slave_path = 14;
  bool has_tty_slave_path() const;
  void clear_tty_slave_path();
  static const int kTtySlavePathFieldNumber = 14;
  const ::std::string& tty_slave_path() const;
  void set_tty_slave_path(const ::std::string& value);
  #if LANG_CXX11
  void set_tty_slave_path(::std::string&& value);
  #endif
  void set_tty_slave_path(const char* value);
  void set_tty_slave_path(const char* value, size_t size);
  ::std::string* mutable_tty_slave_path();
  ::std::string* release_tty_slave_path();
  void set_allocated_tty_slave_path(::std::string* tty_slave_path);

  // optional .mesos.Environment environment = 2;
  bool has_environment() const;
  void clear_environment();
  static const int kEnvironmentFieldNumber = 2;
  const ::mesos::Environment& environment() const;
  ::mesos::Environment* release_environment();
  ::mesos::Environment* mutable_environment();
  void set_allocated_environment(::mesos::Environment* environment);

  // optional .mesos.CommandInfo command = 5;
  bool has_command() const;
  void clear_command();
  static const int kCommandFieldNumber = 5;
  const ::mesos::CommandInfo& command() const;
  ::mesos::CommandInfo* release_command();
  ::mesos::CommandInfo* mutable_command();
  void set_allocated_command(::mesos::CommandInfo* command);

  // optional .mesos.CapabilityInfo effective_capabilities = 7;
  bool has_effective_capabilities() const;
  void clear_effective_capabilities();
  static const int kEffectiveCapabilitiesFieldNumber = 7;
  const ::mesos::CapabilityInfo& effective_capabilities() const;
  ::mesos::CapabilityInfo* release_effective_capabilities();
  ::mesos::CapabilityInfo* mutable_effective_capabilities();
  void set_allocated_effective_capabilities(::mesos::CapabilityInfo* effective_capabilities);

  // optional .mesos.RLimitInfo rlimits = 8;
  bool has_rlimits() const;
  void clear_rlimits();
  static const int kRlimitsFieldNumber = 8;
  const ::mesos::RLimitInfo& rlimits() const;
  ::mesos::RLimitInfo* release_rlimits();
  ::mesos::RLimitInfo* mutable_rlimits();
  void set_allocated_rlimits(::mesos::RLimitInfo* rlimits);

  // optional .mesos.Environment task_environment = 15;
  bool has_task_environment() const;
  void clear_task_environment();
  static const int kTaskEnvironmentFieldNumber = 15;
  const ::mesos::Environment& task_environment() const;
  ::mesos::Environment* release_task_environment();
  ::mesos::Environment* mutable_task_environment();
  void set_allocated_task_environment(::mesos::Environment* task_environment);

  // optional .mesos.CapabilityInfo bounding_capabilities = 16;
  bool has_bounding_capabilities() const;
  void clear_bounding_capabilities();
  static const int kBoundingCapabilitiesFieldNumber = 16;
  const ::mesos::CapabilityInfo& bounding_capabilities() const;
  ::mesos::CapabilityInfo* release_bounding_capabilities();
  ::mesos::CapabilityInfo* mutable_bounding_capabilities();
  void set_allocated_bounding_capabilities(::mesos::CapabilityInfo* bounding_capabilities);

  // @@protoc_insertion_point(class_scope:mesos.slave.ContainerLaunchInfo)
 private:
  void set_has_environment();
  void clear_has_environment();
  void set_has_rootfs();
  void clear_has_rootfs();
  void set_has_user();
  void clear_has_user();
  void set_has_command();
  void clear_has_command();
  void set_has_working_directory();
  void clear_has_working_directory();
  void set_has_effective_capabilities();
  void clear_has_effective_capabilities();
  void set_has_bounding_capabilities();
  void clear_has_bounding_capabilities();
  void set_has_rlimits();
  void clear_has_rlimits();
  void set_has_tty_slave_path();
  void clear_has_tty_slave_path();
  void set_has_task_environment();
  void clear_has_task_environment();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::CommandInfo > pre_exec_commands_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > clone_namespaces_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > enter_namespaces_;
  ::google::protobuf::RepeatedPtrField< ::mesos::slave::ContainerMountInfo > mounts_;
  ::google::protobuf::internal::ArenaStringPtr rootfs_;
  ::google::protobuf::internal::ArenaStringPtr working_directory_;
  ::google::protobuf::internal::ArenaStringPtr user_;
  ::google::protobuf::internal::ArenaStringPtr tty_slave_path_;
  ::mesos::Environment* environment_;
  ::mesos::CommandInfo* command_;
  ::mesos::CapabilityInfo* effective_capabilities_;
  ::mesos::RLimitInfo* rlimits_;
  ::mesos::Environment* task_environment_;
  ::mesos::CapabilityInfo* bounding_capabilities_;
  friend struct ::protobuf_mesos_2fslave_2fcontainerizer_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fslave_2fcontainerizer_2eproto::InitDefaultsContainerLaunchInfoImpl();
};
// -------------------------------------------------------------------

class ContainerTermination : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.slave.ContainerTermination) */ {
 public:
  ContainerTermination();
  virtual ~ContainerTermination();

  ContainerTermination(const ContainerTermination& from);

  inline ContainerTermination& operator=(const ContainerTermination& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ContainerTermination(ContainerTermination&& from) noexcept
    : ContainerTermination() {
    *this = ::std::move(from);
  }

  inline ContainerTermination& operator=(ContainerTermination&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ContainerTermination& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ContainerTermination* internal_default_instance() {
    return reinterpret_cast<const ContainerTermination*>(
               &_ContainerTermination_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(ContainerTermination* other);
  friend void swap(ContainerTermination& a, ContainerTermination& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ContainerTermination* New() const PROTOBUF_FINAL { return New(NULL); }

  ContainerTermination* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ContainerTermination& from);
  void MergeFrom(const ContainerTermination& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ContainerTermination* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.Resource limited_resources = 6;
  int limited_resources_size() const;
  void clear_limited_resources();
  static const int kLimitedResourcesFieldNumber = 6;
  const ::mesos::Resource& limited_resources(int index) const;
  ::mesos::Resource* mutable_limited_resources(int index);
  ::mesos::Resource* add_limited_resources();
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
      mutable_limited_resources();
  const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
      limited_resources() const;

  // optional string message = 2;
  bool has_message() const;
  void clear_message();
  static const int kMessageFieldNumber = 2;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // optional int32 status = 3;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 3;
  ::google::protobuf::int32 status() const;
  void set_status(::google::protobuf::int32 value);

  // optional .mesos.TaskStatus.Reason reason = 5;
  bool has_reason() const;
  void clear_reason();
  static const int kReasonFieldNumber = 5;
  ::mesos::TaskStatus_Reason reason() const;
  void set_reason(::mesos::TaskStatus_Reason value);

  // optional .mesos.TaskState state = 4;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 4;
  ::mesos::TaskState state() const;
  void set_state(::mesos::TaskState value);

  // @@protoc_insertion_point(class_scope:mesos.slave.ContainerTermination)
 private:
  void set_has_status();
  void clear_has_status();
  void set_has_state();
  void clear_has_state();
  void set_has_reason();
  void clear_has_reason();
  void set_has_message();
  void clear_has_message();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource > limited_resources_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  ::google::protobuf::int32 status_;
  int reason_;
  int state_;
  friend struct ::protobuf_mesos_2fslave_2fcontainerizer_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fslave_2fcontainerizer_2eproto::InitDefaultsContainerTerminationImpl();
};
// -------------------------------------------------------------------

class ContainerLayers : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mesos.slave.ContainerLayers) */ {
 public:
  ContainerLayers();
  virtual ~ContainerLayers();

  ContainerLayers(const ContainerLayers& from);

  inline ContainerLayers& operator=(const ContainerLayers& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ContainerLayers(ContainerLayers&& from) noexcept
    : ContainerLayers() {
    *this = ::std::move(from);
  }

  inline ContainerLayers& operator=(ContainerLayers&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ContainerLayers& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ContainerLayers* internal_default_instance() {
    return reinterpret_cast<const ContainerLayers*>(
               &_ContainerLayers_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(ContainerLayers* other);
  friend void swap(ContainerLayers& a, ContainerLayers& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ContainerLayers* New() const PROTOBUF_FINAL { return New(NULL); }

  ContainerLayers* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ContainerLayers& from);
  void MergeFrom(const ContainerLayers& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ContainerLayers* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string paths = 1;
  int paths_size() const;
  void clear_paths();
  static const int kPathsFieldNumber = 1;
  const ::std::string& paths(int index) const;
  ::std::string* mutable_paths(int index);
  void set_paths(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_paths(int index, ::std::string&& value);
  #endif
  void set_paths(int index, const char* value);
  void set_paths(int index, const char* value, size_t size);
  ::std::string* add_paths();
  void add_paths(const ::std::string& value);
  #if LANG_CXX11
  void add_paths(::std::string&& value);
  #endif
  void add_paths(const char* value);
  void add_paths(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& paths() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_paths();

  // @@protoc_insertion_point(class_scope:mesos.slave.ContainerLayers)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> paths_;
  friend struct ::protobuf_mesos_2fslave_2fcontainerizer_2eproto::TableStruct;
  friend void ::protobuf_mesos_2fslave_2fcontainerizer_2eproto::InitDefaultsContainerLayersImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ContainerLimitation

// repeated .mesos.Resource resources = 1;
inline int ContainerLimitation::resources_size() const {
  return resources_.size();
}
inline const ::mesos::Resource& ContainerLimitation::resources(int index) const {
  // @@protoc_insertion_point(field_get:mesos.slave.ContainerLimitation.resources)
  return resources_.Get(index);
}
inline ::mesos::Resource* ContainerLimitation::mutable_resources(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.slave.ContainerLimitation.resources)
  return resources_.Mutable(index);
}
inline ::mesos::Resource* ContainerLimitation::add_resources() {
  // @@protoc_insertion_point(field_add:mesos.slave.ContainerLimitation.resources)
  return resources_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
ContainerLimitation::mutable_resources() {
  // @@protoc_insertion_point(field_mutable_list:mesos.slave.ContainerLimitation.resources)
  return &resources_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
ContainerLimitation::resources() const {
  // @@protoc_insertion_point(field_list:mesos.slave.ContainerLimitation.resources)
  return resources_;
}

// optional string message = 2;
inline bool ContainerLimitation::has_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ContainerLimitation::set_has_message() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ContainerLimitation::clear_has_message() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ContainerLimitation::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_message();
}
inline const ::std::string& ContainerLimitation::message() const {
  // @@protoc_insertion_point(field_get:mesos.slave.ContainerLimitation.message)
  return message_.GetNoArena();
}
inline void ContainerLimitation::set_message(const ::std::string& value) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.slave.ContainerLimitation.message)
}
#if LANG_CXX11
inline void ContainerLimitation::set_message(::std::string&& value) {
  set_has_message();
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mesos.slave.ContainerLimitation.message)
}
#endif
inline void ContainerLimitation::set_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.slave.ContainerLimitation.message)
}
inline void ContainerLimitation::set_message(const char* value, size_t size) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.slave.ContainerLimitation.message)
}
inline ::std::string* ContainerLimitation::mutable_message() {
  set_has_message();
  // @@protoc_insertion_point(field_mutable:mesos.slave.ContainerLimitation.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ContainerLimitation::release_message() {
  // @@protoc_insertion_point(field_release:mesos.slave.ContainerLimitation.message)
  clear_has_message();
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ContainerLimitation::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    set_has_message();
  } else {
    clear_has_message();
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:mesos.slave.ContainerLimitation.message)
}

// optional .mesos.TaskStatus.Reason reason = 3;
inline bool ContainerLimitation::has_reason() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ContainerLimitation::set_has_reason() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ContainerLimitation::clear_has_reason() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ContainerLimitation::clear_reason() {
  reason_ = 0;
  clear_has_reason();
}
inline ::mesos::TaskStatus_Reason ContainerLimitation::reason() const {
  // @@protoc_insertion_point(field_get:mesos.slave.ContainerLimitation.reason)
  return static_cast< ::mesos::TaskStatus_Reason >(reason_);
}
inline void ContainerLimitation::set_reason(::mesos::TaskStatus_Reason value) {
  assert(::mesos::TaskStatus_Reason_IsValid(value));
  set_has_reason();
  reason_ = value;
  // @@protoc_insertion_point(field_set:mesos.slave.ContainerLimitation.reason)
}

// -------------------------------------------------------------------

// ContainerState

// optional .mesos.ExecutorInfo executor_info = 1;
inline bool ContainerState::has_executor_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ContainerState::set_has_executor_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ContainerState::clear_has_executor_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::mesos::ExecutorInfo& ContainerState::executor_info() const {
  const ::mesos::ExecutorInfo* p = executor_info_;
  // @@protoc_insertion_point(field_get:mesos.slave.ContainerState.executor_info)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ExecutorInfo*>(
      &::mesos::_ExecutorInfo_default_instance_);
}
inline ::mesos::ExecutorInfo* ContainerState::release_executor_info() {
  // @@protoc_insertion_point(field_release:mesos.slave.ContainerState.executor_info)
  clear_has_executor_info();
  ::mesos::ExecutorInfo* temp = executor_info_;
  executor_info_ = NULL;
  return temp;
}
inline ::mesos::ExecutorInfo* ContainerState::mutable_executor_info() {
  set_has_executor_info();
  if (executor_info_ == NULL) {
    executor_info_ = new ::mesos::ExecutorInfo;
  }
  // @@protoc_insertion_point(field_mutable:mesos.slave.ContainerState.executor_info)
  return executor_info_;
}
inline void ContainerState::set_allocated_executor_info(::mesos::ExecutorInfo* executor_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(executor_info_);
  }
  if (executor_info) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(executor_info)->GetArena();
    if (message_arena != submessage_arena) {
      executor_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, executor_info, submessage_arena);
    }
    set_has_executor_info();
  } else {
    clear_has_executor_info();
  }
  executor_info_ = executor_info;
  // @@protoc_insertion_point(field_set_allocated:mesos.slave.ContainerState.executor_info)
}

// required .mesos.ContainerID container_id = 2;
inline bool ContainerState::has_container_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ContainerState::set_has_container_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ContainerState::clear_has_container_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::mesos::ContainerID& ContainerState::container_id() const {
  const ::mesos::ContainerID* p = container_id_;
  // @@protoc_insertion_point(field_get:mesos.slave.ContainerState.container_id)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ContainerID*>(
      &::mesos::_ContainerID_default_instance_);
}
inline ::mesos::ContainerID* ContainerState::release_container_id() {
  // @@protoc_insertion_point(field_release:mesos.slave.ContainerState.container_id)
  clear_has_container_id();
  ::mesos::ContainerID* temp = container_id_;
  container_id_ = NULL;
  return temp;
}
inline ::mesos::ContainerID* ContainerState::mutable_container_id() {
  set_has_container_id();
  if (container_id_ == NULL) {
    container_id_ = new ::mesos::ContainerID;
  }
  // @@protoc_insertion_point(field_mutable:mesos.slave.ContainerState.container_id)
  return container_id_;
}
inline void ContainerState::set_allocated_container_id(::mesos::ContainerID* container_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(container_id_);
  }
  if (container_id) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(container_id)->GetArena();
    if (message_arena != submessage_arena) {
      container_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, container_id, submessage_arena);
    }
    set_has_container_id();
  } else {
    clear_has_container_id();
  }
  container_id_ = container_id;
  // @@protoc_insertion_point(field_set_allocated:mesos.slave.ContainerState.container_id)
}

// required uint64 pid = 3;
inline bool ContainerState::has_pid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ContainerState::set_has_pid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ContainerState::clear_has_pid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ContainerState::clear_pid() {
  pid_ = GOOGLE_ULONGLONG(0);
  clear_has_pid();
}
inline ::google::protobuf::uint64 ContainerState::pid() const {
  // @@protoc_insertion_point(field_get:mesos.slave.ContainerState.pid)
  return pid_;
}
inline void ContainerState::set_pid(::google::protobuf::uint64 value) {
  set_has_pid();
  pid_ = value;
  // @@protoc_insertion_point(field_set:mesos.slave.ContainerState.pid)
}

// required string directory = 4;
inline bool ContainerState::has_directory() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ContainerState::set_has_directory() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ContainerState::clear_has_directory() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ContainerState::clear_directory() {
  directory_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_directory();
}
inline const ::std::string& ContainerState::directory() const {
  // @@protoc_insertion_point(field_get:mesos.slave.ContainerState.directory)
  return directory_.GetNoArena();
}
inline void ContainerState::set_directory(const ::std::string& value) {
  set_has_directory();
  directory_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.slave.ContainerState.directory)
}
#if LANG_CXX11
inline void ContainerState::set_directory(::std::string&& value) {
  set_has_directory();
  directory_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mesos.slave.ContainerState.directory)
}
#endif
inline void ContainerState::set_directory(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_directory();
  directory_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.slave.ContainerState.directory)
}
inline void ContainerState::set_directory(const char* value, size_t size) {
  set_has_directory();
  directory_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.slave.ContainerState.directory)
}
inline ::std::string* ContainerState::mutable_directory() {
  set_has_directory();
  // @@protoc_insertion_point(field_mutable:mesos.slave.ContainerState.directory)
  return directory_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ContainerState::release_directory() {
  // @@protoc_insertion_point(field_release:mesos.slave.ContainerState.directory)
  clear_has_directory();
  return directory_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ContainerState::set_allocated_directory(::std::string* directory) {
  if (directory != NULL) {
    set_has_directory();
  } else {
    clear_has_directory();
  }
  directory_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), directory);
  // @@protoc_insertion_point(field_set_allocated:mesos.slave.ContainerState.directory)
}

// -------------------------------------------------------------------

// ContainerRecoverInfo

// repeated .mesos.slave.ContainerState checkpointed_container_states = 1;
inline int ContainerRecoverInfo::checkpointed_container_states_size() const {
  return checkpointed_container_states_.size();
}
inline void ContainerRecoverInfo::clear_checkpointed_container_states() {
  checkpointed_container_states_.Clear();
}
inline const ::mesos::slave::ContainerState& ContainerRecoverInfo::checkpointed_container_states(int index) const {
  // @@protoc_insertion_point(field_get:mesos.slave.ContainerRecoverInfo.checkpointed_container_states)
  return checkpointed_container_states_.Get(index);
}
inline ::mesos::slave::ContainerState* ContainerRecoverInfo::mutable_checkpointed_container_states(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.slave.ContainerRecoverInfo.checkpointed_container_states)
  return checkpointed_container_states_.Mutable(index);
}
inline ::mesos::slave::ContainerState* ContainerRecoverInfo::add_checkpointed_container_states() {
  // @@protoc_insertion_point(field_add:mesos.slave.ContainerRecoverInfo.checkpointed_container_states)
  return checkpointed_container_states_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::slave::ContainerState >*
ContainerRecoverInfo::mutable_checkpointed_container_states() {
  // @@protoc_insertion_point(field_mutable_list:mesos.slave.ContainerRecoverInfo.checkpointed_container_states)
  return &checkpointed_container_states_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::slave::ContainerState >&
ContainerRecoverInfo::checkpointed_container_states() const {
  // @@protoc_insertion_point(field_list:mesos.slave.ContainerRecoverInfo.checkpointed_container_states)
  return checkpointed_container_states_;
}

// repeated .mesos.ContainerID orphan_container_ids = 2;
inline int ContainerRecoverInfo::orphan_container_ids_size() const {
  return orphan_container_ids_.size();
}
inline const ::mesos::ContainerID& ContainerRecoverInfo::orphan_container_ids(int index) const {
  // @@protoc_insertion_point(field_get:mesos.slave.ContainerRecoverInfo.orphan_container_ids)
  return orphan_container_ids_.Get(index);
}
inline ::mesos::ContainerID* ContainerRecoverInfo::mutable_orphan_container_ids(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.slave.ContainerRecoverInfo.orphan_container_ids)
  return orphan_container_ids_.Mutable(index);
}
inline ::mesos::ContainerID* ContainerRecoverInfo::add_orphan_container_ids() {
  // @@protoc_insertion_point(field_add:mesos.slave.ContainerRecoverInfo.orphan_container_ids)
  return orphan_container_ids_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::ContainerID >*
ContainerRecoverInfo::mutable_orphan_container_ids() {
  // @@protoc_insertion_point(field_mutable_list:mesos.slave.ContainerRecoverInfo.orphan_container_ids)
  return &orphan_container_ids_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::ContainerID >&
ContainerRecoverInfo::orphan_container_ids() const {
  // @@protoc_insertion_point(field_list:mesos.slave.ContainerRecoverInfo.orphan_container_ids)
  return orphan_container_ids_;
}

// repeated .mesos.ContainerID known_container_ids = 3;
inline int ContainerRecoverInfo::known_container_ids_size() const {
  return known_container_ids_.size();
}
inline const ::mesos::ContainerID& ContainerRecoverInfo::known_container_ids(int index) const {
  // @@protoc_insertion_point(field_get:mesos.slave.ContainerRecoverInfo.known_container_ids)
  return known_container_ids_.Get(index);
}
inline ::mesos::ContainerID* ContainerRecoverInfo::mutable_known_container_ids(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.slave.ContainerRecoverInfo.known_container_ids)
  return known_container_ids_.Mutable(index);
}
inline ::mesos::ContainerID* ContainerRecoverInfo::add_known_container_ids() {
  // @@protoc_insertion_point(field_add:mesos.slave.ContainerRecoverInfo.known_container_ids)
  return known_container_ids_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::ContainerID >*
ContainerRecoverInfo::mutable_known_container_ids() {
  // @@protoc_insertion_point(field_mutable_list:mesos.slave.ContainerRecoverInfo.known_container_ids)
  return &known_container_ids_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::ContainerID >&
ContainerRecoverInfo::known_container_ids() const {
  // @@protoc_insertion_point(field_list:mesos.slave.ContainerRecoverInfo.known_container_ids)
  return known_container_ids_;
}

// -------------------------------------------------------------------

// ContainerConfig_Docker

// optional .docker.spec.v1.ImageManifest manifest = 1;
inline bool ContainerConfig_Docker::has_manifest() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ContainerConfig_Docker::set_has_manifest() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ContainerConfig_Docker::clear_has_manifest() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::docker::spec::v1::ImageManifest& ContainerConfig_Docker::manifest() const {
  const ::docker::spec::v1::ImageManifest* p = manifest_;
  // @@protoc_insertion_point(field_get:mesos.slave.ContainerConfig.Docker.manifest)
  return p != NULL ? *p : *reinterpret_cast<const ::docker::spec::v1::ImageManifest*>(
      &::docker::spec::v1::_ImageManifest_default_instance_);
}
inline ::docker::spec::v1::ImageManifest* ContainerConfig_Docker::release_manifest() {
  // @@protoc_insertion_point(field_release:mesos.slave.ContainerConfig.Docker.manifest)
  clear_has_manifest();
  ::docker::spec::v1::ImageManifest* temp = manifest_;
  manifest_ = NULL;
  return temp;
}
inline ::docker::spec::v1::ImageManifest* ContainerConfig_Docker::mutable_manifest() {
  set_has_manifest();
  if (manifest_ == NULL) {
    manifest_ = new ::docker::spec::v1::ImageManifest;
  }
  // @@protoc_insertion_point(field_mutable:mesos.slave.ContainerConfig.Docker.manifest)
  return manifest_;
}
inline void ContainerConfig_Docker::set_allocated_manifest(::docker::spec::v1::ImageManifest* manifest) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(manifest_);
  }
  if (manifest) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      manifest = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, manifest, submessage_arena);
    }
    set_has_manifest();
  } else {
    clear_has_manifest();
  }
  manifest_ = manifest;
  // @@protoc_insertion_point(field_set_allocated:mesos.slave.ContainerConfig.Docker.manifest)
}

// -------------------------------------------------------------------

// ContainerConfig_Appc

// optional .appc.spec.ImageManifest manifest = 1;
inline bool ContainerConfig_Appc::has_manifest() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ContainerConfig_Appc::set_has_manifest() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ContainerConfig_Appc::clear_has_manifest() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::appc::spec::ImageManifest& ContainerConfig_Appc::manifest() const {
  const ::appc::spec::ImageManifest* p = manifest_;
  // @@protoc_insertion_point(field_get:mesos.slave.ContainerConfig.Appc.manifest)
  return p != NULL ? *p : *reinterpret_cast<const ::appc::spec::ImageManifest*>(
      &::appc::spec::_ImageManifest_default_instance_);
}
inline ::appc::spec::ImageManifest* ContainerConfig_Appc::release_manifest() {
  // @@protoc_insertion_point(field_release:mesos.slave.ContainerConfig.Appc.manifest)
  clear_has_manifest();
  ::appc::spec::ImageManifest* temp = manifest_;
  manifest_ = NULL;
  return temp;
}
inline ::appc::spec::ImageManifest* ContainerConfig_Appc::mutable_manifest() {
  set_has_manifest();
  if (manifest_ == NULL) {
    manifest_ = new ::appc::spec::ImageManifest;
  }
  // @@protoc_insertion_point(field_mutable:mesos.slave.ContainerConfig.Appc.manifest)
  return manifest_;
}
inline void ContainerConfig_Appc::set_allocated_manifest(::appc::spec::ImageManifest* manifest) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(manifest_);
  }
  if (manifest) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      manifest = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, manifest, submessage_arena);
    }
    set_has_manifest();
  } else {
    clear_has_manifest();
  }
  manifest_ = manifest;
  // @@protoc_insertion_point(field_set_allocated:mesos.slave.ContainerConfig.Appc.manifest)
}

// -------------------------------------------------------------------

// ContainerConfig

// optional .mesos.ExecutorInfo executor_info = 8;
inline bool ContainerConfig::has_executor_info() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ContainerConfig::set_has_executor_info() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ContainerConfig::clear_has_executor_info() {
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::mesos::ExecutorInfo& ContainerConfig::executor_info() const {
  const ::mesos::ExecutorInfo* p = executor_info_;
  // @@protoc_insertion_point(field_get:mesos.slave.ContainerConfig.executor_info)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ExecutorInfo*>(
      &::mesos::_ExecutorInfo_default_instance_);
}
inline ::mesos::ExecutorInfo* ContainerConfig::release_executor_info() {
  // @@protoc_insertion_point(field_release:mesos.slave.ContainerConfig.executor_info)
  clear_has_executor_info();
  ::mesos::ExecutorInfo* temp = executor_info_;
  executor_info_ = NULL;
  return temp;
}
inline ::mesos::ExecutorInfo* ContainerConfig::mutable_executor_info() {
  set_has_executor_info();
  if (executor_info_ == NULL) {
    executor_info_ = new ::mesos::ExecutorInfo;
  }
  // @@protoc_insertion_point(field_mutable:mesos.slave.ContainerConfig.executor_info)
  return executor_info_;
}
inline void ContainerConfig::set_allocated_executor_info(::mesos::ExecutorInfo* executor_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(executor_info_);
  }
  if (executor_info) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(executor_info)->GetArena();
    if (message_arena != submessage_arena) {
      executor_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, executor_info, submessage_arena);
    }
    set_has_executor_info();
  } else {
    clear_has_executor_info();
  }
  executor_info_ = executor_info;
  // @@protoc_insertion_point(field_set_allocated:mesos.slave.ContainerConfig.executor_info)
}

// optional .mesos.TaskInfo task_info = 9;
inline bool ContainerConfig::has_task_info() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ContainerConfig::set_has_task_info() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ContainerConfig::clear_has_task_info() {
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::mesos::TaskInfo& ContainerConfig::task_info() const {
  const ::mesos::TaskInfo* p = task_info_;
  // @@protoc_insertion_point(field_get:mesos.slave.ContainerConfig.task_info)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::TaskInfo*>(
      &::mesos::_TaskInfo_default_instance_);
}
inline ::mesos::TaskInfo* ContainerConfig::release_task_info() {
  // @@protoc_insertion_point(field_release:mesos.slave.ContainerConfig.task_info)
  clear_has_task_info();
  ::mesos::TaskInfo* temp = task_info_;
  task_info_ = NULL;
  return temp;
}
inline ::mesos::TaskInfo* ContainerConfig::mutable_task_info() {
  set_has_task_info();
  if (task_info_ == NULL) {
    task_info_ = new ::mesos::TaskInfo;
  }
  // @@protoc_insertion_point(field_mutable:mesos.slave.ContainerConfig.task_info)
  return task_info_;
}
inline void ContainerConfig::set_allocated_task_info(::mesos::TaskInfo* task_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(task_info_);
  }
  if (task_info) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(task_info)->GetArena();
    if (message_arena != submessage_arena) {
      task_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, task_info, submessage_arena);
    }
    set_has_task_info();
  } else {
    clear_has_task_info();
  }
  task_info_ = task_info;
  // @@protoc_insertion_point(field_set_allocated:mesos.slave.ContainerConfig.task_info)
}

// required .mesos.CommandInfo command_info = 11;
inline bool ContainerConfig::has_command_info() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ContainerConfig::set_has_command_info() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ContainerConfig::clear_has_command_info() {
  _has_bits_[0] &= ~0x00000080u;
}
inline const ::mesos::CommandInfo& ContainerConfig::command_info() const {
  const ::mesos::CommandInfo* p = command_info_;
  // @@protoc_insertion_point(field_get:mesos.slave.ContainerConfig.command_info)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::CommandInfo*>(
      &::mesos::_CommandInfo_default_instance_);
}
inline ::mesos::CommandInfo* ContainerConfig::release_command_info() {
  // @@protoc_insertion_point(field_release:mesos.slave.ContainerConfig.command_info)
  clear_has_command_info();
  ::mesos::CommandInfo* temp = command_info_;
  command_info_ = NULL;
  return temp;
}
inline ::mesos::CommandInfo* ContainerConfig::mutable_command_info() {
  set_has_command_info();
  if (command_info_ == NULL) {
    command_info_ = new ::mesos::CommandInfo;
  }
  // @@protoc_insertion_point(field_mutable:mesos.slave.ContainerConfig.command_info)
  return command_info_;
}
inline void ContainerConfig::set_allocated_command_info(::mesos::CommandInfo* command_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(command_info_);
  }
  if (command_info) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(command_info)->GetArena();
    if (message_arena != submessage_arena) {
      command_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, command_info, submessage_arena);
    }
    set_has_command_info();
  } else {
    clear_has_command_info();
  }
  command_info_ = command_info;
  // @@protoc_insertion_point(field_set_allocated:mesos.slave.ContainerConfig.command_info)
}

// optional .mesos.ContainerInfo container_info = 12;
inline bool ContainerConfig::has_container_info() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ContainerConfig::set_has_container_info() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ContainerConfig::clear_has_container_info() {
  _has_bits_[0] &= ~0x00000100u;
}
inline const ::mesos::ContainerInfo& ContainerConfig::container_info() const {
  const ::mesos::ContainerInfo* p = container_info_;
  // @@protoc_insertion_point(field_get:mesos.slave.ContainerConfig.container_info)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::ContainerInfo*>(
      &::mesos::_ContainerInfo_default_instance_);
}
inline ::mesos::ContainerInfo* ContainerConfig::release_container_info() {
  // @@protoc_insertion_point(field_release:mesos.slave.ContainerConfig.container_info)
  clear_has_container_info();
  ::mesos::ContainerInfo* temp = container_info_;
  container_info_ = NULL;
  return temp;
}
inline ::mesos::ContainerInfo* ContainerConfig::mutable_container_info() {
  set_has_container_info();
  if (container_info_ == NULL) {
    container_info_ = new ::mesos::ContainerInfo;
  }
  // @@protoc_insertion_point(field_mutable:mesos.slave.ContainerConfig.container_info)
  return container_info_;
}
inline void ContainerConfig::set_allocated_container_info(::mesos::ContainerInfo* container_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(container_info_);
  }
  if (container_info) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(container_info)->GetArena();
    if (message_arena != submessage_arena) {
      container_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, container_info, submessage_arena);
    }
    set_has_container_info();
  } else {
    clear_has_container_info();
  }
  container_info_ = container_info;
  // @@protoc_insertion_point(field_set_allocated:mesos.slave.ContainerConfig.container_info)
}

// repeated .mesos.Resource resources = 13;
inline int ContainerConfig::resources_size() const {
  return resources_.size();
}
inline const ::mesos::Resource& ContainerConfig::resources(int index) const {
  // @@protoc_insertion_point(field_get:mesos.slave.ContainerConfig.resources)
  return resources_.Get(index);
}
inline ::mesos::Resource* ContainerConfig::mutable_resources(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.slave.ContainerConfig.resources)
  return resources_.Mutable(index);
}
inline ::mesos::Resource* ContainerConfig::add_resources() {
  // @@protoc_insertion_point(field_add:mesos.slave.ContainerConfig.resources)
  return resources_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
ContainerConfig::mutable_resources() {
  // @@protoc_insertion_point(field_mutable_list:mesos.slave.ContainerConfig.resources)
  return &resources_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
ContainerConfig::resources() const {
  // @@protoc_insertion_point(field_list:mesos.slave.ContainerConfig.resources)
  return resources_;
}

// optional .mesos.slave.ContainerClass container_class = 14;
inline bool ContainerConfig::has_container_class() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ContainerConfig::set_has_container_class() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ContainerConfig::clear_has_container_class() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ContainerConfig::clear_container_class() {
  container_class_ = 1;
  clear_has_container_class();
}
inline ::mesos::slave::ContainerClass ContainerConfig::container_class() const {
  // @@protoc_insertion_point(field_get:mesos.slave.ContainerConfig.container_class)
  return static_cast< ::mesos::slave::ContainerClass >(container_class_);
}
inline void ContainerConfig::set_container_class(::mesos::slave::ContainerClass value) {
  assert(::mesos::slave::ContainerClass_IsValid(value));
  set_has_container_class();
  container_class_ = value;
  // @@protoc_insertion_point(field_set:mesos.slave.ContainerConfig.container_class)
}

// required string directory = 3;
inline bool ContainerConfig::has_directory() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ContainerConfig::set_has_directory() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ContainerConfig::clear_has_directory() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ContainerConfig::clear_directory() {
  directory_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_directory();
}
inline const ::std::string& ContainerConfig::directory() const {
  // @@protoc_insertion_point(field_get:mesos.slave.ContainerConfig.directory)
  return directory_.GetNoArena();
}
inline void ContainerConfig::set_directory(const ::std::string& value) {
  set_has_directory();
  directory_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.slave.ContainerConfig.directory)
}
#if LANG_CXX11
inline void ContainerConfig::set_directory(::std::string&& value) {
  set_has_directory();
  directory_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mesos.slave.ContainerConfig.directory)
}
#endif
inline void ContainerConfig::set_directory(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_directory();
  directory_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.slave.ContainerConfig.directory)
}
inline void ContainerConfig::set_directory(const char* value, size_t size) {
  set_has_directory();
  directory_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.slave.ContainerConfig.directory)
}
inline ::std::string* ContainerConfig::mutable_directory() {
  set_has_directory();
  // @@protoc_insertion_point(field_mutable:mesos.slave.ContainerConfig.directory)
  return directory_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ContainerConfig::release_directory() {
  // @@protoc_insertion_point(field_release:mesos.slave.ContainerConfig.directory)
  clear_has_directory();
  return directory_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ContainerConfig::set_allocated_directory(::std::string* directory) {
  if (directory != NULL) {
    set_has_directory();
  } else {
    clear_has_directory();
  }
  directory_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), directory);
  // @@protoc_insertion_point(field_set_allocated:mesos.slave.ContainerConfig.directory)
}

// optional string user = 4;
inline bool ContainerConfig::has_user() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ContainerConfig::set_has_user() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ContainerConfig::clear_has_user() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ContainerConfig::clear_user() {
  user_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_user();
}
inline const ::std::string& ContainerConfig::user() const {
  // @@protoc_insertion_point(field_get:mesos.slave.ContainerConfig.user)
  return user_.GetNoArena();
}
inline void ContainerConfig::set_user(const ::std::string& value) {
  set_has_user();
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.slave.ContainerConfig.user)
}
#if LANG_CXX11
inline void ContainerConfig::set_user(::std::string&& value) {
  set_has_user();
  user_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mesos.slave.ContainerConfig.user)
}
#endif
inline void ContainerConfig::set_user(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_user();
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.slave.ContainerConfig.user)
}
inline void ContainerConfig::set_user(const char* value, size_t size) {
  set_has_user();
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.slave.ContainerConfig.user)
}
inline ::std::string* ContainerConfig::mutable_user() {
  set_has_user();
  // @@protoc_insertion_point(field_mutable:mesos.slave.ContainerConfig.user)
  return user_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ContainerConfig::release_user() {
  // @@protoc_insertion_point(field_release:mesos.slave.ContainerConfig.user)
  clear_has_user();
  return user_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ContainerConfig::set_allocated_user(::std::string* user) {
  if (user != NULL) {
    set_has_user();
  } else {
    clear_has_user();
  }
  user_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user);
  // @@protoc_insertion_point(field_set_allocated:mesos.slave.ContainerConfig.user)
}

// optional string rootfs = 5;
inline bool ContainerConfig::has_rootfs() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ContainerConfig::set_has_rootfs() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ContainerConfig::clear_has_rootfs() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ContainerConfig::clear_rootfs() {
  rootfs_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_rootfs();
}
inline const ::std::string& ContainerConfig::rootfs() const {
  // @@protoc_insertion_point(field_get:mesos.slave.ContainerConfig.rootfs)
  return rootfs_.GetNoArena();
}
inline void ContainerConfig::set_rootfs(const ::std::string& value) {
  set_has_rootfs();
  rootfs_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.slave.ContainerConfig.rootfs)
}
#if LANG_CXX11
inline void ContainerConfig::set_rootfs(::std::string&& value) {
  set_has_rootfs();
  rootfs_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mesos.slave.ContainerConfig.rootfs)
}
#endif
inline void ContainerConfig::set_rootfs(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_rootfs();
  rootfs_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.slave.ContainerConfig.rootfs)
}
inline void ContainerConfig::set_rootfs(const char* value, size_t size) {
  set_has_rootfs();
  rootfs_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.slave.ContainerConfig.rootfs)
}
inline ::std::string* ContainerConfig::mutable_rootfs() {
  set_has_rootfs();
  // @@protoc_insertion_point(field_mutable:mesos.slave.ContainerConfig.rootfs)
  return rootfs_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ContainerConfig::release_rootfs() {
  // @@protoc_insertion_point(field_release:mesos.slave.ContainerConfig.rootfs)
  clear_has_rootfs();
  return rootfs_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ContainerConfig::set_allocated_rootfs(::std::string* rootfs) {
  if (rootfs != NULL) {
    set_has_rootfs();
  } else {
    clear_has_rootfs();
  }
  rootfs_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), rootfs);
  // @@protoc_insertion_point(field_set_allocated:mesos.slave.ContainerConfig.rootfs)
}

// optional .mesos.slave.ContainerConfig.Docker docker = 7;
inline bool ContainerConfig::has_docker() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ContainerConfig::set_has_docker() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ContainerConfig::clear_has_docker() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ContainerConfig::clear_docker() {
  if (docker_ != NULL) docker_->Clear();
  clear_has_docker();
}
inline const ::mesos::slave::ContainerConfig_Docker& ContainerConfig::docker() const {
  const ::mesos::slave::ContainerConfig_Docker* p = docker_;
  // @@protoc_insertion_point(field_get:mesos.slave.ContainerConfig.docker)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::slave::ContainerConfig_Docker*>(
      &::mesos::slave::_ContainerConfig_Docker_default_instance_);
}
inline ::mesos::slave::ContainerConfig_Docker* ContainerConfig::release_docker() {
  // @@protoc_insertion_point(field_release:mesos.slave.ContainerConfig.docker)
  clear_has_docker();
  ::mesos::slave::ContainerConfig_Docker* temp = docker_;
  docker_ = NULL;
  return temp;
}
inline ::mesos::slave::ContainerConfig_Docker* ContainerConfig::mutable_docker() {
  set_has_docker();
  if (docker_ == NULL) {
    docker_ = new ::mesos::slave::ContainerConfig_Docker;
  }
  // @@protoc_insertion_point(field_mutable:mesos.slave.ContainerConfig.docker)
  return docker_;
}
inline void ContainerConfig::set_allocated_docker(::mesos::slave::ContainerConfig_Docker* docker) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete docker_;
  }
  if (docker) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      docker = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, docker, submessage_arena);
    }
    set_has_docker();
  } else {
    clear_has_docker();
  }
  docker_ = docker;
  // @@protoc_insertion_point(field_set_allocated:mesos.slave.ContainerConfig.docker)
}

// optional .mesos.slave.ContainerConfig.Appc appc = 10;
inline bool ContainerConfig::has_appc() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ContainerConfig::set_has_appc() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ContainerConfig::clear_has_appc() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ContainerConfig::clear_appc() {
  if (appc_ != NULL) appc_->Clear();
  clear_has_appc();
}
inline const ::mesos::slave::ContainerConfig_Appc& ContainerConfig::appc() const {
  const ::mesos::slave::ContainerConfig_Appc* p = appc_;
  // @@protoc_insertion_point(field_get:mesos.slave.ContainerConfig.appc)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::slave::ContainerConfig_Appc*>(
      &::mesos::slave::_ContainerConfig_Appc_default_instance_);
}
inline ::mesos::slave::ContainerConfig_Appc* ContainerConfig::release_appc() {
  // @@protoc_insertion_point(field_release:mesos.slave.ContainerConfig.appc)
  clear_has_appc();
  ::mesos::slave::ContainerConfig_Appc* temp = appc_;
  appc_ = NULL;
  return temp;
}
inline ::mesos::slave::ContainerConfig_Appc* ContainerConfig::mutable_appc() {
  set_has_appc();
  if (appc_ == NULL) {
    appc_ = new ::mesos::slave::ContainerConfig_Appc;
  }
  // @@protoc_insertion_point(field_mutable:mesos.slave.ContainerConfig.appc)
  return appc_;
}
inline void ContainerConfig::set_allocated_appc(::mesos::slave::ContainerConfig_Appc* appc) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete appc_;
  }
  if (appc) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      appc = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, appc, submessage_arena);
    }
    set_has_appc();
  } else {
    clear_has_appc();
  }
  appc_ = appc;
  // @@protoc_insertion_point(field_set_allocated:mesos.slave.ContainerConfig.appc)
}

// -------------------------------------------------------------------

// ContainerMountInfo

// required string target = 1;
inline bool ContainerMountInfo::has_target() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ContainerMountInfo::set_has_target() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ContainerMountInfo::clear_has_target() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ContainerMountInfo::clear_target() {
  target_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_target();
}
inline const ::std::string& ContainerMountInfo::target() const {
  // @@protoc_insertion_point(field_get:mesos.slave.ContainerMountInfo.target)
  return target_.GetNoArena();
}
inline void ContainerMountInfo::set_target(const ::std::string& value) {
  set_has_target();
  target_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.slave.ContainerMountInfo.target)
}
#if LANG_CXX11
inline void ContainerMountInfo::set_target(::std::string&& value) {
  set_has_target();
  target_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mesos.slave.ContainerMountInfo.target)
}
#endif
inline void ContainerMountInfo::set_target(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_target();
  target_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.slave.ContainerMountInfo.target)
}
inline void ContainerMountInfo::set_target(const char* value, size_t size) {
  set_has_target();
  target_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.slave.ContainerMountInfo.target)
}
inline ::std::string* ContainerMountInfo::mutable_target() {
  set_has_target();
  // @@protoc_insertion_point(field_mutable:mesos.slave.ContainerMountInfo.target)
  return target_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ContainerMountInfo::release_target() {
  // @@protoc_insertion_point(field_release:mesos.slave.ContainerMountInfo.target)
  clear_has_target();
  return target_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ContainerMountInfo::set_allocated_target(::std::string* target) {
  if (target != NULL) {
    set_has_target();
  } else {
    clear_has_target();
  }
  target_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), target);
  // @@protoc_insertion_point(field_set_allocated:mesos.slave.ContainerMountInfo.target)
}

// optional string source = 2;
inline bool ContainerMountInfo::has_source() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ContainerMountInfo::set_has_source() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ContainerMountInfo::clear_has_source() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ContainerMountInfo::clear_source() {
  source_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_source();
}
inline const ::std::string& ContainerMountInfo::source() const {
  // @@protoc_insertion_point(field_get:mesos.slave.ContainerMountInfo.source)
  return source_.GetNoArena();
}
inline void ContainerMountInfo::set_source(const ::std::string& value) {
  set_has_source();
  source_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.slave.ContainerMountInfo.source)
}
#if LANG_CXX11
inline void ContainerMountInfo::set_source(::std::string&& value) {
  set_has_source();
  source_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mesos.slave.ContainerMountInfo.source)
}
#endif
inline void ContainerMountInfo::set_source(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_source();
  source_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.slave.ContainerMountInfo.source)
}
inline void ContainerMountInfo::set_source(const char* value, size_t size) {
  set_has_source();
  source_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.slave.ContainerMountInfo.source)
}
inline ::std::string* ContainerMountInfo::mutable_source() {
  set_has_source();
  // @@protoc_insertion_point(field_mutable:mesos.slave.ContainerMountInfo.source)
  return source_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ContainerMountInfo::release_source() {
  // @@protoc_insertion_point(field_release:mesos.slave.ContainerMountInfo.source)
  clear_has_source();
  return source_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ContainerMountInfo::set_allocated_source(::std::string* source) {
  if (source != NULL) {
    set_has_source();
  } else {
    clear_has_source();
  }
  source_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), source);
  // @@protoc_insertion_point(field_set_allocated:mesos.slave.ContainerMountInfo.source)
}

// optional string type = 3;
inline bool ContainerMountInfo::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ContainerMountInfo::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ContainerMountInfo::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ContainerMountInfo::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_type();
}
inline const ::std::string& ContainerMountInfo::type() const {
  // @@protoc_insertion_point(field_get:mesos.slave.ContainerMountInfo.type)
  return type_.GetNoArena();
}
inline void ContainerMountInfo::set_type(const ::std::string& value) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.slave.ContainerMountInfo.type)
}
#if LANG_CXX11
inline void ContainerMountInfo::set_type(::std::string&& value) {
  set_has_type();
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mesos.slave.ContainerMountInfo.type)
}
#endif
inline void ContainerMountInfo::set_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.slave.ContainerMountInfo.type)
}
inline void ContainerMountInfo::set_type(const char* value, size_t size) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.slave.ContainerMountInfo.type)
}
inline ::std::string* ContainerMountInfo::mutable_type() {
  set_has_type();
  // @@protoc_insertion_point(field_mutable:mesos.slave.ContainerMountInfo.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ContainerMountInfo::release_type() {
  // @@protoc_insertion_point(field_release:mesos.slave.ContainerMountInfo.type)
  clear_has_type();
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ContainerMountInfo::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    set_has_type();
  } else {
    clear_has_type();
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:mesos.slave.ContainerMountInfo.type)
}

// optional uint32 flags = 4;
inline bool ContainerMountInfo::has_flags() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ContainerMountInfo::set_has_flags() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ContainerMountInfo::clear_has_flags() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ContainerMountInfo::clear_flags() {
  flags_ = 0u;
  clear_has_flags();
}
inline ::google::protobuf::uint32 ContainerMountInfo::flags() const {
  // @@protoc_insertion_point(field_get:mesos.slave.ContainerMountInfo.flags)
  return flags_;
}
inline void ContainerMountInfo::set_flags(::google::protobuf::uint32 value) {
  set_has_flags();
  flags_ = value;
  // @@protoc_insertion_point(field_set:mesos.slave.ContainerMountInfo.flags)
}

// optional string options = 5;
inline bool ContainerMountInfo::has_options() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ContainerMountInfo::set_has_options() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ContainerMountInfo::clear_has_options() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ContainerMountInfo::clear_options() {
  options_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_options();
}
inline const ::std::string& ContainerMountInfo::options() const {
  // @@protoc_insertion_point(field_get:mesos.slave.ContainerMountInfo.options)
  return options_.GetNoArena();
}
inline void ContainerMountInfo::set_options(const ::std::string& value) {
  set_has_options();
  options_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.slave.ContainerMountInfo.options)
}
#if LANG_CXX11
inline void ContainerMountInfo::set_options(::std::string&& value) {
  set_has_options();
  options_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mesos.slave.ContainerMountInfo.options)
}
#endif
inline void ContainerMountInfo::set_options(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_options();
  options_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.slave.ContainerMountInfo.options)
}
inline void ContainerMountInfo::set_options(const char* value, size_t size) {
  set_has_options();
  options_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.slave.ContainerMountInfo.options)
}
inline ::std::string* ContainerMountInfo::mutable_options() {
  set_has_options();
  // @@protoc_insertion_point(field_mutable:mesos.slave.ContainerMountInfo.options)
  return options_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ContainerMountInfo::release_options() {
  // @@protoc_insertion_point(field_release:mesos.slave.ContainerMountInfo.options)
  clear_has_options();
  return options_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ContainerMountInfo::set_allocated_options(::std::string* options) {
  if (options != NULL) {
    set_has_options();
  } else {
    clear_has_options();
  }
  options_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), options);
  // @@protoc_insertion_point(field_set_allocated:mesos.slave.ContainerMountInfo.options)
}

// -------------------------------------------------------------------

// ContainerLaunchInfo

// repeated .mesos.CommandInfo pre_exec_commands = 1;
inline int ContainerLaunchInfo::pre_exec_commands_size() const {
  return pre_exec_commands_.size();
}
inline const ::mesos::CommandInfo& ContainerLaunchInfo::pre_exec_commands(int index) const {
  // @@protoc_insertion_point(field_get:mesos.slave.ContainerLaunchInfo.pre_exec_commands)
  return pre_exec_commands_.Get(index);
}
inline ::mesos::CommandInfo* ContainerLaunchInfo::mutable_pre_exec_commands(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.slave.ContainerLaunchInfo.pre_exec_commands)
  return pre_exec_commands_.Mutable(index);
}
inline ::mesos::CommandInfo* ContainerLaunchInfo::add_pre_exec_commands() {
  // @@protoc_insertion_point(field_add:mesos.slave.ContainerLaunchInfo.pre_exec_commands)
  return pre_exec_commands_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::CommandInfo >*
ContainerLaunchInfo::mutable_pre_exec_commands() {
  // @@protoc_insertion_point(field_mutable_list:mesos.slave.ContainerLaunchInfo.pre_exec_commands)
  return &pre_exec_commands_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::CommandInfo >&
ContainerLaunchInfo::pre_exec_commands() const {
  // @@protoc_insertion_point(field_list:mesos.slave.ContainerLaunchInfo.pre_exec_commands)
  return pre_exec_commands_;
}

// optional .mesos.Environment environment = 2;
inline bool ContainerLaunchInfo::has_environment() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ContainerLaunchInfo::set_has_environment() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ContainerLaunchInfo::clear_has_environment() {
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::mesos::Environment& ContainerLaunchInfo::environment() const {
  const ::mesos::Environment* p = environment_;
  // @@protoc_insertion_point(field_get:mesos.slave.ContainerLaunchInfo.environment)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::Environment*>(
      &::mesos::_Environment_default_instance_);
}
inline ::mesos::Environment* ContainerLaunchInfo::release_environment() {
  // @@protoc_insertion_point(field_release:mesos.slave.ContainerLaunchInfo.environment)
  clear_has_environment();
  ::mesos::Environment* temp = environment_;
  environment_ = NULL;
  return temp;
}
inline ::mesos::Environment* ContainerLaunchInfo::mutable_environment() {
  set_has_environment();
  if (environment_ == NULL) {
    environment_ = new ::mesos::Environment;
  }
  // @@protoc_insertion_point(field_mutable:mesos.slave.ContainerLaunchInfo.environment)
  return environment_;
}
inline void ContainerLaunchInfo::set_allocated_environment(::mesos::Environment* environment) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(environment_);
  }
  if (environment) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(environment)->GetArena();
    if (message_arena != submessage_arena) {
      environment = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, environment, submessage_arena);
    }
    set_has_environment();
  } else {
    clear_has_environment();
  }
  environment_ = environment;
  // @@protoc_insertion_point(field_set_allocated:mesos.slave.ContainerLaunchInfo.environment)
}

// optional string rootfs = 3;
inline bool ContainerLaunchInfo::has_rootfs() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ContainerLaunchInfo::set_has_rootfs() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ContainerLaunchInfo::clear_has_rootfs() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ContainerLaunchInfo::clear_rootfs() {
  rootfs_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_rootfs();
}
inline const ::std::string& ContainerLaunchInfo::rootfs() const {
  // @@protoc_insertion_point(field_get:mesos.slave.ContainerLaunchInfo.rootfs)
  return rootfs_.GetNoArena();
}
inline void ContainerLaunchInfo::set_rootfs(const ::std::string& value) {
  set_has_rootfs();
  rootfs_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.slave.ContainerLaunchInfo.rootfs)
}
#if LANG_CXX11
inline void ContainerLaunchInfo::set_rootfs(::std::string&& value) {
  set_has_rootfs();
  rootfs_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mesos.slave.ContainerLaunchInfo.rootfs)
}
#endif
inline void ContainerLaunchInfo::set_rootfs(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_rootfs();
  rootfs_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.slave.ContainerLaunchInfo.rootfs)
}
inline void ContainerLaunchInfo::set_rootfs(const char* value, size_t size) {
  set_has_rootfs();
  rootfs_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.slave.ContainerLaunchInfo.rootfs)
}
inline ::std::string* ContainerLaunchInfo::mutable_rootfs() {
  set_has_rootfs();
  // @@protoc_insertion_point(field_mutable:mesos.slave.ContainerLaunchInfo.rootfs)
  return rootfs_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ContainerLaunchInfo::release_rootfs() {
  // @@protoc_insertion_point(field_release:mesos.slave.ContainerLaunchInfo.rootfs)
  clear_has_rootfs();
  return rootfs_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ContainerLaunchInfo::set_allocated_rootfs(::std::string* rootfs) {
  if (rootfs != NULL) {
    set_has_rootfs();
  } else {
    clear_has_rootfs();
  }
  rootfs_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), rootfs);
  // @@protoc_insertion_point(field_set_allocated:mesos.slave.ContainerLaunchInfo.rootfs)
}

// repeated int32 enter_namespaces = 9;
inline int ContainerLaunchInfo::enter_namespaces_size() const {
  return enter_namespaces_.size();
}
inline void ContainerLaunchInfo::clear_enter_namespaces() {
  enter_namespaces_.Clear();
}
inline ::google::protobuf::int32 ContainerLaunchInfo::enter_namespaces(int index) const {
  // @@protoc_insertion_point(field_get:mesos.slave.ContainerLaunchInfo.enter_namespaces)
  return enter_namespaces_.Get(index);
}
inline void ContainerLaunchInfo::set_enter_namespaces(int index, ::google::protobuf::int32 value) {
  enter_namespaces_.Set(index, value);
  // @@protoc_insertion_point(field_set:mesos.slave.ContainerLaunchInfo.enter_namespaces)
}
inline void ContainerLaunchInfo::add_enter_namespaces(::google::protobuf::int32 value) {
  enter_namespaces_.Add(value);
  // @@protoc_insertion_point(field_add:mesos.slave.ContainerLaunchInfo.enter_namespaces)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
ContainerLaunchInfo::enter_namespaces() const {
  // @@protoc_insertion_point(field_list:mesos.slave.ContainerLaunchInfo.enter_namespaces)
  return enter_namespaces_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
ContainerLaunchInfo::mutable_enter_namespaces() {
  // @@protoc_insertion_point(field_mutable_list:mesos.slave.ContainerLaunchInfo.enter_namespaces)
  return &enter_namespaces_;
}

// repeated int32 clone_namespaces = 4;
inline int ContainerLaunchInfo::clone_namespaces_size() const {
  return clone_namespaces_.size();
}
inline void ContainerLaunchInfo::clear_clone_namespaces() {
  clone_namespaces_.Clear();
}
inline ::google::protobuf::int32 ContainerLaunchInfo::clone_namespaces(int index) const {
  // @@protoc_insertion_point(field_get:mesos.slave.ContainerLaunchInfo.clone_namespaces)
  return clone_namespaces_.Get(index);
}
inline void ContainerLaunchInfo::set_clone_namespaces(int index, ::google::protobuf::int32 value) {
  clone_namespaces_.Set(index, value);
  // @@protoc_insertion_point(field_set:mesos.slave.ContainerLaunchInfo.clone_namespaces)
}
inline void ContainerLaunchInfo::add_clone_namespaces(::google::protobuf::int32 value) {
  clone_namespaces_.Add(value);
  // @@protoc_insertion_point(field_add:mesos.slave.ContainerLaunchInfo.clone_namespaces)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
ContainerLaunchInfo::clone_namespaces() const {
  // @@protoc_insertion_point(field_list:mesos.slave.ContainerLaunchInfo.clone_namespaces)
  return clone_namespaces_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
ContainerLaunchInfo::mutable_clone_namespaces() {
  // @@protoc_insertion_point(field_mutable_list:mesos.slave.ContainerLaunchInfo.clone_namespaces)
  return &clone_namespaces_;
}

// optional string user = 10;
inline bool ContainerLaunchInfo::has_user() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ContainerLaunchInfo::set_has_user() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ContainerLaunchInfo::clear_has_user() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ContainerLaunchInfo::clear_user() {
  user_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_user();
}
inline const ::std::string& ContainerLaunchInfo::user() const {
  // @@protoc_insertion_point(field_get:mesos.slave.ContainerLaunchInfo.user)
  return user_.GetNoArena();
}
inline void ContainerLaunchInfo::set_user(const ::std::string& value) {
  set_has_user();
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.slave.ContainerLaunchInfo.user)
}
#if LANG_CXX11
inline void ContainerLaunchInfo::set_user(::std::string&& value) {
  set_has_user();
  user_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mesos.slave.ContainerLaunchInfo.user)
}
#endif
inline void ContainerLaunchInfo::set_user(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_user();
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.slave.ContainerLaunchInfo.user)
}
inline void ContainerLaunchInfo::set_user(const char* value, size_t size) {
  set_has_user();
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.slave.ContainerLaunchInfo.user)
}
inline ::std::string* ContainerLaunchInfo::mutable_user() {
  set_has_user();
  // @@protoc_insertion_point(field_mutable:mesos.slave.ContainerLaunchInfo.user)
  return user_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ContainerLaunchInfo::release_user() {
  // @@protoc_insertion_point(field_release:mesos.slave.ContainerLaunchInfo.user)
  clear_has_user();
  return user_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ContainerLaunchInfo::set_allocated_user(::std::string* user) {
  if (user != NULL) {
    set_has_user();
  } else {
    clear_has_user();
  }
  user_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user);
  // @@protoc_insertion_point(field_set_allocated:mesos.slave.ContainerLaunchInfo.user)
}

// optional .mesos.CommandInfo command = 5;
inline bool ContainerLaunchInfo::has_command() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ContainerLaunchInfo::set_has_command() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ContainerLaunchInfo::clear_has_command() {
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::mesos::CommandInfo& ContainerLaunchInfo::command() const {
  const ::mesos::CommandInfo* p = command_;
  // @@protoc_insertion_point(field_get:mesos.slave.ContainerLaunchInfo.command)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::CommandInfo*>(
      &::mesos::_CommandInfo_default_instance_);
}
inline ::mesos::CommandInfo* ContainerLaunchInfo::release_command() {
  // @@protoc_insertion_point(field_release:mesos.slave.ContainerLaunchInfo.command)
  clear_has_command();
  ::mesos::CommandInfo* temp = command_;
  command_ = NULL;
  return temp;
}
inline ::mesos::CommandInfo* ContainerLaunchInfo::mutable_command() {
  set_has_command();
  if (command_ == NULL) {
    command_ = new ::mesos::CommandInfo;
  }
  // @@protoc_insertion_point(field_mutable:mesos.slave.ContainerLaunchInfo.command)
  return command_;
}
inline void ContainerLaunchInfo::set_allocated_command(::mesos::CommandInfo* command) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(command_);
  }
  if (command) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(command)->GetArena();
    if (message_arena != submessage_arena) {
      command = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, command, submessage_arena);
    }
    set_has_command();
  } else {
    clear_has_command();
  }
  command_ = command;
  // @@protoc_insertion_point(field_set_allocated:mesos.slave.ContainerLaunchInfo.command)
}

// optional string working_directory = 6;
inline bool ContainerLaunchInfo::has_working_directory() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ContainerLaunchInfo::set_has_working_directory() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ContainerLaunchInfo::clear_has_working_directory() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ContainerLaunchInfo::clear_working_directory() {
  working_directory_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_working_directory();
}
inline const ::std::string& ContainerLaunchInfo::working_directory() const {
  // @@protoc_insertion_point(field_get:mesos.slave.ContainerLaunchInfo.working_directory)
  return working_directory_.GetNoArena();
}
inline void ContainerLaunchInfo::set_working_directory(const ::std::string& value) {
  set_has_working_directory();
  working_directory_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.slave.ContainerLaunchInfo.working_directory)
}
#if LANG_CXX11
inline void ContainerLaunchInfo::set_working_directory(::std::string&& value) {
  set_has_working_directory();
  working_directory_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mesos.slave.ContainerLaunchInfo.working_directory)
}
#endif
inline void ContainerLaunchInfo::set_working_directory(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_working_directory();
  working_directory_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.slave.ContainerLaunchInfo.working_directory)
}
inline void ContainerLaunchInfo::set_working_directory(const char* value, size_t size) {
  set_has_working_directory();
  working_directory_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.slave.ContainerLaunchInfo.working_directory)
}
inline ::std::string* ContainerLaunchInfo::mutable_working_directory() {
  set_has_working_directory();
  // @@protoc_insertion_point(field_mutable:mesos.slave.ContainerLaunchInfo.working_directory)
  return working_directory_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ContainerLaunchInfo::release_working_directory() {
  // @@protoc_insertion_point(field_release:mesos.slave.ContainerLaunchInfo.working_directory)
  clear_has_working_directory();
  return working_directory_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ContainerLaunchInfo::set_allocated_working_directory(::std::string* working_directory) {
  if (working_directory != NULL) {
    set_has_working_directory();
  } else {
    clear_has_working_directory();
  }
  working_directory_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), working_directory);
  // @@protoc_insertion_point(field_set_allocated:mesos.slave.ContainerLaunchInfo.working_directory)
}

// repeated .mesos.slave.ContainerMountInfo mounts = 17;
inline int ContainerLaunchInfo::mounts_size() const {
  return mounts_.size();
}
inline void ContainerLaunchInfo::clear_mounts() {
  mounts_.Clear();
}
inline const ::mesos::slave::ContainerMountInfo& ContainerLaunchInfo::mounts(int index) const {
  // @@protoc_insertion_point(field_get:mesos.slave.ContainerLaunchInfo.mounts)
  return mounts_.Get(index);
}
inline ::mesos::slave::ContainerMountInfo* ContainerLaunchInfo::mutable_mounts(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.slave.ContainerLaunchInfo.mounts)
  return mounts_.Mutable(index);
}
inline ::mesos::slave::ContainerMountInfo* ContainerLaunchInfo::add_mounts() {
  // @@protoc_insertion_point(field_add:mesos.slave.ContainerLaunchInfo.mounts)
  return mounts_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::slave::ContainerMountInfo >*
ContainerLaunchInfo::mutable_mounts() {
  // @@protoc_insertion_point(field_mutable_list:mesos.slave.ContainerLaunchInfo.mounts)
  return &mounts_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::slave::ContainerMountInfo >&
ContainerLaunchInfo::mounts() const {
  // @@protoc_insertion_point(field_list:mesos.slave.ContainerLaunchInfo.mounts)
  return mounts_;
}

// optional .mesos.CapabilityInfo effective_capabilities = 7;
inline bool ContainerLaunchInfo::has_effective_capabilities() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ContainerLaunchInfo::set_has_effective_capabilities() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ContainerLaunchInfo::clear_has_effective_capabilities() {
  _has_bits_[0] &= ~0x00000040u;
}
inline const ::mesos::CapabilityInfo& ContainerLaunchInfo::effective_capabilities() const {
  const ::mesos::CapabilityInfo* p = effective_capabilities_;
  // @@protoc_insertion_point(field_get:mesos.slave.ContainerLaunchInfo.effective_capabilities)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::CapabilityInfo*>(
      &::mesos::_CapabilityInfo_default_instance_);
}
inline ::mesos::CapabilityInfo* ContainerLaunchInfo::release_effective_capabilities() {
  // @@protoc_insertion_point(field_release:mesos.slave.ContainerLaunchInfo.effective_capabilities)
  clear_has_effective_capabilities();
  ::mesos::CapabilityInfo* temp = effective_capabilities_;
  effective_capabilities_ = NULL;
  return temp;
}
inline ::mesos::CapabilityInfo* ContainerLaunchInfo::mutable_effective_capabilities() {
  set_has_effective_capabilities();
  if (effective_capabilities_ == NULL) {
    effective_capabilities_ = new ::mesos::CapabilityInfo;
  }
  // @@protoc_insertion_point(field_mutable:mesos.slave.ContainerLaunchInfo.effective_capabilities)
  return effective_capabilities_;
}
inline void ContainerLaunchInfo::set_allocated_effective_capabilities(::mesos::CapabilityInfo* effective_capabilities) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(effective_capabilities_);
  }
  if (effective_capabilities) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(effective_capabilities)->GetArena();
    if (message_arena != submessage_arena) {
      effective_capabilities = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, effective_capabilities, submessage_arena);
    }
    set_has_effective_capabilities();
  } else {
    clear_has_effective_capabilities();
  }
  effective_capabilities_ = effective_capabilities;
  // @@protoc_insertion_point(field_set_allocated:mesos.slave.ContainerLaunchInfo.effective_capabilities)
}

// optional .mesos.CapabilityInfo bounding_capabilities = 16;
inline bool ContainerLaunchInfo::has_bounding_capabilities() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ContainerLaunchInfo::set_has_bounding_capabilities() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ContainerLaunchInfo::clear_has_bounding_capabilities() {
  _has_bits_[0] &= ~0x00000200u;
}
inline const ::mesos::CapabilityInfo& ContainerLaunchInfo::bounding_capabilities() const {
  const ::mesos::CapabilityInfo* p = bounding_capabilities_;
  // @@protoc_insertion_point(field_get:mesos.slave.ContainerLaunchInfo.bounding_capabilities)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::CapabilityInfo*>(
      &::mesos::_CapabilityInfo_default_instance_);
}
inline ::mesos::CapabilityInfo* ContainerLaunchInfo::release_bounding_capabilities() {
  // @@protoc_insertion_point(field_release:mesos.slave.ContainerLaunchInfo.bounding_capabilities)
  clear_has_bounding_capabilities();
  ::mesos::CapabilityInfo* temp = bounding_capabilities_;
  bounding_capabilities_ = NULL;
  return temp;
}
inline ::mesos::CapabilityInfo* ContainerLaunchInfo::mutable_bounding_capabilities() {
  set_has_bounding_capabilities();
  if (bounding_capabilities_ == NULL) {
    bounding_capabilities_ = new ::mesos::CapabilityInfo;
  }
  // @@protoc_insertion_point(field_mutable:mesos.slave.ContainerLaunchInfo.bounding_capabilities)
  return bounding_capabilities_;
}
inline void ContainerLaunchInfo::set_allocated_bounding_capabilities(::mesos::CapabilityInfo* bounding_capabilities) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(bounding_capabilities_);
  }
  if (bounding_capabilities) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(bounding_capabilities)->GetArena();
    if (message_arena != submessage_arena) {
      bounding_capabilities = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, bounding_capabilities, submessage_arena);
    }
    set_has_bounding_capabilities();
  } else {
    clear_has_bounding_capabilities();
  }
  bounding_capabilities_ = bounding_capabilities;
  // @@protoc_insertion_point(field_set_allocated:mesos.slave.ContainerLaunchInfo.bounding_capabilities)
}

// optional .mesos.RLimitInfo rlimits = 8;
inline bool ContainerLaunchInfo::has_rlimits() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ContainerLaunchInfo::set_has_rlimits() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ContainerLaunchInfo::clear_has_rlimits() {
  _has_bits_[0] &= ~0x00000080u;
}
inline const ::mesos::RLimitInfo& ContainerLaunchInfo::rlimits() const {
  const ::mesos::RLimitInfo* p = rlimits_;
  // @@protoc_insertion_point(field_get:mesos.slave.ContainerLaunchInfo.rlimits)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::RLimitInfo*>(
      &::mesos::_RLimitInfo_default_instance_);
}
inline ::mesos::RLimitInfo* ContainerLaunchInfo::release_rlimits() {
  // @@protoc_insertion_point(field_release:mesos.slave.ContainerLaunchInfo.rlimits)
  clear_has_rlimits();
  ::mesos::RLimitInfo* temp = rlimits_;
  rlimits_ = NULL;
  return temp;
}
inline ::mesos::RLimitInfo* ContainerLaunchInfo::mutable_rlimits() {
  set_has_rlimits();
  if (rlimits_ == NULL) {
    rlimits_ = new ::mesos::RLimitInfo;
  }
  // @@protoc_insertion_point(field_mutable:mesos.slave.ContainerLaunchInfo.rlimits)
  return rlimits_;
}
inline void ContainerLaunchInfo::set_allocated_rlimits(::mesos::RLimitInfo* rlimits) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(rlimits_);
  }
  if (rlimits) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(rlimits)->GetArena();
    if (message_arena != submessage_arena) {
      rlimits = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, rlimits, submessage_arena);
    }
    set_has_rlimits();
  } else {
    clear_has_rlimits();
  }
  rlimits_ = rlimits;
  // @@protoc_insertion_point(field_set_allocated:mesos.slave.ContainerLaunchInfo.rlimits)
}

// optional string tty_slave_path = 14;
inline bool ContainerLaunchInfo::has_tty_slave_path() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ContainerLaunchInfo::set_has_tty_slave_path() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ContainerLaunchInfo::clear_has_tty_slave_path() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ContainerLaunchInfo::clear_tty_slave_path() {
  tty_slave_path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_tty_slave_path();
}
inline const ::std::string& ContainerLaunchInfo::tty_slave_path() const {
  // @@protoc_insertion_point(field_get:mesos.slave.ContainerLaunchInfo.tty_slave_path)
  return tty_slave_path_.GetNoArena();
}
inline void ContainerLaunchInfo::set_tty_slave_path(const ::std::string& value) {
  set_has_tty_slave_path();
  tty_slave_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.slave.ContainerLaunchInfo.tty_slave_path)
}
#if LANG_CXX11
inline void ContainerLaunchInfo::set_tty_slave_path(::std::string&& value) {
  set_has_tty_slave_path();
  tty_slave_path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mesos.slave.ContainerLaunchInfo.tty_slave_path)
}
#endif
inline void ContainerLaunchInfo::set_tty_slave_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_tty_slave_path();
  tty_slave_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.slave.ContainerLaunchInfo.tty_slave_path)
}
inline void ContainerLaunchInfo::set_tty_slave_path(const char* value, size_t size) {
  set_has_tty_slave_path();
  tty_slave_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.slave.ContainerLaunchInfo.tty_slave_path)
}
inline ::std::string* ContainerLaunchInfo::mutable_tty_slave_path() {
  set_has_tty_slave_path();
  // @@protoc_insertion_point(field_mutable:mesos.slave.ContainerLaunchInfo.tty_slave_path)
  return tty_slave_path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ContainerLaunchInfo::release_tty_slave_path() {
  // @@protoc_insertion_point(field_release:mesos.slave.ContainerLaunchInfo.tty_slave_path)
  clear_has_tty_slave_path();
  return tty_slave_path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ContainerLaunchInfo::set_allocated_tty_slave_path(::std::string* tty_slave_path) {
  if (tty_slave_path != NULL) {
    set_has_tty_slave_path();
  } else {
    clear_has_tty_slave_path();
  }
  tty_slave_path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tty_slave_path);
  // @@protoc_insertion_point(field_set_allocated:mesos.slave.ContainerLaunchInfo.tty_slave_path)
}

// optional .mesos.Environment task_environment = 15;
inline bool ContainerLaunchInfo::has_task_environment() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ContainerLaunchInfo::set_has_task_environment() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ContainerLaunchInfo::clear_has_task_environment() {
  _has_bits_[0] &= ~0x00000100u;
}
inline const ::mesos::Environment& ContainerLaunchInfo::task_environment() const {
  const ::mesos::Environment* p = task_environment_;
  // @@protoc_insertion_point(field_get:mesos.slave.ContainerLaunchInfo.task_environment)
  return p != NULL ? *p : *reinterpret_cast<const ::mesos::Environment*>(
      &::mesos::_Environment_default_instance_);
}
inline ::mesos::Environment* ContainerLaunchInfo::release_task_environment() {
  // @@protoc_insertion_point(field_release:mesos.slave.ContainerLaunchInfo.task_environment)
  clear_has_task_environment();
  ::mesos::Environment* temp = task_environment_;
  task_environment_ = NULL;
  return temp;
}
inline ::mesos::Environment* ContainerLaunchInfo::mutable_task_environment() {
  set_has_task_environment();
  if (task_environment_ == NULL) {
    task_environment_ = new ::mesos::Environment;
  }
  // @@protoc_insertion_point(field_mutable:mesos.slave.ContainerLaunchInfo.task_environment)
  return task_environment_;
}
inline void ContainerLaunchInfo::set_allocated_task_environment(::mesos::Environment* task_environment) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(task_environment_);
  }
  if (task_environment) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(task_environment)->GetArena();
    if (message_arena != submessage_arena) {
      task_environment = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, task_environment, submessage_arena);
    }
    set_has_task_environment();
  } else {
    clear_has_task_environment();
  }
  task_environment_ = task_environment;
  // @@protoc_insertion_point(field_set_allocated:mesos.slave.ContainerLaunchInfo.task_environment)
}

// -------------------------------------------------------------------

// ContainerTermination

// optional int32 status = 3;
inline bool ContainerTermination::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ContainerTermination::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ContainerTermination::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ContainerTermination::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 ContainerTermination::status() const {
  // @@protoc_insertion_point(field_get:mesos.slave.ContainerTermination.status)
  return status_;
}
inline void ContainerTermination::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:mesos.slave.ContainerTermination.status)
}

// optional .mesos.TaskState state = 4;
inline bool ContainerTermination::has_state() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ContainerTermination::set_has_state() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ContainerTermination::clear_has_state() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ContainerTermination::clear_state() {
  state_ = 6;
  clear_has_state();
}
inline ::mesos::TaskState ContainerTermination::state() const {
  // @@protoc_insertion_point(field_get:mesos.slave.ContainerTermination.state)
  return static_cast< ::mesos::TaskState >(state_);
}
inline void ContainerTermination::set_state(::mesos::TaskState value) {
  assert(::mesos::TaskState_IsValid(value));
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:mesos.slave.ContainerTermination.state)
}

// optional .mesos.TaskStatus.Reason reason = 5;
inline bool ContainerTermination::has_reason() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ContainerTermination::set_has_reason() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ContainerTermination::clear_has_reason() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ContainerTermination::clear_reason() {
  reason_ = 0;
  clear_has_reason();
}
inline ::mesos::TaskStatus_Reason ContainerTermination::reason() const {
  // @@protoc_insertion_point(field_get:mesos.slave.ContainerTermination.reason)
  return static_cast< ::mesos::TaskStatus_Reason >(reason_);
}
inline void ContainerTermination::set_reason(::mesos::TaskStatus_Reason value) {
  assert(::mesos::TaskStatus_Reason_IsValid(value));
  set_has_reason();
  reason_ = value;
  // @@protoc_insertion_point(field_set:mesos.slave.ContainerTermination.reason)
}

// optional string message = 2;
inline bool ContainerTermination::has_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ContainerTermination::set_has_message() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ContainerTermination::clear_has_message() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ContainerTermination::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_message();
}
inline const ::std::string& ContainerTermination::message() const {
  // @@protoc_insertion_point(field_get:mesos.slave.ContainerTermination.message)
  return message_.GetNoArena();
}
inline void ContainerTermination::set_message(const ::std::string& value) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.slave.ContainerTermination.message)
}
#if LANG_CXX11
inline void ContainerTermination::set_message(::std::string&& value) {
  set_has_message();
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mesos.slave.ContainerTermination.message)
}
#endif
inline void ContainerTermination::set_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.slave.ContainerTermination.message)
}
inline void ContainerTermination::set_message(const char* value, size_t size) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.slave.ContainerTermination.message)
}
inline ::std::string* ContainerTermination::mutable_message() {
  set_has_message();
  // @@protoc_insertion_point(field_mutable:mesos.slave.ContainerTermination.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ContainerTermination::release_message() {
  // @@protoc_insertion_point(field_release:mesos.slave.ContainerTermination.message)
  clear_has_message();
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ContainerTermination::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    set_has_message();
  } else {
    clear_has_message();
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:mesos.slave.ContainerTermination.message)
}

// repeated .mesos.Resource limited_resources = 6;
inline int ContainerTermination::limited_resources_size() const {
  return limited_resources_.size();
}
inline const ::mesos::Resource& ContainerTermination::limited_resources(int index) const {
  // @@protoc_insertion_point(field_get:mesos.slave.ContainerTermination.limited_resources)
  return limited_resources_.Get(index);
}
inline ::mesos::Resource* ContainerTermination::mutable_limited_resources(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.slave.ContainerTermination.limited_resources)
  return limited_resources_.Mutable(index);
}
inline ::mesos::Resource* ContainerTermination::add_limited_resources() {
  // @@protoc_insertion_point(field_add:mesos.slave.ContainerTermination.limited_resources)
  return limited_resources_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
ContainerTermination::mutable_limited_resources() {
  // @@protoc_insertion_point(field_mutable_list:mesos.slave.ContainerTermination.limited_resources)
  return &limited_resources_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
ContainerTermination::limited_resources() const {
  // @@protoc_insertion_point(field_list:mesos.slave.ContainerTermination.limited_resources)
  return limited_resources_;
}

// -------------------------------------------------------------------

// ContainerLayers

// repeated string paths = 1;
inline int ContainerLayers::paths_size() const {
  return paths_.size();
}
inline void ContainerLayers::clear_paths() {
  paths_.Clear();
}
inline const ::std::string& ContainerLayers::paths(int index) const {
  // @@protoc_insertion_point(field_get:mesos.slave.ContainerLayers.paths)
  return paths_.Get(index);
}
inline ::std::string* ContainerLayers::mutable_paths(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.slave.ContainerLayers.paths)
  return paths_.Mutable(index);
}
inline void ContainerLayers::set_paths(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:mesos.slave.ContainerLayers.paths)
  paths_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void ContainerLayers::set_paths(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:mesos.slave.ContainerLayers.paths)
  paths_.Mutable(index)->assign(std::move(value));
}
#endif
inline void ContainerLayers::set_paths(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  paths_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.slave.ContainerLayers.paths)
}
inline void ContainerLayers::set_paths(int index, const char* value, size_t size) {
  paths_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.slave.ContainerLayers.paths)
}
inline ::std::string* ContainerLayers::add_paths() {
  // @@protoc_insertion_point(field_add_mutable:mesos.slave.ContainerLayers.paths)
  return paths_.Add();
}
inline void ContainerLayers::add_paths(const ::std::string& value) {
  paths_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:mesos.slave.ContainerLayers.paths)
}
#if LANG_CXX11
inline void ContainerLayers::add_paths(::std::string&& value) {
  paths_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:mesos.slave.ContainerLayers.paths)
}
#endif
inline void ContainerLayers::add_paths(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  paths_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:mesos.slave.ContainerLayers.paths)
}
inline void ContainerLayers::add_paths(const char* value, size_t size) {
  paths_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:mesos.slave.ContainerLayers.paths)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ContainerLayers::paths() const {
  // @@protoc_insertion_point(field_list:mesos.slave.ContainerLayers.paths)
  return paths_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ContainerLayers::mutable_paths() {
  // @@protoc_insertion_point(field_mutable_list:mesos.slave.ContainerLayers.paths)
  return &paths_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace slave
}  // namespace mesos

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::mesos::slave::ContainerClass> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mesos::slave::ContainerClass>() {
  return ::mesos::slave::ContainerClass_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_mesos_2fslave_2fcontainerizer_2eproto__INCLUDED
